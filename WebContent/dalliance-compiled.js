(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// bam.js: indexed binary alignments
//

"use strict";

if (typeof(require) !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var bin = require('./bin');
    var readInt = bin.readInt;
    var readShort = bin.readShort;
    var readByte = bin.readByte;
    var readInt64 = bin.readInt64;
    var readFloat = bin.readFloat;

    var lh3utils = require('./lh3utils');
    var readVob = lh3utils.readVob;
    var unbgzf = lh3utils.unbgzf;
    var reg2bins = lh3utils.reg2bins;
    var Chunk = lh3utils.Chunk;
}


var BAM_MAGIC = 0x14d4142;
var BAI_MAGIC = 0x1494142;

var BamFlags = {
    MULTIPLE_SEGMENTS:       0x1,
    ALL_SEGMENTS_ALIGN:      0x2,
    SEGMENT_UNMAPPED:        0x4,
    NEXT_SEGMENT_UNMAPPED:   0x8,
    REVERSE_COMPLEMENT:      0x10,
    NEXT_REVERSE_COMPLEMENT: 0x20,
    FIRST_SEGMENT:           0x40,
    LAST_SEGMENT:            0x80,
    SECONDARY_ALIGNMENT:     0x100,
    QC_FAIL:                 0x200,
    DUPLICATE:               0x400,
    SUPPLEMENTARY:           0x800
};

function BamFile() {
}


// Calculate the length (in bytes) of the BAI ref starting at offset.
// Returns {nbin, length, minBlockIndex}
function _getBaiRefLength(uncba, offset) {
    var p = offset;
    var nbin = readInt(uncba, p); p += 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(uncba, p);
        var nchnk = readInt(uncba, p+4);
        p += 8 + (nchnk * 16);
    }
    var nintv = readInt(uncba, p); p += 4;

    var minBlockIndex = 1000000000;
    var q = p;
    for (var i = 0; i < nintv; ++i) {
        var v = readVob(uncba, q); q += 8;
        if (v) {
            var bi = v.block;
            if (v.offset > 0)
                bi += 65536;

            if (bi < minBlockIndex)
                minBlockIndex = bi;
            break;
        }
    }
    p += (nintv * 8);

    return {
        minBlockIndex: minBlockIndex,
        nbin: nbin,
        length: p - offset
    };
}


function makeBam(data, bai, indexChunks, callback, attempted) {
    // Do an initial probe on the BAM file to catch any mixed-content errors.
    data.slice(0, 10).fetch(function(header) {
        if (header) {
            return makeBam2(data, bai, indexChunks, callback, attempted);
        } else {
            return callback(null, "Couldn't access BAM.");
        }
    }, {timeout: 5000});
}

function makeBam2(data, bai, indexChunks, callback, attempted) {
    var bam = new BamFile();
    bam.data = data;
    bam.bai = bai;
    bam.indexChunks = indexChunks;

    var minBlockIndex = bam.indexChunks ? bam.indexChunks.minBlockIndex : 1000000000;

    // Fills out bam.chrToIndex and bam.indexToChr based on the first few bytes of the BAM.
    function parseBamHeader(r) {
        if (!r) {
            return callback(null, "Couldn't access BAM");
        }

        var unc = unbgzf(r, r.byteLength);
        var uncba = new Uint8Array(unc);

        var magic = readInt(uncba, 0);
        if (magic != BAM_MAGIC) {
            return callback(null, "Not a BAM file, magic=0x" + magic.toString(16));
        }
        var headLen = readInt(uncba, 4);
        var header = '';
        for (var i = 0; i < headLen; ++i) {
            header += String.fromCharCode(uncba[i + 8]);
        }

        var nRef = readInt(uncba, headLen + 8);
        var p = headLen + 12;

        bam.chrToIndex = {};
        bam.indexToChr = [];
        for (var i = 0; i < nRef; ++i) {
            var lName = readInt(uncba, p);
            var name = '';
            for (var j = 0; j < lName-1; ++j) {
                name += String.fromCharCode(uncba[p + 4 + j]);
            }
            var lRef = readInt(uncba, p + lName + 4);
            bam.chrToIndex[name] = i;
            if (name.indexOf('chr') == 0) {
                bam.chrToIndex[name.substring(3)] = i;
            } else {
                bam.chrToIndex['chr' + name] = i;
            }
            bam.indexToChr.push(name);

            p = p + 8 + lName;
        }

        if (bam.indices) {
            return callback(bam);
        }
    }

    function parseBai(header) {
        if (!header) {
            return "Couldn't access BAI";
        }

        var uncba = new Uint8Array(header);
        var baiMagic = readInt(uncba, 0);
        if (baiMagic != BAI_MAGIC) {
            return callback(null, 'Not a BAI file, magic=0x' + baiMagic.toString(16));
        }

        var nref = readInt(uncba, 4);

        bam.indices = [];

        var p = 8;
        for (var ref = 0; ref < nref; ++ref) {
            var blockStart = p;
            var o = _getBaiRefLength(uncba, blockStart);
            p += o.length;

            minBlockIndex = Math.min(o.minBlockIndex, minBlockIndex);

            var nbin = o.nbin;

            if (nbin > 0) {
                bam.indices[ref] = new Uint8Array(header, blockStart, p - blockStart);
            }
        }

        return true;
    }

    if (!bam.indexChunks) {
        bam.bai.fetch(function(header) {   // Do we really need to fetch the whole thing? :-(
            var result = parseBai(header);
            if (result !== true) {
                if (bam.bai.url && typeof(attempted) === "undefined") {
                    // Already attempted x.bam.bai not there so now trying x.bai
                    bam.bai.url = bam.data.url.replace(new RegExp('.bam$'), '.bai');
                    
                     // True lets us know we are making a second attempt
                    makeBam2(data, bam.bai, indexChunks, callback, true);
                }
                else {
                    // We've attempted x.bam.bai & x.bai and nothing worked
                    callback(null, result);
                }
            } else {
              bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);
            }
        });   // Timeout on first request to catch Chrome mixed-content error.
    } else {
        var chunks = bam.indexChunks.chunks;
        bam.indices = []
        for (var i = 0; i < chunks.length; i++) {
           bam.indices[i] = null;  // To be filled out lazily as needed
        }
        bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);
    }
}



BamFile.prototype.blocksForRange = function(refId, min, max) {
    var index = this.indices[refId];
    if (!index) {
        return [];
    }

    var intBinsL = reg2bins(min, max);
    var intBins = [];
    for (var i = 0; i < intBinsL.length; ++i) {
        intBins[intBinsL[i]] = true;
    }
    var leafChunks = [], otherChunks = [];

    var nbin = readInt(index, 0);
    var p = 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(index, p);
        var nchnk = readInt(index, p+4);
//        dlog('bin=' + bin + '; nchnk=' + nchnk);
        p += 8;
        if (intBins[bin]) {
            for (var c = 0; c < nchnk; ++c) {
                var cs = readVob(index, p);
                var ce = readVob(index, p + 8);
                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));
                p += 16;
            }
        } else {
            p +=  (nchnk * 16);
        }
    }
    // console.log('leafChunks = ' + miniJSONify(leafChunks));
    // console.log('otherChunks = ' + miniJSONify(otherChunks));

    var nintv = readInt(index, p);
    var lowest = null;
    var minLin = Math.min(min>>14, nintv - 1), maxLin = Math.min(max>>14, nintv - 1);
    for (var i = minLin; i <= maxLin; ++i) {
        var lb =  readVob(index, p + 4 + (i * 8));
        if (!lb) {
            continue;
        }
        if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {
            lowest = lb;
        }
    }
    // console.log('Lowest LB = ' + lowest);
    
    var prunedOtherChunks = [];
    if (lowest != null) {
        for (var i = 0; i < otherChunks.length; ++i) {
            var chnk = otherChunks[i];
            if (chnk.maxv.block >= lowest.block && chnk.maxv.offset >= lowest.offset) {
                prunedOtherChunks.push(chnk);
            }
        }
    }
    // console.log('prunedOtherChunks = ' + miniJSONify(prunedOtherChunks));
    otherChunks = prunedOtherChunks;

    var intChunks = [];
    for (var i = 0; i < otherChunks.length; ++i) {
        intChunks.push(otherChunks[i]);
    }
    for (var i = 0; i < leafChunks.length; ++i) {
        intChunks.push(leafChunks[i]);
    }

    intChunks.sort(function(c0, c1) {
        var dif = c0.minv.block - c1.minv.block;
        if (dif != 0) {
            return dif;
        } else {
            return c0.minv.offset - c1.minv.offset;
        }
    });
    var mergedChunks = [];
    if (intChunks.length > 0) {
        var cur = intChunks[0];
        for (var i = 1; i < intChunks.length; ++i) {
            var nc = intChunks[i];
            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) { // no point splitting mid-block
                cur = new Chunk(cur.minv, nc.maxv);
            } else {
                mergedChunks.push(cur);
                cur = nc;
            }
        }
        mergedChunks.push(cur);
    }
    // console.log('mergedChunks = ' + miniJSONify(mergedChunks));

    return mergedChunks;
}

BamFile.prototype.fetch = function(chr, min, max, callback, opts) {
    var thisB = this;
    opts = opts || {};

    var chrId = this.chrToIndex[chr];
    var chunks;
    if (chrId === undefined) {
        chunks = [];
    } else {
        // Fetch this portion of the BAI if it hasn't been loaded yet.
        if (this.indices[chrId] === null && this.indexChunks.chunks[chrId]) {
            var start_stop = this.indexChunks.chunks[chrId];
            return this.bai.slice(start_stop[0], start_stop[1]).fetch(function(data) {
                var buffer = new Uint8Array(data);
                this.indices[chrId] = buffer;
                return this.fetch(chr, min, max, callback, opts);
            }.bind(this));
        }

        chunks = this.blocksForRange(chrId, min, max);
        if (!chunks) {
            callback(null, 'Error in index fetch');
        }
    }
    
    var records = [];
    var index = 0;
    var data;

    function tramp() {
        if (index >= chunks.length) {
            return callback(records);
        } else if (!data) {
            var c = chunks[index];
            var fetchMin = c.minv.block;
            var fetchMax = c.maxv.block + (1<<16); // *sigh*
            // console.log('fetching ' + fetchMin + ':' + fetchMax);
            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function(r) {
                data = unbgzf(r, c.maxv.block - c.minv.block + 1);
                return tramp();
            });
        } else {
            var ba = new Uint8Array(data);
            var finished = thisB.readBamRecords(ba, chunks[index].minv.offset, records, min, max, chrId, opts);
            data = null;
            ++index;
            if (finished)
                return callback(records);
            else
                return tramp();
        }
    }
    tramp();
}

var SEQRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];
var CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];

function BamRecord() {
}

BamFile.prototype.readBamRecords = function(ba, offset, sink, min, max, chrId, opts) {
    while (true) {
        var blockSize = readInt(ba, offset);
        var blockEnd = offset + blockSize + 4;
        if (blockEnd >= ba.length) {
            return false;
        }

        var record = new BamRecord();

        var refID = readInt(ba, offset + 4);
        var pos = readInt(ba, offset + 8);
        
        var bmn = readInt(ba, offset + 12);
        var bin = (bmn & 0xffff0000) >> 16;
        var mq = (bmn & 0xff00) >> 8;
        var nl = bmn & 0xff;

        var flag_nc = readInt(ba, offset + 16);
        var flag = (flag_nc & 0xffff0000) >> 16;
        var nc = flag_nc & 0xffff;
    
        var lseq = readInt(ba, offset + 20);
        
        var nextRef  = readInt(ba, offset + 24);
        var nextPos = readInt(ba, offset + 28);
        
        var tlen = readInt(ba, offset + 32);
    
        record.segment = this.indexToChr[refID];
        record.flag = flag;
        record.pos = pos;
        record.mq = mq;
        if (opts.light)
            record.seqLength = lseq;

        if (!opts.light) {
            if (nextRef >= 0) {
                record.nextSegment = this.indexToChr[nextRef];
                record.nextPos = nextPos;
            }

            var readName = '';
            for (var j = 0; j < nl-1; ++j) {
                readName += String.fromCharCode(ba[offset + 36 + j]);
            }
            record.readName = readName;
        
            var p = offset + 36 + nl;

            var cigar = '';
            for (var c = 0; c < nc; ++c) {
                var cigop = readInt(ba, p);
                cigar = cigar + (cigop>>4) + CIGAR_DECODER[cigop & 0xf];
                p += 4;
            }
            record.cigar = cigar;
        
            var seq = '';
            var seqBytes = (lseq + 1) >> 1;
            for (var j = 0; j < seqBytes; ++j) {
                var sb = ba[p + j];
                seq += SEQRET_DECODER[(sb & 0xf0) >> 4];
                if (seq.length < lseq)
                    seq += SEQRET_DECODER[(sb & 0x0f)];
            }
            p += seqBytes;
            record.seq = seq;

            var qseq = '';
            for (var j = 0; j < lseq; ++j) {
                qseq += String.fromCharCode(ba[p + j] + 33);
            }
            p += lseq;
            record.quals = qseq;

            while (p < blockEnd) {
                var tag = String.fromCharCode(ba[p], ba[p + 1]);
                var type = String.fromCharCode(ba[p + 2]);
                var value;

                if (type == 'A') {
                    value = String.fromCharCode(ba[p + 3]);
                    p += 4;
                } else if (type == 'i' || type == 'I') {
                    value = readInt(ba, p + 3);
                    p += 7;
                } else if (type == 'c' || type == 'C') {
                    value = ba[p + 3];
                    p += 4;
                } else if (type == 's' || type == 'S') {
                    value = readShort(ba, p + 3);
                    p += 5;
                } else if (type == 'f') {
                    value = readFloat(ba, p + 3);
                    p += 7;
                } else if (type == 'Z' || type == 'H') {
                    p += 3;
                    value = '';
                    for (;;) {
                        var cc = ba[p++];
                        if (cc == 0) {
                            break;
                        } else {
                            value += String.fromCharCode(cc);
                        }
                    }
                } else if (type == 'B') {
                    var atype = String.fromCharCode(ba[p + 3]);
                    var alen = readInt(ba, p + 4);
                    var elen;
                    var reader;
                    if (atype == 'i' || atype == 'I' || atype == 'f') {
                        elen = 4;
                        if (atype == 'f')
                            reader = readFloat;
                        else
                            reader = readInt;
                    } else if (atype == 's' || atype == 'S') {
                        elen = 2;
                        reader = readShort;
                    } else if (atype == 'c' || atype == 'C') {
                        elen = 1;
                        reader = readByte;
                    } else {
                        throw 'Unknown array type ' + atype;
                    }

                    p += 8;
                    value = [];
                    for (var i = 0; i < alen; ++i) {
                        value.push(reader(ba, p));
                        p += elen;
                    }
                } else {
                    throw 'Unknown type '+ type;
                }
                record[tag] = value;
            }
        }

        if (!min || record.pos <= max && record.pos + lseq >= min) {
            if (chrId === undefined || refID == chrId) {
                sink.push(record);
            }
        }
        if (record.pos > max) {
            return true;
        }
        offset = blockEnd;
    }

    // Exits via top of loop.
};

if (typeof(module) !== 'undefined') {
    module.exports = {
        makeBam: makeBam,
        BAM_MAGIC: BAM_MAGIC,
        BAI_MAGIC: BAI_MAGIC,
        BamFlags: BamFlags
    };
}

},{"./bin":4,"./lh3utils":24,"./spans":36}],2:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// bedwig.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var sa = require('./sourceadapters');
    var dalliance_registerParserFactory = sa.registerParserFactory;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
}


function BedWigParser(type) {
    this.type = type;
}

BedWigParser.prototype.createSession = function(sink) {
    if (this.type == 'wig')
        return new WigParseSession(this, sink);
    else
        return new BedParseSession(this, sink);
}

var __KV_REGEXP=/([^=]+)=(.+)/;
var __SPACE_REGEXP=/\s/;
var BED_COLOR_REGEXP = new RegExp("^[0-9]+,[0-9]+,[0-9]+");

function BedParseSession(parser, sink) {
    this.parser = parser;
    this.sink = sink;
}

BedParseSession.prototype.parse = function(line) {
    var toks = line.split(__SPACE_REGEXP);
    if (toks.length < 3)
        return;

    var start = parseInt(toks[1]) + 1;
    var end = parseInt(toks[2]);

    var f = {segment: toks[0], 
             min: start,
             max: end};

    if (toks.length > 3 && toks[3] !== '.') {
        f.label = toks[3];
    }

    if (toks.length > 4) {
        f.score = parseFloat(toks[4])
    }

    if (toks.length > 5) {
        f.orientation = toks[5];
    }

    if (toks.length > 8) {
        var color = toks[8];
        if (BED_COLOR_REGEXP.test(color)) {
            f.itemRgb = 'rgb(' + color + ')';
        }
    }

    if (toks.length >= 12) {
        var thickStart = parseInt(toks[6]);
        var thickEnd   = parseInt(toks[7]);
        var blockCount = parseInt(toks[9]);
        var blockSizes = toks[10].split(',').map(function(x) {return parseInt(x)});
        var blockStarts = toks[11].split(',').map(function(x) {return parseInt(x)});

        f.type = 'transcript'
        var grp = new DASGroup();
        grp.id = toks[3];
        grp.type = 'transcript'
        grp.notes = [];
        f.groups = [grp];

        if (toks.length > 12) {
            var geneId = toks[12];
            var geneName = geneId;
            if (toks.length > 13) {
                geneName = toks[13];
            }
            var gg = new DASGroup();
            gg.id = geneId;
            gg.label = geneName;
            gg.type = 'gene';
            f.groups.push(gg);
        }  

        var spans = null;
        for (var b = 0; b < blockCount; ++b) {
            var bmin = blockStarts[b] + start;
            var bmax = bmin + blockSizes[b];
            var span = new Range(bmin, bmax);
            if (spans) {
                spans = union(spans, span);
            } else {
                spans = span;
            }
        }
                    
        var tsList = spans.ranges();
        for (var s = 0; s < tsList.length; ++s) {
            var ts = tsList[s];
            var bf = shallowCopy(f);
            bf.min = ts.min();
            bf.max = ts.max();
            this.sink(bf);
        }

        if (thickEnd > thickStart) {
            var codingRegion = (f.orientation == '+') ? 
                new Range(thickStart, thickEnd + 3) : 
                new Range(thickStart - 3, thickEnd);
                // +/- 3 to account for stop codon

            var tl = intersection(spans, codingRegion);
            if (tl) {
                f.type = 'translation';
                var tlList = tl.ranges();
                var readingFrame = 0;
                for (var s = 0; s < tlList.length; ++s) {
                    // Record reading frame for every exon
                    var index = s;
                    if (f.orientation == '-')
                        index = tlList.length - s - 1;
                    var ts = tlList[index];
                    var bf = shallowCopy(f);
                    bf.min = ts.min();
                    bf.max = ts.max();
                    f.readframe = readingFrame;
                    var length = ts.max() - ts.min();
                    readingFrame = (readingFrame + length) % 3;
                    this.sink(bf);
                }
            }
        }
    } else {
        this.sink(f);
    }
}

BedParseSession.prototype.flush = function() {};

function WigParseSession(parser, sink) {
    this.parser = parser;
    this.sink = sink;
    this.wigState = null;
}

WigParseSession.prototype.parse = function(line) {
    var toks = line.split(__SPACE_REGEXP);

    if (toks[0] == 'fixedStep') {
        this.wigState = 'fixedStep';
        this.chr = this.pos = this.step = null;
        this.span = 1;

        for (var ti = 1; ti < toks.length; ++ti) {
            var m = __KV_REGEXP.exec(toks[ti]);
            if (m) {
                if (m[1] == 'chrom') {
                    this.chr = m[2];
                } else if (m[1] == 'start') {
                    this.pos = parseInt(m[2]);
                } else if (m[1] == 'step') {
                    this.step = parseInt(m[2]);
                } else if (m[1] == 'span') {
                    this.span = parseInt(m[2]);
                }
            }
        }
    } else if (toks[0] == 'variableStep') {
        this.wigState = 'variableStep';
        this.chr = null;
        this.span = 1;

        for (var ti = 1; ti < toks.length; ++ti) {
            var m = __KV_REGEXP.exec(toks[ti]);
            if (m[1] == 'chrom') {
                this.chr = m[2];
            } else if (m[1] == 'span') {
                this.span = parseInt(m[2]);
            }
        }
    } else {
        if (!this.wigState) {
            if (toks.length < 4)
                return;

            var f = {segment: toks[0], 
                     min: parseInt(toks[1]) + 1, 
                     max: parseInt(toks[2]),
                     score: parseFloat(toks[3])};

            this.sink(f);
        } else if (this.wigState == 'fixedStep') {
            if (toks.length != 1)
                return;
            var score = parseFloat(toks[0]);
            var f = {segment: this.chr, min: this.pos, max: this.pos + this.span - 1, score: score};
            this.pos += this.step;
            this.sink(f);
        } else if (this.wigState == 'variableStep') {
            if (toks.length != 2)
                return;
            var pos = parseInt(toks[0]);
            var score = parseFloat(toks[1]);
            var f = {segment: this.chr, min: pos, max: pos + this.span - 1, score: score};
            this.sink(f);
        }
    }
}

WigParseSession.prototype.flush = function() {};

BedWigParser.prototype.getStyleSheet = function(callback) {
    var thisB = this;
    var stylesheet = new DASStylesheet();

    if (this.type == 'wig') {
        var wigStyle = new DASStyle();
        wigStyle.glyph = 'HISTOGRAM';
        wigStyle.BGCOLOR = 'blue';
        wigStyle.HEIGHT=30;
        stylesheet.pushStyle({type: 'default'}, null, wigStyle);
    } else {
        var wigStyle = new DASStyle();
        wigStyle.glyph = 'BOX';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue'
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = true;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({type: 'default'}, null, wigStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = 'BOX';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'red'
        wigStyle.HEIGHT = 10;
        wigStyle.BUMP = true;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({type: 'translation'}, null, wigStyle);
                
        var tsStyle = new DASStyle();
        tsStyle.glyph = 'BOX';
        tsStyle.FGCOLOR = 'black';
        tsStyle.BGCOLOR = 'white';
        tsStyle.HEIGHT = 10;
        tsStyle.ZINDEX = 10;
        tsStyle.BUMP = true;
        tsStyle.LABEL = true;
        stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);

        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'white';
        densStyle.COLOR2 = 'black';
        densStyle.HEIGHT=30;
        stylesheet.pushStyle({type: 'density'}, null, densStyle);
    }

    return callback(stylesheet);
}

dalliance_registerParserFactory('bed', function(t) {return new BedWigParser(t)});
dalliance_registerParserFactory('wig', function(t) {return new BedWigParser(t)});
},{"./das":10,"./sourceadapters":34,"./spans":36,"./utils":49}],3:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// bigwig.js: indexed binary WIG (and BED) files
//

"use strict";


if (typeof(require) !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var das = require('./das');
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var bin = require('./bin');
    var readInt = bin.readInt;

    var jszlib = require('jszlib');
    var jszlib_inflate_buffer = jszlib.inflateBuffer;
    var arrayCopy = jszlib.arrayCopy;
}

var BIG_WIG_MAGIC = 0x888FFC26;
var BIG_WIG_MAGIC_BE = 0x26FC8F88;
var BIG_BED_MAGIC = 0x8789F2EB;
var BIG_BED_MAGIC_BE = 0xEBF28987;


var BIG_WIG_TYPE_GRAPH = 1;
var BIG_WIG_TYPE_VSTEP = 2;
var BIG_WIG_TYPE_FSTEP = 3;
  
var M1 = 256;
var M2 = 256*256;
var M3 = 256*256*256;
var M4 = 256*256*256*256;

var BED_COLOR_REGEXP = new RegExp("^[0-9]+,[0-9]+,[0-9]+");

function bwg_readOffset(ba, o) {
    var offset = ba[o] + ba[o+1]*M1 + ba[o+2]*M2 + ba[o+3]*M3 + ba[o+4]*M4;
    return offset;
}

function BigWig() {
}

BigWig.prototype.readChromTree = function(callback) {
    var thisB = this;
    this.chromsToIDs = {};
    this.idsToChroms = {};
    this.maxID = 0;

    var udo = this.unzoomedDataOffset;
    var eb = (udo - this.chromTreeOffset) & 3;
    udo = udo + 4 - eb;

    this.data.slice(this.chromTreeOffset, udo - this.chromTreeOffset).fetch(function(bpt) {
        var ba = new Uint8Array(bpt);
        var sa = new Int16Array(bpt);
        var la = new Int32Array(bpt);
        var bptMagic = la[0];
        var blockSize = la[1];
        var keySize = la[2];
        var valSize = la[3];
        var itemCount = bwg_readOffset(ba, 16);
        var rootNodeOffset = 32;

        var bptReadNode = function(offset) {
            var nodeType = ba[offset];
            var cnt = sa[(offset/2) + 1];
            offset += 4;
            for (var n = 0; n < cnt; ++n) {
                if (nodeType == 0) {
                    offset += keySize;
                    var childOffset = bwg_readOffset(ba, offset);
                    offset += 8;
                    childOffset -= thisB.chromTreeOffset;
                    bptReadNode(childOffset);
                } else {
                    var key = '';
                    for (var ki = 0; ki < keySize; ++ki) {
                        var charCode = ba[offset++];
                        if (charCode != 0) {
                            key += String.fromCharCode(charCode);
                        }
                    }
                    var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);
                    var chromSize = (ba[offset + 7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);
                    offset += 8;

                    thisB.chromsToIDs[key] = chromId;
                    if (key.indexOf('chr') == 0) {
                        thisB.chromsToIDs[key.substr(3)] = chromId;
                    }
                    thisB.idsToChroms[chromId] = key;
                    thisB.maxID = Math.max(thisB.maxID, chromId);
                }
            }
        };
        bptReadNode(rootNodeOffset);

        callback(thisB);
    });
}

function BigWigView(bwg, cirTreeOffset, cirTreeLength, isSummary) {
    this.bwg = bwg;
    this.cirTreeOffset = cirTreeOffset;
    this.cirTreeLength = cirTreeLength;
    this.isSummary = isSummary;
}



BigWigView.prototype.readWigData = function(chrName, min, max, callback) {
    var chr = this.bwg.chromsToIDs[chrName];
    if (chr === undefined) {
        // Not an error because some .bwgs won't have data for all chromosomes.
        return callback([]);
    } else {
        this.readWigDataById(chr, min, max, callback);
    }
}

BigWigView.prototype.readWigDataById = function(chr, min, max, callback) {
    var thisB = this;
    if (!this.cirHeader) {
        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function(result) {
            thisB.cirHeader = result;
            var la = new Int32Array(thisB.cirHeader);
            thisB.cirBlockSize = la[1];
            thisB.readWigDataById(chr, min, max, callback);
        });
        return;
    }

    var blocksToFetch = [];
    var outstanding = 0;

    var beforeBWG = Date.now();

    var filter = function(chromId, fmin, fmax, toks) {
        return ((chr < 0 || chromId == chr) && fmin <= max && fmax >= min);
    }

    var cirFobRecur = function(offset, level) {
        if (thisB.bwg.instrument)
            console.log('level=' + level + '; offset=' + offset + '; time=' + (Date.now()|0));

        outstanding += offset.length;

        if (offset.length == 1 && offset[0] - thisB.cirTreeOffset == 48 && thisB.cachedCirRoot) {
            cirFobRecur2(thisB.cachedCirRoot, 0, level);
            --outstanding;
            if (outstanding == 0) {
                thisB.fetchFeatures(filter, blocksToFetch, callback);
            }
            return;
        }

        var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.
        var spans;
        for (var i = 0; i < offset.length; ++i) {
            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);
            spans = spans ? union(spans, blockSpan) : blockSpan;
        }
        
        var fetchRanges = spans.ranges();
        for (var r = 0; r < fetchRanges.length; ++r) {
            var fr = fetchRanges[r];
            cirFobStartFetch(offset, fr, level);
        }
    }

    var cirFobStartFetch = function(offset, fr, level, attempts) {
        var length = fr.max() - fr.min();
        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function(resultBuffer) {
            for (var i = 0; i < offset.length; ++i) {
                if (fr.contains(offset[i])) {
                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);

                    if (offset[i] - thisB.cirTreeOffset == 48 && offset[i] - fr.min() == 0)
                        thisB.cachedCirRoot = resultBuffer;

                    --outstanding;
                    if (outstanding == 0) {
                        thisB.fetchFeatures(filter, blocksToFetch, callback);
                    }
                }
            }
        });
    }

    var cirFobRecur2 = function(cirBlockData, offset, level) {
        var ba = new Uint8Array(cirBlockData);
        var sa = new Int16Array(cirBlockData);
        var la = new Int32Array(cirBlockData);

        var isLeaf = ba[offset];
        var cnt = sa[offset/2 + 1];
        offset += 4;

        if (isLeaf != 0) {
            for (var i = 0; i < cnt; ++i) {
                var lo = offset/4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset+16);
                var blockSize = bwg_readOffset(ba, offset+24);
                if (((chr < 0 || startChrom < chr) || (startChrom == chr && startBase <= max)) &&
                    ((chr < 0 || endChrom   > chr) || (endChrom == chr && endBase >= min)))
                {
                    blocksToFetch.push({offset: blockOffset, size: blockSize});
                }
                offset += 32;
            }
        } else {
            var recurOffsets = [];
            for (var i = 0; i < cnt; ++i) {
                var lo = offset/4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset+16);
                if ((chr < 0 || startChrom < chr || (startChrom == chr && startBase <= max)) &&
                    (chr < 0 || endChrom   > chr || (endChrom == chr && endBase >= min)))
                {
                    recurOffsets.push(blockOffset);
                }
                offset += 24;
            }
            if (recurOffsets.length > 0) {
                cirFobRecur(recurOffsets, level + 1);
            }
        }
    };

    cirFobRecur([thisB.cirTreeOffset + 48], 1);
}


BigWigView.prototype.fetchFeatures = function(filter, blocksToFetch, callback) {
    var thisB = this;

    blocksToFetch.sort(function(b0, b1) {
        return (b0.offset|0) - (b1.offset|0);
    });

    if (blocksToFetch.length == 0) {
        callback([]);
    } else {
        var features = [];
        var createFeature = function(chr, fmin, fmax, opts) {
            if (!opts) {
                opts = {};
            }
        
            var f = new DASFeature();
            f._chromId = chr;
            f.segment = thisB.bwg.idsToChroms[chr];
            f.min = fmin;
            f.max = fmax;
            f.type = thisB.bwg.type;
            
            for (var k in opts) {
                f[k] = opts[k];
            }
            
            features.push(f);
        };

        var tramp = function() {
            if (blocksToFetch.length == 0) {
                var afterBWG = Date.now();
                // dlog('BWG fetch took ' + (afterBWG - beforeBWG) + 'ms');
                callback(features);
                return;  // just in case...
            } else {
                var block = blocksToFetch[0];
                if (block.data) {
                    thisB.parseFeatures(block.data, createFeature, filter);
                    blocksToFetch.splice(0, 1);
                    tramp();
                } else {
                    var fetchStart = block.offset;
                    var fetchSize = block.size;
                    var bi = 1;
                    while (bi < blocksToFetch.length && blocksToFetch[bi].offset == (fetchStart + fetchSize)) {
                        fetchSize += blocksToFetch[bi].size;
                        ++bi;
                    }

                    thisB.bwg.data.slice(fetchStart, fetchSize).fetch(function(result) {
                        var offset = 0;
                        var bi = 0;
                        while (offset < fetchSize) {
                            var fb = blocksToFetch[bi];
                        
                            var data;
                            if (thisB.bwg.uncompressBufSize > 0) {
                                data = jszlib_inflate_buffer(result, offset + 2, fb.size - 2);
                            } else {
                                var tmp = new Uint8Array(fb.size);    // FIXME is this really the best we can do?
                                arrayCopy(new Uint8Array(result, offset, fb.size), 0, tmp, 0, fb.size);
                                data = tmp.buffer;
                            }
                            fb.data = data;
                            
                            offset += fb.size;
                            ++bi;
                        }
                        tramp();
                    });
                }
            }
        }
        tramp();
    }
}

BigWigView.prototype.parseFeatures = function(data, createFeature, filter) {
    var ba = new Uint8Array(data);

    if (this.isSummary) {
        var sa = new Int16Array(data);
        var la = new Int32Array(data);
        var fa = new Float32Array(data);

        var itemCount = data.byteLength/32;
        for (var i = 0; i < itemCount; ++i) {
            var chromId =   la[(i*8)];
            var start =     la[(i*8)+1];
            var end =       la[(i*8)+2];
            var validCnt =  la[(i*8)+3];
            var minVal    = fa[(i*8)+4];
            var maxVal    = fa[(i*8)+5];
            var sumData   = fa[(i*8)+6];
            var sumSqData = fa[(i*8)+7];
            
            if (filter(chromId, start + 1, end)) {
                var summaryOpts = {type: 'bigwig', score: sumData/validCnt, maxScore: maxVal};
                if (this.bwg.type == 'bigbed') {
                    summaryOpts.type = 'density';
                }
                createFeature(chromId, start + 1, end, summaryOpts);
            }
        }
    } else if (this.bwg.type == 'bigwig') {
        var sa = new Int16Array(data);
        var la = new Int32Array(data);
        var fa = new Float32Array(data);

        var chromId = la[0];
        var blockStart = la[1];
        var blockEnd = la[2];
        var itemStep = la[3];
        var itemSpan = la[4];
        var blockType = ba[20];
        var itemCount = sa[11];
        
        if (blockType == BIG_WIG_TYPE_FSTEP) {
            for (var i = 0; i < itemCount; ++i) {
                var score = fa[i + 6];
                var fmin = blockStart + (i*itemStep) + 1, fmax = blockStart + (i*itemStep) + itemSpan;
                if (filter(chromId, fmin, fmax))
                    createFeature(chromId, fmin, fmax, {score: score});
            }
        } else if (blockType == BIG_WIG_TYPE_VSTEP) {
            for (var i = 0; i < itemCount; ++i) {
                var start = la[(i*2) + 6] + 1;
                var end = start + itemSpan - 1;
                var score = fa[(i*2) + 7];
                if (filter(chromId, start, end))
                    createFeature(chromId, start, end, {score: score});
            }
        } else if (blockType == BIG_WIG_TYPE_GRAPH) {
            for (var i = 0; i < itemCount; ++i) {
                var start = la[(i*3) + 6] + 1;
                var end   = la[(i*3) + 7];
                var score = fa[(i*3) + 8];
                if (start > end) {
                    start = end;
                }
                if (filter(chromId, start, end))
                    createFeature(chromId, start, end, {score: score});
            }
        } else {
            console.log('Currently not handling bwgType=' + blockType);
        }
    } else if (this.bwg.type == 'bigbed') {
        var offset = 0;
        var dfc = this.bwg.definedFieldCount;
        var schema = this.bwg.schema;

        while (offset < ba.length) {
            var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);
            var start = (ba[offset+7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);
            var end = (ba[offset+11]<<24) | (ba[offset+10]<<16) | (ba[offset+9]<<8) | (ba[offset+8]);
            offset += 12;
            var rest = '';
            while (true) {
                var ch = ba[offset++];
                if (ch != 0) {
                    rest += String.fromCharCode(ch);
                } else {
                    break;
                }
            }

            var featureOpts = {};
            
            var bedColumns;
            if (rest.length > 0) {
                bedColumns = rest.split('\t');
            } else {
                bedColumns = [];
            }
            if (bedColumns.length > 0 && dfc > 3) {
                featureOpts.label = bedColumns[0];
            }
            if (bedColumns.length > 1 && dfc > 4) {
                var score = parseInt(bedColumns[1]);
                if (!isNaN(score))
                    featureOpts.score = score;
            }
            if (bedColumns.length > 2 && dfc > 5) {
                featureOpts.orientation = bedColumns[2];
            }
            if (bedColumns.length > 5 && dfc > 8) {
                var color = bedColumns[5];
                if (BED_COLOR_REGEXP.test(color)) {
                    featureOpts.itemRgb = 'rgb(' + color + ')';
                }
            }

            if (bedColumns.length > dfc-3 && schema) {
                for (var col = dfc - 3; col < bedColumns.length; ++col) {
                    featureOpts[schema.fields[col+3].name] = bedColumns[col];
                }
            }

            if (filter(chromId, start + 1, end, bedColumns)) {
                if (dfc < 12) {
                    createFeature(chromId, start + 1, end, featureOpts);
                } else {
                    var thickStart = bedColumns[3]|0;
                    var thickEnd   = bedColumns[4]|0;
                    var blockCount = bedColumns[6]|0;
                    var blockSizes = bedColumns[7].split(',');
                    var blockStarts = bedColumns[8].split(',');

                    if (featureOpts.exonFrames) {
                        var exonFrames = featureOpts.exonFrames.split(',');
                        featureOpts.exonFrames = undefined;
                    }
                    
                    featureOpts.type = 'transcript'
                    var grp = new DASGroup();
                    for (var k in featureOpts) {
                        grp[k] = featureOpts[k];
                    }
                    grp.id = bedColumns[0];
                    grp.segment = this.bwg.idsToChroms[chromId];
                    grp.min = start + 1;
                    grp.max = end;
                    grp.notes = [];
                    featureOpts.groups = [grp];

                    // Moving towards using bigGenePred model, but will
                    // still support old Dalliance-style BED12+gene-name for the
                    // foreseeable future.
                    if (bedColumns.length > 9) {
                        var geneId = featureOpts.geneName || bedColumns[9];
                        var geneName = geneId;
                        if (bedColumns.length > 10) {
                            geneName = bedColumns[10];
                        }
                        if (featureOpts.geneName2)
                            geneName = featureOpts.geneName2;

                        var gg = shallowCopy(grp);
                        gg.id = geneId;
                        gg.label = geneName;
                        gg.type = 'gene';
                        featureOpts.groups.push(gg);
                    }

                    var spanList = [];
                    for (var b = 0; b < blockCount; ++b) {
                        var bmin = (blockStarts[b]|0) + start;
                        var bmax = bmin + (blockSizes[b]|0);
                        var span = new Range(bmin, bmax);
                        spanList.push(span);
                    }
                    var spans = union(spanList);
                    
                    var tsList = spans.ranges();
                    for (var s = 0; s < tsList.length; ++s) {
                        var ts = tsList[s];
                        createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);
                    }

                    if (thickEnd > thickStart) {
                        var codingRegion = (featureOpts.orientation == '+') ?
                            new Range(thickStart, thickEnd + 3) :
                            new Range(thickStart - 3, thickEnd);
                            // +/- 3 to account for stop codon

                        var tl = intersection(spans, codingRegion);
                        if (tl) {
                            featureOpts.type = 'translation';
                            var tlList = tl.ranges();
                            var readingFrame = 0;

                            var tlOffset = 0;
                            while (tlList[0].min() > tsList[tlOffset].max())
                                tlOffset++;

                            for (var s = 0; s < tlList.length; ++s) {
                                // Record reading frame for every exon
                                var index = s;
                                if (featureOpts.orientation == '-')
                                    index = tlList.length - s - 1;
                                var ts = tlList[index];
                                featureOpts.readframe = readingFrame;
                                if (exonFrames) {
                                    var brf = parseInt(exonFrames[index + tlOffset]);
                                    if (typeof(brf) === 'number' && brf >= 0 && brf <= 2) {
                                        featureOpts.readframe = brf;
                                        featureOpts.readframeExplicit = true;
                                    }
                                }
                                var length = ts.max() - ts.min();
                                readingFrame = (readingFrame + length) % 3;
                                createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);
                            }
                        }
                    }
                }
            }
        }
    } else {
        throw Error("Don't know what to do with " + this.bwg.type);
    }
}

//
// nasty cut/paste, should roll back in!
//

BigWigView.prototype.getFirstAdjacent = function(chrName, pos, dir, callback) {
    var chr = this.bwg.chromsToIDs[chrName];
    if (chr === undefined) {
        // Not an error because some .bwgs won't have data for all chromosomes.
        return callback([]);
    } else {
        this.getFirstAdjacentById(chr, pos, dir, callback);
    }
}

BigWigView.prototype.getFirstAdjacentById = function(chr, pos, dir, callback) {
    var thisB = this;
    if (!this.cirHeader) {
        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function(result) {
            thisB.cirHeader = result;
            var la = new Int32Array(thisB.cirHeader);
            thisB.cirBlockSize = la[1];
            thisB.getFirstAdjacentById(chr, pos, dir, callback);
        });
        return;
    }

    var blockToFetch = null;
    var bestBlockChr = -1;
    var bestBlockOffset = -1;

    var outstanding = 0;

    var beforeBWG = Date.now();

    var cirFobRecur = function(offset, level) {
        outstanding += offset.length;

        var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.
        var spans;
        for (var i = 0; i < offset.length; ++i) {
            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);
            spans = spans ? union(spans, blockSpan) : blockSpan;
        }
        
        var fetchRanges = spans.ranges();
        for (var r = 0; r < fetchRanges.length; ++r) {
            var fr = fetchRanges[r];
            cirFobStartFetch(offset, fr, level);
        }
    }

    var cirFobStartFetch = function(offset, fr, level, attempts) {
        var length = fr.max() - fr.min();
        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function(resultBuffer) {
            for (var i = 0; i < offset.length; ++i) {
                if (fr.contains(offset[i])) {
                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);
                    --outstanding;
                    if (outstanding == 0) {
                        if (!blockToFetch) {
                            if (dir > 0 && (chr != 0 || pos > 0)) {
                                return thisB.getFirstAdjacentById(0, 0, dir, callback);
                            } else if (dir < 0 && (chr != thisB.bwg.maxID || pos < 1000000000)) {
                                return thisB.getFirstAdjacentById(thisB.bwg.maxID, 1000000000, dir, callback);
                            }
                            return callback([]);
                        }

                        thisB.fetchFeatures(function(chrx, fmin, fmax, toks) {
                            return (dir < 0 && (chrx < chr || fmax < pos)) || (dir > 0 && (chrx > chr || fmin > pos));
                        }, [blockToFetch], function(features) {
                            var bestFeature = null;
                            var bestChr = -1;
                            var bestPos = -1;
                            for (var fi = 0; fi < features.length; ++fi) {
                                var f = features[fi];
                                var chrx = f._chromId, fmin = f.min, fmax = f.max;
                                if (bestFeature == null || ((dir < 0) && (chrx > bestChr || fmax > bestPos)) || ((dir > 0) && (chrx < bestChr || fmin < bestPos))) {
                                    bestFeature = f;
                                    bestPos = (dir < 0) ? fmax : fmin;
                                    bestChr = chrx;
                                }
                            }

                            if (bestFeature != null) 
                                return callback([bestFeature]);
                            else
                                return callback([]);
                        });
                    }
                }
            }
        });
    }

    var cirFobRecur2 = function(cirBlockData, offset, level) {
        var ba = new Uint8Array(cirBlockData);
        var sa = new Int16Array(cirBlockData);
        var la = new Int32Array(cirBlockData);

        var isLeaf = ba[offset];
        var cnt = sa[offset/2 + 1];
        offset += 4;

        if (isLeaf != 0) {
            for (var i = 0; i < cnt; ++i) {
                var lo = offset/4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = bwg_readOffset(ba, offset+16);
                var blockSize = bwg_readOffset(ba, offset+24);
                if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)))) ||
                    (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)))))
                {
                    // console.log('Got an interesting block: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);
                    if (/_random/.exec(thisB.bwg.idsToChroms[startChrom])) {
                        // dlog('skipping random: ' + thisB.bwg.idsToChroms[startChrom]);
                    } else if (blockToFetch == null || ((dir < 0) && (endChrom > bestBlockChr || (endChrom == bestBlockChr && endBase > bestBlockOffset)) ||
                                                 (dir > 0) && (startChrom < bestBlockChr || (startChrom == bestBlockChr && startBase < bestBlockOffset))))
                    {
                        //                        dlog('best is: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);
                        blockToFetch = {offset: blockOffset, size: blockSize};
                        bestBlockOffset = (dir < 0) ? endBase : startBase;
                        bestBlockChr = (dir < 0) ? endChrom : startChrom;
                    }
                }
                offset += 32;
            }
        } else {
            var bestRecur = -1;
            var bestPos = -1;
            var bestChr = -1;
            for (var i = 0; i < cnt; ++i) {
                var lo = offset/4;
                var startChrom = la[lo];
                var startBase = la[lo + 1];
                var endChrom = la[lo + 2];
                var endBase = la[lo + 3];
                var blockOffset = (la[lo + 4]<<32) | (la[lo + 5]);
                if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)) &&
                                 (endChrom   >= chr))) ||
                     (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)) &&
                                  (startChrom <= chr))))
                {
                    if (bestRecur < 0 || endBase > bestPos) {
                        bestRecur = blockOffset;
                        bestPos = (dir < 0) ? endBase : startBase;
                        bestChr = (dir < 0) ? endChrom : startChrom;
                    }
                }
                offset += 24;
            }
            if (bestRecur >= 0) {
                cirFobRecur([bestRecur], level + 1);
            }
        }
    };
    

    cirFobRecur([thisB.cirTreeOffset + 48], 1);
}

BigWig.prototype.readWigData = function(chrName, min, max, callback) {
    this.getUnzoomedView().readWigData(chrName, min, max, callback);
}

BigWig.prototype.getUnzoomedView = function() {
    if (!this.unzoomedView) {
        var cirLen = 4000;
        var nzl = this.zoomLevels[0];
        if (nzl) {
            cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;
        }
        this.unzoomedView = new BigWigView(this, this.unzoomedIndexOffset, cirLen, false);
    }
    return this.unzoomedView;
}

BigWig.prototype.getZoomedView = function(z) {
    var zh = this.zoomLevels[z];
    if (!zh.view) {
        zh.view = new BigWigView(this, zh.indexOffset, /* this.zoomLevels[z + 1].dataOffset - zh.indexOffset */ 4000, true);
    }
    return zh.view;
}

function makeBwg(data, callback, name) {
    var bwg = new BigWig();
    bwg.data = data;
    bwg.name = name;
    bwg.data.slice(0, 512).salted().fetch(function(result) {
        if (!result) {
            return callback(null, "Couldn't fetch file");
        }

        var header = result;
        var ba = new Uint8Array(header);
        var sa = new Int16Array(header);
        var la = new Int32Array(header);
        var magic = ba[0] + (M1 * ba[1]) + (M2 * ba[2]) + (M3 * ba[3]);
        if (magic == BIG_WIG_MAGIC) {
            bwg.type = 'bigwig';
        } else if (magic == BIG_BED_MAGIC) {
            bwg.type = 'bigbed';
        } else if (magic == BIG_WIG_MAGIC_BE || magic == BIG_BED_MAGIC_BE) {
            return callback(null, "Currently don't support big-endian BBI files");
            
        } else {
            return callback(null, "Not a supported format, magic=0x" + magic.toString(16));
            
        }

        bwg.version = sa[2];             // 4
        bwg.numZoomLevels = sa[3];       // 6
        bwg.chromTreeOffset = bwg_readOffset(ba, 8);
        bwg.unzoomedDataOffset = bwg_readOffset(ba, 16);
        bwg.unzoomedIndexOffset = bwg_readOffset(ba, 24);
        bwg.fieldCount = sa[16];         // 32
        bwg.definedFieldCount = sa[17];  // 34
        bwg.asOffset = bwg_readOffset(ba, 36);
        bwg.totalSummaryOffset = bwg_readOffset(ba, 44);
        bwg.uncompressBufSize = la[13];  // 52
        bwg.extHeaderOffset = bwg_readOffset(ba, 56);

        bwg.zoomLevels = [];
        for (var zl = 0; zl < bwg.numZoomLevels; ++zl) {
            var zlReduction = la[zl*6 + 16]
            var zlData = bwg_readOffset(ba, zl*24 + 72);
            var zlIndex = bwg_readOffset(ba, zl*24 + 80);
            bwg.zoomLevels.push({reduction: zlReduction, dataOffset: zlData, indexOffset: zlIndex});
        }

        bwg.readChromTree(function() {
            bwg.getAutoSQL(function(as) {
                bwg.schema = as;
                return callback(bwg);
            });
        });
    }, {timeout: 5000});    // Potential timeout on first request to catch mixed-content errors on
                            // Chromium.
}


BigWig.prototype._tsFetch = function(zoom, chr, min, max, callback) {
    var bwg = this;
    if (zoom >= this.zoomLevels.length - 1) {
        if (!this.topLevelReductionCache) {
            this.getZoomedView(this.zoomLevels.length - 1).readWigDataById(-1, 0, 300000000, function(feats) {
                bwg.topLevelReductionCache = feats;
                return bwg._tsFetch(zoom, chr, min, max, callback);
            });
        } else {
            var f = [];
            var c = this.topLevelReductionCache;
            for (var fi = 0; fi < c.length; ++fi) {
                if (c[fi]._chromId == chr) {
                    f.push(c[fi]);
                }
            }
            return callback(f);
        }
    } else {
        var view;
        if (zoom < 0) {
            view = this.getUnzoomedView();
        } else {
            view = this.getZoomedView(zoom);
        }
        return view.readWigDataById(chr, min, max, callback);
    }
}

BigWig.prototype.thresholdSearch = function(chrName, referencePoint, dir, threshold, callback) {
    dir = (dir<0) ? -1 : 1;
    var bwg = this;
    var initialChr = this.chromsToIDs[chrName];
    var candidates = [{chrOrd: 0, chr: initialChr, zoom: bwg.zoomLevels.length - 4, min: 0, max: 300000000, fromRef: true}]
    for (var i = 1; i <= this.maxID + 1; ++i) {
        var chrId = (initialChr + (dir*i)) % (this.maxID + 1);
        if (chrId < 0) 
            chrId += (this.maxID + 1);
        candidates.push({chrOrd: i, chr: chrId, zoom: bwg.zoomLevels.length - 1, min: 0, max: 300000000})
    }
       
    function fbThresholdSearchRecur() {
    	if (candidates.length == 0) {
    	    return callback(null);
    	}
    	candidates.sort(function(c1, c2) {
    	    var d = c1.zoom - c2.zoom;
    	    if (d != 0)
    		    return d;

            d = c1.chrOrd - c2.chrOrd;
            if (d != 0)
                return d;
    	    else
    		    return c1.min - c2.min * dir;
    	});

	    var candidate = candidates.splice(0, 1)[0];
        bwg._tsFetch(candidate.zoom, candidate.chr, candidate.min, candidate.max, function(feats) {
            var rp = dir > 0 ? 0 : 300000000;
            if (candidate.fromRef)
                rp = referencePoint;
            
            for (var fi = 0; fi < feats.length; ++fi) {
    	        var f = feats[fi];
                var score;
                if (f.maxScore != undefined)
                    score = f.maxScore;
                else
                    score = f.score;

                if (dir > 0) {
    	            if (score > threshold) {
        		        if (candidate.zoom < 0) {
        		            if (f.min > rp)
                                return callback(f);
        		        } else if (f.max > rp) {
        		            candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});
        		        }
                    }
                } else {
                    if (score > threshold) {
            		    if (candidate.zoom < 0) {
                	        if (f.max < rp)
                			    return callback(f);
                        } else if (f.min < rp) {
                            candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});
                        }
    	            }
                }
    	    }
            fbThresholdSearchRecur();
        });
    }
    
    fbThresholdSearchRecur();
}

BigWig.prototype.getAutoSQL = function(callback) {
    var thisB = this;
    if (!this.asOffset)
        return callback(null);


    this.data.slice(this.asOffset, 2048).fetch(function(result) {
        var ba = new Uint8Array(result);
        var s = '';
        for (var i = 0; i < ba.length; ++i) {
            if (ba[i] == 0)
                break;
            s += String.fromCharCode(ba[i]);
        }
        
        /* 
         * Quick'n'dirty attempt to parse autoSql format.
         * See: http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/059/5949/5949l2.html
         */

        var header_re = /(\w+)\s+(\w+)\s+("([^"]+)")?\s+\(\s*/;
        var field_re = /([\w\[\]]+)\s+(\w+)\s*;\s*("([^"]+)")?\s*/g;

        var headerMatch = header_re.exec(s);
        if (headerMatch) {
            var as = {
                declType: headerMatch[1],
                name: headerMatch[2],
                comment: headerMatch[4],

                fields: []
            };

            s = s.substring(headerMatch[0]);
            for (var m = field_re.exec(s); m != null; m = field_re.exec(s)) {
                as.fields.push({type: m[1],
                             name: m[2],
                             comment: m[4]});
            }

            return callback(as);
        }
    });
}

BigWig.prototype.getExtraIndices = function(callback) {
    var thisB = this;
    if (this.version < 4 || this.extHeaderOffset == 0 || this.type != 'bigbed') {
        return callback(null);
    } else {
        this.data.slice(this.extHeaderOffset, 64).fetch(function(result) {
            if (!result) {
                return callback(null, "Couldn't fetch extension header");
            }

            var ba = new Uint8Array(result);
            var sa = new Int16Array(result);
            var la = new Int32Array(result);
            
            var extHeaderSize = sa[0];
            var extraIndexCount = sa[1];
            var extraIndexListOffset = bwg_readOffset(ba, 4);

            if (extraIndexCount == 0) {
                return callback(null);
            }

            // FIXME 20byte records only make sense for single-field indices.
            // Right now, these seem to be the only things around, but the format
            // is actually more general.
            thisB.data.slice(extraIndexListOffset, extraIndexCount * 20).fetch(function(eil) {
                if (!eil) {
                    return callback(null, "Couldn't fetch index info");
                }

                var ba = new Uint8Array(eil);
                var sa = new Int16Array(eil);
                var la = new Int32Array(eil);

                var indices = [];
                for (var ii = 0; ii < extraIndexCount; ++ii) {
                    var eiType = sa[ii*10];
                    var eiFieldCount = sa[ii*10 + 1];
                    var eiOffset = bwg_readOffset(ba, ii*20 + 4);
                    var eiField = sa[ii*10 + 8]
                    var index = new BBIExtraIndex(thisB, eiType, eiFieldCount, eiOffset, eiField);
                    indices.push(index);
                }
                callback(indices);
            });
        });
    }
}

function BBIExtraIndex(bbi, type, fieldCount, offset, field) {
    this.bbi = bbi;
    this.type = type;
    this.fieldCount = fieldCount;
    this.offset = offset;
    this.field = field;
}

BBIExtraIndex.prototype.lookup = function(name, callback) {
    var thisB = this;

    this.bbi.data.slice(this.offset, 32).fetch(function(bpt) {
        var ba = new Uint8Array(bpt);
        var sa = new Int16Array(bpt);
        var la = new Int32Array(bpt);
        var bptMagic = la[0];
        var blockSize = la[1];
        var keySize = la[2];
        var valSize = la[3];
        var itemCount = bwg_readOffset(ba, 16);
        var rootNodeOffset = 32;

        function bptReadNode(nodeOffset) {
            thisB.bbi.data.slice(nodeOffset, 4 + (blockSize * (keySize + valSize))).fetch(function(node) {
                var ba = new Uint8Array(node);
                var sa = new Uint16Array(node);
                var la = new Uint32Array(node);

                var nodeType = ba[0];
                var cnt = sa[1];

                var offset = 4;
                if (nodeType == 0) {
                    var lastChildOffset = null;
                    for (var n = 0; n < cnt; ++n) {
                        var key = '';
                        for (var ki = 0; ki < keySize; ++ki) {
                            var charCode = ba[offset++];
                            if (charCode != 0) {
                                key += String.fromCharCode(charCode);
                            }
                        }

                        var childOffset = bwg_readOffset(ba, offset);
                        offset += 8;
                        
                        if (name.localeCompare(key) < 0 && lastChildOffset) {
                            bptReadNode(lastChildOffset);
                            return;
                        }
                        lastChildOffset = childOffset;
                    }
                    bptReadNode(lastChildOffset);
                } else {
                    for (var n = 0; n < cnt; ++n) {
                        var key = '';
                        for (var ki = 0; ki < keySize; ++ki) {
                            var charCode = ba[offset++];
                            if (charCode != 0) {
                                key += String.fromCharCode(charCode);
                            }
                        }
                        
                        // Specific for EI case.
                        if (key == name) {
                            var start = bwg_readOffset(ba, offset);
                            var length = readInt(ba, offset + 8);

                            return thisB.bbi.getUnzoomedView().fetchFeatures(
                                function(chr, min, max, toks) {
                                    if (toks && toks.length > thisB.field - 3)
                                        return toks[thisB.field - 3] == name;
                                }, 
                                [{offset: start, size: length}], 
                                callback);
                        }
                        offset += valSize;
                    }
                    return callback([]);
                }
            });
        }

        bptReadNode(thisB.offset + rootNodeOffset);
    });
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        makeBwg: makeBwg,
        BIG_BED_MAGIC: BIG_BED_MAGIC,
        BIG_WIG_MAGIC: BIG_WIG_MAGIC
    }
}

},{"./bin":4,"./das":10,"./spans":36,"./utils":49,"jszlib":65}],4:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// bin.js general binary data support
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;
}

function BlobFetchable(b) {
    this.blob = b;
}

BlobFetchable.prototype.slice = function(start, length) {
    var b;

    if (this.blob.slice) {
        if (length) {
            b = this.blob.slice(start, start + length);
        } else {
            b = this.blob.slice(start);
        }
    } else {
        if (length) {
            b = this.blob.webkitSlice(start, start + length);
        } else {
            b = this.blob.webkitSlice(start);
        }
    }
    return new BlobFetchable(b);
}

BlobFetchable.prototype.salted = function() {return this;}

if (typeof(FileReader) !== 'undefined') {
    // console.log('defining async BlobFetchable.fetch');

    BlobFetchable.prototype.fetch = function(callback) {
        var reader = new FileReader();
        reader.onloadend = function(ev) {
            callback(bstringToBuffer(reader.result));
        };
        reader.readAsBinaryString(this.blob);
    }

} else {
    // if (console && console.log)
    //    console.log('defining sync BlobFetchable.fetch');

    BlobFetchable.prototype.fetch = function(callback) {
        var reader = new FileReaderSync();
        try {
            var res = reader.readAsArrayBuffer(this.blob);
            callback(res);
        } catch (e) {
            callback(null, e);
        }
    }
}

function URLFetchable(url, start, end, opts) {
    if (!opts) {
        if (typeof start === 'object') {
            opts = start;
            start = undefined;
        } else {
            opts = {};
        }
    }

    this.url = url;
    this.start = start || 0;
    if (end) {
        this.end = end;
    }
    this.opts = opts;
}

URLFetchable.prototype.slice = function(s, l) {
    if (s < 0) {
        throw 'Bad slice ' + s;
    }

    var ns = this.start, ne = this.end;
    if (ns && s) {
        ns = ns + s;
    } else {
        ns = s || ns;
    }
    if (l && ns) {
        ne = ns + l - 1;
    } else {
        ne = ne || l - 1;
    }
    return new URLFetchable(this.url, ns, ne, this.opts);
}

var seed=0;
var isSafari = navigator.userAgent.indexOf('Safari') >= 0 && navigator.userAgent.indexOf('Chrome') < 0 ;

URLFetchable.prototype.fetchAsText = function(callback) {
    try {
        var req = new XMLHttpRequest();
        var length;
        var url = this.url;
        if ((isSafari || this.opts.salt) && url.indexOf('?') < 0) {
            url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++seed));
        }
        req.open('GET', url, true);

        if (this.end) {
            if (this.end - this.start > 100000000) {
                throw 'Monster fetch!';
            }
            req.setRequestHeader('Range', 'bytes=' + this.start + '-' + this.end);
            length = this.end - this.start + 1;
        }

        req.onreadystatechange = function() {
            if (req.readyState == 4) {
                if (req.status == 200 || req.status == 206) {
                    return callback(req.responseText);
                } else {
                    return callback(null);
                }
            }
        };
        if (this.opts.credentials) {
            req.withCredentials = true;
        }
        req.send('');
    } catch (e) {
        return callback(null);
    }
}

URLFetchable.prototype.salted = function() {
    var o = shallowCopy(this.opts);
    o.salt = true;
    return new URLFetchable(this.url, this.start, this.end, o);
}

URLFetchable.prototype.fetch = function(callback, opts) {
    var thisB = this;
 
    opts = opts || {};
    var attempt = opts.attempt || 1;
    var truncatedLength = opts.truncatedLength;
    if (attempt > 3) {
        return callback(null);
    }

    try {
        var timeout;
        if (opts.timeout && !this.opts.credentials) {
            timeout = setTimeout(
                function() {
                    console.log('timing out ' + url);
                    req.abort();
                    return callback(null, 'Timeout');
                },
                opts.timeout
            );
        }

        var req = new XMLHttpRequest();
        var length;
        var url = this.url;
        if ((isSafari || this.opts.salt) && url.indexOf('?') < 0) {
            url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++seed));
        }
        req.open('GET', url, true);
        req.overrideMimeType('text/plain; charset=x-user-defined');
        if (this.end) {
            if (this.end - this.start > 100000000) {
                throw 'Monster fetch!';
            }
            req.setRequestHeader('Range', 'bytes=' + this.start + '-' + this.end);
            length = this.end - this.start + 1;
        }
        req.responseType = 'arraybuffer';
        req.onreadystatechange = function() {
            if (req.readyState == 4) {
                if (timeout)
                    clearTimeout(timeout);
                
                if (req.status == 200 || req.status == 206) {
                    if (req.response) {
                        var bl = req.response.byteLength;
                        if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {
                            return thisB.fetch(callback, {attempt: attempt + 1, truncatedLength: bl});
                        } else {
                            return callback(req.response);
                        }
                    } else if (req.mozResponseArrayBuffer) {
                        return callback(req.mozResponseArrayBuffer);
                    } else {
                        var r = req.responseText;
                        if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {
                            return thisB.fetch(callback, {attempt: attempt + 1, truncatedLength: r.length});
                        } else {
                            return callback(bstringToBuffer(req.responseText));
                        }
                    }
                } else if (req.status == 403 || req.status == 404) { 
                	//refused for lack of permission, usually just trying again later will work
                	return thisB.fetch(callback, {attempt: 0});
                }
                else {
                    return thisB.fetch(callback, {attempt: attempt + 1});
                }
            }
        };
        if (this.opts.credentials) {
            req.withCredentials = true;
        }
        req.send('');
    } catch (e) {
        return callback(null);
    }
}

function bstringToBuffer(result) {
    if (!result) {
        return null;
    }

    var ba = new Uint8Array(result.length);
    for (var i = 0; i < ba.length; ++i) {
        ba[i] = result.charCodeAt(i);
    }
    return ba.buffer;
}

// Read from Uint8Array

(function(global) {
    var convertBuffer = new ArrayBuffer(8);
    var ba = new Uint8Array(convertBuffer);
    var fa = new Float32Array(convertBuffer);


    global.readFloat = function(buf, offset) {
        ba[0] = buf[offset];
        ba[1] = buf[offset+1];
        ba[2] = buf[offset+2];
        ba[3] = buf[offset+3];
        return fa[0];
    };
 }(this));

function readInt64(ba, offset) {
    return (ba[offset + 7] << 24) | (ba[offset + 6] << 16) | (ba[offset + 5] << 8) | (ba[offset + 4]);
}

function readInt(ba, offset) {
    return (ba[offset + 3] << 24) | (ba[offset + 2] << 16) | (ba[offset + 1] << 8) | (ba[offset]);
}

function readShort(ba, offset) {
    return (ba[offset + 1] << 8) | (ba[offset]);
}

function readByte(ba, offset) {
    return ba[offset];
}

function readIntBE(ba, offset) {
    return (ba[offset] << 24) | (ba[offset + 1] << 16) | (ba[offset + 2] << 8) | (ba[offset + 3]);
}

// Exports if we are being used as a module

if (typeof(module) !== 'undefined') {
    module.exports = {
        BlobFetchable: BlobFetchable,
        URLFetchable: URLFetchable,

        readInt: readInt,
        readIntBE: readIntBE,
        readInt64: readInt64,
        readShort: readShort,
        readByte: readByte,
        readFloat: this.readFloat
    }
}

},{"./sha1":33,"./utils":49}],5:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

//
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// browser-us.js: standard UI wiring
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;

    var nf = require('./numformats');
    var formatLongInt = nf.formatLongInt;

    var makeZoomSlider = require('./zoomslider');

    // For side effects

    require('./tier-edit');
    require('./export-config');
    require('./export-ui');
    require('./export-image');
    require('./svg-export');
    require('./session');
}

/*
 * Quite a bit of this ought to be done using a templating system, but
 * since web-components isn't quite ready for prime time yet we'll stick
 * with constructing it all in Javascript for now...
 */

Browser.prototype.initUI = function(holder, genomePanel) {
    if (!this.noSourceCSS) {
      ['bootstrap-scoped.css', 'dalliance-scoped.css', 'font-awesome.min.css'].forEach(function(path) {
        document.head.appendChild(makeElement('link', '', {
          rel: 'stylesheet',
          href: this.resolveURL('$$css/' + path)
        }));
      }.bind(this));
    }

    var b = this;

    if (!b.disableDefaultFeaturePopup) {
        this.addFeatureListener(function(ev, feature, hit, tier) {
            b.featurePopup(ev, feature, hit, tier);
        });
    }

    holder.classList.add('dalliance');
    var toolbar = b.toolbar = makeElement('div', null, {className: 'btn-toolbar toolbar'});

    var title = b.coordSystem.speciesName + ' ' + b.nameForCoordSystem(b.coordSystem);
    if (this.setDocumentTitle) {
        document.title = title + ' :: dalliance';
    }

    var locField = makeElement('input', '', {className: 'loc-field'}, {width: '220px'});
    b.makeTooltip(locField, 'Enter a genomic location or gene name');
    var locStatusField = makeElement('p', '', {className: 'loc-status'});

    var zoomInBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-search-plus'})], {className: 'btn'});
    var zoomSlider = new makeZoomSlider();
    b.makeTooltip(zoomSlider, "Highlighted button shows current zoom level, gray button shows inactive zoom level (click or tap SPACE to toggle).")

    var zoomOutBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-search-minus'})], {className: 'btn'});

    var clearHighlightsButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-eraser'})], {className: 'btn'});

    var addTrackBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-plus'})], {className: 'btn'});
    var favBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-bookmark'})], {className: 'btn'});
    var svgBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-print'})], {className: 'btn'});
    var resetBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-refresh'})], {className: 'btn'});
    var optsButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-cogs'})], {className: 'btn'});
    var helpButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-question'})], {className: 'btn'});

    var tierEditButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-road'})], {className: 'btn'});
    b.makeTooltip(tierEditButton, 'Configure currently selected track(s) (E)');
    
    var tierCommentButton = makeElement('a', [makeElement('i', null, {className: 'glyphicon glyphicon-comment tierCommentButton'},{"font-family": "Glyphicons Halflings","padding-top": "3px"})], {className: 'btn'});
    b.makeTooltip(tierCommentButton, 'Write a comment for the selected track (D)');

    var leapLeftButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-angle-left'})], {className: 'btn'}, {width: '5px'});
    var leapRightButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-angle-right'})], {className: 'btn pull-right'}, {width: '5px'});

    var modeButtons = makeElement('div', null, {className: 'btn-group pull-right'});
    if (!this.noTrackAdder)
        modeButtons.appendChild(addTrackBtn);
    
    modeButtons.appendChild(tierCommentButton);
    
    if (!this.noTrackEditor)
        modeButtons.appendChild(tierEditButton);
    if (!this.noExport)
        modeButtons.appendChild(svgBtn);
    if (!this.noOptions)
        modeButtons.appendChild(optsButton);
    if (!this.noHelp)
        modeButtons.appendChild(helpButton);

    this.setUiMode = function(m) {
        this.uiMode = m;
        var mb = {help: helpButton, add: addTrackBtn, opts: optsButton, 'export': svgBtn, tier: tierEditButton};
        for (var x in mb) {
            if (x == m)
                mb[x].classList.add('active');
            else
                mb[x].classList.remove('active');
        }
    }

    if (!this.noLeapButtons)
        toolbar.appendChild(leapRightButton);

    if (modeButtons.firstChild)
        toolbar.appendChild(modeButtons);
    
    if (!this.noLeapButtons)
        toolbar.appendChild(leapLeftButton);
    if (!this.noTitle) {
        toolbar.appendChild(makeElement('div', makeElement('h4', title, {}, {margin: '0px'}), {className: 'btn-group title'}));
    }
    if (!this.noLocationField)
        toolbar.appendChild(makeElement('div', [locField, locStatusField], {className: 'btn-group loc-group'}));
    if (!this.noClearHighlightsButton)
        toolbar.appendChild(clearHighlightsButton);

    if (!this.noZoomSlider) {
        toolbar.appendChild(makeElement('div', [zoomInBtn,
                                                makeElement('span', zoomSlider, {className: 'btn'}),
                                                zoomOutBtn], {className: 'btn-group'}));
    }
    
    if (this.toolbarBelow) {
        holder.appendChild(genomePanel);
        holder.appendChild(toolbar);
    } else {
        holder.appendChild(toolbar);
        holder.appendChild(genomePanel);
    }


    var lt2 = Math.log(2) / Math.log(10);
    var lt5 = Math.log(5) / Math.log(10);
    var roundSliderValue = function(x) {
        var ltx = (x / b.zoomExpt + Math.log(b.zoomBase)) / Math.log(10);
        
        var whole = ltx|0
        var frac = ltx - whole;
        var rounded

        if (frac < 0.01)
            rounded = whole;
        else if (frac <= (lt2 + 0.01))
            rounded = whole + lt2;
        else if (frac <= (lt5 + 0.01))
            rounded = whole + lt5;
        else {
            rounded = whole + 1;
        }

        return (rounded * Math.log(10) -Math.log(b.zoomBase)) * b.zoomExpt;
    }

    var markSlider = function(x) {
        zoomSlider.addLabel(x, humanReadableScale(Math.exp(x / b.zoomExpt) * b.zoomBase));
    }

    this.addViewListener(function(chr, min, max, _oldZoom, zoom) {
        locField.value = (chr + ':' + formatLongInt(min) + '..' + formatLongInt(max));
        zoomSlider.min = zoom.min|0;
        zoomSlider.max = zoom.max|0;
        if (zoom.isSnapZooming) {
            zoomSlider.value = zoom.alternate
            zoomSlider.value2 = zoom.current;
            zoomSlider.active = 2;
        } else {
            zoomSlider.value = zoom.current;
            zoomSlider.value2 = zoom.alternate;
            zoomSlider.active = 1;
        }

        if (zoom.current == zoom.min)
            zoomInBtn.classList.add('disabled');
        else
            zoomInBtn.classList.remove('disabled');

        if (zoom.current == zoom.max)
            zoomOutBtn.classList.add('disabled');
        else
            zoomOutBtn.classList.remove('disabled');

        zoomSlider.removeLabels();
        var zmin = zoom.min;
        var zmax = zoom.max;
        var zrange = zmax - zmin;

        
        markSlider(roundSliderValue(zmin));
        markSlider(roundSliderValue(zmin + (1.0*zrange/3.0)));
        markSlider(roundSliderValue(zmin + (2.0*zrange/3.0)));
        markSlider(roundSliderValue(zmax));

        if (b.storeStatus) {
            b.storeViewStatus();
        }

        if (b.highlights.length > 0) {
            clearHighlightsButton.style.display = 'inline-block';
        } else {
            clearHighlightsButton.style.display = 'none';
        }
    });

    this.addTierListener(function() {
        if (b.storeStatus) {
            b.storeTierStatus();
        }
    });

    locField.addEventListener('keydown', function(ev) {
        if (ev.keyCode == 40) {
            ev.preventDefault(); ev.stopPropagation();
            b.setSelectedTier(0);
        } if (ev.keyCode == 10 || ev.keyCode == 13) {
            ev.preventDefault();


            var g = locField.value;
            b.search(g, function(err) {
                if (err) {
                    locStatusField.textContent = '' + err;
                } else {
                    locStatusField.textContent = '';
                }
            });
        }
    }, false);
    
    var makeComment = function()
    {
    	if (b.tiers.length == 0)
			return;

		if (b.getSelectedTier() == undefined) {
			showAlert("Warning","Select a custom track to comment on.");
			return;
		}
		
		var tiernum = b.getSelectedTier();
		if (tiernum < 0)
		{
			return;
		}

		var trackid = b.tiers[tiernum]["dasSource"]["_id"];
		if (trackid == undefined) {
			showAlert("Warning","Comments on default tracks not allowed right now.");
			return;
		}

		var tname = b.tiers[b.getSelectedTier()]["dasSource"]["name"]+" ("+trackid+")";

		//prefill fields with current view
		$("#c_trackid").val(trackid);
		$("#c_trackname").val(tname);
		$("#c_chr").val(b.chr);
		$("#c_start").val(b.viewStart | 0);
		$("#c_end").val(b.viewEnd | 0);
		$("#comment-form").modal("show");
    };
    
    //tierCommentButton
    tierCommentButton.addEventListener('click', function(ev) {
        makeComment();
    }, false);
    
    var trackAddPopup;
    addTrackBtn.addEventListener('click', function(ev) {
        if (trackAddPopup && trackAddPopup.displayed) {
            b.removeAllPopups();
        } else {
            trackAddPopup = b.showTrackAdder(ev);
        }
    }, false);
    b.makeTooltip(addTrackBtn, 'Add a new track from the registry or an indexed file. (A)');

    zoomInBtn.addEventListener('click', function(ev) {
      ev.stopPropagation(); ev.preventDefault();

      b.zoomStep(-10);
    }, false);
    b.makeTooltip(zoomInBtn, 'Zoom in (+)');

    zoomOutBtn.addEventListener('click', function(ev) {
      ev.stopPropagation(); ev.preventDefault();

      b.zoomStep(10);
    }, false);
    b.makeTooltip(zoomOutBtn, 'Zoom out (-)');

    zoomSlider.addEventListener('change', function(ev) {
        var wantSnap = zoomSlider.active == 2;
        if (wantSnap != b.isSnapZooming) {
            b.savedZoom = b.zoomSliderValue  - b.zoomMin;
            b.isSnapZooming = wantSnap;
        }
        var activeZSV = zoomSlider.active == 1 ? zoomSlider.value : zoomSlider.value2;

    	b.zoomSliderValue = (1.0 * activeZSV);
    	b.zoom(Math.exp((1.0 * activeZSV) / b.zoomExpt));
    }, false);

    favBtn.addEventListener('click', function(ev) {
       ev.stopPropagation(); ev.preventDefault();
    }, false);
    b.makeTooltip(favBtn, 'Favourite regions');

    svgBtn.addEventListener('click', function(ev) {
       ev.stopPropagation(); ev.preventDefault();
        b.openExportPanel();
    }, false);
    b.makeTooltip(svgBtn, 'Export publication-quality SVG. (X)');

    var optsPopup;
    optsButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();

        b.toggleOptsPopup(ev);
    }, false);
    b.makeTooltip(optsButton, 'Configure options.');

    helpButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();
        b.toggleHelpPopup(ev);
    });
    b.makeTooltip(helpButton, 'Help; Keyboard shortcuts. (H)');

    tierEditButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();
        if (b.selectedTiers.length == 1) {
            b.openTierPanel(b.tiers[b.selectedTiers[0]]);
        }
    }, false);

    leapLeftButton.addEventListener('click', function(ev) {
        b.leap(b.reverseKeyScrolling ? -1 : 1, false);
    }, false);
    b.makeTooltip(leapLeftButton, function(ev) {
        var st = b.getSelectedTier();
        var tier;
        if (st >= 0)
            tier = b.tiers[st];

        if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof(tier.quantLeapThreshold) == 'number') {
            return 'Jump to the next region with a score above the threshold in the selected track "' + (tier.config.name || tier.dasSource.name) + '"" (ctrl+LEFT)';
        } else if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'leap')) {
            return 'Jump to the next feature in the selected track "' + (tier.config.name || tier.dasSource.name) + '" (ctrl+LEFT)';
        } else {
            return 'Jump left (shift+LEFT)';
        }
    });

    leapRightButton.addEventListener('click', function(ev) {
        b.leap(b.reverseKeyScrolling ? 1 : -1, false);
    }, false);
    b.makeTooltip(leapRightButton, function(ev) {
        var st = b.getSelectedTier();
        var tier;
        if (st >= 0)
            tier = b.tiers[st];

        if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof(tier.quantLeapThreshold) == 'number') {
            return 'Jump to the next region with a score above the threshold in the selected track "' + (tier.config.name || tier.dasSource.name) + '"" (ctrl+RIGHT)';
        } else if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'leap')) {
            return 'Jump to the next feature in the selected track "' + (tier.config.name || tier.dasSource.name) + '" (ctrl+RIGHT)';
        } else {
            return 'Jump right (shift+RIGHT)';
        }
    });
    b.addTierSelectionListener(function() {
        var st = b.getSelectedTier();
        var tier;
        if (st >= 0)
            tier = b.tiers[st];

        var canLeap = false;
        if (tier && tier.featureSource) {
            if (b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof(tier.quantLeapThreshold) == 'number')
                canLeap = true;
            else if (b.sourceAdapterIsCapable(tier.featureSource, 'leap'))
                canLeap = true;
        }

        leapLeftButton.firstChild.className = canLeap ? 'fa fa-angle-double-left' : 'fa fa-angle-left';
        leapRightButton.firstChild.className = canLeap ? 'fa fa-angle-double-right' : 'fa fa-angle-right';
    });

    clearHighlightsButton.addEventListener('click', function(ev) {
        b.clearHighlights();
    }, false);
    b.makeTooltip(clearHighlightsButton, 'Clear highlights (C)');

    b.addTierSelectionWrapListener(function(dir) {
        if (dir < 0) {
            b.setSelectedTier(null);
            locField.focus();
        }
    });

    b.addTierSelectionListener(function(sel) {
        if (b.uiMode === 'tier') {
            if (sel.length == 0) {
                b.hideToolPanel();
                b.manipulatingTier = null;
                b.uiMode = 'none';
            } else {
                var ft = b.tiers[sel[0]];
                if (ft != b.manipulatingTier) {
                    b.openTierPanel(ft);
                }
            }
        }
    });

    var uiKeyHandler = function(ev) {
        //console.log('bukh: ' + ev.keyCode);
        if (ev.keyCode == 65 || ev.keyCode == 97) {  // a
            ev.preventDefault(); ev.stopPropagation();
            b.showTrackAdder();
        } else if (ev.keyCode == 72 || ev.keyCode == 104) { // h
            ev.stopPropagation(); ev.preventDefault();
            b.toggleHelpPopup(ev);
        } else if (ev.keyCode == 69 || ev.keyCode == 101) { //e
            ev.stopPropagation(); ev.preventDefault();
            if (b.selectedTiers.length == 1) {
                b.openTierPanel(b.tiers[b.selectedTiers[0]]);
            }
        } else if (ev.keyCode == 88 || ev.keyCode == 120) { // x
            ev.stopPropagation(); ev.preventDefault();
            b.openExportPanel();
        } else if (ev.keyCode == 67 || ev.keyCode == 99) { // c
            ev.stopPropagation(); ev.preventDefault();
            b.clearHighlights();
        } else if (ev.keyCode == 68 || ev.keyCode == 100) { // d
            ev.stopPropagation(); ev.preventDefault();
            
            makeComment();
        }
    };

    holder.addEventListener('focus', function(ev) {
        holder.addEventListener('keydown', uiKeyHandler, false);
    }, false);
    holder.addEventListener('blur', function(ev) {
        holder.removeEventListener('keydown', uiKeyHandler, false);
    }, false);

    holder.addEventListener('keydown', function(ev) {
        if (ev.keyCode === 27) {
            if (b.uiMode !== 'none') {
                // Only consume event if tool panel is open.
                ev.preventDefault();
                ev.stopPropagation();
                b.setUiMode('none');
                b.hideToolPanel();

                if (b.selectedTiers && b.selectedTiers.length > 0) {
                    b.browserHolder.focus();
                }
            }
        }
    }, false);
}

Browser.prototype.showToolPanel = function(panel, nowrap) {
    var thisB = this;

    if (this.activeToolPanel) {
        this.activeToolPanel.parentElement.removeChild(this.activeToolPanel);
    }

    var content;
    if (nowrap)
        content = panel;
    else
        content = makeElement('div', panel, {}, {overflowY: 'auto', width: '100%'});


    var divider = makeElement('div', makeElement('i', null, {className: 'fa fa-caret-right'}), {className: 'tool-divider'});
    divider.addEventListener('click', function(ev) {
        thisB.hideToolPanel();
        thisB.setUiMode('none');
    }, false);
    this.makeTooltip(divider, 'Close tool panel (ESC)');
    this.activeToolPanel = makeElement('div', [divider, content], {className: 'tool-holder'});
    this.svgHolder.appendChild(this.activeToolPanel);
    this.resizeViewer();

    var thisB = this;
}

Browser.prototype.hideToolPanel = function() {
    if (this.activeToolPanel) {
        this.activeToolPanel.parentElement.removeChild(this.activeToolPanel);
    }
    this.svgHolder.style.width = '100%';
    this.activeToolPanel = null;
    this.resizeViewer();
}

Browser.prototype.toggleHelpPopup = function(ev) {
    if (this.uiMode === 'help') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var helpFrame = makeElement('iframe', null, {scrolling: 'yes', seamless: 'seamless', src: this.resolveURL('$$help/index.html'), className: 'help-panel'});
        this.showToolPanel(helpFrame, false);
        this.setUiMode('help');
    }
}

Browser.prototype.toggleOptsPopup = function(ev) {
    var b = this;

    if (this.uiMode === 'opts') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var optsForm = makeElement('div', null, {className: 'form-horizontal'}, {boxSizing: 'border-box', MozBoxSizing: 'border-box', display: 'inline-block', verticalAlign: 'top'});
        var optsTable = makeElement('table');
        optsTable.cellPadding = 5;

        var scrollModeButton = makeElement('input', '', {type: 'checkbox', checked: b.reverseScrolling});
        scrollModeButton.addEventListener('change', function(ev) {
            b.reverseScrolling = scrollModeButton.checked;
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Reverse trackpad scrolling', {align: 'right'}), makeElement('td', scrollModeButton)]));

        var scrollKeyButton = makeElement('input', '', {type: 'checkbox', checked: b.reverseKeyScrolling});
        scrollKeyButton.addEventListener('change', function(ev) {
            b.reverseKeyScrolling = scrollKeyButton.checked;
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Reverse scrolling buttons and keys', {align: 'right'}), makeElement('td', scrollKeyButton)]));


        var rulerSelect = makeElement('select');
        rulerSelect.appendChild(makeElement('option', 'Left', {value: 'left'}));
        rulerSelect.appendChild(makeElement('option', 'Center', {value: 'center'}));
        rulerSelect.appendChild(makeElement('option', 'Right', {value: 'right'}));
        rulerSelect.appendChild(makeElement('option', 'None', {value: 'none'}));
        rulerSelect.value = b.rulerLocation;
        rulerSelect.addEventListener('change', function(ev) {
            b.rulerLocation = rulerSelect.value;
            b.positionRuler();
            for (var ti = 0; ti < b.tiers.length; ++ti) {
                b.tiers[ti].paintQuant();
            }
            b.storeStatus();
        }, false);
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Vertical guideline', {align: 'right'}), makeElement('td', rulerSelect)]));
        
        var singleBaseHighlightButton = makeElement('input', '', {type: 'checkbox', checked: b.singleBaseHighlight}); 
        singleBaseHighlightButton.addEventListener('change', function(ev) {
            b.singleBaseHighlight = singleBaseHighlightButton.checked;
            b.positionRuler();
            b.storeStatus();
        }, false);
        singleBaseHighlightButton.setAttribute('id','singleBaseHightlightButton'); // making this because access is required when the key 'u' is pressed and the options are visible
        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Display and highlight current genome location', {align: 'right'}), makeElement('td', singleBaseHighlightButton)]));
        
        optsForm.appendChild(optsTable);

        var resetButton = makeElement('button', 'Reset browser', {className: 'btn'}, {marginLeft: 'auto', marginRight: 'auto', display: 'block'});
        resetButton.addEventListener('click', function(ev) {
            b.reset();
            b.storeTierStatus();
        }, false);
        optsForm.appendChild(resetButton);

        this.showToolPanel(optsForm);
        this.setUiMode('opts');
    }
}

function humanReadableScale(x) {
    var suffix = 'bp';
    if (x > 1000000000) {
        x /= 1000000000;
        suffix = 'Gb';
    } else if (x > 1000000) {
        x /= 1000000
        suffix = 'Mb';
    } else if (x > 1000) {
        x /= 1000;
        suffix = 'kb';
    }
    return '' + Math.round(x) + suffix;
}

},{"./cbrowser":6,"./export-config":14,"./export-image":15,"./export-ui":16,"./numformats":26,"./session":32,"./svg-export":38,"./tier-edit":44,"./utils":49,"./zoomslider":52}],6:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// cbrowser.js: canvas browser container
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var Observed = utils.Observed;
    var Awaited = utils.Awaited;
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var miniJSONify = utils.miniJSONify;
    var shallowCopy = utils.shallowCopy;
    var textXHR = utils.textXHR;

    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;

    var thub = require('./thub');
    var connectTrackHub = thub.connectTrackHub;

    var VERSION = require('./version');

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
    var formatLongInt = nf.formatLongInt;

    var Chainset = require('./chainset').Chainset;

    var Promise = require('es6-promise').Promise;

    var sourcecompare = require('./sourcecompare');
    var sourcesAreEqual = sourcecompare.sourcesAreEqual;
    var sourcesAreEqualModuloStyle = sourcecompare.sourcesAreEqualModuloStyle;
    var sourceDataURI = sourcecompare.sourceDataURI;
    var sourceStyleURI = sourcecompare.sourceStyleURI;
}

function Region(chr, min, max) {
    this.min = min;
    this.max = max;
    this.chr = chr;
}

function Browser(opts) {
    if (!opts) {
        opts = {};
    }

    this.prefix = '//www.biodalliance.org/release-0.13/';

    this.sources = [];
    this.tiers = [];
    this.tierGroups = {};

    this.featureListeners = [];
    this.featureHoverListeners = [];
    this.viewListeners = [];
    this.regionSelectListeners = [];
    this.tierListeners = [];
    this.tierSelectionListeners = [];
    this.tierSelectionWrapListeners = [];

    this.cookieKey = 'browser';

    this.chains = {};

    this.pageName = 'svgHolder'
    this.maxExtra = 2.5;
    this.minExtra = 0.5;
    this.zoomFactor = 1.0;
    this.maxPixelsPerBase = 10;
    this.origin = 0;
    this.targetQuantRes = 1.0;
    this.featurePanelWidth = 750;
    this.zoomBase = 100;
    this.zoomExpt = 30.0; // Back to being fixed....
    this.zoomSliderValue = 100;
    this.entryPoints = null;
    this.currentSeqMax = -1; // init once EPs are fetched.

    this.highlights = [];
    this.selectedTiers = [1];

    this.maxViewWidth = 500000;
    this.defaultSubtierMax = 100;

    // Options.
    
    this.reverseScrolling = false;
    this.rulerLocation = 'center';
    this.defaultHighlightFill = 'red';
    this.defaultHighlightAlpha = 0.3;
    this.exportHighlights = true;
    this.exportRuler = true;
    this.singleBaseHighlight = true;
    
    // Visual config.

    // this.tierBackgroundColors = ["rgb(245,245,245)", "rgb(230,230,250)" /* 'white' */];
    this.tierBackgroundColors = ["rgb(245,245,245)", 'white'];
    this.minTierHeight = 20;
    this.noDefaultLabels = false;

    // Registry

    this.availableSources = new Observed();
    this.defaultSources = [];
    this.mappableSources = {};

    // Central DAS Registry no longer available 2015-05

    this.registry = null; // '//www.dasregistry.org/das/sources';
    this.noRegistryTabs = true;

    this.hubs = [];
    this.hubObjects = [];

    this.sourceCache = new SourceCache();
    
    this.retina = true;

    this.useFetchWorkers = true;
    this.maxWorkers = 2;
    this.workerPath = '$$worker-all.js';

    this.assemblyNamePrimary = true;
    this.assemblyNameUcsc = true;

    // HTTP warning support

    this.httpCanaryURL = 'http://www.biodalliance.org/http-canary.txt';
    this.httpWarningURL = '//www.biodalliance.org/https.html';

    this.initListeners = [];

    if (opts.baseColors) {
        this.baseColors = opts.baseColors
    } else {
        this.baseColors = {
            A: 'rgb(63, 188, 63)',
            C: 'rgb(180, 220, 255)',
            G: 'rgb(255, 180, 41)',
            T: 'rgb(255, 110, 110)',
            '-' : 'hotpink', // deletion
            'I' : 'red' // insertion
        };
    }

    if (opts.viewStart !== undefined && typeof(opts.viewStart) !== 'number') {
        throw Error('viewStart must be an integer');
    }
    if (opts.viewEnd !== undefined && typeof(opts.viewEnd) !== 'number') {
        throw Error('viewEnd must be an integer');
    }

    for (var k in opts) {
        this[k] = opts[k];
    }
    if (typeof(opts.uiPrefix) === 'string' && typeof(opts.prefix) !== 'string') {
        this.prefix = opts.uiPrefix;
    }
    // If the prefix only starts with a single '/' this is relative to the current
    // site, so we need to prefix the prefix with //{hostname}
    if (this.prefix.indexOf('//') < 0 && this.prefix.indexOf('/') === 0) {
        var location = window.location.hostname;
        if (window.location.port) {
            location += ':' + window.location.port
        };
        this.prefix = '//' + location + this.prefix;
    }
    if (this.prefix.indexOf('//') === 0) {
        var proto = window.location.protocol;
        if (proto == 'http:' || proto == 'https:') {
            // Protocol-relative URLs okay.
        } else {
            console.log(window.location.protocol);
            console.log('WARNING: prefix is set to a protocol-relative URL (' + this.prefix + ' when loading from a non-HTTP source');
            this.prefix = 'http:' + this.prefix;
        }
    }

    if (!this.coordSystem) {
        throw Error('Coordinate system must be configured');
    }

    if (this.chr === undefined || this.viewStart === undefined || this.viewEnd === undefined) {
        throw Error('Viewed region (chr:start..end) must be defined');
    }

    var thisB = this;

    if (document.readyState === 'complete') {
        thisB.realInit();
    } else {
        var loadListener = function(ev) {
            window.removeEventListener('load', loadListener, false);
            thisB.realInit();
        }
        window.addEventListener('load', loadListener, false);
    }
}

Browser.prototype.resolveURL = function(url) {
    return url.replace('$$', this.prefix);
}

Browser.prototype.destroy = function() {
    window.removeEventListener('resize', this.resizeListener, false);
}

Browser.prototype.realInit = function() {
    var self = this;

    if (this.wasInitialized) {
        console.log('Attemping to call realInit on an already-initialized Dalliance instance');
        return;
    }

    this.wasInitialized = true;

    var ua = navigator.userAgent || 'dummy';
    if (ua.indexOf('Trident') >= 0 && ua.indexOf('rv:11') >= 0) {
        // console.log('Detected IE11, disabling tier pinning.');
        this.disablePinning = true;
    }

    this.defaultChr = this.chr;
    this.defaultStart = this.viewStart;
    this.defaultEnd = this.viewEnd;
    this.defaultSources = [];
    for (var i = 0; i < this.sources.length; ++i) {
        var s = this.sources[i];
        if (s)
            this.defaultSources.push(s);
    }

    if (this.restoreStatus) {
        this.statusRestored = this.restoreStatus();
    }

    var helpPopup;
    var thisB = this;
    this.browserHolderHolder = document.getElementById(this.pageName);
    this.browserHolderHolder.classList.add('dalliance-injection-point');
    this.browserHolder = makeElement('div', null, {className: 'dalliance dalliance-root', tabIndex: -1});
    if (this.maxHeight) {
        this.browserHolder.style.maxHeight = this.maxHeight + 'px';
    } else if (this.maxHeight != undefined) {
        this.browserHolder.style.maxHeight = null;
    }
    removeChildren(this.browserHolderHolder);
    this.browserHolderHolder.appendChild(this.browserHolder);
    this.svgHolder = makeElement('div', null, {className: 'main-holder'});

    this.initUI(this.browserHolder, this.svgHolder);

    this.pinnedTierHolder = makeElement('div', null, {className: 'tier-holder tier-holder-pinned'});
    this.tierHolder = makeElement('div', this.makeLoader(24), {className: 'tier-holder tier-holder-rest'});

    this.locSingleBase = makeElement('span', '', {className: 'loc-single-base'});
    var locSingleBaseHolder = makeElement('div', this.locSingleBase,{className: 'loc-single-base-holder'}); 
    // Add listener to update single base location
    this.addViewListener(function(chr, minFloor, maxFloor, zoomSliderValue, zoomSliderDict, min, max) {
        // Just setting textContent causes layout flickering in Blink.
        // This approach means that the element is never empty.
        var loc = Math.round((max + min) / 2);
        self.locSingleBase.appendChild(document.createTextNode(chr + ':' + formatLongInt(loc)));
        self.locSingleBase.removeChild(self.locSingleBase.firstChild);
    });

    if (this.disablePinning) {
        this.tierHolderHolder = this.tierHolder;
    } else {
        this.tierHolderHolder = makeElement('div', [locSingleBaseHolder, this.pinnedTierHolder, this.tierHolder], {className: 'tier-holder-holder'});
        this.svgHolder.appendChild(this.tierHolderHolder);
    }
    this.svgHolder.appendChild(this.tierHolderHolder);

    this.bhtmlRoot = makeElement('div');
    if (!this.disablePoweredBy) {
        this.bhtmlRoot.appendChild(makeElement('span', ['Powered by ', makeElement('a', 'Biodalliance', {href: 'http://www.biodalliance.org/'}), ' ' + VERSION], {className: 'powered-by'}));
    }
    this.browserHolder.appendChild(this.bhtmlRoot);
    
    this.resizeListener = function(ev) {
        thisB.resizeViewer();
    };
    window.addEventListener('resize', this.resizeListener, false);
    this.ruler = makeElement('div', null, {className: 'guideline'})
    this.ruler2 = makeElement('div', null, {className: 'single-base-guideline'});
    this.tierHolderHolder.appendChild(this.ruler);
    this.tierHolderHolder.appendChild(this.ruler2);
    this.chainConfigs = this.chains || {};
    this.chains = {};
    for (var k in this.chainConfigs) {
        var cc = this.chainConfigs[k];
        if (cc instanceof Chainset) {
            console.log('WARNING: Should no longer use "new Chainset" in Biodalliance configurations.');
        }
        this.chains[k] = new Chainset(cc);
    }

    var promisedWorkers;
    if (this.maxWorkers > 0) {
        var pw = [];
        for (var fi = 0; fi < this.maxWorkers; ++fi)
            pw.push(makeFetchWorker(this));
        promisedWorkers = Promise.all(pw);
    } else {
        promisedWorkers = Promise.resolve([]);
    }

    this.fetchWorkers = null;
    this.nextWorker = 0;
    promisedWorkers.then(function(v) {
        console.log('Booted ' + v.length + ' workers');
        thisB.fetchWorkers = v; 
    }, function(v) {
        console.log('Failed to boot workers', v);
    }).then(function() {
        if (window.getComputedStyle(thisB.browserHolderHolder).display != 'none' &&
            thisB.tierHolder.getBoundingClientRect().width > 0)
        {
            setTimeout(function() {thisB.realInit2()}, 1);
        } else {
            var pollInterval = setInterval(function() {
                if (window.getComputedStyle(thisB.browserHolderHolder).display != 'none' &&
                    thisB.tierHolder.getBoundingClientRect().width > 0)
                {
                    clearInterval(pollInterval);
                    thisB.realInit2();
                } 
            }, 300);
        }
    });
}

Browser.prototype.realInit2 = function() {
    var thisB = this;

    // Remove the loader icon, if needed
    removeChildren(this.tierHolder);
    removeChildren(this.pinnedTierHolder);

    this.featurePanelWidth = this.tierHolder.getBoundingClientRect().width | 0;
    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);
    if (!this.zoomMax) {
        this.zoomMax = this.zoomExpt * Math.log(this.maxViewWidth / this.zoomBase);
        this.zoomMin = this.zoomExpt * Math.log(this.featurePanelWidth / this.maxPixelsPerBase / this.zoomBase);
    }
    this.zoomSliderValue = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);

    // Event handlers

//    this.tierHolderHolder.addEventListener('mousewheel', function(ev) {
//        ev.stopPropagation(); ev.preventDefault();
//
//        if (ev.wheelDeltaX) {
//            var delta = ev.wheelDeltaX/5;
//            if (!thisB.reverseScrolling) {
//                delta = -delta;
//            }
//            thisB.move(delta);
//        }
//
//        if (ev.wheelDeltaY) {
//            var delta = ev.wheelDeltaY;
//            if (thisB.reverseScrolling) {
//                delta = -delta;
//            }
//            thisB.tierHolder.scrollTop += delta;
//        }
//    }, false); 

//    this.tierHolderHolder.addEventListener('MozMousePixelScroll', function(ev) {
//        ev.stopPropagation(); ev.preventDefault();
//        if (ev.axis == 1) {
//            if (ev.detail != 0) {
//                var delta = ev.detail/4;
//                if (thisB.reverseScrolling) {
//                    delta = -delta;
//                }
//                thisB.move(delta);
//            }
//        } else {
//            var delta = ev.detail;
//            if (!thisB.reverseScrolling) {
//              delta = -delta;
//            }
//
//            thisB.tierHolder.scrollTop += delta;
//        }
//    }, false); 

    this.tierHolderHolder.addEventListener('touchstart', function(ev) {return thisB.touchStartHandler(ev)}, false);
    this.tierHolderHolder.addEventListener('touchmove', function(ev) {return thisB.touchMoveHandler(ev)}, false);
    this.tierHolderHolder.addEventListener('touchend', function(ev) {return thisB.touchEndHandler(ev)}, false);
    this.tierHolderHolder.addEventListener('touchcancel', function(ev) {return thisB.touchCancelHandler(ev)}, false);

    var keyHandler = function(ev) {
        // console.log('cbkh: ' + ev.keyCode);
        if (ev.keyCode == 13) { // enter
            var layoutsChanged = false;
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                var t = thisB.tiers[ti];
                if (t.wantedLayoutHeight && t.wantedLayoutHeight != t.layoutHeight) {
                    t.layoutHeight = t.wantedLayoutHeight;
                    t.clipTier();
                    layoutsChanged = true;
                }
            }
            if (layoutsChanged) {
                thisB.arrangeTiers();
            }
        } else if (ev.keyCode == 32 || ev.charCode == 32) { // space
            if (!thisB.isSnapZooming) {
                thisB.isSnapZooming = true;
                var newZoom = (thisB.savedZoom || 0.0) + thisB.zoomMin;
                thisB.savedZoom = thisB.zoomSliderValue - thisB.zoomMin;
                thisB.zoomSliderValue = newZoom;
                thisB.zoom(Math.exp((1.0 * newZoom) / thisB.zoomExpt));
            } else {
                thisB.isSnapZooming = false;
                var newZoom = (thisB.savedZoom || 20.0) + thisB.zoomMin;
                thisB.savedZoom = thisB.zoomSliderValue - thisB.zoomMin;
                thisB.zoomSliderValue = newZoom;
                thisB.zoom(Math.exp((1.0 * newZoom) / thisB.zoomExpt));
            }
            ev.stopPropagation(); ev.preventDefault();      
        } else if (ev.keyCode == 85) { // u
            if (thisB.uiMode === 'opts') { // if the options are visible, toggle the checkbox too
                var check = document.getElementById("singleBaseHightlightButton").checked;
                document.getElementById("singleBaseHightlightButton").checked = !check;
            } 
            thisB.singleBaseHighlight = !thisB.singleBaseHighlight;
            thisB.positionRuler();
            ev.stopPropagation(); ev.preventDefault();
        } else if (ev.keyCode == 39) { // right arrow
            ev.stopPropagation(); ev.preventDefault();
            thisB.scrollArrowKey(ev, -1);
        } else if (ev.keyCode == 37) { // left arrow
            ev.stopPropagation(); ev.preventDefault();
            thisB.scrollArrowKey(ev, 1);
        } else if (ev.keyCode == 38 || ev.keyCode == 87) { // up arrow | w
            ev.stopPropagation(); ev.preventDefault();

            if (ev.shiftKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];
                var ch = tt.forceHeight || tt.subtiers[0].height;
                if (ch >= 40) {
                    tt.mergeConfig({height: ch-10});
                }
            } else if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];
  
                if (tt.quantLeapThreshold) {
                    var th = tt.subtiers[0].height;
                    var tq = tt.subtiers[0].quant;
                    if (!tq)
                        return;

                    var qmin = 1.0 * tq.min;
                    var qmax = 1.0 * tq.max;

                    var qscale = (qmax - qmin) / th;
                    tt.mergeConfig({quantLeapThreshold: qmin + ((Math.round((tt.quantLeapThreshold - qmin)/qscale)|0)+1)*qscale});

                    tt.notify('Threshold: ' + formatQuantLabel(tt.quantLeapThreshold));
                }                
            } else if (ev.altKey) {
                var cnt = thisB.selectedTiers.length;
                if (cnt == 0)
                    return;

                var st = thisB.selectedTiers[0];
                var contiguous = true;
                var mt = [];
                for (var si = 0; si < thisB.selectedTiers.length; ++si) {
                    mt.push(thisB.tiers[thisB.selectedTiers[si]]);
                    if (si > 0 && thisB.selectedTiers[si] - thisB.selectedTiers[si - 1] != 1)
                        contiguous = false;
                }

                if (contiguous && st <= 0)
                    return;

                for (var si = thisB.selectedTiers.length - 1; si >= 0; --si)
                    thisB.tiers.splice(thisB.selectedTiers[si], 1);

                thisB.selectedTiers.splice(0, cnt);

                var ip = contiguous ? st - 1 : st;
                for (var si = 0; si < mt.length; ++si) {
                    thisB.tiers.splice(ip+si, 0, mt[si]);
                    thisB.selectedTiers.push(ip + si);
                }

                thisB.withPreservedSelection(thisB._ensureTiersGrouped);
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();
                thisB.reorderTiers();
                thisB.notifyTier();
            } else {
                var st = thisB.getSelectedTier();
                if (st > 0) {
                    thisB.setSelectedTier(st - 1);
                    var nst = thisB.tiers[thisB.getSelectedTier()];
                    var top = nst.row.offsetTop, bottom = top + nst.row.offsetHeight;
                    if (top < thisB.tierHolder.scrollTop || bottom > thisB.tierHolder.scrollTop + thisB.tierHolder.offsetHeight) {
                        thisB.tierHolder.scrollTop = top;
                    }
                } else {
                    thisB.notifyTierSelectionWrap(-1);
                }
            }
        } else if (ev.keyCode == 40 || ev.keyCode == 83) { // down arrow | s
            ev.stopPropagation(); ev.preventDefault();

            if (ev.shiftKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];
                var ch = tt.forceHeight || tt.subtiers[0].height;
                tt.mergeConfig({height: ch+10});
            } else if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var tt = thisB.tiers[st];

                if (tt.quantLeapThreshold) {
                    var th = tt.subtiers[0].height;
                    var tq = tt.subtiers[0].quant;
                    if (!tq)
                        return;

                    var qmin = 1.0 * tq.min;
                    var qmax = 1.0 * tq.max;
                    var qscale = (qmax - qmin) / th;

                    var it = Math.round((tt.quantLeapThreshold - qmin)/qscale)|0;
                    if (it > 1) {
                        tt.mergeConfig({quantLeapThreshold: qmin + (it-1)*qscale});
                        tt.notify('Threshold: ' + formatQuantLabel(tt.quantLeapThreshold));
                    }
                }
            } else if (ev.altKey) {
                var cnt = thisB.selectedTiers.length;
                if (cnt == 0)
                    return;

                var st = thisB.selectedTiers[0];
                var discontig = 0;
                var mt = [];
                for (var si = 0; si < thisB.selectedTiers.length; ++si) {
                    mt.push(thisB.tiers[thisB.selectedTiers[si]]);
                    if (si > 0)
                        discontig += (thisB.selectedTiers[si] - thisB.selectedTiers[si - 1] - 1);
                }
                var contiguous = discontig == 0;

                if (contiguous && st + cnt >= thisB.tiers.length)
                    return;

                for (var si = thisB.selectedTiers.length - 1; si >= 0; --si)
                    thisB.tiers.splice(thisB.selectedTiers[si], 1);

                thisB.selectedTiers.splice(0, cnt);

                var ip = contiguous ? st + 1 : st + discontig;
                for (var si = 0; si < mt.length; ++si) {
                    thisB.tiers.splice(ip+si, 0, mt[si]);
                    thisB.selectedTiers.push(ip + si);
                }

                thisB.withPreservedSelection(function() {
                    thisB._ensureTiersGrouped(true);
                });
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();
                thisB.reorderTiers();
                thisB.notifyTier();
            } else {
                var st = thisB.getSelectedTier();
                if (st < thisB.tiers.length -1) {
                    thisB.setSelectedTier(st + 1);
                    var nst = thisB.tiers[thisB.getSelectedTier()];
                    var top = nst.row.offsetTop, bottom = top + nst.row.offsetHeight;
                    if (top < thisB.tierHolder.scrollTop || bottom > thisB.tierHolder.scrollTop + thisB.tierHolder.offsetHeight) {
                        thisB.tierHolder.scrollTop = Math.min(top, bottom - thisB.tierHolder.offsetHeight);
                    }
                }
            }
        } else if (ev.keyCode == 187 || ev.keyCode == 61) { // +
            ev.stopPropagation(); ev.preventDefault();
            thisB.zoomStep(-10);
        } else if (ev.keyCode == 189 || ev.keyCode == 173) { // -
            ev.stopPropagation(); ev.preventDefault();
            thisB.zoomStep(10);
        } else if (ev.keyCode == 73 || ev.keyCode == 105) { // i
            ev.stopPropagation(); ev.preventDefault();
            var st = thisB.getSelectedTier();
            if (st < 0) return;
            var t = thisB.tiers[st];
            if (!t.infoVisible) {
                t.infoElement.style.display = 'block';
                t.updateHeight();
                t.infoVisible = true;
            } else {
                t.infoElement.style.display = 'none';
                t.updateHeight();
                t.infoVisible = false;
            }
        } else if (ev.keyCode == 84) { // t
            var bumpStatus;
            if( ev.shiftKey ){
                ev.stopPropagation(); ev.preventDefault();
                for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                    var t = thisB.tiers[ti];
                    if (t.dasSource.collapseSuperGroups) {
                        if (bumpStatus === undefined) {
                            bumpStatus = !t.bumped;
                        }
                        t.mergeConfig({bumped: bumpStatus});
                    }
                }
            } else if (!ev.ctrlKey && !ev.metaKey) {
                ev.stopPropagation(); ev.preventDefault();
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                var t = thisB.tiers[st];

                if (t.dasSource.collapseSuperGroups) {
                    if (bumpStatus === undefined) {
                        bumpStatus = !t.bumped;
                    }
                    t.mergeConfig({bumped: bumpStatus});
                }
            }
        } else if (ev.keyCode == 77 || ev.keyCode == 109) { // m
            ev.stopPropagation(); ev.preventDefault();
            if ((ev.ctrlKey || ev.metaKey) && thisB.selectedTiers.length > 1) {
                thisB.mergeSelectedTiers();
            }
        } else if (ev.keyCode == 68 || ev.keyCode == 100) { // d
            ev.stopPropagation(); ev.preventDefault();
            if (ev.ctrlKey || ev.metaKey) {
                var st = thisB.getSelectedTier();
                if (st < 0) return;
                thisB.addTier(thisB.tiers[st].dasSource);
            }
        } else if (ev.keyCode == 80 || ev.keyCode == 112) { // p
            if (ev.ctrlKey || ev.metaKey) {
                // Need to be careful because order of tiers could change
                // once we start updating pinning.
                var tt = [];
                for (var st = 0; st < thisB.selectedTiers.length; ++st) {
                    tt.push(thisB.tiers[thisB.selectedTiers[st]]);
                }
                for (var ti = 0; ti < tt.length; ++ti) {
                    tt[ti].mergeConfig({pinned: !tt[ti].pinned});
                }
            }
        } else {
            // console.log('key: ' + ev.keyCode + '; char: ' + ev.charCode);
        }
    };

    this.browserHolder.addEventListener('focus', function(ev) {
        thisB.browserHolder.addEventListener('keydown', keyHandler, false);
    }, false);
    this.browserHolder.addEventListener('blur', function(ev) {
        thisB.browserHolder.removeEventListener('keydown', keyHandler, false);
    }, false);

    // Popup support (does this really belong here? FIXME)
    this.hPopupHolder = makeElement('div');
    this.hPopupHolder.style['font-family'] = 'helvetica';
    this.hPopupHolder.style['font-size'] = '12pt';
    this.hPopupHolder.classList.add('dalliance');
    document.body.appendChild(this.hPopupHolder);

    for (var t = 0; t < this.sources.length; ++t) {
        var source = this.sources[t];
        if (!source)
            continue;
        
        var config = {};
        if (this.restoredConfigs) {
            config = this.restoredConfigs[t];
        }

        if (!source.disabled) {
            this.makeTier(source, config);
        }
    }

    thisB._ensureTiersGrouped();
    thisB.arrangeTiers();
    thisB.reorderTiers();
    thisB.refresh();
    thisB.setSelectedTier(1);

    thisB.positionRuler();


    var ss = this.getSequenceSource();
    if (ss) {
        ss.getSeqInfo(this.chr, function(si) {
            if (si)
                thisB.currentSeqMax = si.length;
            else
                thisB.currentSeqMax = -1;
        });
    }

    this.queryRegistry();
    for (var m in this.chains) {
        this.queryRegistry(m, true);
    }

    if (this.hubs) {
        for (var hi = 0; hi < this.hubs.length; ++hi) {
            var hc = this.hubs[hi];
            if (typeof hc == 'string') {
                hc = {url: hc};
            };

            (function(hc) {
                connectTrackHub(hc.url, function(hub, err) {
                    if (err) {
                        console.log(err);
                    } else {
                        var tdb;
                        if (hc.genome)
                            tdb = hub.genomes[hc.genome];
                        else 
                            tdb = hub.genomes[thisB.coordSystem.ucscName];

                        if (tdb) {
                            if (hc.mapping) 
                                tdb.mapping = hc.mapping;
                            if (hc.label)
                                tdb.hub.altLabel = hc.label
                            thisB.hubObjects.push(tdb);
                        }
                    }
                }, hc);
            })(hc);
        }
    }

    if (this.fullScreen) {
        this.setFullScreenHeight();
    }

    if (!this.statusRestored && this.storeStatus) {
        this.storeStatus();
    }

    // Ping any init listeners.
    for (var ii = 0; ii < this.initListeners.length; ++ii) {
        try {
            this.initListeners[ii].call(this);
        } catch (e) {
            console.log(e);
        }
    }
}

// 
// Touch event support
//

Browser.prototype.touchStartHandler = function(ev) {
    // Events not consumed so they can be interpretted as clicks as well.

    this.touchOriginX = ev.touches[0].pageX;
    this.touchOriginY = ev.touches[0].pageY;
    if (ev.touches.length == 2) {
        var sep = Math.abs(ev.touches[0].pageX - ev.touches[1].pageX);
        this.zooming = true;
        this.zoomLastSep = this.zoomInitialSep = sep;
        this.zoomInitialScale = this.scale;
    }
}

Browser.prototype.touchMoveHandler = function(ev) {
    // These events *are* consumed to ensure we never get any dragging that
    // we don't manage ourselves.

    ev.stopPropagation(); ev.preventDefault();
    
    if (ev.touches.length == 1) {
        var touchX = ev.touches[0].pageX;
        var touchY = ev.touches[0].pageY;
        if (this.touchOriginX && touchX != this.touchOriginX) {
            this.move(touchX - this.touchOriginX);
        }
        if (this.touchOriginY && touchY != this.touchOriginY) {
            this.tierHolder.scrollTop -= (touchY - this.touchOriginY);
        }
        this.touchOriginX = touchX;
        this.touchOriginY = touchY;
    } else if (this.zooming && ev.touches.length == 2) {
        var sep = Math.abs(ev.touches[0].pageX - ev.touches[1].pageX);
        if (sep != this.zoomLastSep) {
            var cp = (ev.touches[0].pageX + ev.touches[1].pageX)/2;
            var scp = this.viewStart + (cp/this.scale)|0
            this.scale = this.zoomInitialScale * (sep/this.zoomInitialSep);
            this.viewStart = scp - (cp/this.scale)|0;
            for (var i = 0; i < this.tiers.length; ++i) {
                this.tiers[i].draw();
            }
        }
        this.zoomLastSep = sep;
    }
}

Browser.prototype.touchEndHandler = function(ev) {
}

Browser.prototype.touchCancelHandler = function(ev) {
}


Browser.prototype.makeTier = function(source, config) {
    try {
        return this.realMakeTier(source, config);
    } catch (e) {
        console.log('Error initializing', source);
        console.log(e.stack || e);
    }
}

Browser.prototype.realMakeTier = function(source, config) {
    var thisB = this;
    var background = null;
    if (this.tierBackgroundColors) {
        background = this.tierBackgroundColors[this.tiers.length % this.tierBackgroundColors.length];
    }

    var tier = new DasTier(this, source, config, background);
    tier.oorigin = this.viewStart

    var isDragging = false;
    var dragOrigin, dragMoveOrigin;
    var hoverTimeout;

    var featureLookup = function(rx, ry) {
        var st = tier.subtiers;
        if (!st) {
            return;
        }

        var sti = 0;
        ry -= tier.padding;;
        while (sti < st.length && ry > st[sti].height && sti < (st.length - 1)) {
            ry = ry - st[sti].height - tier.padding;
            ++sti;
        }
        if (sti >= st.length) {
            return;
        }

        var glyphs = st[sti].glyphs;
        var viewCenter = (thisB.viewStart + thisB.viewEnd)/2;
        var offset = (tier.glyphCacheOrigin - thisB.viewStart)*thisB.scale;
        rx -= offset;
       
        return glyphLookup(glyphs, rx, ry);
    }

    var dragMoveHandler = function(ev) {
        ev.preventDefault(); ev.stopPropagation();
        var rx = ev.clientX;
        if (rx != dragMoveOrigin) {
            thisB.move((rx - dragMoveOrigin), true);
            dragMoveOrigin = rx;
        }
        thisB.isDragging = true;
    }

    var dragUpHandler = function(ev) {
        window.removeEventListener('mousemove', dragMoveHandler, true);
        window.removeEventListener('mouseup', dragUpHandler, true);
        thisB.move((ev.clientX - dragMoveOrigin)); // Snap back (FIXME: consider animation)
    }
        

    tier.viewport.addEventListener('mousedown', function(ev) {
        thisB.browserHolder.focus();
        ev.preventDefault();
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX, ry = ev.clientY;

        window.addEventListener('mousemove', dragMoveHandler, true);
        window.addEventListener('mouseup', dragUpHandler, true);
        dragOrigin = dragMoveOrigin = rx;
        thisB.isDragging = false; // Not dragging until a movement event arrives.
    }, false);

    tier.viewport.addEventListener('mousemove', function(ev) {
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX - br.left, ry = ev.clientY - br.top;

        var hit = featureLookup(rx, ry);
        if (hit && hit.length > 0) {
            tier.row.style.cursor = 'pointer';
        } else {
            tier.row.style.cursor = 'default';
        }

        if (hoverTimeout) {
            clearTimeout(hoverTimeout);
        }

        if (isDragging) {
            // if (tier.dasSource.tier_type !== 'sequence' && rx != dragMoveOrigin) {
            //    thisB.move((rx - dragMoveOrigin));
            //    dragMoveOrigin = rx;
            // }
        } else {
            hoverTimeout = setTimeout(function() {
                var hit = featureLookup(rx, ry);
                if (hit && hit.length > 0) {
                    thisB.notifyFeatureHover(ev, hit[hit.length - 1], hit, tier);
                }
            }, 1000);
        }
    });

    var doubleClickTimeout = null;
    tier.viewport.addEventListener('mouseup', function(ev) {
        var br = tier.row.getBoundingClientRect();
        var rx = ev.clientX - br.left, ry = ev.clientY - br.top;

        var hit = featureLookup(rx, ry);
        if (hit && hit.length > 0 && !thisB.isDragging) {
            if (doubleClickTimeout) {
                clearTimeout(doubleClickTimeout);
                doubleClickTimeout = null;
                thisB.featureDoubleClick(hit, rx, ry);
            } else {
                doubleClickTimeout = setTimeout(function() {
                    doubleClickTimeout = null;
                    thisB.notifyFeature(ev, hit[hit.length-1], hit, tier);
                }, 500);
            }
        }

        if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
            var a = thisB.viewStart + (rx/thisB.scale);
            var b = thisB.viewStart + (dragOrigin/thisB.scale);

            var min, max;
            if (a < b) {
                min = a|0; max = b|0;
            } else {
                min = b|0; max = a|0;
            }

            thisB.notifyRegionSelect(thisB.chr, min, max);
        }
        thisB.isDragging = false;
    }, false);

    tier.viewport.addEventListener('mouseout', function(ev) {
        isDragging = false;
    });

    tier.removeButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();
        for (var ti = 0; ti < thisB.tiers.length; ++ti) {
            if (thisB.tiers[ti] === tier) {
                thisB.removeTier({index: ti});
                break;
            }
        }
    }, false);
    tier.nameButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();

        if (ev.shiftKey) {
            var hitTier = -1;
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    hitTier = ti;
                    break;
                }
            }
            if (hitTier >= 0) {
                var i = thisB.selectedTiers.indexOf(hitTier);
                if (i >= 0) {
                    thisB.selectedTiers.splice(i, 1);
                } else {
                    thisB.selectedTiers.push(hitTier);
                    thisB.selectedTiers.sort();
                }
                thisB.markSelectedTiers();
                thisB.notifyTierSelection();

                if (thisB.selectedTiers.length > 0) {
                    thisB.browserHolder.focus();
                } else {
                    thisB.notifyTierSelectionWrap(-1);
                }
            }
        } else {
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    thisB.browserHolder.focus();
                    if (thisB.selectedTiers.length != 1 || thisB.selectedTiers[0] != ti) {
                        thisB.setSelectedTier(ti);
                        return;
                    }
                }
            }

            if (!tier.infoVisible) {
                tier.infoElement.style.display = 'block';
                tier.updateHeight();
                tier.infoVisible = true;
            } else {
                tier.infoElement.style.display = 'none';
                tier.updateHeight();
                tier.infoVisible = false;
            }
        }
    }, false);
    tier.bumpButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();
        var bumpStatus;
        var t = tier;
        if (t.dasSource.collapseSuperGroups) {
            if (bumpStatus === undefined) {
                bumpStatus = !t.bumped;
            }
            t.mergeConfig({bumped: bumpStatus});
        }
    }, false);

    
    var dragLabel;
    var dragTierHolder;
    var dragTierHolderScrollLimit;
    var tierOrdinal;
    var yAtLastReorder;
    var tiersWereReordered = false;

    var labelDragHandler = function(ev) {
        var label = tier.label;

        ev.stopPropagation(); ev.preventDefault();
        if (!dragLabel) {
            if (tier.pinned) {
                dragTierHolder = thisB.pinnedTierHolder;
            } else {
                dragTierHolder = thisB.tierHolder;
            }
            dragTierHolderScrollLimit = dragTierHolder.scrollHeight - dragTierHolder.offsetHeight;

            dragLabel = label.cloneNode(true);
            dragLabel.style.cursor = 'pointer';
            dragTierHolder.appendChild(dragLabel);
            label.style.visibility = 'hidden';

            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] === tier) {
                    tierOrdinal = ti;
                    break;
                }
            }

            yAtLastReorder = ev.clientY;
        }
        
        var holderBCR = dragTierHolder.getBoundingClientRect();
        dragLabel.style.left = (label.getBoundingClientRect().left - holderBCR.left) + 'px'; 
        dragLabel.style.top = (ev.clientY - holderBCR.top + dragTierHolder.scrollTop - 10) + 'px';

        var pty = ev.clientY - holderBCR.top + dragTierHolder.scrollTop;
        for (var ti = 0; ti < thisB.tiers.length; ++ti) {
            var tt = thisB.tiers[ti];
            if (tt.pinned ^ tier.pinned)
                continue; 

            var ttr = tt.row.getBoundingClientRect();
            pty -= (ttr.bottom - ttr.top);
            if (pty < 0) {
                if (ti < tierOrdinal && ev.clientY < yAtLastReorder || ti > tierOrdinal && ev.clientY > yAtLastReorder) {
                    thisB.withPreservedSelection(function() {
                        thisB.tiers.splice(tierOrdinal, 1);
                        thisB.tiers.splice(ti, 0, tier);
                        thisB._ensureTiersGrouped(ti > tierOrdinal);
                    });

                    for (var tix = 0; tix < thisB.tiers.length; ++tix)
                        if (thisB.tiers[tix] == tier)
                            tierOrdinal = tix;

                    yAtLastReorder = ev.clientY;
                    thisB.reorderTiers();
                    dragTierHolder.appendChild(dragLabel); // Because reorderTiers removes all children.
                    tiersWereReordered = true;
                }
                break;
            }
        }

        if (dragLabel.offsetTop < dragTierHolder.scrollTop) {
            dragTierHolder.scrollTop -= (dragTierHolder.scrollTop - dragLabel.offsetTop);
        } else if ((dragLabel.offsetTop + dragLabel.offsetHeight) > (dragTierHolder.scrollTop + dragTierHolder.offsetHeight)) {
            dragTierHolder.scrollTop = Math.min(dragTierHolder.scrollTop + 
                                                   (dragLabel.offsetTop + dragLabel.offsetHeight) - 
                                                   (dragTierHolder.scrollTop + dragTierHolder.offsetHeight),
                                                dragTierHolderScrollLimit);
        }
    };

    var labelReleaseHandler = function(ev) {
        var label = tier.label;

        ev.stopPropagation(); ev.preventDefault();
        if (dragLabel) {
            dragLabel.style.cursor = 'auto';
            dragTierHolder.removeChild(dragLabel);
            dragLabel = null;
            label.style.visibility = 'visible';
        }
        document.removeEventListener('mousemove', labelDragHandler, false);
        document.removeEventListener('mouseup', labelReleaseHandler, false);

        if (tiersWereReordered) {
            for (var ti = 0; ti < thisB.tiers.length; ++ti) {
                if (thisB.tiers[ti] == tier) {
                    thisB.setSelectedTier(ti);
                    break;
                }
            }
            thisB.notifyTier();
        }
    };

    tier.label.addEventListener('mousedown', function(ev) {
        ev.stopPropagation(); ev.preventDefault();
        tiersWereReordered = false;
        document.addEventListener('mousemove', labelDragHandler, false);
        document.addEventListener('mouseup', labelReleaseHandler, false);
    }, false);

    this.tiers.push(tier);  // NB this currently tells any extant knownSpace about the new tier.
    
    tier.init(); // fetches stylesheet
    tier.currentlyHeight = 50;
    this.updateHeight();
    tier.updateLabel();



    this.withPreservedSelection(thisB._ensureTiersGrouped);
    tier._updateFromConfig();
    this.reorderTiers();

    return tier;
}

Browser.prototype.reorderTiers = function() {
    removeChildren(this.tierHolder);
    removeChildren(this.pinnedTierHolder);
    if (this.disablePinning) {
        this.tierHolder.appendChild(this.ruler);
        this.tierHolder.appendChild(this.ruler2);
    }
    var hasPinned = false;
    var pinnedTiers = [], unpinnedTiers = [];
    for (var i = 0; i < this.tiers.length; ++i) {
        var t = this.tiers[i];
        if (t.pinned && !this.disablePinning) {
            pinnedTiers.push(t);
            this.pinnedTierHolder.appendChild(this.tiers[i].row);
            hasPinned = true;
        } else {
            unpinnedTiers.push(t);
            this.tierHolder.appendChild(this.tiers[i].row);
        }
    }

    this.withPreservedSelection(function() {
        this.tiers.splice(0, this.tiers.length);
        for (var i = 0; i < pinnedTiers.length; ++i)
            this.tiers.push(pinnedTiers[i]);
        for (var i = 0; i < unpinnedTiers.length; ++i)
            this.tiers.push(unpinnedTiers[i]);
    });

    if (hasPinned)
        this.pinnedTierHolder.classList.add('tier-holder-pinned-full');
    else
        this.pinnedTierHolder.classList.remove('tier-holder-pinned-full');

    this.arrangeTiers();
}

Browser.prototype.withPreservedSelection = function(f) {
    var st = [];
    for (var xi = 0; xi < this.selectedTiers.length; ++xi) {
        st.push(this.tiers[this.selectedTiers[xi]]);
    }

    f.call(this);

    this.selectedTiers = [];
    for (var sti = 0; sti < this.tiers.length; ++sti) {
        if (st.indexOf(this.tiers[sti]) >= 0)
            this.selectedTiers.push(sti);
    }
}

Browser.prototype.refreshTier = function(tier) {
    if (this.knownSpace) {
        this.knownSpace.invalidate(tier);
    }
}

/* Internal use only, assumes selection is being managed elsewhere... */

Browser.prototype._ensureTiersGrouped = function(down) {
    var groupedTiers = {};
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.dasSource.tierGroup) {
            pusho(groupedTiers, t.dasSource.tierGroup, t);
        }   
    }

    var newTiers = [];
    if (down)
        this.tiers.reverse();
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.dasSource.tierGroup) {
            var nt = groupedTiers[t.dasSource.tierGroup];
            if (nt) {
                if (down)
                    nt.reverse();
                for (var nti = 0; nti < nt.length; ++nti)
                    newTiers.push(nt[nti]);
                groupedTiers[t.dasSource.tierGroup] = null;
            }
        } else {
            newTiers.push(t);
        }
    }
    if (down)
        newTiers.reverse();
    this.tiers.splice(0, this.tiers.length);
    for (var nti = 0; nti < newTiers.length; ++nti)
        this.tiers.push(newTiers[nti]);
}

Browser.prototype.arrangeTiers = function() {
    var arrangedTiers = [];
    var groupedTiers = {};

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (t.pinned) {
            arrangedTiers.push(t);
            if (t.dasSource.tierGroup) {
                pusho(groupedTiers, t.dasSource.tierGroup, t);
            }
        }
        
    }
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var t = this.tiers[ti];
        if (!t.pinned) {
            arrangedTiers.push(t);
            if (t.dasSource.tierGroup) {
                pusho(groupedTiers, t.dasSource.tierGroup, t);
            }
        }
    }

    for (var g in groupedTiers) {
        var tiers = groupedTiers[g];
        var tierGroup = this.tierGroups[g];
        if (!tierGroup) {
            tierGroup = {
                element: makeElement(
                    'div',
                    makeElement('span', g, {className: 'tier-group-label'}),
                    {className: "tier-group"})
            };
            this.tierGroups[g] = tierGroup;
        }

        if (tierGroup.element.parentNode)
            tierGroup.element.parentNode.removeChild(tierGroup.element);

        var holder = tiers[0].pinned ? this.pinnedTierHolder : this.tierHolder;
        var min = 10000000, max = 0;
        for (var ti = 0; ti < tiers.length; ++ti) {
            var row = tiers[ti].row;
            min = Math.min(min, row.offsetTop);
            max = Math.max(max, row.offsetTop + row.offsetHeight);
        }
        tierGroup.element.style.top = min + 'px';
        tierGroup.element.style.left = '0px';
        tierGroup.element.style.height = (max-min) + 'px';
        holder.appendChild(tierGroup.element);
    }

    if (this.tierBackgroundColors) {
        for (var ti = 0; ti < arrangedTiers.length; ++ti) {
            var t = arrangedTiers[ti];
            t.setBackground(this.tierBackgroundColors[ti % this.tierBackgroundColors.length]);
            if (t.dasSource.tierGroup) 
                t.label.style.left = '18px';
            else
                t.label.style.left = '2px';
            t.background = this.tierBackgroundColors[ti % this.tierBackgroundColors.length];
        }
    }
}

Browser.prototype.refresh = function() {
    this.notifyLocation();
    var width = (this.viewEnd - this.viewStart) + 1;
    var minExtraW = (100.0/this.scale)|0;
    var maxExtraW = (1000.0/this.scale)|0;

    var newOrigin = (this.viewStart + this.viewEnd) / 2;
    var oh = newOrigin - this.origin;
    this.origin = newOrigin;
    this.scaleAtLastRedraw = this.scale;
    for (var t = 0; t < this.tiers.length; ++t) {
        var od = oh;
        if (this.tiers[t].originHaxx) {
            od += this.tiers[t].originHaxx;
        }
        this.tiers[t].originHaxx = od;
    }

    var scaledQuantRes = this.targetQuantRes / this.scale;

    var innerDrawnStart = Math.max(1, (this.viewStart|0) - minExtraW);
    var innerDrawnEnd = Math.min((this.viewEnd|0) + minExtraW, ((this.currentSeqMax|0) > 0 ? (this.currentSeqMax|0) : 1000000000))
    var outerDrawnStart = Math.max(1, (this.viewStart|0) - maxExtraW);
    var outerDrawnEnd = Math.min((this.viewEnd|0) + maxExtraW, ((this.currentSeqMax|0) > 0 ? (this.currentSeqMax|0) : 1000000000));

    if (!this.knownSpace || this.knownSpace.chr !== this.chr) {
        var ss = this.getSequenceSource();
        if (this.knownSpace)
            this.knownSpace.cancel();
        this.knownSpace = new KnownSpace(this.tiers, this.chr, outerDrawnStart, outerDrawnEnd, scaledQuantRes, ss);
    }
    
    var seg = this.knownSpace.bestCacheOverlapping(this.chr, innerDrawnStart, innerDrawnEnd);
    if (seg && seg.min <= innerDrawnStart && seg.max >= innerDrawnEnd) {
        this.drawnStart = Math.max(seg.min, outerDrawnStart);
        this.drawnEnd = Math.min(seg.max, outerDrawnEnd);
    } else {
        this.drawnStart = outerDrawnStart;
        this.drawnEnd = outerDrawnEnd;
    }
    
    this.knownSpace.viewFeatures(this.chr, this.drawnStart, this.drawnEnd, scaledQuantRes);
    this.drawOverlays();
    this.positionRuler();
}

function setSources(msh, availableSources, maybeMapping) {
    if (maybeMapping) {
        for (var s = 0; s < availableSources.length; ++s) {
            availableSources[s].mapping = maybeMapping;
        }
    }
    msh.set(availableSources);
}

Browser.prototype.queryRegistry = function(maybeMapping, tryCache) {
    if (!this.registry)
        return;

    var thisB = this;
    var coords, msh;
    if (maybeMapping) {
        coords = this.chains[maybeMapping].coords;
        if (!thisB.mappableSources[maybeMapping]) {
            thisB.mappableSources[maybeMapping] = new Observed();
        }
        msh = thisB.mappableSources[maybeMapping];
    } else {
        coords = this.coordSystem;
        msh = this.availableSources;
    }
    var cacheHash = hex_sha1(miniJSONify(coords));
    if (tryCache) {
        var cacheTime = localStorage['dalliance.registry.' + cacheHash + '.last_queried'];
        if (cacheTime) {
            try {
                setSources(msh, JSON.parse(localStorage['dalliance.registry.' + cacheHash + '.sources']), maybeMapping);
                var cacheAge = (Date.now()|0) - (cacheTime|0);
                if (cacheAge < (12 * 60 * 60 * 1000)) {
                    return;
                }
            } catch (rex) {
                console.log('Bad registry cache: ' + rex);
            }
        }
    }

    var rurl = this.registry;
    if (rurl.indexOf('//') == 0) {
        var proto = window.location.protocol;
        if (proto != 'https:' && proto != 'http:')
            rurl = 'http:' + rurl;
    }
    new DASRegistry(rurl).sources(function(sources) {
        var availableSources = [];
        for (var s = 0; s < sources.length; ++s) {
            var source = sources[s];
            if (!source.coords || source.coords.length == 0) {
                continue;
            }
            var scoords = source.coords[0];
            if (scoords.taxon != coords.taxon || scoords.auth != coords.auth || scoords.version != coords.version) {
                continue;
            }   
            availableSources.push(source);
        }

        localStorage['dalliance.registry.' + cacheHash + '.sources'] = JSON.stringify(availableSources);
        localStorage['dalliance.registry.' + cacheHash + '.last_queried'] = '' + Date.now();
        
        setSources(msh, availableSources, maybeMapping);
    }, function(error) {
        // msh.set(null);
    }, coords);
}

//
// Navigation
//

Browser.prototype.move = function(pos, soft)
{
    var wid = this.viewEnd - this.viewStart;
    var nStart = this.viewStart - ((1.0 * pos) / this.scale);
    var nEnd = nStart + wid;

    if (!soft) {
        if (this.currentSeqMax > 0 && nEnd > this.currentSeqMax) {
            nEnd = this.currentSeqMax;
            nStart = this.viewEnd - wid;
        }
        if (nStart < 1) {
            nStart = 1;
            nEnd = nStart + wid;
        }
    }

    this.setLocation(null, nStart, nEnd, null, soft);
}

Browser.prototype.zoomStep = function(delta) {
    var oz = 1.0 * this.zoomSliderValue;
    var nz = oz + delta;
    if (nz < this.zoomMin) {
        nz= this.zoomMin;
    }
    if (nz > this.zoomMax) {
        nz = this.zoomMax;
    }

    if (nz != oz) {
        this.zoomSliderValue = nz; // FIXME maybe ought to set inside zoom!
        this.zoom(Math.exp((1.0 * nz) / this.zoomExpt));
    }
}

Browser.prototype.zoom = function(factor) {
    this.zoomFactor = factor;
    var viewCenter = Math.round((this.viewStart + this.viewEnd) / 2.0)|0;
    this.viewStart = viewCenter - this.zoomBase * this.zoomFactor / 2;
    this.viewEnd = viewCenter + this.zoomBase * this.zoomFactor / 2;
    if (this.currentSeqMax > 0 && (this.viewEnd > this.currentSeqMax + 5)) {
        var len = this.viewEnd - this.viewStart + 1;
        this.viewEnd = this.currentSeqMax;
        this.viewStart = this.viewEnd - len + 1;
    }
    if (this.viewStart < 1) {
        var len = this.viewEnd - this.viewStart + 1;
        this.viewStart = 1;
        this.viewEnd = this.viewStart + len - 1;
    }
    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart)
    var width = this.viewEnd - this.viewStart + 1;
    
    var scaleRat = (this.scale / this.scaleAtLastRedraw);

    this.notifyLocation();
    this.refresh();
}

Browser.prototype.spaceCheck = function(dontRefresh) {
    if (!this.knownSpace || this.knownSpace.chr !== this.chr) {
        this.refresh();
        return;
    } 

    var width = ((this.viewEnd - this.viewStart)|0) + 1;
    var minExtraW = (100.0/this.scale)|0;
    var maxExtraW = (1000.0/this.scale)|0;

    if ((this.drawnStart|0) > Math.max(1, ((this.viewStart|0) - minExtraW)|0)  || (this.drawnEnd|0) < Math.min((this.viewEnd|0) + minExtraW, ((this.currentSeqMax|0) > 0 ? (this.currentSeqMax|0) : 1000000000)))  {
        this.refresh();
    }
}

Browser.prototype.resizeViewer = function(skipRefresh) {
    var width = this.tierHolder.getBoundingClientRect().width | 0;
    if (width == 0)
        return;

    var oldFPW = Math.max(this.featurePanelWidth, 300); // Can get silly values stored
                                                        // when the browser is hidden.
    this.featurePanelWidth = width|0;

    if (oldFPW != this.featurePanelWidth) {
        this.zoomMax = this.zoomExpt * Math.log(this.maxViewWidth / this.zoomBase);
        this.zoomMin = this.zoomExpt * Math.log(this.featurePanelWidth / this.maxPixelsPerBase / this.zoomBase);   // FIXME hard-coded minimum.
        this.zoomSliderValue = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);

        var viewWidth = this.viewEnd - this.viewStart;
        var nve = this.viewStart + (viewWidth * this.featurePanelWidth) / oldFPW;

        this.viewEnd = nve;

        var wid = this.viewEnd - this.viewStart + 1;
        if (this.currentSeqMax > 0 && this.viewEnd > this.currentSeqMax) {
            this.viewEnd = this.currentSeqMax;
            this.viewStart = this.viewEnd - wid + 1;
        }
        if (this.viewStart < 1) {
            this.viewStart = 1;
            this.viewEnd = this.viewStart + wid - 1;
        }

        this.positionRuler();

        if (!skipRefresh) {
            this.spaceCheck();
        }
        this.notifyLocation();
    }

    if (this.fullScreen) {
        this.setFullScreenHeight();
    }
}

Browser.prototype.setFullScreenHeight = function() {
    var rest = document.body.offsetHeight - this.browserHolder.offsetHeight;
    this.browserHolder.style.maxHeight = Math.max(300, window.innerHeight - rest - 20) + 'px'
}

Browser.prototype.addTier = function(conf) {
    conf = shallowCopy(conf);
    conf.disabled = false;
    
    var tier = this.makeTier(conf);
    this.markSelectedTiers();
    this.positionRuler();
    this.notifyTier();
    return tier;
}

Browser.prototype.removeTier = function(conf, force) {
    var target = -1;

    if (typeof conf.index !== 'undefined' && conf.index >=0 && conf.index < this.tiers.length) {
        target = conf.index;
    } else {
        for (var ti = 0; ti < this.tiers.length; ++ti) {
            var ts = this.tiers[ti].dasSource;
            
            if (sourcesAreEqual(conf, ts)) {
                target = ti; break;
            }
        }
    }

    if (target < 0) {
        throw "Couldn't find requested tier";
    }

    var targetTier = this.tiers[target];
    this.tiers.splice(target, 1);

    var nst = [];
    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {
        var st = this.selectedTiers[sti];
        if (st < target) {
            nst.push(st);
        } else if (st > target) {
            nst.push(st - 1);
        }
    }
    this.selectedTiers = nst;
    this.markSelectedTiers();

    targetTier.destroy();
    if (this.knownSpace) {
        this.knownSpace.featureCache[targetTier] = null;
    }

    this.reorderTiers();
    this.notifyTier();
}

Browser.prototype.nn_removeTier = function(conf, force) {
    var target = -1;

    if (typeof conf.index !== 'undefined' && conf.index >=0 && conf.index < this.tiers.length) {
        target = conf.index;
    } else {
        for (var ti = 0; ti < this.tiers.length; ++ti) {
            var ts = this.tiers[ti].dasSource;
            
            if (sourcesAreEqual(conf, ts)) {
                target = ti; break;
            }
        }
    }

    if (target < 0) {
        throw "Couldn't find requested tier";
    }

    var targetTier = this.tiers[target];
    this.tiers.splice(target, 1);

    var nst = [];
    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {
        var st = this.selectedTiers[sti];
        if (st < target) {
            nst.push(st);
        } else if (st > target) {
            nst.push(st - 1);
        }
    }
    this.selectedTiers = nst;
    this.markSelectedTiers();

    targetTier.destroy();
    if (this.knownSpace) {
        this.knownSpace.featureCache[targetTier] = null;
    }

    this.reorderTiers();
}

Browser.prototype.removeAllTiers = function() {
  var thisB = this;
  this.selectedTiers = [];
  this.markSelectedTiers();
  this.tiers.forEach(function (targetTier) {
	  targetTier.destroy();
	  if (thisB.knownSpace) {
	      thisB.knownSpace.featureCache[targetTier] = null;
	  }
  });
  this.tiers.length = 0;
  this.reorderTiers();
  this.notifyTier();
}

Browser.prototype.nn_removeAllTiers = function() {
  var thisB = this;
  this.selectedTiers = [];
  this.markSelectedTiers();
  this.tiers.forEach(function (targetTier) {
	  targetTier.destroy();
	  if (thisB.knownSpace) {
	      thisB.knownSpace.featureCache[targetTier] = null;
	  }
  });
  this.tiers.length = 0;
  this.reorderTiers();
}

Browser.prototype.getSequenceSource = function() {
    if (this._sequenceSource === undefined)
        this._sequenceSource = this._getSequenceSource();
    return this._sequenceSource;
}

Browser.prototype._getSequenceSource = function() {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (this.tiers[ti].sequenceSource) {
            return this.tiers[ti].sequenceSource;
        }
    }

    for (var si = 0; si < this.defaultSources.length; ++si) {
        var s = this.defaultSources[si];
        if (s.provides_entrypoints || s.tier_type == 'sequence' || s.twoBitURI || s.twoBitBlob) {
            if (s.twoBitURI || s.twoBitBlob) {
                return new TwoBitSequenceSource(s);
            } else {
                return new DASSequenceSource(s);
            }
        }
    }
}

Browser.prototype.setLocation = function(newChr, newMin, newMax, callback, soft) {
    if (typeof(newMin) !== 'number') {
        throw Error('minimum must be a number (got ' + JSON.stringify(newMin) + ')');
    }
    if (typeof(newMax) !== 'number') {
        throw Error('maximum must be a number (got ' + JSON.stringify(newMax) + ')');
    }

    if (newMin > newMax) {
        var oldNewMin = newMin;
        newMin = newMax;
        newMax = oldNewMin;
    } else if (newMin === newMax) {
        newMax += 1;
    }

    if (!callback) {
        callback = function(err) {
            if (err) {
                throw err;
            }
        }
    }
    var thisB = this;

    if ((!newChr || newChr == this.chr) && this.currentSeqMax > 0) {
        return this._setLocation(null, newMin, newMax, null, callback, soft);
    } else {
        var ss = this.getSequenceSource();
        if (!ss) {
            return callback('Need a sequence source');
        }

        var findChr = newChr || this.chr;
        ss.getSeqInfo(findChr, function(si) {
            if (!si) {
                var altChr;
                if (findChr.indexOf('chr') == 0) {
                    altChr = findChr.substr(3);
                } else {
                    altChr = 'chr' + findChr;
                }
                ss.getSeqInfo(altChr, function(si2) {
                    if (!si2 && newChr) {
                        return callback("Couldn't find sequence '" + newChr + "'");
                    } else if (!si2) {
                        return thisB._setLocation(null, newMin, newMax, null, callback, soft);
                    } else {
                        return thisB._setLocation(altChr, newMin, newMax, si2, callback, soft);
                    }
                });
            } else {
                return thisB._setLocation(newChr, newMin, newMax, si, callback, soft);
            }
        });
    }
}

Browser.prototype._setLocation = function(newChr, newMin, newMax, newChrInfo, callback, soft) {
    var chrChanged = false;
    if (newChr) {
        if (newChr.indexOf('chr') == 0)
            newChr = newChr.substring(3);

        if (this.chr != newChr)
            chrChanged = true;
        this.chr = newChr;
        this.currentSeqMax = newChrInfo.length;
    }

    newMin = parseFloat(newMin); newMax=parseFloat(newMax);

    var newWidth = Math.max(10, newMax-newMin+1);

    if (!soft) {
        var csm = this.currentSeqMax;
        if (csm <= 0)
            csm = 1000000000000;
        if (newMin < 1) {
            newMin = 1; newMax = newMin + newWidth - 1;
        }
        if (newMax > csm) {
            newMax = csm;
            newMin = Math.max(1, newMax - newWidth + 1);
        }
    }

    this.viewStart = newMin;
    this.viewEnd = newMax;
    var newScale = Math.max(this.featurePanelWidth, 50) / (this.viewEnd - this.viewStart);
    var oldScale = this.scale;
    var scaleChanged = (Math.abs(newScale - oldScale)) > 0.000001;
    this.scale = newScale;

    var newZS, oldZS;
    oldZS = this.zoomSliderValue;
    this.zoomSliderValue = newZS = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);
    
    if (scaleChanged || chrChanged) {
        for (var i = 0; i < this.tiers.length; ++i) {
            this.tiers[i].viewportHolder.style.left = '5000px';
            this.tiers[i].overlay.style.left = '5000px';
        }

        this.refresh();

        if (this.savedZoom) {
            newZS -= this.zoomMin;
            oldZS -= this.zoomMin;
            var difToActive = newZS - oldZS;
            var difToSaved = newZS - this.savedZoom;
            if (Math.abs(difToActive) > Math.abs(difToSaved)) {
                this.isSnapZooming = !this.isSnapZooming;
                this.savedZoom = oldZS;
            }
        } else {
            this.isSnapZooming = false;
            this.savedZoom = null;
        }
    } else {
        var viewCenter = (this.viewStart + this.viewEnd)/2;
    
        for (var i = 0; i < this.tiers.length; ++i) {
            var offset = (this.viewStart - this.tiers[i].norigin)*this.scale;
            this.tiers[i].viewportHolder.style.left = '' + ((-offset|0) - 1000) + 'px';
            this.tiers[i].drawOverlay();
        }
    }

    this.notifyLocation();

    this.spaceCheck();
    if (this.instrumentActivity)
        this.activityStartTime = Date.now()|0;
    return callback();
}


Browser.prototype.nn_setLocation = function(newChr, newMin, newMax, callback, soft) {
    if (typeof(newMin) !== 'number') {
        throw Error('minimum must be a number (got ' + JSON.stringify(newMin) + ')');
    }
    if (typeof(newMax) !== 'number') {
        throw Error('maximum must be a number (got ' + JSON.stringify(newMax) + ')');
    }

    if (newMin > newMax) {
        var oldNewMin = newMin;
        newMin = newMax;
        newMax = oldNewMin;
    } else if (newMin === newMax) {
        newMax += 1;
    }

    if (!callback) {
        callback = function(err) {
            if (err) {
                throw err;
            }
        }
    }
    var thisB = this;

    if ((!newChr || newChr == this.chr) && this.currentSeqMax > 0) {
        return this._nn_setLocation(null, newMin, newMax, null, callback, soft);
    } else {
        var ss = this.getSequenceSource();
        if (!ss) {
            return callback('Need a sequence source');
        }

        var findChr = newChr || this.chr;
        ss.getSeqInfo(findChr, function(si) {
            if (!si) {
                var altChr;
                if (findChr.indexOf('chr') == 0) {
                    altChr = findChr.substr(3);
                } else {
                    altChr = 'chr' + findChr;
                }
                ss.getSeqInfo(altChr, function(si2) {
                    if (!si2 && newChr) {
                        return callback("Couldn't find sequence '" + newChr + "'");
                    } else if (!si2) {
                        return thisB._nn_setLocation(null, newMin, newMax, null, callback, soft);
                    } else {
                        return thisB._nn_setLocation(altChr, newMin, newMax, si2, callback, soft);
                    }
                });
            } else {
                return thisB._nn_setLocation(newChr, newMin, newMax, si, callback, soft);
            }
        });
    }
}

Browser.prototype._nn_setLocation = function(newChr, newMin, newMax, newChrInfo, callback, soft) {
    var chrChanged = false;
    if (newChr) {
        if (newChr.indexOf('chr') == 0)
            newChr = newChr.substring(3);

        if (this.chr != newChr)
            chrChanged = true;
        this.chr = newChr;
        this.currentSeqMax = newChrInfo.length;
    }

    newMin = parseFloat(newMin); newMax=parseFloat(newMax);

    var newWidth = Math.max(10, newMax-newMin+1);

    if (!soft) {
        var csm = this.currentSeqMax;
        if (csm <= 0)
            csm = 1000000000000;
        if (newMin < 1) {
            newMin = 1; newMax = newMin + newWidth - 1;
        }
        if (newMax > csm) {
            newMax = csm;
            newMin = Math.max(1, newMax - newWidth + 1);
        }
    }

    this.viewStart = newMin;
    this.viewEnd = newMax;
    var newScale = Math.max(this.featurePanelWidth, 50) / (this.viewEnd - this.viewStart);
    var oldScale = this.scale;
    var scaleChanged = (Math.abs(newScale - oldScale)) > 0.000001;
    this.scale = newScale;

    var newZS, oldZS;
    oldZS = this.zoomSliderValue;
    this.zoomSliderValue = newZS = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);
    
    if (scaleChanged || chrChanged) {
        for (var i = 0; i < this.tiers.length; ++i) {
            this.tiers[i].viewportHolder.style.left = '5000px';
            this.tiers[i].overlay.style.left = '5000px';
        }

        this.refresh();

        if (this.savedZoom) {
            newZS -= this.zoomMin;
            oldZS -= this.zoomMin;
            var difToActive = newZS - oldZS;
            var difToSaved = newZS - this.savedZoom;
            if (Math.abs(difToActive) > Math.abs(difToSaved)) {
                this.isSnapZooming = !this.isSnapZooming;
                this.savedZoom = oldZS;
            }
        } else {
            this.isSnapZooming = false;
            this.savedZoom = null;
        }
    } else {
        var viewCenter = (this.viewStart + this.viewEnd)/2;
    
        for (var i = 0; i < this.tiers.length; ++i) {
            var offset = (this.viewStart - this.tiers[i].norigin)*this.scale;
            this.tiers[i].viewportHolder.style.left = '' + ((-offset|0) - 1000) + 'px';
            this.tiers[i].drawOverlay();
        }
    }

    this.spaceCheck();
    if (this.instrumentActivity)
        this.activityStartTime = Date.now()|0;
    return callback();
}


Browser.prototype.setCenterLocation = function(newChr, newCenterLoc) {
    var halfWidth = (this.viewEnd - this.viewStart)/2,
    newMin = newCenterLoc - halfWidth,
    newMax = newCenterLoc + halfWidth;
    this.setLocation(newChr, newMin, newMax);
}

Browser.prototype.pingActivity = function() {
    if (!this.instrumentActivity || !this.activityStartTime)
        return;

    var activity = 0;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (this.tiers[ti].loaderButton.style.display !== 'none')
            ++activity;
    }

    if (activity == 0) {
        var now = Date.now()|0;
        console.log('Loading took ' + (now-this.activityStartTime) + 'ms');
        this.activityStartTime = null;
    }
}

Browser.prototype.addInitListener = function(handler) {
    this.initListeners.push(handler);
}

Browser.prototype.addFeatureListener = function(handler, opts) {
    opts = opts || {};
    this.featureListeners.push(handler);
}

Browser.prototype.removeFeatureListener = function(handler, opts) {
    var idx = arrayIndexOf(this.featureListeners, handler);
    if (idx >= 0) {
        this.featureListeners.splice(idx, 1);
    }
}

Browser.prototype.notifyFeature = function(ev, feature, hit, tier) {
  for (var fli = 0; fli < this.featureListeners.length; ++fli) {
      try {
          if (this.featureListeners[fli](ev, feature, hit, tier))
            return;
      } catch (ex) {
          console.log(ex.stack);
      }
  }
}

Browser.prototype.addFeatureHoverListener = function(handler, opts) {
    opts = opts || {};
    this.featureHoverListeners.push(handler);
}

Browser.prototype.removeFeatureHoverListener = function(handler, opts) {
    var idx = arrayIndexOf(this.featureHoverListeners, handler);
    if (idx >= 0) {
        this.featureHoverListeners.splice(idx, 1);
    }
}

Browser.prototype.notifyFeatureHover = function(ev, feature, hit, tier) {
    for (var fli = 0; fli < this.featureHoverListeners.length; ++fli) {
        try {
            this.featureHoverListeners[fli](ev, feature, hit, tier);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
}

Browser.prototype.addViewListener = function(handler, opts) {
    opts = opts || {};
    this.viewListeners.push(handler);
}

Browser.prototype.removeViewListener = function(handler, opts) {
    var idx = arrayIndexOf(this.viewListeners, handler);
    if (idx >= 0) {
        this.viewListeners.splice(idx, 1);
    }
}

Browser.prototype.notifyLocation = function() {
    var nvs = Math.max(1, this.viewStart|0);
    var nve = this.viewEnd|0;
    if (this.currentSeqMax > 0 && nve > this.currentSeqMax)
        nve = this.currentSeqMax;

    for (var lli = 0; lli < this.viewListeners.length; ++lli) {
        try {
            this.viewListeners[lli](
                this.chr, 
                nvs, 
                nve, 
                this.zoomSliderValue, 
                {current: this.zoomSliderValue,
                 alternate: (this.savedZoom+this.zoomMin) || this.zoomMin,
                 isSnapZooming: this.isSnapZooming,
                 min: this.zoomMin, 
                 max: this.zoomMax},
                 this.viewStart,
                 this.viewEnd);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
}

Browser.prototype.addTierListener = function(handler) {
    this.tierListeners.push(handler);
}

Browser.prototype.removeTierListener = function(handler) {
    var idx = arrayIndexOf(this.tierListeners, handler);
    if (idx >= 0) {
        this.tierListeners.splice(idx, 1);
    }
}

Browser.prototype.notifyTier = function() {
    for (var tli = 0; tli < this.tierListeners.length; ++tli) {
        try {
            this.tierListeners[tli]();
        } catch (ex) {
            console.log(ex.stack);
        }
    }
}

Browser.prototype.addRegionSelectListener = function(handler) {
    this.regionSelectListeners.push(handler);
}

Browser.prototype.removeRegionSelectListener = function(handler) {
    var idx = arrayIndexOf(this.regionSelectListeners, handler);
    if (idx >= 0) {
        this.regionSelectListeners.splice(idx, 1);
    }
}

Browser.prototype.notifyRegionSelect = function(chr, min, max) {
    for (var rli = 0; rli < this.regionSelectListeners.length; ++rli) {
        try {
            this.regionSelectListeners[rli](chr, min, max);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
}


Browser.prototype.highlightRegion = function(chr, min, max) {
    var thisB = this;
    
    if (chr == this.chr) {
        return this._highlightRegion(chr, min, max);
    }

    var ss = this.getSequenceSource();
    if (!ss) {
        throw 'Need a sequence source';
    }

    ss.getSeqInfo(chr, function(si) {
        if (!si) {
            var altChr;
            if (chr.indexOf('chr') == 0) {
                altChr = chr.substr(3);
            } else {
                altChr = 'chr' + chr;
            }
            ss.getSeqInfo(altChr, function(si2) {
                if (!si2) {
                    // Fail silently.
                } else {
                    return thisB._highlightRegion(altChr, min, max);
                }
            });
        } else {
            return thisB._highlightRegion(chr, min, max);
        }
    });
}

Browser.prototype._highlightRegion = function(chr, min, max) {
    for (var hi = 0; hi < this.highlights.length; ++hi) {
        var h = this.highlights[hi];
        if (h.chr == chr && h.min == min && h.max == max)
            return;
    }

    this.highlights.push(new Region(chr, min, max));
    var visStart = this.viewStart - (1000/this.scale);
    var visEnd = this.viewEnd + (1000/this.scale);
    if ((chr == this.chr || chr == ('chr'+this.chr)) && min < visEnd && max > visStart) {
        this.drawOverlays();
    }

    this.notifyLocation();
}

Browser.prototype.clearHighlights = function() {
    this.highlights = [];
    this.drawOverlays();
    this.notifyLocation();
}

Browser.prototype.drawOverlays = function() {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        this.tiers[ti].drawOverlay();
    }
}

Browser.prototype.featuresInRegion = function(chr, min, max) {
    var features = [];
    if (chr !== this.chr) {
        return [];
    }

    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var fl = this.tiers[ti].currentFeatures || [];
        for (var fi = 0; fi < fl.length; ++fi) {
            var f = fl[fi];
            if (f.min <= max && f.max >= min) {
                features.push(f);
            }
        }
    }
    return features;
}


Browser.prototype.getSelectedTier = function() {
    if (this.selectedTiers.length > 0) 
        return this.selectedTiers[0];
    else
        return -1;
}

Browser.prototype.setSelectedTier = function(t) {
    if (t == null) {
        this.selectedTiers = [];
    } else {
        this.selectedTiers = [t];
    }
    this.markSelectedTiers();
    this.notifyTierSelection();
}

Browser.prototype.markSelectedTiers = function() {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var button = this.tiers[ti].nameButton;

        if (this.selectedTiers.indexOf(ti) >= 0) {
            button.classList.add('active');
        } else {
            button.classList.remove('active');
        }
    }
    if (this.selectedTiers.length > 0) {
        var browserMid = this.browserHolder.offsetTop + this.browserHolder.offsetHeight/2;
        if (browserMid > document.body.scrollTop && (browserMid + 100) < document.body.scrollTop + window.innerHeight)
            this.browserHolder.focus();
    }
}

Browser.prototype.addTierSelectionListener = function(handler) {
    this.tierSelectionListeners.push(handler);
}

Browser.prototype.removeTierSelectionListener = function(handler) {
    var idx = arrayIndexOf(this.tierSelectionListeners, handler);
    if (idx >= 0) {
        this.tierSelectionListeners.splice(idx, 1);
    }
}

Browser.prototype.notifyTierSelection = function() {
    for (var fli = 0; fli < this.tierSelectionListeners.length; ++fli) {
        try {
            this.tierSelectionListeners[fli](this.selectedTiers);
        } catch (ex) {
            console.log(ex.stack);
        }
    }

}

Browser.prototype.addTierSelectionWrapListener = function(f) {
    this.tierSelectionWrapListeners.push(f);
}

Browser.prototype.removeTierSelectionWrapListener = function(handler) {
    var idx = arrayIndexOf(this.tierSelectionWrapListeners, handler);
    if (idx >= 0) {
        this.tierSelectionWrapListeners.splice(idx, 1);
    }
}

Browser.prototype.notifyTierSelectionWrap = function(i) {
    for (var fli = 0; fli < this.tierSelectionWrapListeners.length; ++fli) {
        try {
            this.tierSelectionWrapListeners[fli](i);
        } catch (ex) {
            console.log(ex.stack);
        }
    }
}


Browser.prototype.positionRuler = function() {
    var display = 'none';
    var left = '';
    var right = '';

    if (this.rulerLocation == 'center') {
        display = 'block';
        left = '' + ((this.featurePanelWidth/2)|0) + 'px';
    } else if (this.rulerLocation == 'left') {
        display = 'block';
        left = '0px';
    } else if (this.rulerLocation == 'right') {
        display = 'block';
        right = '0px'
    } else {
        display = 'none';
    }

    this.ruler.style.display = display;
    this.ruler.style.left = left;
    this.ruler.style.right = right;

    if(this.singleBaseHighlight) {
        this.ruler2.style.display = 'block';
        this.ruler2.style.borderWidth = '1px';
        if (this.scale < 1) {
            this.ruler2.style.width = '0px';
            this.ruler2.style.borderRightWidth = '0px' 
        } else {
            this.ruler2.style.width = this.scale + 'px';
            this.ruler2.style.borderRightWidth = '1px' 
        } 
        // Position accompanying single base location text
        this.locSingleBase.style.visibility = 'visible';
        var centreOffset = this.featurePanelWidth/2 - this.locSingleBase.offsetWidth/2 + this.ruler2.offsetWidth/2; 
        this.locSingleBase.style.left = '' + (centreOffset|0) + 'px';
    } else {
        this.locSingleBase.style.visibility = 'hidden';
        this.ruler2.style.width = '1px';
        this.ruler2.style.borderWidth = '0px';
        this.ruler2.style.display = this.rulerLocation == 'center' ? 'none' : 'block';
    }
   
    this.ruler2.style.left = '' + ((this.featurePanelWidth/2)|0) + 'px';
    
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var q = tier.quantOverlay;

        var quant;
        if (tier.subtiers && tier.subtiers.length > 0)
            quant = tier.subtiers[0].quant;

        if (q) {
            q.style.display = quant ? display : 'none';
            q.style.left = left;
            q.style.right = right;
        }
    }
}

Browser.prototype.featureDoubleClick = function(hit, rx, ry) {
    if (!hit || hit.length == 0)
        return;

    var f = hit[hit.length - 1];

    if (!f.min || !f.max) {
        return;
    }

    var fstart = (((f.min|0) - (this.viewStart|0)) * this.scale);
    var fwidth = (((f.max - f.min) + 1) * this.scale);
    
    var newMid = (((f.min|0) + (f.max|0)))/2;
    if (fwidth > 10) {
        var frac = (1.0 * (rx - fstart)) / fwidth;
        if (frac < 0.3) {
            newMid = (f.min|0);
        } else  if (frac > 0.7) {
            newMid = (f.max|0) + 1;
        }
    }

    var width = this.viewEnd - this.viewStart;
    this.setLocation(null, newMid - (width/2), newMid + (width/2));
}

Browser.prototype.zoomForScale = function(scale) {
    var ssScale;
    if (scale > 0.2) {
        ssScale = 'high';
    } else if (scale > 0.01) {
        ssScale = 'medium';
    } else  {
        ssScale = 'low';
    }
    return ssScale;
}

Browser.prototype.zoomForCurrentScale = function() {
    return this.zoomForScale(this.scale);
}

Browser.prototype.updateHeight = function() {
    var tierTotal = 0;
    for (var ti = 0; ti < this.tiers.length; ++ti) 
        tierTotal += (this.tiers[ti].currentHeight || 30);
    this.ruler.style.height = '' + tierTotal + 'px';
    this.ruler2.style.height = '' + tierTotal + 'px';
    this.browserHolder.style.display = 'block';
    this.browserHolder.style.display = '-webkit-flex';
    this.browserHolder.style.display = 'flex';
    // this.svgHolder.style.maxHeight = '' + Math.max(tierTotal, 500) + 'px';
}

Browser.prototype.scrollArrowKey = function(ev, dir) {
    if (this.reverseKeyScrolling)
        dir = -dir;
    
    if (ev.ctrlKey || ev.metaKey) {
        var fedge = false;
        if(ev.shiftKey){
            fedge = true;
        }

        this.leap(dir, fedge);
    } else if (this.scale > 1) {
        // per-base scrolling mode, tries to perfectly center.
        var mid = (this.viewStart + this.viewEnd)/2
        var err = mid - Math.round(mid);
        var n = 1;
        if (ev.shiftKey)
            n *= 10;
        if (dir > 0) {
            n = -n;
            n -= err;
            if (err > 0)
                n += 1;
        } else {
            n -= err;
            if (err < 0)
                n -= 1;
        }
        this.setLocation(null, this.viewStart + n, this.viewEnd + n);
    } else {
        this.move(ev.shiftKey ? 100*dir : 25*dir);
    }
}

Browser.prototype.leap = function(dir, fedge) {
    var thisB = this;
    var pos=((thisB.viewStart + thisB.viewEnd + 1)/2)|0;
    if (dir > 0 && thisB.viewStart <= 1) {
        pos -= 100000000;
    } else if (dir < 0 && thisB.viewEnd >= thisB.currentSeqMax) {
        pos += 100000000;
    }

    var st = thisB.getSelectedTier();
    if (st < 0) return;
    var tier = thisB.tiers[st];

    if (tier && ((tier.featureSource && this.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof(tier.quantLeapThreshold) == 'number')
                 || (tier.featureSource && this.sourceAdapterIsCapable(tier.featureSource, 'leap')))) {
        tier.findNextFeature(
              thisB.chr,
              pos,
              -dir,
              fedge,
              function(nxt) {
                  if (nxt) {
                      var nmin = nxt.min;
                      var nmax = nxt.max;
                      if (fedge) { 
                        if (dir > 0) {
                          if (nmin>pos+1) {
                              nmax=nmin;
                          } else {
                              nmax++;
                              nmin=nmax
                          }
                        } else {
                            if (nmax<pos-1) {
                                nmax++;
                                nmin=nmax;
                            } else {
                                nmax=nmin;
                            }
                        } 
                      }
                      var wid = thisB.viewEnd - thisB.viewStart + 1;
                      if(parseFloat(wid/2) == parseInt(wid/2)){wid--;}
                      var newStart = (nmin + nmax - wid)/2 + 1;
                      var newEnd = newStart + wid - 1;
                      var pos2=pos;
                      thisB.setLocation(nxt.segment, newStart, newEnd);
                  } else {
                      alert('no next feature'); // FIXME better reporting would be nice!
                  }
              });
    } else {
        this.move(100*dir);
    }
}

function glyphLookup(glyphs, rx, ry, matches) {
    matches = matches || [];

    for (var gi = glyphs.length - 1; gi >= 0; --gi) {
        var g = glyphs[gi];
        if (!g.notSelectable && g.min() <= rx && g.max() >= rx) {
            if (g.minY) {
                if (ry < g.minY() || ry > g.maxY())
                    continue;
            }

            if (g.feature) {
                matches.push(g.feature);
            } else if (g.group) {
                matches.push(g.group);
            }
    
            if (g.glyphs) {
                return glyphLookup(g.glyphs, rx, ry, matches);
            } else if (g.glyph) {
                return glyphLookup([g.glyph], rx, ry, matches);
            } else {
                return matches;
            }
        }
    }
    return matches;
}

Browser.prototype.nameForCoordSystem = function(cs) {
    var primary = null, ucsc = null;
    if (this.assemblyNamePrimary) {
        primary = '' + cs.auth;
        if (typeof(cs.version) !== 'undefined')
            primary += cs.version;
    }
    if (this.assemblyNameUcsc) {
        ucsc = cs.ucscName;
    }
    if (primary != null && ucsc != null)
        return primary + '/' + ucsc;
    else 
        return primary || ucsc || 'unknown';
}

Browser.prototype.makeLoader = function(size) {
    size = size || 16;
    var retina = window.devicePixelRatio > 1;
    if (size < 20) {
        return makeElement('img', null, {src: this.resolveURL('$$img/spinner_' + (retina ? 16 : 32) + '.gif'), width: '16', height: '16'});
    } else {
        return makeElement('img', null, {src: this.resolveURL('$$img/spinner_' + (retina ? 24 : 48) + '.gif'), width: '24', height: '24'});
    }
}

Browser.prototype.canFetchPlainHTTP = function() {
    var self = this;
    if (!this._plainHTTPPromise) {
        var worker = this.getWorker();
        if (worker) {
            this._plainHTTPPromise = new Promise(function(resolve, reject) {
                worker.postCommand(
                    {command: 'textxhr',
                     uri: self.httpCanaryURL},
                    function(result, err) {
                        if (result) {
                            resolve(true);
                        } else {
                            resolve(false);
                        }
                    });
                });
        } else {
           this._plainHTTPPromise = new Promise(function(resolve, reject) {
                textXHR(
                    self.httpCanaryURL,
                    function(result, err) {
                        if (result) {
                            resolve(true);
                        } else {
                            resolve(false);
                        }
                    },
                    {timeout: 2000}
                );
            });
        }
    }
    return this._plainHTTPPromise;
}

Browser.prototype.getWorker = function() {
    if (!this.useFetchWorkers || !this.fetchWorkers || this.fetchWorkers.length==0)
        return null;

    if (this.nextWorker >= this.fetchWorkers.length)
        this.nextWorker = 0;
    return this.fetchWorkers[this.nextWorker++];
}

function FetchWorker(browser, worker) {
    var thisB = this;
    this.tagSeed = 0;
    this.callbacks = {};
    this.browser = browser;
    this.worker = worker;

    this.worker.onmessage = function(ev) {
        var cb = thisB.callbacks[ev.data.tag];
        if (cb) {
            cb(ev.data.result, ev.data.error);
            delete thisB.callbacks[ev.data.tag];
        }
    };
}

function makeFetchWorker(browser) {
    var wurl = browser.resolveURL(browser.workerPath);
    if (wurl.indexOf('//') == 0) {
        var proto = window.location.protocol;
        if (proto == 'https:')
            wurl = 'https:' + wurl;
        else
            wurl = 'http:' + wurl;
    }

    var wscript = 'importScripts("' + wurl + '?version=' + VERSION + '");';
    var wblob = new Blob([wscript], {type: 'application/javascript'});


    return new Promise(function(resolve, reject) {
        var worker = new Worker(URL.createObjectURL(wblob));

        worker.onmessage = function(ev) {
            if (ev.data.tag === 'init') {
                console.log('Worker initialized');
                resolve(new FetchWorker(browser, worker))
            }
            
        }

        worker.onerror = function(ev) {
            reject(ev.message);
        }
    });    
}

FetchWorker.prototype.postCommand = function(cmd, callback, transfer) {
    var tag = 'x' + (++this.tagSeed);
    cmd.tag = tag;
    this.callbacks[tag] = callback;
    this.worker.postMessage(cmd, transfer);
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        Browser: Browser
    };

    // Required because they add stuff to Browser.prototype
    require('./browser-ui');
    require('./track-adder');
    require('./feature-popup');
    require('./tier-actions');
    require('./domui');
    require('./search');

    var sa = require('./sourceadapters');
    var TwoBitSequenceSource = sa.TwoBitSequenceSource;
    var DASSequenceSource = sa.DASSequenceSource;

    var KnownSpace = require('./kspace').KnownSpace;

    var DASRegistry = require('./das').DASRegistry;
}

function SourceCache() {
    this.sourcesByURI = {}
}

SourceCache.prototype.get = function(conf) {
    var scb = this.sourcesByURI[sourceDataURI(conf)];
    if (scb) {
        for (var si = 0; si < scb.configs.length; ++si) {
            if (sourcesAreEqualModuloStyle(scb.configs[si], conf)) {
                return scb.sources[si];
            }
        }
    }
}

SourceCache.prototype.put = function(conf, source) {
    var uri = sourceDataURI(conf);
    var scb = this.sourcesByURI[uri];
    if (!scb) {
        scb = {configs: [], sources: []};
        this.sourcesByURI[uri] = scb;
    }
    scb.configs.push(conf);
    scb.sources.push(source);
}

},{"./browser-ui":5,"./chainset":7,"./das":10,"./domui":11,"./feature-popup":19,"./kspace":23,"./numformats":26,"./search":30,"./sha1":33,"./sourceadapters":34,"./sourcecompare":35,"./thub":42,"./tier":45,"./tier-actions":43,"./track-adder":46,"./utils":49,"./version":51,"es6-promise":53}],7:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// chainset.js: liftover support
//

"use strict";

if (typeof(require) !== 'undefined') {
    var das = require('./das');
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;

    var utils = require('./utils');
    var pusho = utils.pusho;
    var shallowCopy = utils.shallowCopy;

    var parseCigar = require('./cigar').parseCigar;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;

    var bbi = require('./bigwig');
    var makeBwg = bbi.makeBwg;

    var Promise = require('es6-promise').Promise;
}

function Chainset(conf, srcTag, destTag, coords) {
    if (typeof(conf) == 'string') {
        this.uri = conf;
        this.srcTag = srcTag;
        this.destTag = destTag;
        this.coords = coords;
    } else {
        this.uri = conf.uri;
        this.srcTag = conf.srcTag;
        this.destTag = conf.destTag;
        this.coords = shallowCopy(conf.coords);
        this.type = conf.type;
        this.credentials = conf.credentials;
    }

    this.chainsBySrc = {};
    this.chainsByDest = {};
    this.postFetchQueues = {};
    this.fetchedTiles = {};
    this.granularity = 1000000;  // size in bases of tile to fetch

    if (this.type == 'bigbed') {
        this.chainFetcher = new BBIChainFetcher(this.uri, this.credentials);
    } else if (this.type == 'alias') {
        this.chainFetcher = new AliasChainFetcher(conf);
    } else {
        this.chainFetcher = new DASChainFetcher(this.uri, this.srcTag, this.destTag);
    }
};

Chainset.prototype.exportConfig = function() {
    return {
        uri: this.uri,
        srcTag: this.srcTag,
        destTag: this.destTag,
        coords: this.coords,
        type: this.type,
        credentials: this.credentials
    };
}

Chainset.prototype.mapPoint = function(chr, pos) {
    var chains = this.chainsBySrc[chr] || [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (pos >= c.srcMin && pos <= c.srcMax) {
            var cpos;
            if (c.srcOri == '-') {
                cpos = c.srcMax - pos;
            } else {
                cpos = pos - c.srcMin;
            }
            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];
                if (cpos >= bSrc && cpos <= (bSrc + bSize)) {
                    var apos = cpos - bSrc;

                    var dpos;
                    if (c.destOri == '-') {
                        dpos = c.destMax - bDest - apos;
                    } else {
                        dpos = apos + bDest + c.destMin;
                    }
                    return {seq: c.destChr, pos: dpos, flipped: (c.srcOri != c.destOri)}
                }
            }
        }
    }
    return null;
}

Chainset.prototype.mapSegment = function(chr, min, max) {
    var chains = this.chainsBySrc[chr] || [];
    var mappings = [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (max >= c.srcMin && min <= c.srcMax) {
            var cmin, cmax;
            if (c.srcOri == '-') {
                cmin = c.srcMax - max;
                cmax = c.srcMax - min;
            } else {
                cmin = min - c.srcMin;
                cmax = max - c.srcMin;
            }
            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];
                if (cmax >= bSrc && cmin <= (bSrc + bSize)) {
                    var m = {
                        segment: c.destChr,
                        flipped: (c.srcOri == '-') ^ (c.destOri == '-')};

                    if (c.destOri == '-') {
                        if (cmin >= bSrc) {
                            m.max = c.destMax - bDest - cmin + bSrc;
                        } else {
                            m.max = c.destMax - bDest;
                            m.partialMax = bSrc - cmin;
                        }
                        if (cmax <= (bSrc + bSize)) {
                            m.min = c.destMax - bDest - cmax + bSrc;
                        } else {
                            m.min = c.destMax - bDest - bSize;
                            m.partialMin = cmax - bSrc - bSize;
                        }
                    } else {
                        if (cmin >= bSrc) {
                            m.min = c.destMin + bDest + cmin - bSrc;
                        } else {
                            m.min = c.destMin + bDest;
                            m.partialMin = bSrc - cmin;
                        }
                        if (cmax <= (bSrc + bSize)) {
                            m.max = c.destMin + bDest + cmax - bSrc;
                        } else {
                            m.max = c.destMin + bDest + bSize;
                            m.partialMax = cmax - bSrc - bSize;
                        }
                    }
                    mappings.push(m);
                }
            }
        }
    }
    return mappings;
}

Chainset.prototype.unmapPoint = function(chr, pos) {
    var chains = this.chainsByDest[chr] || [];
    for (var ci = 0; ci < chains.length; ++ci) {
        var c = chains[ci];
        if (pos >= c.destMin && pos <= c.destMax) {
            var cpos;
            if (c.srcOri == '-') {
                cpos = c.destMax - pos;
            } else {
                cpos = pos - c.destMin;
            }    
            
            var blocks = c.blocks;
            for (var bi = 0; bi < blocks.length; ++bi) {
                var b = blocks[bi];
                var bSrc = b[0];
                var bDest = b[1];
                var bSize = b[2];

                if (cpos >= bDest && cpos <= (bDest + bSize)) {
                    var apos = cpos - bDest;

                    var dpos = apos + bSrc + c.srcMin;
                    var dpos;
                    if (c.destOri == '-') {
                        dpos = c.srcMax - bSrc - apos;
                    } else {
                        dpos = apos + bSrc + c.srcMin;
                    }
                    return {seq: c.srcChr, pos: dpos, flipped: (c.srcOri != c.destOri)}
                }
            }
            // return null;
        }
    }
    return null;
}

Chainset.prototype.sourceBlocksForRange = function(chr, min, max, callback) {
    var STATE_PENDING = 1;
    var STATE_FETCHED = 2;

    var thisCS = this;
    var minTile = (min/this.granularity)|0;
    var maxTile = (max/this.granularity)|0;

    var needsNewOrPending = false;
    var needsNewFetch = false;
    for (var t = minTile; t <= maxTile; ++t) {
        var tn = chr + '_' + t;
        if (this.fetchedTiles[tn] != STATE_FETCHED) {
            needsNewOrPending = true;
            if (this.fetchedTiles[tn] != STATE_PENDING) {
                this.fetchedTiles[tn] = STATE_PENDING;
                needsNewFetch = true;
            }
        }
    }

    if (needsNewOrPending) {
        if (!this.postFetchQueues[chr]) {
            this.chainFetcher.fetchChains(
                chr, 
                minTile * this.granularity, 
                (maxTile+1) * this.granularity - 1)
              .then(function(chains) {
                if (!thisCS.chainsByDest)
                    thisCS.chainsByDest[chr] = [];
                for (var ci = 0; ci < chains.length; ++ci) {
                    var chain = chains[ci];

                    {
                        var cbs = thisCS.chainsBySrc[chain.srcChr];
                        if (!cbs) {
                            thisCS.chainsBySrc[chain.srcChr] = [chain];
                        } else {
                            var present = false;
                            for (var oci = 0; oci < cbs.length; ++oci) {
                                var oc = cbs[oci];
                                if (oc.srcMin == chain.srcMin && oc.srcMax == chain.srcMax) {
                                    present = true;
                                    break;
                                }
                            }
                            if (!present)
                                cbs.push(chain);
                        }
                    }

                    {
                        var cbd = thisCS.chainsByDest[chain.destChr];
                        if (!cbd) {
                            thisCS.chainsByDest[chain.destChr] = [chain];
                        } else {
                            var present = false;
                            for (var oci = 0; oci < cbd.length; ++oci) {
                                var oc = cbd[oci];
                                if (oc.destMin == chain.destMin && oc.destMax == chain.destMax) {
                                    present = true;
                                    break;
                                }
                            }
                            if (!present)
                                cbd.push(chain);
                        }
                    }
                }
                for (var t = minTile; t <= maxTile; ++t) {
                    var tn = chr + '_' + t;
                    thisCS.fetchedTiles[tn] = STATE_FETCHED;
                }
                if (thisCS.postFetchQueues[chr]) {
                    var pfq = thisCS.postFetchQueues[chr];
                    for (var i = 0; i < pfq.length; ++i) {
                        pfq[i]();
                    }
                    thisCS.postFetchQueues[chr] = null;
                }
              }).catch(function (err) {
                console.log(err);
              });   
        }

        pusho(this.postFetchQueues, chr, function() {
            // Will either succeed if the tiles that are needed have already been fetched,
            // or queue up a new fetch.

            thisCS.sourceBlocksForRange(chr, min, max, callback);
        });
    } else {
        var srcBlocks = [];
        var chains = this.chainsByDest[chr] || [];
        for (var ci = 0; ci < chains.length; ++ci) {
            var c = chains[ci];
            if (min <= c.destMax && max >= c.destMin) {
                var cmin, cmax;
                if (c.srcOri == '-') {
                    cmin = c.destMax - max;
                    cmax = c.destMax - min;
                } else {
                    cmin = min - c.destMin;
                    cmax = max - c.destMin;
                }

                var blocks = c.blocks;
                for (var bi = 0; bi < blocks.length; ++bi) {
                    var b = blocks[bi];
                    var bSrc = b[0];
                    var bDest = b[1];
                    var bSize = b[2];

                    if (cmax >= bDest && cmin <= (bDest + bSize)) {
                        var amin = Math.max(cmin, bDest) - bDest;
                        var amax = Math.min(cmax, bDest + bSize) - bDest;

                        if (c.destOri == '-') {
                            srcBlocks.push(new DASSegment(c.srcChr, c.srcMax - bSrc - amax, c.srcMax - bSrc - amin));
                        } else {
                            srcBlocks.push(new DASSegment(c.srcChr, c.srcMin + amin + bSrc, c.srcMin + amax + bSrc));
                        }
                    }
                }
            }
        }
        callback(srcBlocks);
    }
}

function DASChainFetcher(uri, srcTag, destTag) {
    this.source = new DASSource(uri);
    this.srcTag = srcTag;
    this.destTag =destTag;
}

DASChainFetcher.prototype.fetchChains = function(chr, _min, _max) {
    var thisCS = this;

    return new Promise(function(resolve, reject) {
        thisCS.source.alignments(chr, {}, function(aligns) {
            var chains = [];

            for (var ai = 0; ai < aligns.length; ++ai) {
                var aln = aligns[ai];
                for (var bi = 0; bi < aln.blocks.length; ++bi) {
                    var block = aln.blocks[bi];
                    var srcSeg, destSeg;
                    for (var si = 0; si < block.segments.length; ++si) {
                        var seg = block.segments[si];
                        var obj = aln.objects[seg.object];
                        if (obj.dbSource === thisCS.srcTag) {
                            srcSeg = seg;
                        } else if (obj.dbSource === thisCS.destTag) {
                            destSeg = seg;
                        }
                    }
                    if (srcSeg && destSeg) {
                        var chain = {
                            srcChr:     aln.objects[srcSeg.object].accession,
                            srcMin:     srcSeg.min|0,
                            srcMax:     srcSeg.max|0,
                            srcOri:     srcSeg.strand,
                            destChr:    aln.objects[destSeg.object].accession,
                            destMin:    destSeg.min|0,
                            destMax:    destSeg.max|0,
                            destOri:    destSeg.strand,
                            blocks:     []
                        }

                        var srcops = parseCigar(srcSeg.cigar), destops = parseCigar(destSeg.cigar);

                        var srcOffset = 0, destOffset = 0;
                        var srci = 0, desti = 0;
                        while (srci < srcops.length && desti < destops.length) {
                            if (srcops[srci].op == 'M' && destops[desti].op == 'M') {
                                var blockLen = Math.min(srcops[srci].cnt, destops[desti].cnt);
                                chain.blocks.push([srcOffset, destOffset, blockLen]);
                                if (srcops[srci].cnt == blockLen) {
                                    ++srci;
                                } else {
                                    srcops[srci].cnt -= blockLen;
                                }
                                if (destops[desti].cnt == blockLen) {
                                    ++desti;
                                } else {
                                    destops[desti] -= blockLen;
                                }
                                srcOffset += blockLen;
                                destOffset += blockLen;
                            } else if (srcops[srci].op == 'I') {
                                destOffset += srcops[srci++].cnt;
                            } else if (destops[desti].op == 'I') {
                                srcOffset += destops[desti++].cnt;
                            }
                        }

                        chains.push(chain);
                    }
                }
            }
            resolve(chains);
        });
    });
}

function BBIChainFetcher(uri, credentials) {
    var self = this;
    this.uri = uri;
    this.credentials = credentials;

    this.bwg = new Promise(function(resolve, reject) {
        makeBwg(new URLFetchable(self.uri, {credentials: self.credentials}), function(bwg, err) {
            if (bwg) {
                resolve(bwg);
            } else {
                reject(err);
            }
        });
    });

    this.bwg.then(function(bwg, err) {
        if (err)
            console.log(err);
    });
}

function pi(x) {
    return parseInt(x);
}

function cleanChr(c) {
    if (c.indexOf('chr') == 0)
        return c.substr(3);
    else
        return c;
}

function bbiFeatureToChain(feature) {
    var chain = {
        srcChr:     cleanChr(feature.srcChrom),
        srcMin:     parseInt(feature.srcStart),
        srcMax:     parseInt(feature.srcEnd),
        srcOri:     feature.srcOri,
        destChr:    cleanChr(feature.segment),
        destMin:    feature.min - 1,     // Convert back from bigbed parser
        destMax:    feature.max,
        destOri:    feature.ori,
        blocks:     []
    };
    var srcStarts = feature.srcStarts.split(',').map(pi);
    var destStarts = feature.destStarts.split(',').map(pi);
    var blockLengths = feature.blockLens.split(',').map(pi);
    for (var bi = 0; bi < srcStarts.length; ++bi) {
        chain.blocks.push([srcStarts[bi], destStarts[bi], blockLengths[bi]]);
    }

    return chain;
}

BBIChainFetcher.prototype.fetchChains = function(chr, min, max) {
    return this.bwg.then(function(bwg, err) {
        if (!bwg)
            throw Error("No BWG");

        return new Promise(function(resolve, reject) {
            bwg.getUnzoomedView().readWigData(chr, min, max, function(feats) {
                resolve(feats.map(bbiFeatureToChain));
            });
        });
    });
};

function AliasChainFetcher(conf) {
    this.conf = conf;
    this.forwardAliases = {};
    var sa = conf.sequenceAliases || [];
    for (var ai = 0; ai < sa.length; ++ai) {
        var al = sa[ai];
        if (al.length < 2)
            continue;

        var fa = [];
        for (var i = 0; i < al.length - 1; ++i)
            fa.push(al[i]);
        this.forwardAliases[al[al.length - 1]] = fa;
    }
}

AliasChainFetcher.prototype.fetchChains = function(chr, min, max) {
    var resp = [];
    var fa = this.forwardAliases[chr] || [];
    for (var i = 0; i < fa.length; ++i) {
        resp.push(
            {
                srcChr:         fa[i],
                srcMin:         1,
                srcMax:         1000000000,
                srcOri:         '+',
                destChr:        chr,
                destMin:        1,
                destMax:        1000000000,
                destOri:        '+',
                blocks: [[1, 1, 1000000000]]
            });
    }

    return Promise.resolve(resp);
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        Chainset: Chainset
    };
}
},{"./bigwig":3,"./bin":4,"./cigar":8,"./das":10,"./utils":49,"es6-promise":53}],8:[function(require,module,exports){

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// chainset.js: liftover support
//

var CIGAR_REGEXP = new RegExp('([0-9]*)([MIDS])', 'g');

function parseCigar(cigar)
{
    var cigops = [];
    var match;
    while ((match = CIGAR_REGEXP.exec(cigar)) != null) {
        var count = match[1];
        if (count.length == 0) {
            count = 1;
        }
        cigops.push({cnt: count|0, op: match[2]});
    }
    return cigops;
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        parseCigar: parseCigar
    };
}
},{}],9:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// color.js
//

"use strict";

function DColour(red, green, blue, name) {
    this.red = red|0;
    this.green = green|0;
    this.blue = blue|0;
    if (name) {
        this.name = name;
    }
}

DColour.prototype.toSvgString = function() {
    if (!this.name) {
        this.name = "rgb(" + this.red + "," + this.green + "," + this.blue + ")";
    }

    return this.name;
}

function hex2(x) {
    var y = '00' + x.toString(16);
    return y.substring(y.length - 2);
}

DColour.prototype.toHexString = function() {
    return '#' + hex2(this.red) + hex2(this.green) + hex2(this.blue);
}

var palette = {
    red: new DColour(255, 0, 0, 'red'),
    green: new DColour(0, 255, 0, 'green'),
    blue: new DColour(0, 0, 255, 'blue'),
    yellow: new DColour(255, 255, 0, 'yellow'),
    white: new DColour(255, 255, 255, 'white'),
    black: new DColour(0, 0, 0, 'black'),
    gray: new DColour(180, 180, 180, 'gray'),
    grey: new DColour(180, 180, 180, 'grey'),
    lightskyblue: new DColour(135, 206, 250, 'lightskyblue'),
    lightsalmon: new DColour(255, 160, 122, 'lightsalmon'),
    hotpink: new DColour(255, 105, 180, 'hotpink')
};

var COLOR_RE = new RegExp('^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$');
var CSS_COLOR_RE = /rgb\(([0-9]+),([0-9]+),([0-9]+)\)/

function dasColourForName(name) {
    var c = palette[name];
    if (!c) {
        var match = COLOR_RE.exec(name);
        if (match) {
            c = new DColour(('0x' + match[1])|0, ('0x' + match[2])|0, ('0x' + match[3])|0, name);
            palette[name] = c;
        } else {
    	    match = CSS_COLOR_RE.exec(name);
    	    if (match) {
        		c = new DColour(match[1]|0, match[2]|0, match[3]|0, name);
        		palette[name] = c;
	       } else {
		      console.log("couldn't handle color: " + name);
		      c = palette.black;
		      palette[name] = c;
	       }
        }
    }
    return c;
}

function makeColourSteps(steps, stops, colours) {
    var dcolours = [];
    for (var ci = 0; ci < colours.length; ++ci) {
        dcolours.push(dasColourForName(colours[ci]));
    }

    var grad = [];
  STEP_LOOP:
    for (var si = 0; si < steps; ++si) {
        var rs = (1.0 * si) / (steps-1);
        var score = stops[0] + (stops[stops.length -1] - stops[0]) * rs;
        for (var i = 0; i < stops.length - 1; ++i) {
            if (score >= stops[i] && score <= stops[i+1]) {
                var frac = (score - stops[i]) / (stops[i+1] - stops[i]);
                var ca = dcolours[i];
                var cb = dcolours[i+1];

                var fill = new DColour(
                    ((ca.red * (1.0 - frac)) + (cb.red * frac))|0,
                    ((ca.green * (1.0 - frac)) + (cb.green * frac))|0,
                    ((ca.blue * (1.0 - frac)) + (cb.blue * frac))|0
                ).toSvgString();
                grad.push(fill);

                continue STEP_LOOP;
            }
        }
        throw 'Bad step';
    }

    return grad;
}

function makeGradient(steps, color1, color2, color3) {
    if (color3) {
        return makeColourSteps(steps, [0, 0.5, 1], [color1, color2, color3]);
    } else {
        return makeColourSteps(steps, [0, 1], [color1, color2]);
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        makeColourSteps: makeColourSteps,
        makeGradient: makeGradient,
        dasColourForName: dasColourForName
    };
}

},{}],10:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// das.js: queries and low-level data model.
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
    var pusho = utils.pusho;

    var color = require('./color');
    var makeColourSteps = color.makeColourSteps;
}

var dasLibErrorHandler = function(errMsg) {
    alert(errMsg);
}
var dasLibRequestQueue = new Array();

function DASSegment(name, start, end, description) {
    this.name = name;
    this.start = start;
    this.end = end;
    this.description = description;
}
DASSegment.prototype.toString = function() {
    return this.name + ':' + this.start + '..' + this.end;
};
DASSegment.prototype.isBounded = function() {
    return this.start && this.end;
}
DASSegment.prototype.toDASQuery = function() {
    var q = 'segment=' + this.name;
    if (this.start && this.end) {
        q += (':' + this.start + ',' + this.end);
    }
    return q;
}


function DASSource(a1, a2) {
    var options;
    if (typeof a1 == 'string') {
        this.uri = a1;
        options = a2 || {};
    } else {
        options = a1 || {};
    }
    for (var k in options) {
        if (typeof(options[k]) != 'function') {
            this[k] = options[k];
        }
    }


    if (!this.coords) {
        this.coords = [];
    }
    if (!this.props) {
        this.props = {};
    }

    this.dasBaseURI = this.uri;
    if (this.dasBaseURI && this.dasBaseURI.substr(this.uri.length - 1) != '/') {
        this.dasBaseURI = this.dasBaseURI + '/';
    }
}

function DASCoords() {
}

function coordsMatch(c1, c2) {
    return c1.taxon == c2.taxon && c1.auth == c2.auth && c1.version == c2.version;
}

//
// DAS 1.6 entry_points command
//

DASSource.prototype.entryPoints = function(callback) {
    var dasURI = this.dasBaseURI + 'entry_points';
    this.doCrossDomainRequest(dasURI, function(responseXML) {
            if (!responseXML) {
                return callback([]);
            }

                var entryPoints = new Array();
                
                var segs = responseXML.getElementsByTagName('SEGMENT');
                for (var i = 0; i < segs.length; ++i) {
                    var seg = segs[i];
                    var segId = seg.getAttribute('id');
                    
                    var segSize = seg.getAttribute('size');
                    var segMin, segMax;
                    if (segSize) {
                        segMin = 1; segMax = segSize|0;
                    } else {
                        segMin = seg.getAttribute('start');
                        if (segMin) {
                            segMin |= 0;
                        }
                        segMax = seg.getAttribute('stop');
                        if (segMax) {
                            segMax |= 0;
                        }
                    }
                    var segDesc = null;
                    if (seg.firstChild) {
                        segDesc = seg.firstChild.nodeValue;
                    }
                    entryPoints.push(new DASSegment(segId, segMin, segMax, segDesc));
                }          
               callback(entryPoints);
    });         
}

//
// DAS 1.6 sequence command
// Do we need an option to fall back to the dna command?
//

function DASSequence(name, start, end, alpha, seq) {
    this.name = name;
    this.start = start;
    this.end = end;
    this.alphabet = alpha;
    this.seq = seq;
}

DASSource.prototype.sequence = function(segment, callback) {
    var dasURI = this.dasBaseURI + 'sequence?' + segment.toDASQuery();
    this.doCrossDomainRequest(dasURI, function(responseXML) {
        if (!responseXML) {
            callback([]);
            return;
        } else {
                var seqs = new Array();
                
                var segs = responseXML.getElementsByTagName('SEQUENCE');
                for (var i = 0; i < segs.length; ++i) {
                    var seg = segs[i];
                    var segId = seg.getAttribute('id');
                    var segMin = seg.getAttribute('start');
                    var segMax = seg.getAttribute('stop');
                    var segAlpha = 'DNA';
                    var segSeq = null;
                    if (seg.firstChild) {
                        var rawSeq = seg.firstChild.nodeValue;
                        segSeq = '';
                        var idx = 0;
                        while (true) {
                            var space = rawSeq.indexOf('\n', idx);
                            if (space >= 0) {
                                segSeq += rawSeq.substring(idx, space).toUpperCase();
                                idx = space + 1;
                            } else {
                                segSeq += rawSeq.substring(idx).toUpperCase();
                                break;
                            }
                        }
                    }
                    seqs.push(new DASSequence(segId, segMin, segMax, segAlpha, segSeq));
                }
                
                callback(seqs);
        }
    });
}

//
// DAS 1.6 features command
//

function DASFeature() {
}

function DASGroup(id) {
    if (id)
        this.id = id;
}

function DASLink(desc, uri) {
    this.desc = desc;
    this.uri = uri;
}

DASSource.prototype.features = function(segment, options, callback) {
    options = options || {};
    var thisB = this;

    var dasURI;
    if (this.features_uri) {
        dasURI = this.features_uri;
    } else {
        var filters = [];

        if (segment) {
            filters.push(segment.toDASQuery());
        } else if (options.group) {
            var g = options.group;
            if (typeof g == 'string') {
                filters.push('group_id=' + g);
            } else {
                for (var gi = 0; gi < g.length; ++gi) {
                    filters.push('group_id=' + g[gi]);
                }
            }
        }

        if (options.adjacent) {
            var adj = options.adjacent;
            if (typeof adj == 'string') {
                adj = [adj];
            }
            for (var ai = 0; ai < adj.length; ++ai) {
                filters.push('adjacent=' + adj[ai]);
            }
        }

        if (options.type) {
            if (typeof options.type == 'string') {
                filters.push('type=' + options.type);
            } else {
                for (var ti = 0; ti < options.type.length; ++ti) {
                    filters.push('type=' + options.type[ti]);
                }
            }
        }
        
        if (options.maxbins) {
            filters.push('maxbins=' + options.maxbins);
        }
        
        if (filters.length > 0) {
            dasURI = this.dasBaseURI + 'features?' + filters.join(';');
        } else {
            callback([], 'No filters specified');
        }
    } 
   

    this.doCrossDomainRequest(dasURI, function(responseXML, req) {
        if (!responseXML) {
            var msg;
            if (req.status == 0) {
                msg = 'server may not support CORS';
            } else {
                msg = 'status=' + req.status;
            }
            callback([], 'Failed request: ' + msg);
            return;
        }
/*      if (req) {
            var caps = req.getResponseHeader('X-DAS-Capabilties');
            if (caps) {
                alert(caps);
            }
        } */

        var features = new Array();
        var segmentMap = {};

        var segs = responseXML.getElementsByTagName('SEGMENT');
        for (var si = 0; si < segs.length; ++si) {
            var segmentXML = segs[si];
            var segmentID = segmentXML.getAttribute('id');
            segmentMap[segmentID] = {
                min: segmentXML.getAttribute('start'),
                max: segmentXML.getAttribute('stop')
            };
            
            var featureXMLs = segmentXML.getElementsByTagName('FEATURE');
            for (var i = 0; i < featureXMLs.length; ++i) {
                var feature = featureXMLs[i];
                var dasFeature = new DASFeature();
                
                dasFeature.segment = segmentID;
                dasFeature.id = feature.getAttribute('id');
                dasFeature.label = feature.getAttribute('label');


/*
                var childNodes = feature.childNodes;
                for (var c = 0; c < childNodes.length; ++c) {
                    var cn = childNodes[c];
                    if (cn.nodeType == Node.ELEMENT_NODE) {
                        var key = cn.tagName;
                        //var val = null;
                        //if (cn.firstChild) {
                        //   val = cn.firstChild.nodeValue;
                        //}
                        dasFeature[key] = 'x';
                    }
                } */


                var spos = elementValue(feature, "START");
                var epos = elementValue(feature, "END");
                if ((spos|0) > (epos|0)) {
                    dasFeature.min = epos|0;
                    dasFeature.max = spos|0;
                } else {
                    dasFeature.min = spos|0;
                    dasFeature.max = epos|0;
                }
                {
                    var tec = feature.getElementsByTagName('TYPE');
                    if (tec.length > 0) {
                        var te = tec[0];
                        if (te.firstChild) {
                            dasFeature.type = te.firstChild.nodeValue;
                        }
                        dasFeature.typeId = te.getAttribute('id');
                        dasFeature.typeCv = te.getAttribute('cvId');
                    }
                }
                dasFeature.type = elementValue(feature, "TYPE");
                if (!dasFeature.type && dasFeature.typeId) {
                    dasFeature.type = dasFeature.typeId; // FIXME?
                }
                
                dasFeature.method = elementValue(feature, "METHOD");
                {
                    var ori = elementValue(feature, "ORIENTATION");
                    if (!ori) {
                        ori = '0';
                    }
                    dasFeature.orientation = ori;
                }
                dasFeature.score = elementValue(feature, "SCORE");
                dasFeature.links = dasLinksOf(feature);
                dasFeature.notes = dasNotesOf(feature);
                
                var groups = feature.getElementsByTagName("GROUP");
                for (var gi  = 0; gi < groups.length; ++gi) {
                    var groupXML = groups[gi];
                    var dasGroup = new DASGroup();
                    dasGroup.type = groupXML.getAttribute('type');
                    dasGroup.id = groupXML.getAttribute('id');
                    dasGroup.links = dasLinksOf(groupXML);
                    dasGroup.notes = dasNotesOf(groupXML);
                    if (!dasFeature.groups) {
                        dasFeature.groups = new Array(dasGroup);
                    } else {
                        dasFeature.groups.push(dasGroup);
                    }
                }

                // Magic notes.  Check with TAD before changing this.
                if (dasFeature.notes) {
                    for (var ni = 0; ni < dasFeature.notes.length; ++ni) {
                        var n = dasFeature.notes[ni];
                        if (n.indexOf('Genename=') == 0) {
                            var gg = new DASGroup();
                            gg.type='gene';
                            gg.id = n.substring(9);
                            if (!dasFeature.groups) {
                                dasFeature.groups = new Array(gg);
                            } else {
                                dasFeature.groups.push(gg);
                            }
                        }
                    }
                }
                
                {
                    var pec = feature.getElementsByTagName('PART');
                    if (pec.length > 0) {
                        var parts = [];
                        for (var pi = 0; pi < pec.length; ++pi) {
                            parts.push(pec[pi].getAttribute('id'));
                        }
                        dasFeature.parts = parts;
                    }
                }
                {
                    var pec = feature.getElementsByTagName('PARENT');
                    if (pec.length > 0) {
                        var parents = [];
                        for (var pi = 0; pi < pec.length; ++pi) {
                            parents.push(pec[pi].getAttribute('id'));
                        }
                        dasFeature.parents = parents;
                    }
                }
                
                features.push(dasFeature);
            }
        }
                
        callback(features, undefined, segmentMap);
    },
    function (err) {
        callback([], err);
    });
}

function DASAlignment(type) {
    this.type = type;
    this.objects = {};
    this.blocks = [];
}

DASSource.prototype.alignments = function(segment, options, callback) {
    var dasURI = this.dasBaseURI + 'alignment?query=' + segment;
    this.doCrossDomainRequest(dasURI, function(responseXML) {
        if (!responseXML) {
            callback([], 'Failed request ' + dasURI);
            return;
        }

        var alignments = [];
        var aliXMLs = responseXML.getElementsByTagName('alignment');
        for (var ai = 0; ai < aliXMLs.length; ++ai) {
            var aliXML = aliXMLs[ai];
            var ali = new DASAlignment(aliXML.getAttribute('alignType'));
            var objXMLs = aliXML.getElementsByTagName('alignObject');
            for (var oi = 0; oi < objXMLs.length; ++oi) {
                var objXML = objXMLs[oi];
                var obj = {
                    id:          objXML.getAttribute('intObjectId'),
                    accession:   objXML.getAttribute('dbAccessionId'),
                    version:     objXML.getAttribute('objectVersion'),
                    dbSource:    objXML.getAttribute('dbSource'),
                    dbVersion:   objXML.getAttribute('dbVersion')
                };
                ali.objects[obj.id] = obj;
            }
            
            var blockXMLs = aliXML.getElementsByTagName('block');
            for (var bi = 0; bi < blockXMLs.length; ++bi) {
                var blockXML = blockXMLs[bi];
                var block = {
                    order:      blockXML.getAttribute('blockOrder'),
                    segments:   []
                };
                var segXMLs = blockXML.getElementsByTagName('segment');
                for (var si = 0; si < segXMLs.length; ++si) {
                    var segXML = segXMLs[si];
                    var seg = {
                        object:      segXML.getAttribute('intObjectId'),
                        min:         segXML.getAttribute('start'),
                        max:         segXML.getAttribute('end'),
                        strand:      segXML.getAttribute('strand'),
                        cigar:       elementValue(segXML, 'cigar')
                    };
                    block.segments.push(seg);
                }
                ali.blocks.push(block);
            }       
                    
            alignments.push(ali);
        }
        callback(alignments);
    });
}


function DASStylesheet() {
/*
    this.highZoomStyles = new Object();
    this.mediumZoomStyles = new Object();
    this.lowZoomStyles = new Object();
*/

    this.styles = [];
}

DASStylesheet.prototype.pushStyle = function(filters, zoom, style) {
    /*

    if (!zoom) {
        this.highZoomStyles[type] = style;
        this.mediumZoomStyles[type] = style;
        this.lowZoomStyles[type] = style;
    } else if (zoom == 'high') {
        this.highZoomStyles[type] = style;
    } else if (zoom == 'medium') {
        this.mediumZoomStyles[type] = style;
    } else if (zoom == 'low') {
        this.lowZoomStyles[type] = style;
    }

    */

    if (!filters) {
        filters = {type: 'default'};
    }
    var styleHolder = shallowCopy(filters);
    if (zoom) {
        styleHolder.zoom = zoom;
    }
    styleHolder.style = style;
    this.styles.push(styleHolder);
}

function DASStyle() {
}

function parseGradient(grad) {
    var steps = grad.getAttribute('steps');
    if (steps) {
        steps = steps|0;
    } else {
        steps = 50;
    }


    var stops = [];
    var colors = [];
    var se = grad.getElementsByTagName('STOP');
    for (var si = 0; si < se.length; ++si) {
        var stop = se[si];
        stops.push(1.0 * stop.getAttribute('score'));
        colors.push(stop.firstChild.nodeValue);
    }

    return makeColourSteps(steps, stops, colors);
}

DASSource.prototype.stylesheet = function(successCB, failureCB) {
    var dasURI, creds = this.credentials;
    if (this.stylesheet_uri) {
        dasURI = this.stylesheet_uri;
        creds = false;
    } else {
        dasURI = this.dasBaseURI + 'stylesheet';
    }

    doCrossDomainRequest(dasURI, function(responseXML) {
        if (!responseXML) {
            if (failureCB) {
                failureCB();
            } 
            return;
        }
        var stylesheet = new DASStylesheet();
        var typeXMLs = responseXML.getElementsByTagName('TYPE');
        for (var i = 0; i < typeXMLs.length; ++i) {
            var typeStyle = typeXMLs[i];
            
            var filter = {};
            filter.type = typeStyle.getAttribute('id'); // Am I right in thinking that this makes DASSTYLE XML invalid?  Ugh.
            filter.label = typeStyle.getAttribute('label');
            filter.method = typeStyle.getAttribute('method');
            var glyphXMLs = typeStyle.getElementsByTagName('GLYPH');
            for (var gi = 0; gi < glyphXMLs.length; ++gi) {
                var glyphXML = glyphXMLs[gi];
                var zoom = glyphXML.getAttribute('zoom');
                var glyph = childElementOf(glyphXML);
                var style = new DASStyle();
                style.glyph = glyph.localName;
                var child = glyph.firstChild;
        
                while (child) {
                    if (child.nodeType == Node.ELEMENT_NODE) {
                        // alert(child.localName);
                        if (child.localName == 'BGGRAD') {
                            style[child.localName] = parseGradient(child);
                        } else {      
                            style[child.localName] = child.firstChild.nodeValue;
                        }
                    }
                    child = child.nextSibling;
                }
                stylesheet.pushStyle(filter, zoom, style);
            }
        }
        successCB(stylesheet);
    }, creds);
}

//
// sources command
// 

function DASRegistry(uri, opts)
{
    opts = opts || {};
    this.uri = uri;
    this.opts = opts;   
}

DASRegistry.prototype.sources = function(callback, failure, opts)
{
    if (!opts) {
        opts = {};
    }

    var filters = [];
    if (opts.taxon) {
        filters.push('organism=' + opts.taxon);
    }
    if (opts.auth) {
        filters.push('authority=' + opts.auth);
    }
    if (opts.version) {
        filters.push('version=' + opts.version);
    }
    var quri = this.uri;
    if (filters.length > 0) {
        quri = quri + '?' + filters.join('&');   // '&' as a separator to hack around dasregistry.org bug.
    }

    doCrossDomainRequest(quri, function(responseXML) {
        if (!responseXML && failure) {
            failure();
            return;
        }

        var sources = [];       
        var sourceXMLs = responseXML.getElementsByTagName('SOURCE');
        for (var si = 0; si < sourceXMLs.length; ++si) {
            var sourceXML = sourceXMLs[si];
            var versionXMLs = sourceXML.getElementsByTagName('VERSION');
            if (versionXMLs.length < 1) {
                continue;
            }
            var versionXML = versionXMLs[0];

            var coordXMLs = versionXML.getElementsByTagName('COORDINATES');
            var coords = [];
            for (var ci = 0; ci < coordXMLs.length; ++ci) {
                var coordXML = coordXMLs[ci];
                var coord = new DASCoords();
                coord.auth = coordXML.getAttribute('authority');
                coord.taxon = coordXML.getAttribute('taxid');
                coord.version = coordXML.getAttribute('version');
                coords.push(coord);
            }
            
            var caps = [];
            var capXMLs = versionXML.getElementsByTagName('CAPABILITY');
            var uri;
            for (var ci = 0; ci < capXMLs.length; ++ci) {
                var capXML = capXMLs[ci];
                
                caps.push(capXML.getAttribute('type'));

                if (capXML.getAttribute('type') == 'das1:features') {
                    var fep = capXML.getAttribute('query_uri');
                    uri = fep.substring(0, fep.length - ('features'.length));
                }
            }

            var props = {};
            var propXMLs = versionXML.getElementsByTagName('PROP');
            for (var pi = 0; pi < propXMLs.length; ++pi) {
                pusho(props, propXMLs[pi].getAttribute('name'), propXMLs[pi].getAttribute('value'));
            }
            
            if (uri) {
                var source = new DASSource(uri, {
                    source_uri: sourceXML.getAttribute('uri'),
                    name:  sourceXML.getAttribute('title'),
                    desc:  sourceXML.getAttribute('description'),
                    coords: coords,
                    props: props,
                    capabilities: caps
                });
                sources.push(source);
            }
        }
        
        callback(sources);
    });
}


//
// Utility functions
//

function elementValue(element, tag)
{
    var children = element.getElementsByTagName(tag);
    if (children.length > 0 && children[0].firstChild) {
        var c = children[0];
        if (c.childNodes.length == 1) {
            return c.firstChild.nodeValue;
        } else {
            var s = '';
            for (var ni = 0; ni < c.childNodes.length; ++ni) {
                s += c.childNodes[ni].nodeValue;
            }
            return s;
        }

    } else {
        return null;
    }
}

function childElementOf(element)
{
    if (element.hasChildNodes()) {
        var child = element.firstChild;
        do {
            if (child.nodeType == Node.ELEMENT_NODE) {
                return child;
            } 
            child = child.nextSibling;
        } while (child != null);
    }
    return null;
}


function dasLinksOf(element)
{
    var links = new Array();
    var maybeLinkChilden = element.getElementsByTagName('LINK');
    for (var ci = 0; ci < maybeLinkChilden.length; ++ci) {
        var linkXML = maybeLinkChilden[ci];
        if (linkXML.parentNode == element) {
            links.push(new DASLink(linkXML.firstChild ? linkXML.firstChild.nodeValue : 'Unknown', linkXML.getAttribute('href')));
        }
    }
    
    return links;
}

function dasNotesOf(element)
{
    var notes = [];
    var maybeNotes = element.getElementsByTagName('NOTE');
    for (var ni = 0; ni < maybeNotes.length; ++ni) {
        if (maybeNotes[ni].firstChild) {
            notes.push(maybeNotes[ni].firstChild.nodeValue);
        }
    }
    return notes;
}

function doCrossDomainRequest(url, handler, credentials, custAuth) {
    // TODO: explicit error handlers?

    if (window.XDomainRequest) {
        var req = new XDomainRequest();
        req.onload = function() {
            var dom = new ActiveXObject("Microsoft.XMLDOM");
            dom.async = false;
            dom.loadXML(req.responseText);
            handler(dom);
        }
        req.open("get", url);
        req.send('');
    } else {
        try {
            var req = new XMLHttpRequest();
            var timeout = setTimeout(
                function() {
                    console.log('timing out '  + url);
                    req.abort();
                    handler(null, req);
                },
                5000
            );

            req.timeout = 5000;
            req.ontimeout = function() {
                console.log('timeout on ' + url);
            };

            req.onreadystatechange = function() {
                if (req.readyState == 4) {
                    clearTimeout(timeout);
                    if (req.status >= 200 || req.status == 0) {
                        handler(req.responseXML, req);
                    }
                }
            };
            req.open("get", url, true);
            if (credentials) {
                req.withCredentials = true;
            }
            if (custAuth) {
                req.setRequestHeader('X-DAS-Authorisation', custAuth);
            }
            req.overrideMimeType('text/xml');
            req.setRequestHeader('Accept', 'application/xml,*/*');
            req.send('');
        } catch (e) {
            handler(null, req, e);
        }
    }
}

DASSource.prototype.doCrossDomainRequest = function(url, handler, errHandler) {
    var custAuth;
    if (this.xUser) {
        custAuth = 'Basic ' + btoa(this.xUser + ':' + this.xPass);
    }

    try {
        return doCrossDomainRequest(url, handler, this.credentials, custAuth);
    } catch (err) {
        if (errHandler) {
            errHandler(err);
        } else {
            throw err;
        }
    }
}

function isDasBooleanTrue(s) {
    s = ('' + s).toLowerCase();
    return s==='yes' || s==='true';
}

function isDasBooleanNotFalse(s) {
    if (!s)
        return false;

    s = ('' + s).toLowerCase();
    return s!=='no' || s!=='false';
}

function copyStylesheet(ss) {
    var nss = shallowCopy(ss);
    nss.styles = [];
    for (var si = 0; si < ss.styles.length; ++si) {
        var sh = nss.styles[si] = shallowCopy(ss.styles[si]);
        sh._methodRE = sh._labelRE = sh._typeRE = undefined;
        sh.style = shallowCopy(sh.style);
        sh.style.id = undefined;
        sh.style._gradient = undefined;
    }
    return nss;
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        DASGroup: DASGroup,
        DASFeature: DASFeature,
        DASStylesheet: DASStylesheet,
        DASStyle: DASStyle,
        DASSource: DASSource,
        DASSegment: DASSegment,
        DASRegistry: DASRegistry,
        DASSequence: DASSequence,
        DASLink: DASLink,

        isDasBooleanTrue: isDasBooleanTrue,
        isDasBooleanNotFalse: isDasBooleanNotFalse,
        copyStylesheet: copyStylesheet,
        coordsMatch: coordsMatch
    };
}

},{"./color":9,"./utils":49}],11:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// domui.js: SVG UI components
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
}

Browser.prototype.removeAllPopups = function() {
    removeChildren(this.hPopupHolder);
    removeChildren(this.popupHolder);
}

Browser.prototype.makeTooltip = function(ele, text)
{
    var isin = false;
    var thisB = this;
    var timer = null;
    var outlistener;
    outlistener = function(ev) {
        isin = false;
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
        ele.removeEventListener('mouseout', outlistener, false);
    };

    var setup = function(ev) {
        var mx = ev.clientX + window.scrollX, my = ev.clientY + window.scrollY;
        if (!timer) {
            timer = setTimeout(function() {
                var ttt;
                if (typeof(text) === 'function') {
                    ttt = text();
                } else {
                    ttt = text;
                }

                var popup = makeElement('div',
                    [makeElement('div', null, {className: 'tooltip-arrow'}),
                     makeElement('div', ttt, {className: 'tooltip-inner'})], 
                    {className: 'tooltip bottom in'}, {
                    display: 'block',
                    top: '' + (my + 20) + 'px',
                    left: '' + Math.max(mx - 30, 20) + 'px'
                });
                thisB.hPopupHolder.appendChild(popup);
                var moveHandler;
                moveHandler = function(ev) {
                    try {
                        thisB.hPopupHolder.removeChild(popup);
                    } catch (e) {
                        // May have been removed by other code which clears the popup layer.
                    }
                    window.removeEventListener('mousemove', moveHandler, false);
                    if (isin) {
                        if (ele.offsetParent == null) {
                        } else {
                            setup(ev);
                        }
                    }
                }
                window.addEventListener('mousemove', moveHandler, false);
                timer = null;
            }, 1000);
        }
    };

    ele.addEventListener('mouseover', function(ev) {
        isin = true
        ele.addEventListener('mouseout', outlistener, false);
        setup(ev);
    }, false);
    ele.addEventListener('DOMNodeRemovedFromDocument', function(ev) {
        isin = false;
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    }, false);
}

Browser.prototype.popit = function(ev, name, ele, opts)
{
    var thisB = this;
    if (!opts) 
        opts = {};
    if (!ev) 
        ev = {};

    var width = opts.width || 200;

    var mx, my;

    if (ev.clientX) {
        var mx =  ev.clientX, my = ev.clientY;
    } else {
        mx = 500; my= 50;
    }
    mx +=  document.documentElement.scrollLeft || document.body.scrollLeft;
    my +=  document.documentElement.scrollTop || document.body.scrollTop;
    var winWidth = window.innerWidth;

    var top = my;
    var left = Math.min(mx - (width/2) - 4, (winWidth - width - 30));

    var popup = makeElement('div');
    popup.className = 'popover fade ' + (ev.clientX ? 'bottom ' : '') + 'in';
    popup.style.display = 'block';
    popup.style.position = 'absolute';
    popup.style.top = '' + top + 'px';
    popup.style.left = '' + left + 'px';
    popup.style.width = width + 'px';
    if (width > 276) {
        // HACK Bootstrappification...
        popup.style.maxWidth = width + 'px';
    }

    popup.appendChild(makeElement('div', null, {className: 'arrow'}));

    if (name) {
        var closeButton = makeElement('button', '', {className: 'close'});
        closeButton.innerHTML = '&times;'

        closeButton.addEventListener('mouseover', function(ev) {
            closeButton.style.color = 'red';
        }, false);
        closeButton.addEventListener('mouseout', function(ev) {
            closeButton.style.color = 'black';
        }, false);
        closeButton.addEventListener('click', function(ev) {
            ev.preventDefault(); ev.stopPropagation();
            thisB.removeAllPopups();
        }, false);
        var tbar = makeElement('h4', [makeElement('span', name, null, {maxWidth: '200px'}), closeButton], {/*className: 'popover-title' */}, {paddingLeft: '10px', paddingRight: '10px'});

        var dragOX, dragOY;
        var moveHandler, upHandler;
        moveHandler = function(ev) {
            ev.stopPropagation(); ev.preventDefault();
            left = left + (ev.clientX - dragOX);
            if (left < 8) {
                left = 8;
            } if (left > (winWidth - width - 32)) {
                left = (winWidth - width - 26);
            }
            top = top + (ev.clientY - dragOY);
            top = Math.max(10, top);
            popup.style.top = '' + top + 'px';
            popup.style.left = '' + Math.min(left, (winWidth - width - 10)) + 'px';
            dragOX = ev.clientX; dragOY = ev.clientY;
        }
        upHandler = function(ev) {
            ev.stopPropagation(); ev.preventDefault();
            window.removeEventListener('mousemove', moveHandler, false);
            window.removeEventListener('mouseup', upHandler, false);
        }
        tbar.addEventListener('mousedown', function(ev) {
            ev.preventDefault(); ev.stopPropagation();
            dragOX = ev.clientX; dragOY = ev.clientY;
            window.addEventListener('mousemove', moveHandler, false);
            window.addEventListener('mouseup', upHandler, false);
        }, false);
                              

        popup.appendChild(tbar);
    }

    popup.appendChild(makeElement('div', ele, {className: 'popover-content'}, {
        padding: '0px'
    }));
    this.hPopupHolder.appendChild(popup);

    var popupHandle = {
        node: popup,
        displayed: true
    };
    popup.addEventListener('DOMNodeRemoved', function(ev) {
        if (ev.target == popup) {
            popupHandle.displayed = false;
        }
    }, false);
    return popupHandle;
}

function makeTreeTableSection(title, content, visible) {
    var ttButton = makeElement('i');
    function update() {
        if (visible) {
            ttButton.className = 'fa fa-caret-down';
            content.style.display = 'table';
        } else {
            ttButton.className = 'fa fa-caret-right';
            content.style.display = 'none';
        }
    }
    update();

    ttButton.addEventListener('click', function(ev) {
        ev.preventDefault(); ev.stopPropagation();
        visible = !visible;
        update();
    }, false);

    var heading = makeElement('h6', [ttButton, ' ', title], {}, {display: 'block', background: 'gray', color: 'white', width: '100%', padding: '5px 2px', margin: '0px'});
    return makeElement('div', [heading, content], {});
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        makeTreeTableSection: makeTreeTableSection
    };
}

},{"./cbrowser":6,"./utils":49}],12:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// encode.js: interface for ENCODE DCC services
//

"use strict";

if (typeof(require) !== 'undefined') {
    var Promise = require('es6-promise').Promise;
}

function lookupEncodeURI(uri, json) {
    if (uri.indexOf('?') < 0)
        uri = uri + '?soft=true';

    return new Promise(function(accept, reject) {
        var req = new XMLHttpRequest();
        req.onreadystatechange = function() {
            if (req.readyState == 4) {
                if (req.status >= 300) {
                    reject('Error code ' + req.status);
                } else {
                    var resp = JSON.parse(req.response);
                    accept(json ? resp : resp.location);
                }
            }
        };
    
        req.open('GET', uri, true);
        req.setRequestHeader('Accept', 'application/json');
        req.responseType = 'text';
        req.send('');
    });
}

function EncodeURLHolder(url) {
    this.rawurl = url;
}

EncodeURLHolder.prototype.getURLPromise = function() {
    if (this.urlPromise && this.urlPromiseValidity > Date.now()) {
        return this.urlPromise;
    } else {
        this.urlPromise = lookupEncodeURI(this.rawurl, true).then(function(resp) {
            return resp.location;
        });
        this.urlPromiseValidity = Date.now() + (12 * 3600 * 1000);
        return this.urlPromise;
    }
}

function EncodeFetchable(url, start, end, opts) {
    if (!opts) {
        if (typeof start === 'object') {
            opts = start;
            start = undefined;
        } else {
            opts = {};
        }
    }

    this.url = (typeof url === 'string' ? new EncodeURLHolder(url) : url);
    this.start = start || 0;
    if (end) {
        this.end = end;
    }
    this.opts = opts;
}



EncodeFetchable.prototype.slice = function(s, l) {
    if (s < 0) {
        throw 'Bad slice ' + s;
    }

    var ns = this.start, ne = this.end;
    if (ns && s) {
        ns = ns + s;
    } else {
        ns = s || ns;
    }
    if (l && ns) {
        ne = ns + l - 1;
    } else {
        ne = ne || l - 1;
    }
    return new EncodeFetchable(this.url, ns, ne, this.opts);
}

EncodeFetchable.prototype.fetchAsText = function(callback) {
    var self = this;
    var req = new XMLHttpRequest();
    var length;
    self.url.getURLPromise().then(function(url) {
        req.open('GET', url, true);

        if (self.end) {
            if (self.end - self.start > 100000000) {
                throw 'Monster fetch!';
            }
            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);
            length = self.end - self.start + 1;
        }

        req.onreadystatechange = function() {
            if (req.readyState == 4) {
                if (req.status == 200 || req.status == 206) {
                    return callback(req.responseText);
                } else {
                    return callback(null);
                }
            }
        };
        if (self.opts.credentials) {
            req.withCredentials = true;
        }
        req.send('');
    }).catch(function(err) {
        console.log(err);
        return callback(null);
    });
}

EncodeFetchable.prototype.salted = function() {
    return this;
}

EncodeFetchable.prototype.fetch = function(callback, attempt, truncatedLength) {
    var self = this;

    attempt = attempt || 1;
    if (attempt > 3) {
    	console.log("EXCEED ATTEMPT");
        return callback(null);
    }

    self.url.getURLPromise().then(function (url) {
        var req = new XMLHttpRequest();
        var length;
        req.open('GET', url, true);
        req.overrideMimeType('text/plain; charset=x-user-defined');
        if (self.end) {
            if (self.end - self.start > 100000000) {
                throw 'Monster fetch!';
            }
            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);
            length = self.end - self.start + 1;
        }
        req.responseType = 'arraybuffer';
        req.onreadystatechange = function() {
            if (req.readyState == 4) {
                if (req.status == 200 || req.status == 206) {
                    if (req.response) {
                        var bl = req.response.byteLength;
                        if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {
                            return self.fetch(callback, attempt + 1, bl);
                        } else {
                            return callback(req.response);
                        }
                    } else if (req.mozResponseArrayBuffer) {
                        return callback(req.mozResponseArrayBuffer);
                    } else {
                        var r = req.responseText;
                        if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {
                            return self.fetch(callback, attempt + 1, r.length);
                        } else {
                            return callback(bstringToBuffer(req.responseText));
                        }
                    }
                } else if (req.status == 403 || req.status == 404) { 
                	//refused for lack of permission, usually just trying again later will work
                	return self.fetch(callback, {attempt: 0});
                } else {
                    return self.fetch(callback, attempt + 1);
                }
            }
        };
        if (self.opts.credentials) {
            req.withCredentials = true;
        }
        req.send('');
    }).catch(function(err) {
        console.log(err);
    });
}

function bstringToBuffer(result) {
    if (!result) {
        return null;
    }

    var ba = new Uint8Array(result.length);
    for (var i = 0; i < ba.length; ++i) {
        ba[i] = result.charCodeAt(i);
    }
    return ba.buffer;
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        lookupEncodeURI: lookupEncodeURI,
        EncodeFetchable: EncodeFetchable
    };
}

},{"es6-promise":53}],13:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// ensembljson.js -- query the Ensembl REST API.
//

"use strict";

if (typeof(require) !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;
}



function EnsemblFeatureSource(source) {
    FeatureSourceBase.call(this);
    this.source = source;
    this.base = source.uri || '//rest.ensembl.org';
    if (this.base.indexOf('//') === 0) {
        var proto = window.location.protocol;
        if (proto == 'http:' || proto == 'https:') {
            // Protocol-relative URLs okay.
        } else {
            this.base = 'http:' + this.base;
        }
    }
    this.species = source.species || 'human';

    if (typeof source.type === 'string') {
        this.type = [source.type];
    } else {
        this.type = source.type || ['regulatory'];
    }
}

EnsemblFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);
EnsemblFeatureSource.prototype.constructor = EnsemblFeatureSource;

EnsemblFeatureSource.prototype.getStyleSheet = function(callback) {
    var stylesheet = new DASStylesheet();

    var tsStyle = new DASStyle();
    tsStyle.glyph = '__NONE';
    if (this.type.indexOf('exon') >= 0)
        stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);
    if (this.type.indexOf('exon') >= 0 || this.type.indexOf('transcript') >= 0)
        stylesheet.pushStyle({type: 'gene'}, null, tsStyle);

    var cdsStyle = new DASStyle();
    cdsStyle.glyph = 'BOX';
    cdsStyle.FGCOLOR = 'black';
    cdsStyle.BGCOLOR = 'red'
    cdsStyle.HEIGHT = 8;
    cdsStyle.BUMP = true;
    cdsStyle.LABEL = true;
    cdsStyle.ZINDEX = 10;
    stylesheet.pushStyle({type: 'cds'}, null, cdsStyle);

    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'SQUARE';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({type: 'variation', method: '.+_UTR_variant'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'S';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({type: 'variation', method: 'missense_variant'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'N';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({type: 'variation', method: 'splice_.+_variant'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'STAR';
        varStyle.POINTS = 6;
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'blue';
        stylesheet.pushStyle({type: 'variation', method: 'regulatory_region_variant'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        // varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({type: 'variation'}, null, varStyle);
    }
        {
        var varStyle = new DASStyle();
        varStyle.glyph = 'SQUARE';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({type: 'indel', method: '.+_UTR_variant'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'S';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({type: 'indel', method: 'missense_variant'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'TRIANGLE';
        varStyle.DIRECTION = 'N';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({type: 'indel', method: 'splice_.+_variant'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'STAR';
        varStyle.POINTS = 6;
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        stylesheet.pushStyle({type: 'indel', method: 'regulatory_region_variant'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.BGCOLOR = '#888888';
        varStyle.FGCOLOR = 'red';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({type: 'indel'}, null, varStyle);
    }

    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = 'orange'
    wigStyle.HEIGHT = 8;
    wigStyle.BUMP = true;
    wigStyle.LABEL = true;
    wigStyle.ZINDEX = 20;
    stylesheet.pushStyle({type: 'default'}, null, wigStyle);
    return callback(stylesheet);
}


EnsemblFeatureSource.prototype.getScales = function() {
    return [];
}

EnsemblFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {
    var thisB = this;
    var url = this.base + '/overlap/region/' + this.species + '/' + chr + ':' + min + '-' + max;

    var filters = [];
    for (var ti = 0; ti < this.type.length; ++ti) {
        filters.push('feature=' + this.type[ti]);
    }
    filters.push('content-type=application/json');
    url = url + '?' + filters.join(';');

    var req = new XMLHttpRequest();
    req.onreadystatechange = function() {
    	if (req.readyState == 4) {
            thisB.busy--;
            thisB.notifyActivity();

    	    if (req.status >= 300) {
                var err = 'Error code ' + req.status;
                try {
                    var jr = JSON.parse(req.response);
                    if (jr.error) {
                        err = jr.error;
                    }
                } catch (ex) {};

    		    callback(err, null);
    	    } else {
        		var jf = JSON.parse(req.response);
        		var features = [];
        		for (var fi = 0; fi < jf.length; ++fi) {
        		    var j = jf[fi];

        		    var notes = [];
        		    var f = new DASFeature();
        		    f.segment = chr;
        		    f.min = j['start'] | 0;
        		    f.max = j['end'] | 0;
        		    f.type = j.feature_type || 'unknown';
        		    f.id = j.ID;

                    if (j.Parent) {
                        var grp = new DASGroup();
                        grp.id = j.Parent;
                        f.groups = [grp];
                    }

                    if (j.strand) {
                        if (j.strand < 0) 
                            f.orientation = '-';
                        else if (j.strand > 0) 
                            f.orientation = '+';
                    }

                    if (j.consequence_type)
                        f.method = j.consequence_type;

                    if (j.alt_alleles) {
                        notes.push('Alleles=' + j.alt_alleles.join('/'));
                        if (j.alt_alleles.length > 1) {
                            if (j.alt_alleles[1].length != j.alt_alleles[0].length || j.alt_alleles[1] == '-') {
                                f.type = 'indel';
                            }
                        }
                    }
        		    
                    if (notes.length > 0) {
                        f.notes = notes;
                    }
        		    features.push(f);
        		}
        		callback(null, features);
    	    }
    	}
	
    };
    
    thisB.busy++;
    thisB.notifyActivity();

    req.open('GET', url, true);
    req.responseType = 'text';
    req.send('');
}

dalliance_registerSourceAdapterFactory('ensembl', function(source) {
    return {features: new EnsemblFeatureSource(source)};
});

},{"./das":10,"./sourceadapters":34}],14:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-config.js
//

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;

    var das = require('./das');
    var copyStylesheet = das.copyStylesheet;
}

Browser.prototype.exportFullConfig = function(opts) {
    opts = opts || {};

    var config = {
        chr: this.chr,
        viewStart: this.viewStart|0,
        viewEnd: this.viewEnd|0,
        cookieKey: 'dalliance_' + hex_sha1(Date.now()),

        coordSystem: this.coordSystem,

        sources: this.exportSourceConfig(),

        chains: this.exportChains()
    };

    if (this.prefix)
        config.prefix = this.prefix;

    return config;
}

Browser.prototype.exportChains = function() {
    var cc = {};
    var cs = this.chains || {};
    for (var k in cs) {
        cc[k] = cs[k].exportConfig();
    }
    return cc;
}

Browser.prototype.exportSourceConfig = function(opts) {
    opts = opts || {};

    var sourceConfig = [];
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var source = shallowCopy(tier.dasSource);

        if (source.noPersist)
            continue;

        source.coords = undefined;
        source.props = undefined;
        if (!source.disabled)
            source.disabled = undefined;

        if (tier.config.stylesheet) {
            source.style = copyStylesheet(tier.config.stylesheet).styles;
            source.stylesheet_uri = undefined;
        } else if (source.style) {
            source.style = copyStylesheet({styles: source.style}).styles;
        }

        if (typeof(tier.config.name) === 'string') {
            source.name = tier.config.name;
        }

        if (tier.config.height !== undefined) {
            source.forceHeight = tier.config.height;
        }
        if (tier.config.forceMin !== undefined) {
            source.forceMin = tier.config.forceMin;
        }
        if (tier.config.forceMinDynamic)
            source.forceMinDynamic = tier.config.forceMinDynamic;
        if (tier.config.forceMax !== undefined) {
            source.forceMax = tier.config.forceMax;
        }
        if (tier.config.bumped !== undefined) {
            source.bumped = tier.config.bumped;
        }
        if (tier.config.forceMaxDynamic)
            source.forceMaxDynamic = tier.config.forceMaxDynamic;

        sourceConfig.push(source);
    }

    return sourceConfig;
}

Browser.prototype.exportPageTemplate = function(opts) {
    opts = opts || {};
    var template = '<html>\n' +
                   '  <head>\n' +
                   '    <script language="javascript" src="' + this.resolveURL('$$dalliance-compiled.js') + '"></script>\n' +
                   '    <script language="javascript">\n' +
                   '      var dalliance_browser = new Browser(' + JSON.stringify(this.exportFullConfig(opts), null, 2) + ');\n' +
                   '    </script>\n' +  
                   '  </head>\n' +
                   '  <body>\n' +
                   '    <div id="svgHolder">Dalliance goes here</div>\n' +
                   '  </body>\n' +
                   '<html>\n';

    return template;
}
},{"./cbrowser":6,"./das":10,"./sha1":33,"./utils":49}],15:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-image.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var g = require('./glyphs');
    var OverlayLabelCanvas = g.OverlayLabelCanvas;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;

    var drawSeqTierGC = require('./sequence-draw').drawSeqTierGC;
}

function fillTextRightJustified(g, text, x, y) {
    g.fillText(text, x - g.measureText(text).width, y);
}

Browser.prototype.exportImage = function(opts) {
    opts = opts || {};

    var fpw = this.featurePanelWidth;
    var padding = 3;
    var totHeight = 0;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (ti > 0)
            totHeight += padding;
        var tier = this.tiers[ti];
        if (tier.layoutHeight !== undefined)
            totHeight += tier.layoutHeight;
    }
    var mult = opts.resolutionMultiplier || 1.0;
    var margin = 200;


    var cw = ((fpw + margin) * mult)|0;
    var ch = (totHeight * mult)|0;
    var c = makeElement('canvas', null, {width: cw, height: ch});
    var g = c.getContext('2d');
    g.fillStyle = 'white';
    g.fillRect(0, 0, cw, ch);

    g.scale(mult, mult);
    
    var ypos = 0;
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        var tier = this.tiers[ti];
        var offset = ((tier.glyphCacheOrigin - this.viewStart)*this.scale);

        var oc = new OverlayLabelCanvas();
        g.save();       // 1
        g.translate(0, ypos);

        g.save();       // 2
        g.beginPath();
        g.moveTo(margin, 0);
        g.lineTo(margin + fpw, 0);
        g.lineTo(margin + fpw, tier.layoutHeight);
        g.lineTo(margin, tier.layoutHeight);
        g.closePath();
        g.clip();
        g.translate(margin, 0);

        g.save();      // 3
        g.translate(offset, 0);
        if (tier.subtiers) {
            tier.paintToContext(g, oc, offset + 1000);
        } else {
            drawSeqTierGC(tier, tier.currentSequence, g);
        }
        g.restore();   // 2
        
        g.save()       // 3
        g.translate(offset, 0);
        oc.draw(g, -offset, fpw - offset);
        g.restore();   // 2
        g.restore();   // 1

        var hasQuant = false;
        var pos = 0;
        var subtiers = tier.subtiers || [];
        for (var sti = 0; sti < subtiers.length; ++sti) {
            var subtier = subtiers[sti];
                    
            if (subtier.quant) {
                hasQuant = true;
                var q = subtier.quant;
                var h = subtier.height;

                var numTics = 2;
                if (h > 40) {
                    numTics = 1 + ((h/20) | 0);
                }
                var ticSpacing = h / (numTics - 1);
                var ticInterval = (q.max - q.min) / (numTics - 1);

                g.beginPath();
                g.moveTo(margin + 5, pos);
                g.lineTo(margin, pos);
                g.lineTo(margin, pos + subtier.height);
                g.lineTo(margin + 5, pos + subtier.height);
                for (var t = 1; t < numTics-1; ++t) {
                    var ty = t*ticSpacing;
                    g.moveTo(margin, pos + ty);
                    g.lineTo(margin+3, pos + ty);
                }
                g.strokeStyle = 'black';
                g.strokeWidth = 2;
                g.stroke();

                g.fillStyle = 'black';
                fillTextRightJustified(g, formatQuantLabel(q.max), margin - 3, pos + 7);
                fillTextRightJustified(g, formatQuantLabel(q.min), margin - 3, pos + subtier.height);
                for (var t = 1; t < numTics-1; ++t) {
                    var ty = t*ticSpacing;
                    fillTextRightJustified(g, formatQuantLabel((1.0*q.max) - (t*ticInterval)), margin - 3, pos + ty + 3);
                }
            }

            pos += subtier.height + padding;
        }

        var labelName;
        if (typeof tier.config.name === 'string')
            labelName = tier.config.name;
        else
            labelName = tier.dasSource.name;
        var labelWidth = g.measureText(labelName).width;
        g.fillStyle = 'black';
        g.fillText(labelName, margin - (hasQuant ? 22 : 12) - labelWidth, (tier.layoutHeight + 6) / 2);

        g.restore(); // 0

        ypos += tier.layoutHeight + padding;
    }

    if (opts.highlights) {
        g.save();

        g.beginPath();
        g.moveTo(margin, 0);
        g.lineTo(margin + fpw, 0);
        g.lineTo(margin + fpw, ypos);
        g.lineTo(margin, ypos);
        g.closePath();
        g.clip();

        g.translate(margin + offset, 0);
        var origin = this.viewStart;
        var visStart = this.viewStart;
        var visEnd = this.viewEnd;

        for (var hi = 0; hi < this.highlights.length; ++hi) {
            var h = this.highlights[hi];
            if (((h.chr === this.chr) || (h.chr === ('chr' + this.chr))) && h.min < visEnd && h.max > visStart) {
                g.globalAlpha = this.defaultHighlightAlpha;
                g.fillStyle = this.defaultHighlightFill;
                g.fillRect((h.min - origin) * this.scale,
                           0,
                           (h.max - h.min) * this.scale,
                           ypos);
            }
        } 
        g.restore();
    }

    var rulerPos = -1; 
    if (opts.ruler == 'center') {
        rulerPos = margin + ((this.viewEnd - this.viewStart + 1)*this.scale) / 2;
    } else if (opts.ruler == 'left') {
        rulerPos = margin;
    } else if (opts.ruler == 'right') {
        rulerPos = margin + ((this.viewEnd - this.viewStart + 1)*this.scale);
    }
    if (rulerPos >= 0) {
        g.strokeStyle = 'blue';
        g.beginPath();
        g.moveTo(rulerPos, 0);
        g.lineTo(rulerPos, ypos);
        g.stroke();
    }

    return c.toDataURL('image/png');
}
},{"./cbrowser":6,"./glyphs":21,"./numformats":26,"./sequence-draw":31}],16:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// export-ui.js
//

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
}

Browser.prototype.openExportPanel = function() {
    var b = this;
    if (this.uiMode === 'export') {
        this.hideToolPanel();
        this.setUiMode('none');
    } else {
        var exportForm = makeElement('div', null, {className: 'export-form'});
        var exportSelect = makeElement('select');
        exportSelect.appendChild(makeElement('option', 'SVG', {value: 'svg'}));
        exportSelect.appendChild(makeElement('option', 'Image', {value: 'png'}));
        exportSelect.appendChild(makeElement('option', 'Dalliance config', {value: 'config'}));
        exportSelect.appendChild(makeElement('option', 'Dalliance sources', {value: 'sources'}));
        exportSelect.appendChild(makeElement('option', 'Dalliance page', {value: 'page'}));
        exportSelect.value = 'svg';

        exportSelect.addEventListener('change', function(ev) {
            removeChildren(exportContent);
            setupEOT();
        }, false);
        exportForm.appendChild(makeElement('p', ['Export as: ', exportSelect]));

        var exportHighlightsToggle = makeElement('input', null, {type: 'checkbox', checked: this.exportHighlights});
        exportHighlightsToggle.addEventListener('change', function(ev) {
            b.exportHighlights = exportHighlightsToggle.checked;
            b.storeStatus();
        }, false);
        var exportRulerToggle = makeElement('input', null, {type: 'checkbox', checked: this.exportRuler});
        exportRulerToggle.addEventListener('change', function(ev) {
            b.exportRuler = exportRulerToggle.checked;
            b.storeStatus();
        }, false);
        var exportScale = makeElement('input', null, {type: 'text', value: '1.0'});

        var exportButton = makeElement('button', 'Export', {className: 'btn btn-primary'});
        exportButton.addEventListener('click', function(ev) {
            removeChildren(exportContent);

            var blobURL;
            var note, type, name;
            if (exportSelect.value === 'svg') {
                blobURL = URL.createObjectURL(b.makeSVG({highlights: exportHighlightsToggle.checked,
                                                         ruler: exportRulerToggle.checked ? b.rulerLocation : 'none'}));
                note = 'SVG';
                type = 'image/svg';
                name = 'dalliance-view.svg';
            } else if (exportSelect.value === 'png') {
                var mult = parseFloat(exportScale.value);
                if (mult < 0.1 || mult > 10) {
                    alert('bad scale ' + mult);
                    return;
                }

                blobURL = b.exportImage({highlights: exportHighlightsToggle.checked,
                                         ruler: exportRulerToggle.checked ? b.rulerLocation : 'none',
                                         resolutionMultiplier: mult});
                note = 'Image';
                type = 'image/png';
                name = 'dalliance-view.png';
            } else if (exportSelect.value === 'config') {
                var config = JSON.stringify(b.exportFullConfig(), null, 2);
                var blob = new Blob([config], {type: 'text/plain'});
                blobURL = URL.createObjectURL(blob);
                note = 'Configuration';
                type = 'text/plain';
                name = 'dalliance-config.json';
            } else if (exportSelect.value === 'sources') {
                var config = JSON.stringify(b.exportSourceConfig(), null, 2);
                var blob = new Blob([config], {type: 'text/plain'});
                blobURL = URL.createObjectURL(blob);
                note = 'Source array';
                type = 'text/plain';
                name = 'dalliance-sources.json';
            } else if (exportSelect.value === 'page') {
                var page = b.exportPageTemplate();
                var type = 'text/html';
                var blob = new Blob([page], {type: type});
                blobURL = URL.createObjectURL(blob);
                note = 'Page template';
                name = 'dalliance-view.html';
            }

            if (blobURL) {
                var downloadLink = makeElement('a', '[Download]', {
                    href: blobURL,
                    download: name,
                    type: type
                });

                var previewLink = makeElement('a', '[Preview in browser]', {
                    href: blobURL,
                    type: type,
                    target: '_new'
                });

                exportContent.appendChild(makeElement('p', ['' + note + ' created: ', downloadLink, previewLink]));
            }
        }, false);

        b.addViewListener(function() {
            removeChildren(exportContent);
        });
        b.addTierListener(function() {
            removeChildren(exportContent);
        });

        var exportContent = makeElement('p', '');

        var eotHighlights = makeElement('tr',
                [makeElement('th', 'Include highlights', {}, {width: '200px', textAlign: 'right'}),
                 makeElement('td', exportHighlightsToggle)]);
        var eotGuideline = makeElement('tr',
                [makeElement('th', 'Include vertical guideline'),
                 makeElement('td', exportRulerToggle)]);
        var eotScale = makeElement('tr',
            [makeElement('th', 'Scale multiplier'),
             makeElement('td', exportScale)]);

        var exportOptsTable = makeElement('table',
            [eotHighlights,
             eotGuideline,
             eotScale]);
        var setupEOT = function() {
            var es = exportSelect.value;
            eotHighlights.style.display = (es == 'svg' || es == 'png') ? 'table-row' : 'none';
            eotGuideline.style.display = (es == 'svg' || es == 'png') ? 'table-row' : 'none';
            eotScale.style.display = (es == 'png') ? 'table-row' : 'none';
        }
        setupEOT();

        exportForm.appendChild(exportOptsTable);
        exportForm.appendChild(exportButton);
        exportForm.appendChild(exportContent);

        if (this.uiMode !== 'none')
            this.hideToolPanel();
        this.browserHolder.insertBefore(exportForm, this.svgHolder);
        this.activeToolPanel = exportForm;

        this.setUiMode('export');
    }
}

},{"./cbrowser":6,"./utils":49}],17:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// exports.js: shim to export symbols into global namespace for ease of embedding
//

var browser = require('./cbrowser');
var chainset = require('./chainset');
var sa = require('./sourceadapters');
var utils = require('./utils');
var das = require('./das');
var sc = require('./sourcecompare');

window.Browser = browser.Browser;
window.sourcesAreEqual = sc.sourcesAreEqual;
window.Chainset = chainset.Chainset;    // Pre-0.12 configurations need this.

// Useful for info plugins.  Should be reconsidered in the future.
window.makeElement = utils.makeElement;

// Allow source plugins to be loaded separately.
window.dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
window.dalliance_registerParserFactory = sa.registerParserFactory;
window.dalliance_makeParser = sa.makeParser;

// DAS* objects for some plugins -- remove when plugin API changes...

window.DASSequence = das.DASSequence;
window.DASFeature = das.DASFeature;
window.DASGroup = das.DASGroup;
window.DASStylesheet = das.DASStylesheet;
window.DASStyle = das.DASStyle;
window.DASSource = das.DASSource;    // Pre-0.8 configurations used this.  Still some around...

},{"./cbrowser":6,"./chainset":7,"./das":10,"./sourceadapters":34,"./sourcecompare":35,"./utils":49}],18:[function(require,module,exports){
// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// feature-draw.js: new feature-tier renderer
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
    var pusho = utils.pusho;

    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var sortFeatures = require('./features').sortFeatures;

    var g = require('./glyphs');
    var BoxGlyph = g.BoxGlyph;
    var GroupGlyph = g.GroupGlyph;
    var LineGraphGlyph = g.LineGraphGlyph;
    var LabelledGlyph = g.LabelledGlyph;
    var CrossGlyph = g.CrossGlyph;
    var ExGlyph = g.ExGlyph;
    var TriangleGlyph = g.TriangleGlyph;
    var DotGlyph = g.DotGlyph;
    var PaddedGlyph = g.PaddedGlyph;
    var AArrowGlyph = g.AArrowGlyph;
    var SpanGlyph = g.SpanGlyph;
    var LineGlyph = g.LineGlyph;
    var PrimersGlyph = g.PrimersGlyph;
    var ArrowGlyph = g.ArrowGlyph;
    var TooManyGlyph = g.TooManyGlyph;
    var TextGlyph = g.TextGlyph;
    var SequenceGlyph = g.SequenceGlyph;
    var AminoAcidGlyph = g.AminoAcidGlyph;
    var TranslatedGlyph = g.TranslatedGlyph;
    var PointGlyph = g.PointGlyph;
    var GridGlyph = g.GridGlyph;
    var StarGlyph = g.StarGlyph;
    var PlimsollGlyph = g.PlimsollGlyph;
    var OverlayLabelCanvas = g.OverlayLabelCanvas;

    var color = require('./color');
    var makeGradient = color.makeGradient;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;

    var das = require('./das');
    var DASFeature = das.DASFeature;
    var isDasBooleanTrue = das.isDasBooleanTrue;
    var isDasBooleanNotFalse = das.isDasBooleanNotFalse;

    var parseCigar = require('./cigar').parseCigar;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
}

var MIN_PADDING = 3;

function SubTier() {
    this.glyphs = [];
    this.height = 0;
    this.quant = null;
}

SubTier.prototype.indexFor = function(glyph) {
    var gmin = glyph.min();
    var lb = 0, ub = this.glyphs.length;
    while (ub > lb) {
        var mid = ((lb + ub)/2)|0;
        if (mid >= this.glyphs.length)
            return this.glyphs.length;
        var mg = this.glyphs[mid];
        if (gmin < mg.min()) {
            ub = mid;
        } else {
            lb = mid + 1;
        }
    }
    return ub;
}

SubTier.prototype.add = function(glyph) {
    var ind = this.indexFor(glyph);
    this.glyphs.splice(ind, 0, glyph);
    this.height = Math.max(this.height, glyph.height());
    if (glyph.quant && this.quant == null) {
        this.quant = glyph.quant;
    }
}

SubTier.prototype.hasSpaceFor = function(glyph) {
    var ind = this.indexFor(glyph);
    if (ind > 0 && this.glyphs[ind-1].max() >= glyph.min())
        return false;
    if (ind < this.glyphs.length && this.glyphs[ind].min() <= glyph.max())
        return false;

    return true;
}

var GLOBAL_GC;

function drawFeatureTier(tier)
{
    var start = Date.now()|0;
    GLOBAL_GC = tier.viewport.getContext('2d'); // Should only be used for metrics.
    sortFeatures(tier);
    if (typeof(tier.dasSource.padding) === 'number')
        tier.padding = tier.dasSource.padding;
    else
        tier.padding = MIN_PADDING;

    var glyphs = [];
    var specials = false;

    // group by style
    var gbsFeatures = {};
    var gbsStyles = {};

    for (var uft in tier.ungroupedFeatures) {
        var ufl = tier.ungroupedFeatures[uft];
        
        for (var pgid = 0; pgid < ufl.length; ++pgid) {
            var f = ufl[pgid];
            if (f.parts) {  // FIXME shouldn't really be needed
                continue;
            }

            var style = tier.styleForFeature(f);
            if (!style)
                continue;

            if (style.glyph == 'LINEPLOT') {
                pusho(gbsFeatures, style.id, f);
                gbsStyles[style.id] = style;
            } else {
                var g = glyphForFeature(f, 0, style, tier);
                if (g)
                    glyphs.push(g);
            }
        }
    }

    for (var gbs in gbsFeatures) {
        var gf = gbsFeatures[gbs];
        var style = gbsStyles[gbs];
        if (style.glyph == 'LINEPLOT') {
            glyphs.push(makeLineGlyph(gf, style, tier));
            specials = true;
        }
    }

    // Merge supergroups    

    if (tier.dasSource.collapseSuperGroups && !tier.bumped) {
        for (var sg in tier.superGroups) {
            var sgg = tier.superGroups[sg];
            tier.groups[sg] = shallowCopy(tier.groups[sg]);
            tier.groups[sg].isSuperGroup = true;
            var featsByType = {};

            var sgMin = 10000000000, sgMax = -10000000000;
            var sgSeg = null;
            for (var g = 0; g < sgg.length; ++g) {
                var gf = tier.groupedFeatures[sgg[g]];
                if (!gf)
                    continue;

                for (var fi = 0; fi < gf.length; ++fi) {
                    var f = gf[fi];
                    pusho(featsByType, f.type, f);
                    sgMin = Math.min(f.min, sgMin);
                    sgMax = Math.max(f.max, sgMax);
                    if (f.segment && !sgSeg)
                        sgSeg = f.segment;
                }

                if (tier.groups[sg] && !tier.groups[sg].links || tier.groups[sg].links.length == 0) {
                   tier.groups[sg].links = tier.groups[sgg[0]].links;
                }

                delete tier.groupedFeatures[sgg[g]];  // 'cos we don't want to render the unmerged version.
            }

            tier.groups[sg].max = sgMax;
            tier.groups[sg].min = sgMin;
            tier.groups[sg].segment = sgSeg;

            for (var t in featsByType) {
                var feats = featsByType[t];
                var template = feats[0];
                var loc = null;
                for (var fi = 0; fi < feats.length; ++fi) {
                    var f = feats[fi];
                    var fl = new Range(f.min, f.max);
                    if (!loc) {
                        loc = fl;
                    } else {
                        loc = union(loc, fl);
                    }
                }
                var mergedRanges = loc.ranges();
                for (var si = 0; si < mergedRanges.length; ++si) {
                    var r = mergedRanges[si];

                    // begin coverage-counting
                    var posCoverage = ((r.max()|0) - (r.min()|0) + 1) * sgg.length;
                    var actCoverage = 0;
                    for (var fi = 0; fi < feats.length; ++fi) {
                        var f = feats[fi];
                        if ((f.min|0) <= r.max() && (f.max|0) >= r.min()) {
                            var umin = Math.max(f.min|0, r.min());
                            var umax = Math.min(f.max|0, r.max());
                            actCoverage += (umax - umin + 1);
                        }
                    }
                    var visualWeight = ((1.0 * actCoverage) / posCoverage);
                    // end coverage-counting

                    var newf = new DASFeature();
                    for (var k in template) {
                        newf[k] = template[k];
                    }
                    newf.min = r.min();
                    newf.max = r.max();
                    if (newf.label && sgg.length > 1) {
                        newf.label += ' (' + sgg.length + ' vars)';
                    }
                    newf.visualWeight = ((1.0 * actCoverage) / posCoverage);
                    pusho(tier.groupedFeatures, sg, newf);
                    // supergroups are already in tier.groups.
                }
            }

            delete tier.superGroups[sg]; // Do we want this?
        }       
    }

    // Glyphify groups.

    var gl = new Array();
    for (var gid in tier.groupedFeatures) {
        gl.push(gid);
    }
    gl.sort(function(g1, g2) {
        var d = tier.groupedFeatures[g1][0].score - tier.groupedFeatures[g2][0].score;
        if (d > 0) {
            return -1;
        } else if (d == 0) {
            return 0;
        } else {
            return 1;
        }
    });

    var groupGlyphs = {};
    for (var gx = 0; gx < gl.length; ++gx) {
        var gid = gl[gx];
        var g = glyphsForGroup(tier.groupedFeatures[gid], 0, tier.groups[gid], tier,
                               (tier.dasSource.collapseSuperGroups && !tier.bumped) ? 'collapsed_gene' : 'tent');
        if (g) {
            g.group = tier.groups[gid];
            groupGlyphs[gid] = g;
        }
    }

    for (var sg in tier.superGroups) {
        var sgg = tier.superGroups[sg];
        var sgGlyphs = [];
        var sgMin = 10000000000;
        var sgMax = -10000000000;
        for (var sgi = 0; sgi < sgg.length; ++sgi) {
            var gg = groupGlyphs[sgg[sgi]];
            groupGlyphs[sgg[sgi]] = null;
            if (gg) {
                sgGlyphs.push(gg);
                sgMin = Math.min(sgMin, gg.min());
                sgMax = Math.max(sgMax, gg.max());
            }
        }
        for (var sgi = 0; sgi < sgGlyphs.length; ++sgi) {
            var gg = sgGlyphs[sgi];
            glyphs.push(new PaddedGlyph(gg, sgMin, sgMax));
        }
    }
    for (var g in groupGlyphs) {
        var gg = groupGlyphs[g];
        if (gg) {
            glyphs.push(gg);
        }
    }

    // Bumping

    var unbumpedST = new SubTier();
    var bumpedSTs = [];
    var hasBumpedFeatures = false;
    var subtierMax = tier.subtierMax || tier.dasSource.subtierMax || tier.browser.defaultSubtierMax;
    var subtiersExceeded = false;

  GLYPH_LOOP:
    for (var i = 0; i < glyphs.length; ++i) {
        var g = glyphs[i];
        if (g.bump) {
            hasBumpedFeatures = true;
        }
        if (g.bump && (tier.bumped || tier.dasSource.collapseSuperGroups)) {       // kind-of nasty.  supergroup collapsing is different from "normal" unbumping
            for (var sti = 0; sti < bumpedSTs.length;  ++sti) {
                var st = bumpedSTs[sti];
                if (st.hasSpaceFor(g)) {
                    st.add(g);
                    continue GLYPH_LOOP;
                }
            }
            if (bumpedSTs.length >= subtierMax) {
                subtiersExceeded = true;
            } else {
                var st = new SubTier();
                st.add(g);
                bumpedSTs.push(st);
            }
        } else {
            unbumpedST.add(g);
        }
    }

    if (unbumpedST.glyphs.length > 0) {
        bumpedSTs = [unbumpedST].concat(bumpedSTs);
    }

    for (var sti = 0; sti < bumpedSTs.length; ++sti) {
        var st = bumpedSTs[sti];
        if (st.quant) {
            st.glyphs.unshift(new GridGlyph(st.height));
        }
    }

    for (var sti = 0; sti < bumpedSTs.length; ++sti) {
        var st = bumpedSTs[sti];
        st.glyphs.sort(function (g1, g2) {
            var z1 = g1.zindex || 0;
            var z2 = g2.zindex || 0;
            return z1 - z2;
        });
    }

    tier.subtiers = bumpedSTs;
    tier.glyphCacheOrigin = tier.browser.viewStart;

    if (subtiersExceeded)
        tier.updateStatus('Bumping limit exceeded, use the track editor to see more features');
    else
        tier.updateStatus();
}

DasTier.prototype.paint = function() {
    var retina = this.browser.retina && window.devicePixelRatio > 1;

    var subtiers = this.subtiers;
    if (!subtiers) {
	   return;
    }

    var desiredWidth = this.browser.featurePanelWidth + 2000;
    if (retina) {
        desiredWidth *= 2;
    }
    var fpw = this.viewport.width|0;
    if (fpw < desiredWidth - 50) {
        this.viewport.width = fpw = desiredWidth;
    }

    var lh = this.padding;
    for (var s = 0; s < subtiers.length; ++s) {
        lh = lh + subtiers[s].height + this.padding;
    }
    lh += 6
    lh = Math.max(lh, this.browser.minTierHeight);

    var canvasHeight = lh;
    if (retina) {
        canvasHeight *= 2;
    }

    if (canvasHeight != this.viewport.height) {
        this.viewport.height = canvasHeight;
    }
    
    var tierHeight = Math.max(lh, this.browser.minTierHeight);
    this.viewportHolder.style.left = '-1000px';
    this.viewport.style.width = retina ? ('' + (fpw/2) + 'px') : ('' + fpw + 'px');
    this.viewport.style.height = '' + lh + 'px';
    this.layoutHeight =  Math.max(lh, this.browser.minTierHeight);

    this.updateHeight();
    this.norigin = this.browser.viewStart;

    var gc = this.viewport.getContext('2d');
    gc.clearRect(0, 0, fpw, canvasHeight);

    gc.save();
    if (retina) {
        gc.scale(2, 2);
    }

    /*
    if (this.background) {
        gc.fillStyle = this.background;

        if (this.knownCoverage) {
            var knownRanges = this.knownCoverage.ranges();
            for (var ri = 0; ri < knownRanges.length; ++ri) {
                var r = knownRanges[ri];
                var knownMin = (r.min() - this.browser.viewStart) * this.browser.scale + 1000;
                var knownMax = (r.max() - this.browser.viewStart) * this.browser.scale + 1000;
                gc.fillRect(knownMin, 0, knownMax - knownMin, lh);
            }
        }
    }*/

    var drawStart =  this.browser.viewStart - 1000.0/this.browser.scale;
    var drawEnd = this.browser.viewEnd + 1000.0/this.browser.scale;
    var unmappedBlocks = [];
    if (this.knownCoverage) {
        var knownRanges = this.knownCoverage.ranges();
        for (var ri = 0; ri < knownRanges.length; ++ri) {
            var r = knownRanges[ri];
            if (ri == 0) {
                if (r.min() > drawStart) 
                   unmappedBlocks.push({min: drawStart, max: r.min() - 1});
            } else {
                unmappedBlocks.push({min: knownRanges[ri-1].max() + 1, max: r.min() - 1});
            }

            if (ri == knownRanges.length - 1 && r.max() < drawEnd) {
                unmappedBlocks.push({min: r.max() + 1, max: drawEnd});
            } 
        }
    }
    if (unmappedBlocks.length > 0) {
        gc.fillStyle = 'gray';
        for (var i = 0; i < unmappedBlocks.length; ++i) {
            var b = unmappedBlocks[i];
            var min = (b.min - this.browser.viewStart) * this.browser.scale + 1000;
            var max = (b.max - this.browser.viewStart) * this.browser.scale + 1000;
            gc.fillRect(min, 0, max - min, lh);
        }
    }

    var oc = new OverlayLabelCanvas();
    var offset = ((this.glyphCacheOrigin - this.browser.viewStart)*this.browser.scale)+1000;
    gc.translate(offset, this.padding);
    oc.translate(0, this.padding);

    this.paintToContext(gc, oc, offset);

    if (oc.glyphs.length > 0)
        this.overlayLabelCanvas = oc;
    else
        this.overlayLabelCanvas = null;

    gc.restore();
    this.drawOverlay();
    this.paintQuant();
}

DasTier.prototype.paintToContext = function(gc, oc, offset) {
    var subtiers = this.subtiers;
    var fpw = this.viewport.width|0;

    gc.save();
    for (var s = 0; s < subtiers.length; ++s) {
        var quant = null;
        var glyphs = subtiers[s].glyphs;
        for (var i = 0; i < glyphs.length; ++i) {
            var glyph = glyphs[i];
            if (glyph.min() < fpw-offset && glyph.max() > -offset) { 
                var glyph = glyphs[i];
                glyph.draw(gc, oc);
                if (glyph.quant) {
                    quant = glyph.quant;
                }
            }
        }
        gc.translate(0, subtiers[s].height + this.padding);
        oc.translate(0, subtiers[s].height + this.padding);
    }
    gc.restore();

    if (quant && this.quantLeapThreshold && this.featureSource && this.browser.sourceAdapterIsCapable(this.featureSource, 'quantLeap')) {
        var ry = subtiers[0].height * (1.0 - ((this.quantLeapThreshold - quant.min) / (quant.max - quant.min)));

        gc.save();
        gc.strokeStyle = 'red';
        gc.lineWidth = 0.3;
        gc.beginPath();
        gc.moveTo(-1000, ry);
        gc.lineTo(fpw + 1000, ry);
        gc.stroke();
        gc.restore();
    }    
}

DasTier.prototype.paintQuant = function() {
    if (!this.quantOverlay)
        return;

    var retina = this.browser.retina && window.devicePixelRatio > 1;

    var quant;
    if (this.subtiers && this.subtiers.length > 0)
        quant = this.subtiers[0].quant;

    if (quant) {
        var h = this.subtiers[0].height;
        var w = 50;
        this.quantOverlay.height = this.viewport.height;
        this.quantOverlay.width = retina ? w*2 : w;
        this.quantOverlay.style.height = '' + (retina ? this.quantOverlay.height/2 : this.quantOverlay.height) + 'px';
        this.quantOverlay.style.width = '' + w + 'px';
        this.quantOverlay.style.display = 'block';
        var ctx = this.quantOverlay.getContext('2d');
        if (retina)
            ctx.scale(2, 2);

        var numTics = 2;
        if (h > 40) {
            numTics = 1 + ((h/20) | 0);
        }
        var ticSpacing = (h + this.padding*2) / (numTics - 1);
        var ticInterval = (quant.max - quant.min) / (numTics - 1);

        ctx.fillStyle = 'white'
        ctx.globalAlpha = 0.6;
        if (this.browser.rulerLocation == 'right') {
            ctx.fillRect(w-30, 0, 30, h + this.padding*2);
        } else {
            ctx.fillRect(0, 0, 30, h + this.padding*2);
        }
        ctx.globalAlpha = 1.0;

        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.beginPath();

        if (this.browser.rulerLocation == 'right') {
            ctx.moveTo(w - 8, this.padding);
            ctx.lineTo(w, this.padding);
            ctx.lineTo(w, h + this.padding);
            ctx.lineTo(w - 8, h + this.padding);
            for (var t = 1; t < numTics-1; ++t) {
                var ty = t*ticSpacing;
                ctx.moveTo(w, ty);
                ctx.lineTo(w - 5, ty);
            }
        } else {
            ctx.moveTo(8, this.padding);
            ctx.lineTo(0, this.padding);
            ctx.lineTo(0, h + this.padding);
            ctx.lineTo(8, h + this.padding);
            for (var t = 1; t < numTics-1; ++t) {
                var ty = t*ticSpacing;
                ctx.moveTo(0, ty);
                ctx.lineTo(5, ty);
            }
        }
        ctx.stroke();

        ctx.fillStyle = 'black';

        if (this.browser.rulerLocation == 'right') {
            ctx.textAlign = 'right';
            ctx.fillText(formatQuantLabel(quant.max), w-9, 8);
            ctx.fillText(formatQuantLabel(quant.min), w-9, h + this.padding);
            for (var t = 1; t < numTics-1; ++t) {
                var ty = t*ticSpacing;
                ctx.fillText(formatQuantLabel((1.0*quant.max) - (t*ticInterval)), w - 9, ty + 3);
            }
        } else {
            ctx.textAlign = 'left';
            ctx.fillText(formatQuantLabel(quant.max), 9, 8);
            ctx.fillText(formatQuantLabel(quant.min), 9, h + this.padding);
            for (var t = 1; t < numTics-1; ++t) {
                var ty = t*ticSpacing;
                ctx.fillText(formatQuantLabel((1.0*quant.max) - (t*ticInterval)), 9, ty + 3);
            }
        }
    } else {
        this.quantOverlay.style.display = 'none';
    }
}

function glyphsForGroup(features, y, groupElement, tier, connectorType) {
    var gstyle = tier.styleForFeature(groupElement);
    var label;
    var labelWanted = false;

    var glyphs = [];
    var strand = null;
    for (var i = 0; i < features.length; ++i) {
        var f = features[i];
        if (f.orientation && strand==null) {
            strand = f.orientation;
        }
         if (!label && f.label) {
            label = f.label;
        }

        var style = tier.styleForFeature(f);
        if (!style) {
            continue;
        }
        if (f.parts) {  // FIXME shouldn't really be needed
            continue;
        }
        if (isDasBooleanTrue(style.LABEL))
            labelWanted = true;

        var g = glyphForFeature(f, 0, style, tier, null, true);
        if (g) {
            glyphs.push(g);
        }
    }

    if (glyphs.length == 0)
        return null;
    
    var connector = 'flat';
    if (gstyle && gstyle.glyph === 'LINE') {
        // Stick with flat...
    } else {
        if (tier.dasSource.collapseSuperGroups && !tier.bumped) {
            if (strand === '+') {
                connector = 'collapsed+';
            } else if (strand === '-') {
                connector = 'collapsed-';
            }
        } else {
            if (strand === '+') {
                connector = 'hat+';
            } else if (strand === '-') {
                connector = 'hat-';
            }
        }
    }   

    var labelText = null;
    if ((label && labelWanted) || (gstyle && (isDasBooleanTrue(gstyle.LABEL) || isDasBooleanTrue(gstyle.LABELS)))) {  // HACK, LABELS should work.
        labelText = groupElement.label || label;
    }

    var gg = new GroupGlyph(glyphs, connector);
    if (labelText) {
        if (strand === '+') {
            labelText = '>' + labelText;
        } else if (strand === '-') {
            labelText = '<' + labelText;
        }
        gg = new LabelledGlyph(GLOBAL_GC, gg, labelText, false);
    }
    gg.bump = true;
    return gg;
}

function glyphForFeature(feature, y, style, tier, forceHeight, noLabel)
{
    function getRefSeq(tier, min, max) {
        var refSeq = null;
        if (tier.currentSequence) {
            var csStart = tier.currentSequence.start|0;
            var csEnd = tier.currentSequence.end|0;
            if (csStart <= max && csEnd >= min) {
                var sfMin = Math.max(min, csStart);
                var sfMax = Math.min(max, csEnd);

                refSeq = tier.currentSequence.seq.substr(sfMin - csStart, sfMax - sfMin + 1);
                while (min < sfMin) {
                    refSeq = 'N' + refSeq;
                    sfMin--;
                }
                while (max > sfMax) {
                    refSeq = refSeq + 'N';
                    sfMax++;
                }
            }
        }
        return refSeq;
    }

    var scale = tier.browser.scale, origin = tier.browser.viewStart;
    var gtype = style.glyph || 'BOX';
    var glyph;

    var min = feature.min;
    var max = feature.max;
    var type = feature.type;
    var strand = feature.orientation;
    var score = feature.score;
    var label = feature.label || feature.id;

    var minPos = (min - origin) * scale;
    var rawMaxPos = ((max - origin + 1) * scale);
    var maxPos = Math.max(rawMaxPos, minPos + 1);

    var height = tier.forceHeight || style.HEIGHT || forceHeight || 12;
    var requiredHeight = height = 1.0 * height;
    var bump = style.BUMP && isDasBooleanTrue(style.BUMP);

    var gg, quant;

    if (gtype === 'CROSS' || gtype === 'EX' || gtype === 'TRIANGLE' || gtype === 'DOT' || gtype === 'SQUARE' || gtype === 'STAR' || gtype === 'PLIMSOLL') {
        var stroke = style.FGCOLOR || 'black';
        var fill = style.BGCOLOR || 'none';
        var outline = style.STROKECOLOR;

        if (style.BGITEM && feature.itemRgb) {
            stroke = feature.itemRgb;
        } else if (isDasBooleanTrue(style.COLOR_BY_SCORE2)) {
            var grad = style.BGGRAD || style._gradient;
            if (!grad) {
                grad = makeGradient(50, style.COLOR1, style.COLOR2, style.COLOR3);
                style._gradient = grad;
            }

            var sc2 = feature.score2;
            if (sc2 != undefined || !stroke) {
                sc2 = sc2 || 0;

                var smin2 = style.MIN2 ? (1.0 * style.MIN2) : 0.0;
                var smax2 = style.MAX2 ? (1.0 * style.MAX2) : 1.0;
                var relScore2 = ((1.0 * sc2) - smin2) / (smax2-smin2);

                var step = (relScore2*grad.length)|0;
                if (step < 0) step = 0;
                if (step >= grad.length) step = grad.length - 1;
                stroke = grad[step];
            }
        }



        var height = tier.forceHeight || style.HEIGHT || forceHeight || 12;
        requiredHeight = height = 1.0 * height;

        var size = style.SIZE || height;
        if (style.RSIZE) {
            size = (1.0 * style.RSIZE) * height;
        }

        if (style.STROKETHRESHOLD) {
            if (size < (1.0 * style.STROKETHRESHOLD))
                outline = null;
        }
        
        size = 1.0 * size;

        var mid = (minPos + maxPos)/2;
        var hh = size/2;

        var mark;
        var bMinPos = minPos, bMaxPos = maxPos;

        if (gtype === 'EX') {
            gg = new ExGlyph(mid, size, stroke);
        } else if (gtype === 'TRIANGLE') {
            var dir = style.DIRECTION || 'N';
            var width = style.LINEWIDTH || size;
            gg = new TriangleGlyph(mid, size, dir, width, stroke, outline);
        } else if (gtype === 'DOT') {
            gg = new DotGlyph(mid, size, stroke, outline);
        } else if (gtype === 'PLIMSOLL') {
            gg = new PlimsollGlyph(mid, size, 0.2 * size, stroke, outline);
        } else if (gtype === 'SQUARE') {
            gg = new BoxGlyph(mid - hh, 0, size, size, stroke, outline);
        } else if (gtype === 'STAR') {
            var points = 5;
            if (style.POINTS) 
                points = style.POINTS | 0;
            gg = new StarGlyph(mid, hh, points, stroke, outline);
        } else {
            gg = new CrossGlyph(mid, size, stroke);
        }

        if (fill && fill != 'none' && (maxPos - minPos) > 5) {
            var bgg = new BoxGlyph(minPos, 0, (maxPos - minPos), size, fill);
            gg = new GroupGlyph([bgg, gg]);
        }

        if (isDasBooleanTrue(style.SCATTER)) {
            var smin = tier.quantMin(style);
            var smax = tier.quantMax(style);

            if (!smax) {
                if (smin < 0) {
                    smax = 0;
                } else {
                    smax = 10;
                }
            }
            if (!smin) {
                smin = 0;
            }

            var relScore = ((1.0 * score) - smin) / (smax-smin);
            var relOrigin = (-1.0 * smin) / (smax - smin);

            if (relScore < 0.0 || relScore > 1.0) {
                // Glyph is out of bounds.
                // Should we allow for "partially showing" glyphs?

                return null;
            } else {
                if (relScore >= relOrigin) {
                    height = Math.max(1, (relScore - relOrigin) * requiredHeight);
                    y = y + ((1.0 - relOrigin) * requiredHeight) - height;
                } else {
                    height = Math.max(1, (relScore - relOrigin) * requiredHeight);
                    y = y + ((1.0 - relOrigin) * requiredHeight);
                }
                
                quant = {min: smin, max: smax};

                var heightFudge = 0;
                var featureLabel;
                if (typeof(feature.forceLabel) !== 'undefined')
                    featureLabel = feature.forceLabel;
                else
                    featureLabel = style.LABEL;

                if (isDasBooleanNotFalse(featureLabel) && label && !noLabel) {
                    gg = new LabelledGlyph(GLOBAL_GC, gg, label, true, null, featureLabel == 'above' ? 'above' : 'below');
                    if (featureLabel == 'above') {
                        heightFudge = gg.textHeight + 2;
                    }
                    noLabel = true;
                }
                gg = new TranslatedGlyph(gg, 0, y - hh - heightFudge, requiredHeight);
            }
        }
    } else if (gtype === 'HISTOGRAM' || gtype === 'GRADIENT' && score !== 'undefined') {
        var smin = tier.quantMin(style);
        var smax = tier.quantMax(style);

        if (!smax) {
            if (smin < 0) {
                smax = 0;
            } else {
                smax = 10;
            }
        }
        if (!smin) {
            smin = 0;
        }

        if ((1.0 * score) < (1.0 *smin)) {
            score = smin;
        }
        if ((1.0 * score) > (1.0 * smax)) {
            score = smax;
        }
        var relScore = ((1.0 * score) - smin) / (smax-smin);
        var relOrigin = (-1.0 * smin) / (smax - smin);

        if (gtype === 'HISTOGRAM') {
            if (relScore >= relOrigin) {
                height = (relScore - Math.max(0, relOrigin)) * requiredHeight;
                y = y + ((1.0 - Math.max(0, relOrigin)) * requiredHeight) - height;
            } else {
                height = (Math.max(0, relOrigin) - relScore) * requiredHeight;
                y = y + ((1.0 - Math.max(0, relOrigin)) * requiredHeight);
            }
            quant = {min: smin, max: smax};
        }

        var stroke = style.FGCOLOR || null;
        var fill = style.BGCOLOR || style.COLOR1 || 'green';
        if (style.BGITEM && feature.itemRgb)
            fill = feature.itemRgb;
        var alpha = style.ALPHA ? (1.0 * style.ALPHA) : null;

        if (style.BGGRAD) {
            var grad = style.BGGRAD;
            var step = (relScore*grad.length)|0;
            if (step < 0) step = 0;
            if (step >= grad.length) step = grad.length - 1;
            fill = grad[step];
        }
        if (style.COLOR2) {
            var grad = style._gradient;
            if (!grad) {
                grad = makeGradient(50, style.COLOR1, style.COLOR2, style.COLOR3);
                style._gradient = grad;
            }

            var step = (relScore*grad.length)|0;
            if (step < 0) step = 0;
            if (step >= grad.length) step = grad.length - 1;
            fill = grad[step];
        }

        gg = new BoxGlyph(minPos, y, (maxPos - minPos), height, fill, stroke, alpha);
        gg = new TranslatedGlyph(gg, 0, 0, requiredHeight);
    } else if (gtype === 'HIDDEN') {
        gg = new PaddedGlyph(null, minPos, maxPos);
        noLabel = true;
    } else if (gtype === 'ARROW') {
        var color = style.FGCOLOR || 'purple';
        var parallel = isDasBooleanTrue(style.PARALLEL);
        var sw = isDasBooleanTrue(style.SOUTHWEST);
        var ne = isDasBooleanTrue(style.NORTHEAST);
        gg = new ArrowGlyph(minPos, maxPos, height, color, parallel, sw, ne);
    } else if (gtype === 'ANCHORED_ARROW') {
        var stroke = style.FGCOLOR || 'none';
        var fill = style.BGCOLOR || 'green';
        gg = new AArrowGlyph(minPos, maxPos, height, fill, stroke, strand);
        gg.bump = true;
    } else if (gtype === 'SPAN') {
        var stroke = style.FGCOLOR || 'black';
        gg = new SpanGlyph(minPos, maxPos, height, stroke);
    } else if (gtype === 'LINE') {
        var stroke = style.FGCOLOR || 'black';
        var lineStyle = style.STYLE || 'solid';
        gg = new LineGlyph(minPos, maxPos, height, lineStyle, strand, stroke);
    } else if (gtype === 'PRIMERS') {
        var stroke = style.FGCOLOR || 'black';
        var fill = style.BGCOLOR || 'red';
        gg = new PrimersGlyph(minPos, maxPos, height, fill, stroke);
    } else if (gtype === 'TEXT') {
        var string = style.STRING || 'text';
        var fill = style.FGCOLOR || 'black';
        gg = new TextGlyph(GLOBAL_GC, minPos, maxPos, height, fill, string);
    } else if (gtype === 'TOOMANY') {
        var stroke = style.FGCOLOR || 'gray';
        var fill = style.BGCOLOR || 'orange';
        gg = new TooManyGlyph(minPos, maxPos, height, fill, stroke);
    } else if (gtype === 'POINT') {
        var height = tier.forceHeight || style.HEIGHT || 30;
        var smin = tier.quantMin(style);
        var smax = tier.quantMax(style);
        var yscale = ((1.0 * height) / (smax - smin));
        var relScore = ((1.0 * score) - smin) / (smax-smin);
        var sc = ((score - (1.0*smin)) * yscale)|0;
        quant = {min: smin, max: smax};

        var fill = style.FGCOLOR || style.COLOR1 || 'black';
        if (style.COLOR2) {
            var grad = style._gradient;
            if (!grad) {
                grad = makeGradient(50, style.COLOR1, style.COLOR2, style.COLOR3);
                style._gradient = grad;
            }

            var step = (relScore*grad.length)|0;
            if (step < 0) step = 0;
            if (step >= grad.length) step = grad.length - 1;
            fill = grad[step];
        } 

        gg = new PointGlyph((minPos + maxPos)/2, height-sc, height, fill);
    } else if (gtype === '__SEQUENCE') {
        var rawseq = feature.seq;
        var seq = rawseq;
        var rawquals = feature.quals;
        var quals = rawquals;
        var insertionLabels = isDasBooleanTrue(style.__INSERTIONS);

        var indels = [];
        if (feature.cigar) {
            var ops = parseCigar(feature.cigar);
            seq = ''
            quals = '';
            var cursor = 0;
            for (var ci = 0; ci < ops.length; ++ci) {
                var co = ops[ci];
                if (co.op == 'M') {
                    seq += rawseq.substr(cursor, co.cnt);
                    quals += rawquals.substr(cursor, co.cnt);
                    cursor += co.cnt;
                } else if (co.op == 'D') {
                    for (var oi = 0; oi < co.cnt; ++oi) {
                        seq += '-';
                        quals += 'Z';
                    }
                } else if (co.op == 'I') {
                    var inseq =  rawseq.substr(cursor, co.cnt);
                    var ig = new TriangleGlyph(minPos + (seq.length*scale), 5, 'S', 5, tier.browser.baseColors['I']);
                    if (insertionLabels)
                        ig = new LabelledGlyph(GLOBAL_GC, ig, inseq, false, 'center', 'above', '7px sans-serif');
                    ig.feature = {label: 'Insertion: ' + inseq, type: 'insertion', method: 'insertion'};
                    indels.push(ig);

                    cursor += co.cnt;
                } else if (co.op == 'S') {
                    cursor += co.cnt;
                } else {
                    console.log('unknown cigop' + co.op);
                }
            }
        }

        var refSeq = getRefSeq(tier, min, max);
        if (seq && refSeq && (style.__SEQCOLOR === 'mismatch' || style.__SEQCOLOR === 'mismatch-all')) {
            var mismatchSeq = [];
            var match = feature.orientation === '-' ? ',' : '.';
            for (var i = 0; i < seq.length; ++i)
                mismatchSeq.push(seq[i] == refSeq[i] ? match : seq[i]);
            seq = mismatchSeq.join('');
        }

        var strandColor;
        if (feature.orientation === '-')
            strandColor = style._minusColor || 'lightskyblue';
        else
            strandColor = style._plusColor || 'lightsalmon';

        if (style.__disableQuals)
            quals = false;
        
        gg = new SequenceGlyph(
            tier.browser.baseColors, 
            strandColor, 
            minPos, 
            maxPos, 
            height, 
            seq, 
            refSeq, 
            style.__SEQCOLOR, 
            quals,
            !isDasBooleanTrue(style.__CLEARBG)
        );
        if (insertionLabels)
            gg = new TranslatedGlyph(gg, 0, 7);
        if (indels.length > 0) {
            indels.splice(0, 0, gg);
            gg = new GroupGlyph(indels);
        }
    } else if (gtype === '__INSERTION') {
        var ig = new TriangleGlyph(minPos, 5, 'S', 5, tier.browser.baseColors['I']);
        gg = new LabelledGlyph(GLOBAL_GC, ig, feature.insertion || feature.altAlleles[0], false, 'center', 'above', '7px sans-serif');
        if ((maxPos - minPos) > 1) {
            var fill = style.BGCOLOR || style.COLOR1 || 'green';
            var bg = new BoxGlyph(minPos, 5, (maxPos - minPos), height, fill, stroke);
            gg = new GroupGlyph([bg, gg]);
        }
    } else if (gtype === '__NONE') {
        return null;
    } else /* default to BOX */ {
        var stroke = style.FGCOLOR || null;
        var fill = style.BGCOLOR || style.COLOR1 || 'green';
        if (style.BGITEM && feature.itemRgb)
            fill = feature.itemRgb;
        var scale = (maxPos - minPos) / (max - min);
        if (feature.type == 'translation' &&
            (feature.method == 'protein_coding' || feature.readframeExplicit) &&
            (!feature.tags || feature.tags.indexOf('cds_start_NF') < 0 || feature.readframeExplicit) &&
            (!tier.dasSource.collapseSuperGroups || tier.bumped)
            && scale >= 0.5) {
            var refSeq = getRefSeq(tier, min, max);
            gg = new AminoAcidGlyph(minPos, maxPos, height, fill, refSeq, feature.orientation, feature.readframe);    
        } else {
            gg = new BoxGlyph(minPos, 0, (maxPos - minPos), height, fill, stroke);
        }
        // gg.bump = true;
    }

    if ((isDasBooleanTrue(style.LABEL) || feature.forceLabel) && label && !noLabel) {
        gg = new LabelledGlyph(GLOBAL_GC, gg, label, false);
    }

    if (bump) {
        gg.bump = true;
    }

    gg.feature = feature;
    if (quant) {
        gg.quant = quant;
    }

    if (style.ZINDEX) {
        gg.zindex = style.ZINDEX | 0;
    }

    return gg;
}

DasTier.prototype.styleForFeature = function(f) {
    var ssScale = this.browser.zoomForCurrentScale();

    if (!this.stylesheet) {
        return null;
    }

    var maybe = null;
    var ss = this.stylesheet.styles;
    for (var si = 0; si < ss.length; ++si) {
        var sh = ss[si];
        if (sh.zoom && sh.zoom != ssScale) {
            continue;
        }

        if (sh.orientation) {
            if (sh.orientation != f.orientation) {
                continue;
            }
        }

        var labelRE = sh._labelRE;
        if (!labelRE || !labelRE.test) {
            labelRE = new RegExp('^' + sh.label + '$');
            sh._labelRE = labelRE;
        }
        if (sh.label && !(labelRE.test(f.label))) {
            continue;
        }
        var methodRE = sh._methodRE;
        if (!methodRE || !methodRE.test) {
            methodRE = new RegExp('^' + sh.method + '$');
            sh._methodRE = methodRE;
        }
        if (sh.method && !(methodRE.test(f.method))) {
            continue;
        }
        if (sh.type) {
            if (sh.type == 'default') {
                if (!maybe) {
                    maybe = sh.style;
                }
                continue;
            } else {
                var typeRE = sh._typeRE;
                if (!typeRE || !typeRE.test) {
                    typeRE = new RegExp('^' + sh.type + '$');
                    sh._typeRE = typeRE;
                }
                if (!typeRE.test(f.type)) 
                    continue;
            }
        }
        return sh.style;
    }
    return maybe;
}

function makeLineGlyph(features, style, tier) {
    var origin = tier.browser.viewStart, scale = tier.browser.scale;
    var height = tier.forceHeight || style.HEIGHT || 30;
    var min = tier.quantMin(style);
    var max = tier.quantMax(style);
    var yscale = ((1.0 * height) / (max - min));
    var width = style.LINEWIDTH || 1;
    var color = style.FGCOLOR || style.COLOR1 || 'black';

    var points = [];
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];

        var px = ((((f.min|0) + (f.max|0)) / 2) - origin) * scale;
        var sc = ((f.score - (1.0*min)) * yscale)|0;
        var py = (height - sc);  // FIXME y???
        points.push(px);
        points.push(py);
    }
    var lgg = new LineGraphGlyph(points, color, height);
    lgg.quant = {min: min, max: max};

    if (style.ZINDEX) 
        lgg.zindex = style.ZINDEX|0;

    return lgg;
}

DasTier.prototype.quantMin = function(style) {
    if (this.forceMinDynamic) {
        return this.currentFeaturesMinScore || 0;
    } else if (typeof(this.forceMin) === 'number') {
        return this.forceMin;
    } else {
        return style.MIN || this.currentFeaturesMinScore || 0;
    }
}

DasTier.prototype.quantMax = function(style) {
    if (this.forceMaxDynamic) {
        return this.currentFeaturesMaxScore || 0;
    } else if (typeof(this.forceMax) === 'number') {
        return this.forceMax;
    } else {
        return style.MAX || this.currentFeaturesMaxScore || 0;
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        drawFeatureTier: drawFeatureTier
    };
}

},{"./cigar":8,"./color":9,"./das":10,"./features":20,"./glyphs":21,"./numformats":26,"./spans":36,"./tier":45,"./utils":49}],19:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// feature-popup.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var pick = utils.pick;
    var pushnew = utils.pushnew;
    var makeElement = utils.makeElement;
}


var TAGVAL_NOTE_RE = new RegExp('^([A-Za-z_-]+)=(.+)');

Browser.prototype.addFeatureInfoPlugin = function(handler) {
    if (!this.featureInfoPlugins) {
        this.featureInfoPlugins = [];
    }
    this.featureInfoPlugins.push(handler);
}

function FeatureInfo(hit, feature, group) {
    var name = pick(group.type, feature.type);
    var fid = pick(group.label, feature.label, group.id, feature.id);
    if (fid && fid.indexOf('__dazzle') != 0) {
        name = name + ': ' + fid;
    }

    this.hit = hit;
    this.feature = feature;
    this.group = group;
    this.title = name;
    this.sections = [];
}

FeatureInfo.prototype.setTitle = function(t) {
    this.title = t;
}

FeatureInfo.prototype.add = function(label, info) {
    if (typeof info === 'string') {
        info = makeElement('span', info);
    }
    this.sections.push({label: label, info: info});
}

Browser.prototype.featurePopup = function(ev, __ignored_feature, hit, tier) {
    var hi = hit.length;
    var feature = --hi >= 0 ? hit[hi] : {};
    var group = --hi >= 0 ? hit[hi] : {};

    var featureInfo = new FeatureInfo(hit, feature, group);
    featureInfo.tier = tier;
    var fips = this.featureInfoPlugins || [];
    for (var fipi = 0; fipi < fips.length; ++fipi) {
        try {
            fips[fipi](feature, featureInfo);
        } catch (e) {
            console.log(e.stack || e);
        }
    }
    fips = tier.featureInfoPlugins || [];
    for (fipi = 0; fipi < fips.length; ++fipi) {
        try {
            fips[fipi](feature, featureInfo);
        } catch (e) {
            console.log(e.stack || e);
        }
    }

    this.removeAllPopups();

    var table = makeElement('table', null, {className: 'table table-striped table-condensed'});
    table.style.width = '100%';
    table.style.margin = '0px';

    var idx = 0;
    if (feature.method) {
        var row = makeElement('tr', [
            makeElement('th', 'Method'),
            makeElement('td', feature.method)
        ]);
        table.appendChild(row);
        ++idx;
    }
    {
        var loc;
        if (group.segment) {
            loc = group;
        } else {
            loc = feature;
        }
        var row = makeElement('tr', [
            makeElement('th', 'Location'),
            makeElement('td', loc.segment + ':' + loc.min + '-' + loc.max, {}, {minWidth: '200px'})
        ]);
        table.appendChild(row);
        ++idx;
    }
    if (feature.score !== undefined && feature.score !== null && feature.score != '-'
        && !feature.suppressScore) {
        var row = makeElement('tr', [
            makeElement('th', 'Score'),
            makeElement('td', '' + feature.score)
        ]);
        table.appendChild(row);
        ++idx;
    }
    {
        var links = maybeConcat(group.links, feature.links);
        if (links && links.length > 0) {
            var row = makeElement('tr', [
                makeElement('th', 'Links'),
                makeElement('td', links.map(function(l) {
                    return makeElement('div', makeElement('a', l.desc, {href: l.uri, target: '_new'}));
                }))
            ]);
            table.appendChild(row);
            ++idx;
        }
    }
    {
        var notes = maybeConcat(group.notes, feature.notes);
        for (var ni = 0; ni < notes.length; ++ni) {
            var k = 'Note';
            var v = notes[ni];
            var m = v.match(TAGVAL_NOTE_RE);
            if (m) {
                k = m[1];
                v = m[2];
            }

            var row = makeElement('tr', [
                makeElement('th', k),
                makeElement('td', v)
            ]);
            table.appendChild(row);
            ++idx;
        }
    }

    for (var fisi = 0; fisi < featureInfo.sections.length; ++fisi) {
        var section = featureInfo.sections[fisi];
        table.appendChild(makeElement('tr', [
            makeElement('th', section.label),
            makeElement('td', section.info)]));
    }        

    this.popit(ev, featureInfo.title || 'Feature', table, {width: 450});
}

function maybeConcat(a, b) {
    var l = [];
    if (a) {
        for (var i = 0; i < a.length; ++i) {
            pushnew(l, a[i]);
        }
    }
    if (b) {
        for (var i = 0; i < b.length; ++i) {
            pushnew(l, b[i]);
        }
    }
    return l;
}

},{"./cbrowser":6,"./utils":49}],20:[function(require,module,exports){
"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var pusho = utils.pusho;
    var pushnewo = utils.pushnewo;
}

function sortFeatures(tier)
{
    var dmin = tier.browser.drawnStart, dmax = tier.browser.drawnEnd;
    var ungroupedFeatures = {};
    var groupedFeatures = {};
    var drawnGroupedFeatures = {};
    var groupMins = {}, groupMaxes = {};
    var groups = {};
    var superGroups = {};
    var groupsToSupers = {};
    var nonPositional = [];
    var minScore, maxScore;
    var fbid;

    var init_fbid = function() {
        fbid = {};
        for (var fi = 0; fi < tier.currentFeatures.length; ++fi) {
            var f = tier.currentFeatures[fi];
            if (f.id) {
                fbid[f.id] = f;
            }
        }
    };
    
    var superParentsOf = function(f) {
        // FIXME: should recur.
        var spids = [];
        if (f.parents) {
            for (var pi = 0; pi < f.parents.length; ++pi) {
                var pid = f.parents[pi];
                var p = fbid[pid];
                if (!p) {
                    continue;
                }
                // alert(p.type + ':' + p.typeCv);
                if (p.typeCv == 'SO:0000704') {
                    pushnew(spids, pid);
                }
            }
        }
        return spids;
    }

    for (var fi = 0; fi < tier.currentFeatures.length; ++fi) {
        var f = tier.currentFeatures[fi];
        if (f.parts) {
            continue;
        }

        var drawn = f.min <= dmax && f.max >= dmin;

        if (!f.min || !f.max) {
            nonPositional.push(f);
            continue;
        }

        if (f.score && f.score != '.' && f.score != '-') {
            var sc = 1.0 * f.score;
            if (!minScore || sc < minScore) {
                minScore = sc;
            }
            if (!maxScore || sc > maxScore) {
                maxScore = sc;
            }
        }

        var fGroups = [];
        var fSuperGroup = null;
        if (f.groups) {
            for (var gi = 0; gi < f.groups.length; ++gi) {
                var g = f.groups[gi];
                var gid = g.id;
                if (g.type == 'gene') {
                    // Like a super-grouper...
                    fSuperGroup = gid; 
                    groups[gid] = g;
                } else if (g.type == 'translation') {
                    // have to ignore this to get sensible results from bj-e :-(.
                } else {
                    pusho(groupedFeatures, gid, f);
                    groups[gid] = g;
                    fGroups.push(gid);

                    var ogm = groupMins[gid];
                    if (!ogm || f.min < ogm)
                        groupMins[gid] = f.min;

                    ogm = groupMaxes[gid];
                    if (!ogm || f.max > ogm)
                        groupMaxes[gid] = f.max;
                }
            }
        }

        if (f.parents) {
            if (!fbid) {
                init_fbid();
            }
            for (var pi = 0; pi < f.parents.length; ++pi) {
                var pid = f.parents[pi];
                var p = fbid[pid];
                if (!p) {
                    // alert("couldn't find " + pid);
                    continue;
                }
                if (!p.parts) {
                    p.parts = [f];
                }
                pushnewo(groupedFeatures, pid, p);
                pusho(groupedFeatures, pid, f);
                
                if (!groups[pid]) {
                    groups[pid] = {
                        type: p.type,
                        id: p.id,
                        label: p.label || p.id
                    };
                }
                fGroups.push(pid);

                var ogm = groupMins[pid];
                if (!ogm || f.min < ogm)
                    groupMins[pid] = f.min;

                ogm = groupMaxes[pid];
                if (!ogm || f.max > ogm)
                    groupMaxes[pid] = f.max;

                var sgs = superParentsOf(p);
                if (sgs.length > 0) {
                    fSuperGroup = sgs[0];
                    var sp = fbid[sgs[0]];
                    groups[sgs[0]] = {
                        type: sp.type,
                        id: sp.id,
                        label: sp.label || sp.id
                    };
                    if (!tier.dasSource.collapseSuperGroups) {
                        tier.dasSource.collapseSuperGroups = true;
                    }
                }
            }   
        }

        if (fGroups.length == 0) {
            if (drawn)
                pusho(ungroupedFeatures, f.type, f);
        } else if (fSuperGroup) {
            for (var g = 0; g < fGroups.length; ++g) {
                var gid = fGroups[g];
                pushnewo(superGroups, fSuperGroup, gid);
                groupsToSupers[gid] = fSuperGroup;
            } 
        }       
    }

    for (var gid in groupedFeatures) {
        var group = groups[gid];
        if (typeof(group.min) !== 'number') 
            group.min = groupMins[gid];
        if (typeof(group.max) !== 'number') 
            group.max = groupMaxes[gid];

        if (groupMaxes[gid] >= dmin && groupMins[gid] <= dmax)
            drawnGroupedFeatures[gid] = groupedFeatures[gid];
    }

    tier.ungroupedFeatures = ungroupedFeatures;
    tier.groupedFeatures = drawnGroupedFeatures;
    tier.groups = groups;
    tier.superGroups = superGroups;
    tier.groupsToSupers = groupsToSupers;

    if (minScore) {
        if (minScore > 0) {
            minScore = 0;
        } else if (maxScore < 0) {
            maxScore = 0;
        }
        tier.currentFeaturesMinScore = minScore;
        tier.currentFeaturesMaxScore = maxScore;
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        sortFeatures: sortFeatures
    };
}

},{"./utils":49}],21:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// glyphs.js: components which know how to draw themselves
//

"use strict";

if (typeof(require) !== 'undefined') {
    var spans = require('./spans');
    var union = spans.union;
    var Range = spans.Range;

    var utils = require('./utils');
    var makeElementNS = utils.makeElementNS;
    var AMINO_ACID_TRANSLATION = utils.AMINO_ACID_TRANSLATION;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;
}

function PathGlyphBase(stroke, fill) {
    this._stroke = stroke;
    this._fill = fill;
}

PathGlyphBase.prototype.draw = function(g) {
    g.beginPath();
    this.drawPath(g);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }
    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
}

PathGlyphBase.prototype.toSVG = function() {
    var g = new SVGPath();
    this.drawPath(g);
    
    return makeElementNS(
        NS_SVG, 'path',
        null,
        {d: g.toPathData(),
         fill: this._fill || 'none',
         stroke: this._stroke || 'none'});
}

PathGlyphBase.prototype.drawPath = function(g) {
    throw 'drawPath method on PathGlyphBase must be overridden';
}

function BoxGlyph(x, y, width, height, fill, stroke, alpha, radius) {
    this.x = x;
    this.y = y;
    this._width = width;
    this._height = height;
    this.fill = fill;
    this.stroke = stroke;
    this._alpha = alpha;
    this._radius = radius || 0;
}

BoxGlyph.prototype.draw = function(g) {
    var r = this._radius;

    if (r > 0) {
        g.beginPath();
        g.moveTo(this.x + r, this.y);
        g.lineTo(this.x + this._width - r, this.y);
        g.arcTo(this.x + this._width, this.y, this.x + this._width, this.y + r, r);
        g.lineTo(this.x + this._width, this.y + this._height - r);
        g.arcTo(this.x + this._width, this.y + this._height, this.x + this._width - r, this.y + this._height, r);
        g.lineTo(this.x + r, this.y + this._height);
        g.arcTo(this.x, this.y + this._height, this.x, this.y + this._height - r, r);
        g.lineTo(this.x, this.y + r);
        g.arcTo(this.x, this.y, this.x + r, this.y, r);
        g.closePath();

        if (this._alpha != null) {
            g.save();
            g.globalAlpha = this._alpha;
        }
        
        if (this.fill) {
            g.fillStyle = this.fill;
            g.fill();
        }
        if (this.stroke) {
            g.strokeStyle = this.stroke;
            g.lineWidth = 0.5;
            g.stroke();
        }

        if (this._alpha != null) {
            g.restore();
        }
    } else {
        if (this._alpha != null) {
            g.save();
            g.globalAlpha = this._alpha;
        }

        if (this.fill) {
            g.fillStyle = this.fill;
            g.fillRect(this.x, this.y, this._width, this._height);
        }

        if (this.stroke) {
            g.strokeStyle = this.stroke;
            g.lineWidth = 0.5;
            g.strokeRect(this.x, this.y, this._width, this._height)
        }

        if (this._alpha != null) {
            g.restore();
        }
    }
}

BoxGlyph.prototype.toSVG = function() {
    var s = makeElementNS(NS_SVG, 'rect', null,
                         {x: this.x, 
                          y: this.y, 
                          width: this._width, 
                          height: this._height,
                          stroke: this.stroke || 'none',
                          strokeWidth: 0.5,
                          fill: this.fill || 'none'});
    if (this._alpha != null) {
        s.setAttribute('opacity', this._alpha);
    }

    return s;
}

BoxGlyph.prototype.min = function() {
    return this.x;
}

BoxGlyph.prototype.max = function() {
    return this.x + this._width;
}

BoxGlyph.prototype.height = function() {
    return this.y + this._height;
}


function GroupGlyph(glyphs, connector) {
    this.glyphs = glyphs;
    this.connector = connector;
    this.h = glyphs[0].height();

    var covList = [];
    for (var g = 0; g < glyphs.length; ++g) {
        var gg = glyphs[g];
        covList.push(new Range(gg.min(), gg.max()));
        this.h = Math.max(this.h, gg.height());
    }
    this.coverage = union(covList);
}

GroupGlyph.prototype.drawConnectors = function(g) {
    var ranges = this.coverage.ranges();
    for (var r = 1; r < ranges.length; ++r) {
        var gl = ranges[r];
        var last = ranges[r - 1];
        if (last && gl.min() > last.max()) {
            var start = last.max();
            var end = gl.min();
            var mid = (start+end)/2
            
            if (this.connector === 'hat+') {
                g.moveTo(start, this.h/2);
                g.lineTo(mid, 0);
                g.lineTo(end, this.h/2);
            } else if (this.connector === 'hat-') {
                g.moveTo(start, this.h/2);
                g.lineTo(mid, this.h);
                g.lineTo(end, this.h/2);
            } else if (this.connector === 'collapsed+') {
                g.moveTo(start, this.h/2);
                g.lineTo(end, this.h/2);
                if (end - start > 4) {
                    g.moveTo(mid - 2, (this.h/2) - 3);
                    g.lineTo(mid + 2, this.h/2);
                    g.lineTo(mid - 2, (this.h/2) + 3);
                }
            } else if (this.connector === 'collapsed-') {
                g.moveTo(start, this.h/2);
                g.lineTo(end, this.h/2);
                if (end - start > 4) {
                    g.moveTo(mid + 2, (this.h/2) - 3);
                    g.lineTo(mid - 2, this.h/2);
                    g.lineTo(mid + 2, (this.h/2) + 3);
                }
            } else {
                g.moveTo(start, this.h/2);
                g.lineTo(end, this.h/2);
            }
        }
        last = gl;
    }
}

GroupGlyph.prototype.draw = function(g, oc) {
    for (var i = 0; i < this.glyphs.length; ++i) {
        var gl = this.glyphs[i];
        gl.draw(g, oc);
    }

    g.strokeStyle = 'black';
    g.beginPath();
    this.drawConnectors(g);
    g.stroke();
}

GroupGlyph.prototype.toSVG = function() {
    var g = makeElementNS(NS_SVG, 'g');
    for (var i = 0; i < this.glyphs.length; ++i) {
        g.appendChild(this.glyphs[i].toSVG());
    }

    var p = new SVGPath();
    this.drawConnectors(p);

    var pathData = p.toPathData();
    if (pathData.length > 0) {
        var path = makeElementNS(
            NS_SVG, 'path',
            null,
            {d: p.toPathData(),
             fill: 'none',
             stroke: 'black',
             strokeWidth: 0.5});
        g.appendChild(path);
    }

    return g;
}

GroupGlyph.prototype.min = function() {
    return this.coverage.min();
}

GroupGlyph.prototype.max = function() {
    return this.coverage.max();
}

GroupGlyph.prototype.height = function() {
    return this.h;
}


function LineGraphGlyph(points, color, height) {
    this.points = points;
    this.color = color;
    this._height = height || 50;
}

LineGraphGlyph.prototype.min = function() {
    return this.points[0];
};

LineGraphGlyph.prototype.max = function() {
    return this.points[this.points.length - 2];
};

LineGraphGlyph.prototype.height = function() {
    return this._height;
}

LineGraphGlyph.prototype.draw = function(g) {
    g.save();
    g.strokeStyle = this.color;
    g.lineWidth = 2;
    g.beginPath();
    for (var i = 0; i < this.points.length; i += 2) {
        var x = this.points[i];
        var y = this.points[i + 1];
        if (i == 0) {
            g.moveTo(x, y);
        } else {
            g.lineTo(x, y);
        }
    }
    g.stroke();
    g.restore();
}

LineGraphGlyph.prototype.toSVG = function() {
    var p = new SVGPath();
    for (var i = 0; i < this.points.length; i += 2) {
        var x = this.points[i];
        var y = this.points[i + 1];
        if (i == 0) {
            p.moveTo(x, y);
        } else {
            p.lineTo(x, y);
        }
    }
    
    return makeElementNS(
        NS_SVG, 'path',
        null,
        {d: p.toPathData(),
         fill: 'none',
         stroke: this.color,
         strokeWidth: '2px'});
}

function LabelledGlyph(GLOBAL_GC, glyph, text, unmeasured, anchor, align, font) {
    this.glyph = glyph;
    this.text = text;
    this.anchor = anchor || 'left';
    this.align = align || 'below';
    if (font) {
        this.font = font;
    }
    if (this.font) {
        GLOBAL_GC.save();
        GLOBAL_GC.font = this.font;
    }
    var metrics = GLOBAL_GC.measureText(text);
    if (this.font) {
        GLOBAL_GC.restore();
    }
    this.textLen = metrics.width;
    this.textHeight = 5;
    this.bump = glyph.bump;
    this.measured = !unmeasured;
}

LabelledGlyph.prototype.toSVG = function() {
    var child = this.glyph.toSVG();
    var opts = {};
    
    if (this.align == 'above') {
        child = makeElementNS(NS_SVG, 'g', child, {transform: "translate(0, " + (this.textHeight|0 + 2) + ")"});
        opts.y = this.textHeight;
    } else {
        opts.y = this.glyph.height() + 15;
    }

    if (this.font) {
        opts.fontSize  = 7;
    }

    if ('center' == this.anchor) {
        opts.x = (this.glyph.min() + this.glyph.max() - this.textLen) / 2;
    } else {
        opts.x = this.glyph.min();
    }

    return makeElementNS(NS_SVG, 'g',
        [child,
         makeElementNS(NS_SVG, 'text', this.text, opts)]);
}

LabelledGlyph.prototype.min = function() {
    return this.glyph.min();
}

LabelledGlyph.prototype.max = function() {
    if (this.measured)
        return Math.max(this.glyph.max(), (1.0*this.glyph.min()) + this.textLen + 10);
    else
        return this.glyph.max();
}

LabelledGlyph.prototype.height = function() {
    var h = this.glyph.height();
    if (this.measured) {
        if (this.align == 'above') {
            h += this.textHeight + 2;
        } else {
            h += 20;
        }
    }
    return h;
}

LabelledGlyph.prototype.draw = function(g, oc) {
    if (this.align == 'above') {
        g.save();
        g.translate(0, this.textHeight + 2);
    }
    this.glyph.draw(g);
    if (this.align == 'above') {
        g.restore();
    }

    oc.registerGlyph(this);
}

LabelledGlyph.prototype.drawOverlay = function(g, minVisible, maxVisible) {
    g.fillStyle = 'black';
    if (this.font) {
        g.save();
        g.font = this.font;
    }
    var p;
    if ('center' == this.anchor) {
        p = (this.glyph.min() + this.glyph.max() - this.textLen) / 2;
    } else {
        p = this.glyph.min();
        if (p < minVisible) {
            p = Math.min(minVisible, this.glyph.max() - this.textLen);
        }
    }
    g.fillText(this.text, p, this.align == 'above' ? this.textHeight : this.glyph.height() + 15);
    if (this.font) {
        g.restore();
    }
}



function CrossGlyph(x, height, stroke) {
    this._x = x;
    this._height = height;
    this._stroke = stroke;
}

CrossGlyph.prototype.draw = function(g) {
    var hh = this._height/2;
    
    g.beginPath();
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);
    g.moveTo(this._x - hh, hh);
    g.lineTo(this._x + hh, hh);

    g.strokeStyle = this._stroke;
    g.lineWidth = 1;

    g.stroke();
}

CrossGlyph.prototype.toSVG = function() {
    var hh = this._height/2;

    var g = new SVGPath();
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);
    g.moveTo(this._x - hh, hh);
    g.lineTo(this._x + hh, hh);
    
    return makeElementNS(
        NS_SVG, 'path',
        null,
        {d: g.toPathData(),
         fill: 'none',
         stroke: this._stroke,
         strokeWidth: '1px'});
}

CrossGlyph.prototype.min = function() {
    return this._x - this._height/2;
}

CrossGlyph.prototype.max = function() {
    return this._x + this._height/2;
}

CrossGlyph.prototype.height = function() {
    return this._height;
}

function ExGlyph(x, height, stroke) {
    this._x = x;
    this._height = height;
    this._stroke = stroke;
}

ExGlyph.prototype.draw = function(g) {
    var hh = this._height/2;
    
    g.beginPath();
    g.moveTo(this._x - hh, 0);
    g.lineTo(this._x + hh, this._height);
    g.moveTo(this._x - hh, this._height);
    g.lineTo(this._x + hh, 0);

    g.strokeStyle = this._stroke;
    g.lineWidth = 1;

    g.stroke();
}

ExGlyph.prototype.toSVG = function() {
    var hh = this._height/2;

    var g = new SVGPath();
    g.moveTo(this._x - hh, 0);
    g.lineTo(this._x + hh, this._height);
    g.moveTo(this._x - hh, this._height);
    g.lineTo(this._x + hh, 0);
    
    return makeElementNS(
        NS_SVG, 'path',
        null,
        {d: g.toPathData(),
         fill: 'none',
         stroke: this._stroke,
         strokeWidth: '1px'});
}

ExGlyph.prototype.min = function() {
    return this._x - this._height/2;
}

ExGlyph.prototype.max = function() {
    return this._x + this._height/2;
}

ExGlyph.prototype.height = function() {
    return this._height;
}



function TriangleGlyph(x, height, dir, width, fill, stroke) {
    PathGlyphBase.call(this, stroke, fill);

    this._x = x;
    this._height = height;
    this._dir = dir;
    this._width = width;
}

TriangleGlyph.prototype = Object.create(PathGlyphBase.prototype);

TriangleGlyph.prototype.drawPath = function(g) {
    var hh = this._height/2;
    var hw = this._width/2;

    if (this._dir === 'S') {
        g.moveTo(this._x, this._height);
        g.lineTo(this._x - hw, 0);
        g.lineTo(this._x + hw, 0);
    } else if (this._dir === 'W') {
        g.moveTo(this._x + hw, hh);
        g.lineTo(this._x - hw, 0);
        g.lineTo(this._x - hw, this._height);
    } else if (this._dir === 'E') {
        g.moveTo(this._x - hw, hh);
        g.lineTo(this._x + hw, 0);
        g.lineTo(this._x + hw, this._height);
    } else {
        g.moveTo(this._x , 0);
        g.lineTo(this._x + hw, this._height);
        g.lineTo(this._x - hw, this._height);
    }

    g.closePath();
}

TriangleGlyph.prototype.min = function() {
    return this._x - this._height/2;
}

TriangleGlyph.prototype.max = function() {
    return this._x + this._height/2;
}

TriangleGlyph.prototype.height = function() {
    return this._height;
}




function DotGlyph(x, height, fill, stroke) {
    this._x = x;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

DotGlyph.prototype.draw = function(g) {
    var hh = this._height/2;
    g.fillStyle = this._stroke;
    g.beginPath();
    g.arc(this._x, hh, hh, 0, 6.29);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }

    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
}

DotGlyph.prototype.toSVG = function() {
    var hh = this._height/2;
    return makeElementNS(
        NS_SVG, 'circle',
        null,
        {cx: this._x, cy: hh, r: hh,
         fill: this._fill || 'none',
         stroke: this._stroke || 'none',
         strokeWidth: '1px'});
}

DotGlyph.prototype.min = function() {
    return this._x - this._height/2;
}

DotGlyph.prototype.max = function() {
    return this._x + this._height/2;
}

DotGlyph.prototype.height = function() {
    return this._height;
}


function PaddedGlyph(glyph, minp, maxp) {
    this.glyph = glyph;
    this._min = minp;
    this._max = maxp;
    if (glyph) {
        this.bump = glyph.bump;
    }
}

PaddedGlyph.prototype.draw = function(g, oc) {
    if (this.glyph) 
        this.glyph.draw(g, oc);
}

PaddedGlyph.prototype.toSVG = function() {
    if (this.glyph) {
        return this.glyph.toSVG();
    } else {
        return makeElementNS(NS_SVG, 'g');
    }
}

PaddedGlyph.prototype.min = function() {
    return this._min;
}

PaddedGlyph.prototype.max = function() {
    return this._max;
}

PaddedGlyph.prototype.height = function() {
    if (this.glyph) {
        return this.glyph.height();
    } else {
        return 1;
    }
}


function AArrowGlyph(min, max, height, fill, stroke, ori) {
    PathGlyphBase.call(this, stroke, fill);
    this._min = min;
    this._max = max;
    this._height = height;
    this._ori = ori;
}

AArrowGlyph.prototype = Object.create(PathGlyphBase.prototype);

AArrowGlyph.prototype.min = function() {
    return this._min;
}

AArrowGlyph.prototype.max = function() {
    return this._max;
}

AArrowGlyph.prototype.height = function() {
    return this._height;
}

AArrowGlyph.prototype.drawPath = function(g) {
    var maxPos = this._max;
    var minPos = this._min;
    var height = this._height;
    var lInset = 0;
    var rInset = 0;
    var minLength = this._height + 2;
    var instep = 0.333333 * this._height;
    var y = 0;

    if (this._ori) {
        if (this._ori === '+') {
            rInset = 0.5 * this._height;
        } else if (this._ori === '-') {
            lInset = 0.5 * this._height;
        }
    }

    if (maxPos - minPos < minLength) {
        minPos = (maxPos + minPos - minLength) / 2;
        maxPos = minPos + minLength;
    }

    g.moveTo(minPos + lInset, y+instep);
    g.lineTo(maxPos - rInset, y+instep);
    g.lineTo(maxPos - rInset, y);
    g.lineTo(maxPos, y + this._height/2);
    g.lineTo(maxPos - rInset, y+height);
    g.lineTo(maxPos - rInset, y+instep+instep);
    g.lineTo(minPos + lInset, y+instep+instep);
    g.lineTo(minPos + lInset, y+height);
    g.lineTo(minPos, y+height/2);
    g.lineTo(minPos + lInset, y);
    g.lineTo(minPos + lInset, y+instep);
}

function SpanGlyph(min, max, height, stroke) {
    PathGlyphBase.call(this, stroke, null);
    this._min = min;
    this._max = max;
    this._height = height;
}

SpanGlyph.prototype = Object.create(PathGlyphBase.prototype);

SpanGlyph.prototype.min = function() {return this._min};
SpanGlyph.prototype.max = function() {return this._max};
SpanGlyph.prototype.height = function() {return this._height};

SpanGlyph.prototype.drawPath = function(g) {
    var minPos = this._min, maxPos = this._max;
    var height = this._height, hh = height/2;
    g.moveTo(minPos, hh);
    g.lineTo(maxPos, hh);
    g.moveTo(minPos, 0);
    g.lineTo(minPos, height);
    g.moveTo(maxPos, 0);
    g.lineTo(maxPos, height);
}

function LineGlyph(min, max, height, style, strand, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._style = style;
    this._strand = strand;
    this._stroke = stroke;
}

LineGlyph.prototype.min = function() {return this._min};
LineGlyph.prototype.max = function() {return this._max};
LineGlyph.prototype.height = function() {return this._height};

LineGlyph.prototype.drawPath = function(g) {
    var minPos = this._min, maxPos = this._max;
    var height = this._height, hh = height/2;

    if (this._style === 'hat') {
        g.moveTo(minPos, hh);
        g.lineTo((minPos + maxPos)/2, this._strand === '-' ? height : 0);
        g.lineTo(maxPos, hh);
    } else {
        g.moveTo(minPos, hh);
        g.lineTo(maxPos, hh);
    }
}


LineGlyph.prototype.draw = function(g) {
    g.beginPath();
    this.drawPath(g);
    g.strokeStyle = this._stroke;
    if (this._style === 'dashed' && g.setLineDash) {
        g.save();
        g.setLineDash([3]);
        g.stroke();
        g.restore();
    } else {
        g.stroke();
    }
}

LineGlyph.prototype.toSVG = function() {
    var g = new SVGPath();
    this.drawPath(g);
    
    var opts = {d: g.toPathData(),
            stroke: this._stroke || 'none'};
    if (this._style === 'dashed') {
        opts['strokeDasharray'] = '3';
    }

    return makeElementNS(
        NS_SVG, 'path',
        null, opts
    );
}





function PrimersGlyph(min, max, height, fill, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

PrimersGlyph.prototype.min = function() {return this._min};
PrimersGlyph.prototype.max = function() {return this._max};
PrimersGlyph.prototype.height = function() {return this._height};


PrimersGlyph.prototype.drawStemPath = function(g) {
    var minPos = this._min, maxPos = this._max;
    var height = this._height, hh = height/2;
    g.moveTo(minPos, hh);
    g.lineTo(maxPos, hh);
}

PrimersGlyph.prototype.drawTrigsPath = function(g) {
    var minPos = this._min, maxPos = this._max;
    var height = this._height, hh = height/2;
    g.moveTo(minPos, 0);
    g.lineTo(minPos + height, hh);
    g.lineTo(minPos, height);
    g.lineTo(minPos, 0);
    g.moveTo(maxPos, 0);
    g.lineTo(maxPos - height, hh);
    g.lineTo(maxPos, height);
    g.lineTo(maxPos, 0);
}


PrimersGlyph.prototype.draw = function(g) {
    g.beginPath();
    this.drawStemPath(g);
    g.strokeStyle = this._stroke;
    g.stroke();
    g.beginPath();
    this.drawTrigsPath(g);
    g.fillStyle = this._fill;
    g.fill();
}

PrimersGlyph.prototype.toSVG = function() {
    var s = new SVGPath();
    this.drawStemPath(s);
    var t = new SVGPath();
    this.drawTrigsPath(t);
    
    return makeElementNS(
        NS_SVG, 'g',
        [makeElementNS(
            NS_SVG, 'path',
            null,
            {d: s.toPathData(),
             stroke: this._stroke || 'none'}),
         makeElementNS(
             NS_SVG, 'path',
             null,
             {d: t.toPathData(),
              fill: this._fill || 'none'})]);
}

function ArrowGlyph(min, max, height, color, parallel, sw, ne) {
    PathGlyphBase.call(this, null, color);
    this._min = min;
    this._max = max;
    this._height = height;
    this._color = color;
    this._parallel = parallel;
    this._sw = sw;
    this._ne = ne;
}

ArrowGlyph.prototype = Object.create(PathGlyphBase.prototype);

ArrowGlyph.prototype.min = function() {return this._min};
ArrowGlyph.prototype.max = function() {return this._max};
ArrowGlyph.prototype.height = function() {return this._height};

ArrowGlyph.prototype.drawPath = function(g) {
    var min = this._min, max = this._max, height = this._height;
    
    if (this._parallel) {
        var hh = height/2;
        var instep = 0.4 * height;
        if (this._sw) {
            g.moveTo(min + hh, height-instep);
            g.lineTo(min + hh, height);
            g.lineTo(min, hh);
            g.lineTo(min + hh, 0);
            g.lineTo(min + hh, instep);
        } else {
            g.moveTo(min, height-instep);
            g.lineTo(min, instep);
        }
        if (this._ne) {
            g.lineTo(max - hh, instep);
            g.lineTo(max - hh, 0);
            g.lineTo(max, hh);
            g.lineTo(max - hh, height);
            g.lineTo(max - hh, height - instep);
        } else {
            g.lineTo(max, instep);
            g.lineTo(max, height-instep);
        }
        g.closePath();
    } else {
        var mid = (min+max)/2;
        var instep = 0.4*(max-min);
        var th = height/3;

        if (this._ne) {
            g.moveTo(min + instep, th);
            g.lineTo(min, th);
            g.lineTo(mid, 0);
            g.lineTo(max, th);
            g.lineTo(max - instep, th);
        } else {
            g.moveTo(min+instep, 0);
            g.lineTo(max-instep, 0);
        }
        if (this._sw) {
            g.lineTo(max - instep, height-th);
            g.lineTo(max, height-th);
            g.lineTo(mid, height);
            g.lineTo(min, height-th)
            g.lineTo(min + instep, height-th);
        } else {
            g.lineTo(max - instep, height);
            g.lineTo(min + instep, height);
        }
        g.closePath();
    }
}


function TooManyGlyph(min, max, height, fill, stroke) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._stroke = stroke;
}

TooManyGlyph.prototype.min = function() {return this._min};
TooManyGlyph.prototype.max = function() {return this._max};
TooManyGlyph.prototype.height = function() {return this._height};

TooManyGlyph.prototype.toSVG = function() {
    return makeElementNS(NS_SVG, 'rect', null,
                         {x: this._min, 
                          y: 0, 
                          width: this._max - this._min, 
                          height: this._height,
                          stroke: this._stroke || 'none',
                          fill: this._fill || 'none'});
}

TooManyGlyph.prototype.draw = function(g) {
    if (this._fill) {
        g.fillStyle = this._fill;
        g.fillRect(this._min, 0, this._max - this._min, this._height);
    }
    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.strokeRect(this._min, 0, this._max - this._min, this._height);
        g.beginPath();
        for (var n = 2; n < this._height; n += 3) {
            g.moveTo(this._min, n);
            g.lineTo(this._max, n);
        }
        g.stroke();
    }
}

function TextGlyph(GLOBAL_GC, min, max, height, fill, string) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._string = string;
    this._textLen = GLOBAL_GC.measureText(string).width;
}

TextGlyph.prototype.min = function() {return this._min};
TextGlyph.prototype.max = function() {return Math.max(this._max, this._min + this._textLen)};
TextGlyph.prototype.height = function() {return this._height};

TextGlyph.prototype.draw = function(g) {
    g.fillStyle = this._fill;
    g.fillText(this._string, this._min, this._height - 4);
}

TextGlyph.prototype.toSVG = function() {
    return makeElementNS(NS_SVG, 'text', this._string, {x: this._min, y: this._height - 4});
};

function aminoTileColor(aa, start, color) {
    var ALTERNATE_COLOR = {
        'red': 'darkred',
        'purple': 'mediumpurple',
        'blue': 'darkblue',
        'green': 'darkgreen'
    };
    var color2 = ALTERNATE_COLOR[color.toLowerCase()];
    var tileColors;
    if (!color2)
        tileColors = ['rgb(73, 68, 149)', 'rgb(9, 0, 103)'];
        // default to UCSC colors
    else
        tileColors = [color, color2];

    if (aa == '?')
        return 'black';
    else if (aa == 'M')
        return 'greenyellow';
    else if (aa == '*')
        return 'crimson';
    else
        return tileColors[start % 2];
}

function reverseComplement(sequence) {
    var seq_dict = {'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'};
    var rev_seq = sequence.split('').reverse().join('');
    var rev_compl_seq = [];
    for (var b = 0; b < rev_seq.length; ++b) {
        var base = rev_seq.substr(b, 1).toUpperCase();
        rev_compl_seq.push(base in seq_dict ? seq_dict[base] : 'N');
    }
    return rev_compl_seq.join('');
}

function AminoAcidGlyph(min, max, height, fill, seq, orientation, readframe) {
    this._min = min;
    this._max = max;
    this._height = height;
    this._fill = fill;
    this._seq = seq;
    this._orientation = orientation;
    this._readframe = readframe;
}

AminoAcidGlyph.prototype.min = function() {return this._min};
AminoAcidGlyph.prototype.max = function() {return this._max};
AminoAcidGlyph.prototype.height = function() {return this._height};

AminoAcidGlyph.prototype.draw = function(gc) {
    var seq = this._seq;
    var color = this._fill;

    if (!seq) return;

    var scale = (this._max - this._min + 1) / seq.length;

    var prevOverhang = (3 - this._readframe) % 3;
    var nextOverhang = (seq.length - prevOverhang) % 3;
    var leftOverhang = this._orientation == '+' ? prevOverhang : nextOverhang;
    
    if (leftOverhang > 0) {
        gc.fillStyle = color;
        gc.fillRect(this._min, 0, scale * leftOverhang, this._height);
    }

    for (var p = leftOverhang; p < seq.length; p += 3) {
        var codon = seq.substr(p, 3).toUpperCase();
        if (this._orientation == '-')
            codon = reverseComplement(codon);
        var aa = codon in AMINO_ACID_TRANSLATION ? AMINO_ACID_TRANSLATION[codon] : '?';
        color = codon.length == 3 ? aminoTileColor(aa, p, this._fill) : this._fill;
        gc.fillStyle = color;
        gc.fillRect(this._min + p * scale, 0, scale * codon.length, this._height);

        if (scale >= 8 && codon.length == 3) {
            gc.fillStyle = 'white';
            gc.fillText(aa, this._min + (p+1) * scale, this._height);
        } 
    }
}

AminoAcidGlyph.prototype.toSVG = function() {
    var g = makeElementNS(NS_SVG, 'g');
    var seq = this._seq;
    var color = this._fill;

    if (!seq)
        return g;

    var scale = (this._max - this._min + 1) / seq.length;

    var prevOverhang = (3 - this._readframe) % 3;
    var nextOverhang = (seq.length - prevOverhang) % 3;
    var leftOverhang = this._orientation == '+' ? prevOverhang : nextOverhang;

    if (leftOverhang > 0) {
        g.appendChild(
            makeElementNS(NS_SVG, 'rect', null, {
                x: this._min,
                y: 0,
                width: scale * leftOverhang,
                height: this._height,
                fill: color}));
    }
    for (var p = leftOverhang; p < seq.length; p += 3) {
        var codon = seq.substr(p, 3).toUpperCase();
        if (this._orientation == '-')
            codon = reverseComplement(codon);
        var aa = codon in AMINO_ACID_TRANSLATION ? AMINO_ACID_TRANSLATION[codon] : '?';
        color = codon.length == 3 ? aminoTileColor(aa, p, this._fill) : this._fill;
        g.appendChild(
            makeElementNS(NS_SVG, 'rect', null, {
                x: this._min + p * scale,
                y: 0,
                width: scale * codon.length,
                height: this._height,
                fill: color}));

        if (scale >= 8 && codon.length == 3) {
            g.appendChild(
                makeElementNS(NS_SVG, 'text', aa, {
                    x: this._min + (p+1) * scale,
                    y: this._height,
                    fill: 'white'}));
        }
    }
    return g;
};

(function(scope) {

var isRetina = window.devicePixelRatio > 1;
var __dalliance_SequenceGlyphCache = {};
var altPattern = new RegExp('^[ACGT-]$');
var isCloseUp = function(scale) {
    return scale >= 8;
}

function SequenceGlyph(baseColors, strandColor, min, max, height, seq, ref, scheme, quals, fillbg) {
    this.baseColors = baseColors;
    this._strandColor = strandColor;
    this._min = min;
    this._max = max;
    this._height = height;
    this._seq = seq;
    this._ref = ref;
    this._scheme = scheme;
    this._quals = quals;
    this._fillbg = fillbg;
}

SequenceGlyph.prototype.min = function() {return this._min};
SequenceGlyph.prototype.max = function() {return this._max};
SequenceGlyph.prototype.height = function() {return this._height};


SequenceGlyph.prototype.alphaForQual = function(qual) {
    return 0.1 + 0.9*Math.max(0.0, Math.min((1.0 * qual) / 30.0, 1.0));
}

SequenceGlyph.prototype.draw = function(gc) {
    var seq = this._seq;
    var ref = this._ref;
    var mismatch = this._scheme === 'mismatch' || this._scheme === 'mismatch-all';
    var all = this._scheme === 'mismatch-all';
    
    var seqLength = seq ? seq.length : (this._max - this._min + 1);
    var scale = (this._max - this._min + 1) / seqLength;

    if (mismatch && !isCloseUp(scale)) {
        gc.fillStyle = this._strandColor;
        gc.fillRect(this._min, this._height/4, this._max - this._min, this._height/2);
    }

    for (var p = 0; p < seqLength; ++p) {
        var base = seq ? seq.substr(p, 1).toUpperCase() : 'N';
        
        if (!altPattern.test(base) && !isCloseUp(scale))
            continue;

        var color = this.baseColors[base];

        if (this._quals) {
            var qc = this._quals.charCodeAt(p) - 33;
            var oldAlpha = gc.globalAlpha;            // NB hoisted!
            gc.globalAlpha = this.alphaForQual(qc);
        }

        if (!color) {
            var refBase = ref ? ref.substr(p, 1).toUpperCase() : 'N';
            if (base == 'N' || refBase == 'N')
                color = 'gray';
            else
                color = this._strandColor;

            if (all)
                base = refBase;
        }

        gc.fillStyle = color;

        var alt = altPattern.test(base);
        if (this._fillbg || !isCloseUp(scale) || !alt)
            gc.fillRect(this._min + p*scale, 0, scale, this._height);

        if (isCloseUp(scale) && alt) {
            var key = color + '_' + base
            var img = __dalliance_SequenceGlyphCache[key];
            if (!img) {
                img = document.createElement('canvas');
                if (isRetina) {
                    img.width = 16;
                    img.height = 20;
                } else {
                    img.width = 8;
                    img.height = 10;
                }
                var imgGc = img.getContext('2d');
                if (isRetina) {
                    imgGc.scale(2, 2);
                }
                imgGc.fillStyle = this._fillbg ? 'black' : color;
                var w = imgGc.measureText(base).width;
                imgGc.fillText(base, 0.5 * (8.0 - w), 8);
                __dalliance_SequenceGlyphCache[key] = img;
            }
            if (isRetina)
                gc.drawImage(img, this._min + p*scale + 0.5*(scale-8), 0, 8, 10);
            else
                gc.drawImage(img, this._min + p*scale + 0.5*(scale-8), 0);
        } 

        if (this._quals) {
            gc.globalAlpha = oldAlpha;
        }
    }
}

SequenceGlyph.prototype.toSVG = function() {
    var seq = this._seq;
    var ref = this._ref;
    var mismatch = this._scheme === 'mismatch' || this._scheme === 'mismatch-all';
    var all = this._scheme === 'mismatch-all';
    var scale = (this._max - this._min + 1) / this._seq.length;
    var  g = makeElementNS(NS_SVG, 'g'); 

    for (var p = 0; p < seq.length; ++p) {
        var base = seq ? seq.substr(p, 1).toUpperCase() : 'N';
        var color = this.baseColors[base];

        if (!color) {
            var refBase = ref ? ref.substr(p, 1).toUpperCase() : 'N';
            if (base == 'N' || refBase == 'N')
                color = 'gray';
            else
                color = this._strandColor;

            if (all)
                base = refBase;
        }

        var alpha = 1.0;
        if (this._quals) {
            var qc = this._quals.charCodeAt(p) - 33;
            alpha = this.alphaForQual(qc);
        }

        var alt = altPattern.test(base);
        if (this._fillbg || !isCloseUp(scale) || !alt) {
            g.appendChild(
                makeElementNS(NS_SVG, 'rect', null, {
                    x:this._min + p*scale,
                    y: 0,
                    width: scale,
                    height: this._height,
                    fill: color,
                    fillOpacity: alpha}));
        }

        if (isCloseUp(scale) && alt) {
            g.appendChild(
                makeElementNS(NS_SVG, 'text', base, {
                    x: this._min + (0.5+p)*scale,
                    y: 8,
                    textAnchor: 'middle',
                    fill: this._fillbg ? 'black' : color,
                    fillOpacity: alpha}));
        }
    }

    return g;
}

scope.SequenceGlyph = SequenceGlyph;

}(this));

function TranslatedGlyph(glyph, x, y, height) {
    this.glyph = glyph;
    this._height = height;
    this._x = x;
    this._y = y;
}

TranslatedGlyph.prototype.height = function() {
    if (this._height) {
        return this._height;
    } else {
        return this.glyph.height() + this._y;
    }
}

TranslatedGlyph.prototype.min = function() {
    return this.glyph.min() + this._x;
}

TranslatedGlyph.prototype.max = function() {
    return this.glyph.max() + this._x;
}

TranslatedGlyph.prototype.minY = function() {
    return this._y;
}

TranslatedGlyph.prototype.maxY = function() {
    return this._y + this.glyph.height();
}

TranslatedGlyph.prototype.draw = function(g, o) {
    g.save();
    g.translate(this._x, this._y);
    this.glyph.draw(g, o);
    g.restore();
}

TranslatedGlyph.prototype.toSVG = function() {
    var s =  this.glyph.toSVG();
    s.setAttribute('transform', 'translate(' + this._x + ',' + this._y + ')');
    return s;
}

function PointGlyph(x, y, height, fill) {
    this._x = x;
    this._y = y;
    this._height = height;
    this._fill = fill;
}

PointGlyph.prototype.min = function() {
    return this._x - 2;
}

PointGlyph.prototype.max = function() {
    return this._x + 2;
}

PointGlyph.prototype.height = function() {
    return this._height;
}

PointGlyph.prototype.draw = function(g) {
    g.save();
    g.globalAlpha = 0.3;
    g.fillStyle = this._fill;
    g.beginPath();
    g.arc(this._x, this._y, 1.5, 0, 6.29);
    g.fill();
    g.restore();
}

PointGlyph.prototype.toSVG = function() {
    return makeElementNS(
        NS_SVG, 'circle',
        null,
        {cx: this._x, cy: this._y, r: 2,
         fill: this._fill,
         stroke: 'none'});
}


function GridGlyph(height) {
    this._height = height || 50;
}

GridGlyph.prototype.notSelectable = true;

GridGlyph.prototype.min = function() {
    return -100000;
};

GridGlyph.prototype.max = function() {
    return 100000;
};

GridGlyph.prototype.height = function() {
    return this._height;
}

GridGlyph.prototype.draw = function(g) {
    g.save();
    g.strokeStyle = 'black'
    g.lineWidth = 0.1;

    g.beginPath();
    for (var y = 0; y <= this._height; y += 10) {
        g.moveTo(-5000, y);
        g.lineTo(5000, y);
    }
    g.stroke();
    g.restore();
}

GridGlyph.prototype.toSVG = function() {
    var p = new SVGPath();
    for (var y = 0; y <= this._height; y += 10) {
        p.moveTo(-5000, y);
        p.lineTo(5000, y);
    }
    
    return makeElementNS(
        NS_SVG, 'path',
        null,
        {d: p.toPathData(),
         fill: 'none',
         stroke: 'black',
         strokeWidth: '0.1px'});
}

function StarGlyph(x, r, points, fill, stroke) {
    PathGlyphBase.call(this, stroke, fill);
    this._x = x;
    this._r = r;
    this._points = points;
}

StarGlyph.prototype = Object.create(PathGlyphBase.prototype);

StarGlyph.prototype.min = function() {
    return this._x - this._r;
}

StarGlyph.prototype.max = function() {
    return this._x + this._r;
}

StarGlyph.prototype.height = function() {
    return 2 * this._r;
}

StarGlyph.prototype.drawPath = function(g) {
    var midX = this._x, midY = this._r, r = this._r;
    for (var p = 0; p < this._points; ++p) {
        var theta = (p * 6.28) / this._points;
        var px = midX + r*Math.sin(theta);
        var py = midY - r*Math.cos(theta);
        if (p == 0) {
            g.moveTo(px, py);
        } else {
            g.lineTo(px, py);
        }
        theta = ((p+0.5) * 6.28) / this._points;
        px = midX + 0.4*r*Math.sin(theta);
        py = midY - 0.4*r*Math.cos(theta);
        g.lineTo(px, py);
    }
    g.closePath();
}

function PlimsollGlyph(x, height, overhang, fill, stroke) {
    this._x = x;
    this._height = height;
    this._overhang = overhang;
    this._fill = fill;
    this._stroke = stroke;
    this._hh = height / 2;
}

PlimsollGlyph.prototype.draw = function(g) {
    var hh = this._height/2;
    g.fillStyle = this._stroke;
    g.beginPath();
    g.arc(this._x, hh, hh - this._overhang, 0, 6.29);
    g.moveTo(this._x, 0);
    g.lineTo(this._x, this._height);

    if (this._fill) {
        g.fillStyle = this._fill;
        g.fill();
    }

    if (this._stroke) {
        g.strokeStyle = this._stroke;
        g.stroke();
    }
}

PlimsollGlyph.prototype.toSVG = function() {
    var hh = this._hh;
    return makeElementNS(NS_SVG, 'g', 
        [makeElementNS(NS_SVG, 'circle', null, {cx: this._x, cy: hh, r: hh - this._overhang}),
         makeElementNS(NS_SVG, 'line', null, {x1: this._x, y1: 0, x2: this._x, y2: this._height})],
        {fill: this._fill || 'none',
         stroke: this._stroke || 'none',
         strokeWidth: '1px'});
}

PlimsollGlyph.prototype.min = function() {
    return this._x - this._hh;
}

PlimsollGlyph.prototype.max = function() {
    return this._x + this._hh;
}

PlimsollGlyph.prototype.height = function() {
    return this._height;
}


function OverlayLabelCanvas() {
    this.ox = 0;
    this.oy = 0;
    this.glyphs = [];
}

OverlayLabelCanvas.prototype.translate = function(x, y) {
    this.ox += x;
    this.oy += y;
}

OverlayLabelCanvas.prototype.registerGlyph = function(g) {
    this.glyphs.push({
        x: this.ox,
        y: this.oy,
        glyph: g
    });
}


OverlayLabelCanvas.prototype.draw = function(g, minVisible, maxVisible) {
    for (var gi = 0; gi < this.glyphs.length; ++gi) {
        var gg = this.glyphs[gi];
        g.save();
        g.translate(gg.x, gg.y);
        gg.glyph.drawOverlay(g, minVisible, maxVisible);
        g.restore();
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        BoxGlyph: BoxGlyph,
        GroupGlyph: GroupGlyph,
        LineGraphGlyph: LineGraphGlyph,
        LabelledGlyph: LabelledGlyph,
        CrossGlyph: CrossGlyph,
        ExGlyph: ExGlyph,
        TriangleGlyph: TriangleGlyph,
        DotGlyph: DotGlyph,
        PaddedGlyph: PaddedGlyph,
        AArrowGlyph: AArrowGlyph,
        SpanGlyph: SpanGlyph,
        LineGlyph: LineGlyph,
        PrimersGlyph: PrimersGlyph,
        ArrowGlyph: ArrowGlyph,
        TooManyGlyph: TooManyGlyph,
        TextGlyph: TextGlyph,
        SequenceGlyph: this.SequenceGlyph,
        AminoAcidGlyph: AminoAcidGlyph,
        TranslatedGlyph: TranslatedGlyph,
        GridGlyph: GridGlyph,
        StarGlyph: StarGlyph,
        PointGlyph: PointGlyph,
        PlimsollGlyph: PlimsollGlyph,

        OverlayLabelCanvas: OverlayLabelCanvas
    }
}

},{"./spans":36,"./svg-utils":39,"./utils":49}],22:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// jbjson.js -- query JBrowse-style REST data stores
//

if (typeof(require) !== 'undefined') {
    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;
}

function JBrowseStore(base, query) {
    this.base = base;
    this.query = query;
}

JBrowseStore.prototype.features = function(segment, opts, callback) {
    opts = opts || {};

    url = this.base + '/features/' + segment.name;

    var filters = [];
    if (this.query) {
	   filters.push(this.query);
    }
    if (segment.isBounded) {
    	filters.push('start=' + segment.start);
    	filters.push('end=' + segment.end);
    }
    if (filters.length > 0) {
	    url = url + '?' + filters.join('&');
    }

    var req = new XMLHttpRequest();
    req.onreadystatechange = function() {
	if (req.readyState == 4) {
	    if (req.status >= 300) {
		    callback(null, 'Error code ' + req.status);
	    } else {
		var jf = JSON.parse(req.response)['features'];
		var features = [];
		for (fi = 0; fi < jf.length; ++fi) {
		    var j = jf[fi];
		    
		    var f = new DASFeature();
		    f.segment = segment.name;
		    f.min = (j['start'] | 0) + 1;
		    f.max = j['end'] | 0;
		    if (j.name) {
			f.label = j.name;
		    }
		    f.type = j.type || 'unknown';
		    
		    features.push(f);
		}
		callback(features);
	    }
	}
	
    };
    
    req.open('GET', url, true);
    req.responseType = 'text';
    req.send('');
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        JBrowseStore: JBrowseStore
    };
}

},{"./das":10}],23:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// kspace.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var Awaited = utils.Awaited;
    var pusho = utils.pusho;

    var sa = require('./sourceadapters');
    var MappedFeatureSource = sa.MappedFeatureSource;
    var CachingFeatureSource = sa.CachingFeatureSource;
    var BWGFeatureSource = sa.BWGFeatureSource;
    var RemoteBWGFeatureSource = sa.RemoteBWGFeatureSource;
    var BAMFeatureSource = sa.BAMFeatureSource;
    var RemoteBAMFeatureSource = sa.RemoteBAMFeatureSource;
    var DummySequenceSource = sa.DummySequenceSource;
    var DummyFeatureSource = sa.DummyFeatureSource;

    var OverlayFeatureSource = require('./overlay').OverlayFeatureSource;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var sample = require('./sample');
    var downsample = sample.downsample;
    var getBaseCoverage = sample.getBaseCoverage;

    var das = require('./das');
    var DASSequence = das.DASSequence;
    
    var Promise = require('es6-promise').Promise;
}

function FetchPool() {
    var self = this;
    this.reqs = [];
    this.awaitedFeatures = {};
    this.requestsIssued = new Promise(function(resolve, reject) {
        self.notifyRequestsIssued = resolve;
    });
}

FetchPool.prototype.addRequest = function(xhr) {
    this.reqs.push(xhr);
}

FetchPool.prototype.abortAll = function() {
    for (var i = 0; i < this.reqs.length; ++i) {
        this.reqs[i].abort();
    }
}

function KSCacheBaton(chr, min, max, scale, features, status, coverage) {
    this.chr = chr;
    this.min = min;
    this.max = max;
    this.coverage = coverage;
    this.scale = scale;
    this.features = features || [];
    this.status = status;
}

KSCacheBaton.prototype.toString = function() {
    return this.chr + ":" + this.min + ".." + this.max + ";scale=" + this.scale;
}

function KnownSpace(tierMap, chr, min, max, scale, seqSource) {
    this.tierMap = tierMap;
    this.chr = chr;
    this.min = min;
    this.max = max;
    this.scale = scale;
    this.seqSource = seqSource || new DummySequenceSource();
    this.viewCount = 0;

    this.featureCache = {};
    this.latestViews = {};
}

KnownSpace.prototype.cancel = function() {
    this.cancelled = true;
}

KnownSpace.prototype.bestCacheOverlapping = function(chr, min, max) {
    var baton = this.featureCache[this.tierMap[0]];
    if (baton) {
        return baton;
    } else {
        return null;
    }
}

KnownSpace.prototype.viewFeatures = function(chr, min, max, scale) {
    if (scale != scale) {
        throw "viewFeatures called with silly scale";
    }

    if (chr != this.chr) {
        throw "Can't extend Known Space to a new chromosome";
    }
    if (min < 1) {
        min = 1;
    }

    this.min = min;
    this.max = max;
    this.scale = scale;

    if (this.pool) {
        this.pool.abortAll();
    }
    this.pool = new FetchPool();
    this.awaitedSeq = new Awaited();
    this.seqWasFetched = false;
    this.viewCount++;
    
    this.startFetchesForTiers(this.tierMap);
    this.pool.notifyRequestsIssued();
}
    
function filterFeatures(features, min, max) {
    var ff = [];
    var featuresByGroup = {};

    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (!f.min || !f.max) {
            ff.push(f);
        } else if (f.groups && f.groups.length > 0) {
            pusho(featuresByGroup, f.groups[0].id, f);
        } else if (f.min <= max && f.max >= min) {
            ff.push(f);
        }
    }

    for (var gid in featuresByGroup) {
        var gf = featuresByGroup[gid];
        var gmin = 100000000000, gmax = -100000000000;
        for (var fi = 0; fi < gf.length; ++fi) {
            var f = gf[fi];
            gmin = Math.min(gmin, f.min);
            gmax = Math.max(gmax, f.max);
        }
        if (gmin <= max || gmax >= min) {
            for (var fi = 0; fi < gf.length; ++fi) {
                ff.push(gf[fi]);
            }
        }
    }

    return ff;
}

KnownSpace.prototype.invalidate = function(tier) {
    if (!this.pool) {
        return;
    }

    this.featureCache[tier] = null;
    this.startFetchesForTiers([tier]);
}

KnownSpace.prototype.startFetchesForTiers = function(tiers) {
    var thisB = this;

    var awaitedSeq = this.awaitedSeq;
    var needSeq = false;

    var gex;

    for (var t = 0; t < tiers.length; ++t) {
        try {
            if (this.startFetchesFor(tiers[t], awaitedSeq)) {
                needSeq = true;
            }
        } catch (ex) {
            var tier = tiers[t];
            tier.currentFeatures = [];
            tier.currentSequence = null;
            tier.draw();
            tier.updateHeight();
            tier.updateStatus(ex);
            console.log('Error fetching tier source');
            console.log(ex);
            gex = ex;
        }
    }

    if (needSeq && !this.seqWasFetched) {
        this.seqWasFetched = true;
        var smin = this.min, smax = this.max;

        if (this.cs) {
            if (this.cs.start <= smin && this.cs.end >= smax) {
                var cachedSeq;
                if (this.cs.start == smin && this.cs.end == smax) {
                    cachedSeq = this.cs;
                } else {
                    cachedSeq = new DASSequence(this.cs.name, smin, smax, this.cs.alphabet, 
                                                this.cs.seq.substring(smin - this.cs.start, smax + 1 - this.cs.start));
                }
                return awaitedSeq.provide(cachedSeq);
            }
        }
        
        this.seqSource.fetch(this.chr, smin, smax, this.pool, function(err, seq) {
            if (seq) {
                if (!thisB.cs || (smin <= thisB.cs.start && smax >= thisB.cs.end) || 
                    (smin >= thisB.cs.end) || (smax <= thisB.cs.start) || 
                    ((smax - smin) > (thisB.cs.end - thisB.cs.start))) 
                {
                    thisB.cs = seq;
                }
                awaitedSeq.provide(seq);
            } else {
                console.log('Sequence loading failed', err);
                awaitedSeq.provide(null);
            }
        });
    } 

    if (gex)
        throw gex;
}

KnownSpace.prototype.startFetchesFor = function(tier, awaitedSeq) {
    var thisB = this;

    var viewID = this.viewCount;
    var source = tier.getSource() || new DummyFeatureSource();
    var needsSeq = tier.needsSequence(this.scale);
    var baton = thisB.featureCache[tier];
    var styleFilters = tier.getActiveStyleFilters(this.scale);
    var wantedTypes;
    if (styleFilters)
        wantedTypes = styleFilters.typeList();
    var chr = this.chr, min = this.min, max = this.max;


    if (wantedTypes === undefined) {
        return false;
    }
    if (baton && baton.chr === this.chr && baton.min <= min && baton.max >= max) {
        var cachedFeatures = baton.features;
        if (baton.min < min || baton.max > max) {
            cachedFeatures = filterFeatures(cachedFeatures, min, max);
        }
        
        thisB.provision(tier, baton.chr, intersection(baton.coverage, new Range(min, max)), baton.scale, wantedTypes, cachedFeatures, baton.status, needsSeq ? awaitedSeq : null);

        var availableScales = source.getScales();
        if (baton.scale <= this.scale || !availableScales) {
            return needsSeq;
        } else {
        }
    }

    if (source.instrument)
        console.log('Starting  fetch ' + viewID + ' (' + min + ', ' + max + ')');
    source.fetch(chr, min, max, this.scale, wantedTypes, this.pool, function(status, features, scale, coverage) {
    	if (source.instrument)
    	    console.log('Finishing fetch ' + viewID);

    	var latestViewID = thisB.latestViews[tier] || -1;
    	if (thisB.cancelled || latestViewID > viewID) {
    	    return;
    	}

        if (!coverage) {
            coverage = new Range(min, max);
        }

        if (!baton || (min < baton.min) || (max > baton.max)) {         // FIXME should be merging in some cases?
            thisB.featureCache[tier] = new KSCacheBaton(chr, min, max, scale, features, status, coverage);
        }

	    thisB.latestViews[tier] = viewID;
        thisB.provision(tier, chr, coverage, scale, wantedTypes, features, status, needsSeq ? awaitedSeq : null);
    }, styleFilters);
    return needsSeq;
}

KnownSpace.prototype.provision = function(tier, chr, coverage, actualScale, wantedTypes, features, status, awaitedSeq) {
    if (status) {
        tier.currentFeatures = [];
        tier.currentSequence = null;
        tier.draw();
        tier.updateHeight();
    }
    tier.updateStatus(status);
   
    if (!status) {
        var mayDownsample = false;
        var needBaseComposition = false;
        var src = tier.getSource();
        while (MappedFeatureSource.prototype.isPrototypeOf(src) || CachingFeatureSource.prototype.isPrototypeOf(src) || OverlayFeatureSource.prototype.isPrototypeOf(src)) {
	        if (OverlayFeatureSource.prototype.isPrototypeOf(src)) {
		        src = src.sources[0];
	        } else {
		        src = src.source;
	        }
        }
        if (BWGFeatureSource.prototype.isPrototypeOf(src) || RemoteBWGFeatureSource.prototype.isPrototypeOf(src) || BAMFeatureSource.prototype.isPrototypeOf(src) || RemoteBAMFeatureSource.prototype.isPrototypeOf(src)) {
            mayDownsample = true;
        }

    	if (!src.opts || (!src.opts.forceReduction && !src.opts.noDownsample)) {
            if (/* (actualScale < (this.scale/2) && features.length > 200)  || */
		        (mayDownsample && wantedTypes && wantedTypes.length == 1 && wantedTypes.indexOf('density') >= 0))
            {
		        features = downsample(features, this.scale);
            }
    	}

        if (wantedTypes && wantedTypes.length == 1 && wantedTypes.indexOf('base-coverage') >= 0)
        {
            // Base-composition coverage track
            needBaseComposition = true;
        }
        if (awaitedSeq) {
            awaitedSeq.await(function(seq) {
                if (needBaseComposition) {
                    features = getBaseCoverage(features, seq, tier.browser.baseColors);
                }
                tier.viewFeatures(chr, coverage, actualScale, features, seq);
            });
        } else {
            tier.viewFeatures(chr, coverage, actualScale, features);
        }
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        KnownSpace: KnownSpace
    };
}

},{"./das":10,"./overlay":27,"./sample":29,"./sourceadapters":34,"./spans":36,"./utils":49,"es6-promise":53}],24:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// lh3utils.js: common support for lh3's file formats
//

if (typeof(require) !== 'undefined') {
    var jszlib = require('jszlib');
    var jszlib_inflate_buffer = jszlib.inflateBuffer;
    var arrayCopy = jszlib.arrayCopy;
}

function Vob(b, o) {
    this.block = b;
    this.offset = o;
}

Vob.prototype.toString = function() {
    return '' + this.block + ':' + this.offset;
}

function readVob(ba, offset) {
    var block = ((ba[offset+6] & 0xff) * 0x100000000) + ((ba[offset+5] & 0xff) * 0x1000000) + ((ba[offset+4] & 0xff) * 0x10000) + ((ba[offset+3] & 0xff) * 0x100) + ((ba[offset+2] & 0xff));
    var bint = (ba[offset+1] << 8) | (ba[offset]);
    if (block == 0 && bint == 0) {
        return null;  // Should only happen in the linear index?
    } else {
        return new Vob(block, bint);
    }
}

function unbgzf(data, lim) {
    lim = Math.min(lim || 1, data.byteLength - 50);
    var oBlockList = [];
    var ptr = [0];
    var totalSize = 0;

    while (ptr[0] < lim) {
        var ba = new Uint8Array(data, ptr[0], 12); // FIXME is this enough for all credible BGZF block headers?
        var xlen = (ba[11] << 8) | (ba[10]);
        // dlog('xlen[' + (ptr[0]) +']=' + xlen);
        var unc = jszlib_inflate_buffer(data, 12 + xlen + ptr[0], Math.min(65536, data.byteLength - 12 - xlen - ptr[0]), ptr);
        ptr[0] += 8;
        totalSize += unc.byteLength;
        oBlockList.push(unc);
    }

    if (oBlockList.length == 1) {
        return oBlockList[0];
    } else {
        var out = new Uint8Array(totalSize);
        var cursor = 0;
        for (var i = 0; i < oBlockList.length; ++i) {
            var b = new Uint8Array(oBlockList[i]);
            arrayCopy(b, 0, out, cursor, b.length);
            cursor += b.length;
        }
        return out.buffer;
    }
}

function Chunk(minv, maxv) {
    this.minv = minv; this.maxv = maxv;
}


//
// Binning (transliterated from SAM1.3 spec)
//

/* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */
function reg2bin(beg, end)
{
    --end;
    if (beg>>14 == end>>14) return ((1<<15)-1)/7 + (beg>>14);
    if (beg>>17 == end>>17) return ((1<<12)-1)/7 + (beg>>17);
    if (beg>>20 == end>>20) return ((1<<9)-1)/7 + (beg>>20);
    if (beg>>23 == end>>23) return ((1<<6)-1)/7 + (beg>>23);
    if (beg>>26 == end>>26) return ((1<<3)-1)/7 + (beg>>26);
    return 0;
}

/* calculate the list of bins that may overlap with region [beg,end) (zero-based) */
var MAX_BIN = (((1<<18)-1)/7);
function reg2bins(beg, end) 
{
    var i = 0, k, list = [];
    --end;
    list.push(0);
    for (k = 1 + (beg>>26); k <= 1 + (end>>26); ++k) list.push(k);
    for (k = 9 + (beg>>23); k <= 9 + (end>>23); ++k) list.push(k);
    for (k = 73 + (beg>>20); k <= 73 + (end>>20); ++k) list.push(k);
    for (k = 585 + (beg>>17); k <= 585 + (end>>17); ++k) list.push(k);
    for (k = 4681 + (beg>>14); k <= 4681 + (end>>14); ++k) list.push(k);
    return list;
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        unbgzf: unbgzf,
        readVob: readVob,
        reg2bin: reg2bin,
        reg2bins: reg2bins,
        Chunk: Chunk
    };
}
},{"jszlib":65}],25:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// memstore.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var dalliance_makeParser = sa.makeParser;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;

    var utils = require('./utils');
    var Awaited = utils.Awaited;
    var textXHR = utils.textXHR;
}

function MemStore() {
    this.featuresByChr = {};
    this.maxLength = 1;
    this.chrRing = null;
}

MemStore.prototype.addFeatures = function(features) {
    var dirty = {};
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        var chr = f.segment || f.chr;
        var fa = this.featuresByChr[chr];
        if (!fa) {
            fa = [];
            this.featuresByChr[chr] = fa;
        }
        fa.push(f);
        dirty[chr] = true;

        var len = f.max - f.min + 1;
        if (len > this.maxLength)
            this.maxLength = len;
    }

    for (chr in dirty) {
        var fa = this.featuresByChr[chr];
        fa.sort(function(f1, f2) {
            var d = f1.min - f2.min;
            if (d != 0)
                return d;
            return f1.max - f2.max;
        });
    }
    this.chrRing = null;
}

MemStore.prototype._indexFor = function(fa, p) {
    var lb = 0, ub = fa.length;
    while (ub > lb) {
        var mid = ((lb + ub)/2)|0;
        if (mid >= fa.length)
            return fa.length;
        var mg = fa[mid];
        if (p < mg.min) {
            ub = mid;
        } else {
            lb = mid + 1;
        }
    }
    return ub;
}

MemStore.prototype.fetch = function(chr, min, max) {
    var fa = this.featuresByChr[chr];
    if (!fa) {
        if (chr.indexOf('chr') == 0)
            fa = this.featuresByChr[chr.substring(3)];
        else
            fa = this.featuresByChr['chr' + chr];
    }
    if (!fa)
        return [];

    var mini = Math.max(0, this._indexFor(fa, min - this.maxLength - 1));
    var maxi = Math.min(fa.length - 1, this._indexFor(fa, max));

    var res = [];
    for (var fi = mini; fi <= maxi; ++fi) {
        var f = fa[fi];
        if (f.min <= max && f.max >= min)
            res.push(f);
    }
    return res;
}

MemStore.prototype.findNextFeature = function(chr, pos, dir) {
    if (this.chrRing == null) {
        this.chrRing = [];
        for (var chr in this.featuresByChr) {
            this.chrRing.push(chr);
        }
        this.chrRing.sort();
    }

    var fa = this.featuresByChr[chr];
    if (!fa) {
        if (chr.indexOf('chr') == 0) {
            chr = chr.substring(3);
            fa = this.featuresByChr[chr];
        } else {
            chr = 'chr' + chr;
            fa = this.featuresByChr[chr];
        }
    }
    if (!fa)
        return null;

    var i = Math.max(0, Math.min(this._indexFor(fa, pos), fa.length - 1));
    if (dir > 0) {
        while (i < fa.length) {
            var f = fa[i++];
            if (f.min > pos)
                return f;
        }
        var chrInd = this.chrRing.indexOf(chr) + 1;
        if (chrInd >= this.chrRing.length)
            chrInd = 0;
        return this.findNextFeature(this.chrRing[chrInd], 0, dir);
    } else {
        while (i >= 0) {
            var f = fa[i--];
            if (f.max < pos)
                return f;
        }
        var chrInd = this.chrRing.indexOf(chr) - 1;
        if (chrInd < 0)
            chrInd = this.chrRing.length - 1;
        return this.findNextFeature(this.chrRing[chrInd], 10000000000, dir);
    }
}

function MemStoreFeatureSource(source) {
    this.source = source;
    FeatureSourceBase.call(this);
    this.storeHolder = new Awaited();
    this.parser = dalliance_makeParser(source.payload);
    if (!this.parser) {
        throw "Unsupported memstore payload: " + source.payload;
    }

    var thisB = this;
    this._load(function(resp, err) {
        if (!resp) {
            thisB.error = err || "No data"
            thisB.storeHolder.provide(null);
        } else {
            var store = new MemStore();
            var features = [];
            var lines = resp.split('\n');

            var session = thisB.parser.createSession(function(f) {features.push(f)});
            for (var li = 0; li < lines.length; ++li) {
                var line = lines[li];
                if (line.length > 0) {
                    session.parse(line);
                }
            }
            session.flush();

            store.addFeatures(features);

            thisB.storeHolder.provide(store);
        }
    });
}

MemStoreFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

MemStoreFeatureSource.prototype._load = function(callback) {
    if (this.source.blob) {
        var r = new FileReader();
        r.onloadend = function() {
            return callback(r.result, r.error);
        }
        r.readAsText(this.source.blob);
    } else {
        if (this.source.credentials)
            var opts = {credentials : this.source.credentials};
        textXHR(this.source.uri, callback, opts);
    }
}

MemStoreFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, cnt) {
    var thisB = this;
    this.storeHolder.await(function(store) {
        if (store) {
            var f = store.fetch(chr, min, max);
            return cnt(null, f, 100000000);
        } else {
            return cnt(thisB.error)
        }
    });
}

MemStoreFeatureSource.prototype.getStyleSheet = function(callback) {
    if (this.parser && this.parser.getStyleSheet)
        this.parser.getStyleSheet(callback)
}

MemStoreFeatureSource.prototype.getDefaultFIPs = function(callback) {
    if (this.parser && this.parser.getDefaultFIPs)
        this.parser.getDefaultFIPs(callback);
}

MemStoreFeatureSource.prototype.getScales = function() {
    return 100000000;
}

MemStoreFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {
    var thisB = this;
    this.storeHolder.await(function(store) {
        if (store) {
            return callback(store.findNextFeature(chr, pos, dir));
        } else {
            return callback(null, thisB.error);
        }
    });
}


MemStoreFeatureSource.prototype.capabilities = function() {
    var caps = {leap: true};
    return caps;
}

dalliance_registerSourceAdapterFactory('memstore', function(source) {
    return {features: new MemStoreFeatureSource(source)};
});

},{"./das":10,"./sourceadapters":34,"./utils":49}],26:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// memstore.js
//

function formatLongInt(n) {
    return (n|0).toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',')
}

function formatQuantLabel(v) {
    var t = '' + v;
    var dot = t.indexOf('.');
    if (dot < 0) {
        return t;
    } else {
        var dotThreshold = 2;
        if (t.substring(0, 1) == '-') {
            ++dotThreshold;
        }

        if (dot >= dotThreshold) {
            return t.substring(0, dot);
        } else {
            return t.substring(0, dot + 2);
        }
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        formatLongInt: formatLongInt,
        formatQuantLabel: formatQuantLabel
    };
}
},{}],27:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// overlay.js: featuresources composed from multiple underlying sources
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
    var arrayIndexOf = utils.arrayIndexOf;
}

function OverlayFeatureSource(sources, opts) {
    this.sources = sources;
    this.opts = opts || {};
    this.activityListeners = [];
    this.readinessListeners = [];
    this.changeListeners = [];
    this.business = [];
    this.readiness = [];

    for (var i = 0; i < this.sources.length; ++i) {
        this.initN(i);
    }

    if (typeof(opts.merge) === 'function') {
        this.merge = opts.merge;
    } else if (opts.merge == 'concat') {
        this.merge = OverlayFeatureSource_merge_concat;
    } else if (opts.merge == 'alternates') {
        this.merge = OverlayFeatureSource_merge_concat;
        this.filterDispatchOnMethod = true;
    } else {
        this.merge = OverlayFeatureSource_merge_byKey;
    }
}

OverlayFeatureSource.prototype.initN = function(n) {
    var s = this.sources[n];
    var thisB = this;
    this.business[n] = 0;

    if (s.addActivityListener) {
        s.addActivityListener(function(b) {
            thisB.business[n] = b;
            thisB.notifyActivity();
        });
    }
    if (s.addChangeListener) {
        s.addChangeListener(function() {
            thisB.notifyChange();
        });
    }
    if (s.addReadinessListener) {
        s.addReadinessListener(function(r) {
            thisB.readiness[n] = r;
            thisB.notifyReadiness();
        });
    }
}

OverlayFeatureSource.prototype.addReadinessListener = function(l) {
    this.readinessListeners.push(l);
    this.notifyReadinessListener(l);
}

OverlayFeatureSource.prototype.removeReadinessListener = function(l) {
    var idx = arrayIndexOf(this.readinessListeners, l);
    if (idx >= 0) {
        this.readinessListeners.splice(idx, 1);
    }
}

OverlayFeatureSource.prototype.notifyReadiness = function() {
    for (var i = 0; i < this.readinessListeners.length; ++i) {
        this.notifyReadinessListener(this.readinessListeners[i]);
    }
}

OverlayFeatureSource.prototype.notifyReadinessListener = function(l) {
    var r = null;
    for (var i = 0; i < this.readiness.length; ++i) {
        if (this.readiness[i] != null) {
            r = this.readiness[i]; break;
        }
    }
    try {
        l(r);
    } catch (e) {
        console.log(e);
    }
}

OverlayFeatureSource.prototype.addActivityListener = function(l) {
    this.activityListeners.push(l);
}

OverlayFeatureSource.prototype.removeActivityListener = function(l) {
    var idx = arrayIndexOf(this.activityListeners, l);
    if (idx >= 0) {
        this.activityListeners.splice(idx, 1);
    }
}

OverlayFeatureSource.prototype.notifyActivity = function() {
    var busy = 0;
    for (var i = 0; i < this.business.length; ++i) {
        busy += this.business[i];
    }

    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](busy);
        } catch (e) {
            console.log(e);
        }
    }
}

OverlayFeatureSource.prototype.addChangeListener = function(listener) {
    this.changeListeners.push(listener);
}

OverlayFeatureSource.prototype.removeChangeListener = function(l) {
    var idx = arrayIndexOf(this.changeListeners, l);
    if (idx >= 0) {
        this.changeListeners.splice(idx, 1);
    }
}

OverlayFeatureSource.prototype.notifyChange = function() {
    for (var li = 0; li < this.changeListeners.length; ++li) {
        try {
            this.changeListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
}

OverlayFeatureSource.prototype.getScales = function() {
    return this.sources[0].getScales();
}

OverlayFeatureSource.prototype.getStyleSheet = function(callback) {
    return this.sources[0].getStyleSheet(callback);
}

OverlayFeatureSource.prototype.capabilities = function() {
    var caps = {};
    var s0 = this.sources[0];
    if (s0.capabilities) 
        caps = shallowCopy(s0.capabilities());

    for (var i = 1; i < this.sources.length; ++i) {
        var si = this.sources[i];
        if (si.capabilities) {
            var co = si.capabilities();
            if (co.search) {
                caps.search = co.search;
            }
        }
    }

    return caps;
}

OverlayFeatureSource.prototype.search = function(query, callback) {
    for (var i = 0; i < this.sources.length; ++i) {
        if (_sourceAdapterIsCapable(this.sources[i], 'search')) {
            return this.sources[i].search(query, callback);
        }
    }
}

OverlayFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback, styleFilters) {
    var sources;
    if (this.filterDispatchOnMethod) {
        sources = [];
        var sfl = styleFilters.list();
        for (var si = 0; si < this.sources.length; ++si) {
            var source = this.sources[si];
            for (var fi = 0; fi < sfl.length; ++fi) {
                var filter = sfl[fi];
                if (!filter.method || filter.method == source.name) {
                    sources.push(source);
                    break;
                }
            }
        }
    } else {
        sources = this.sources;
    }

    var baton = new OverlayBaton(this, callback, sources);
    for (var si = 0; si < sources.length; ++si) {
	   this.fetchN(baton, si, sources[si], chr, min, max, scale, types, pool, styleFilters);
    }
}

OverlayFeatureSource.prototype.fetchN = function(baton, si, source, chr, min, max, scale, types, pool, styleFilters) {
    // FIXME should we try to prune styleFilters?
    source.fetch(chr, min, max, scale, types, pool, function(status, features, scale) {
	   return baton.completed(si, status, features, scale);
    }, styleFilters);
}

OverlayFeatureSource.prototype.quantFindNextFeature = function(chr, pos, dir, threshold, callback) {
    return this.sources[0].quantFindNextFeature(chr, pos, dir, threshold, callback);
}

OverlayFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {
    return this.sources[0].findNextFeature(chr, pos, dir, callback);
}

function OverlayBaton(source, callback, sources) {
    this.source = source;
    this.callback = callback;
    this.sources = sources;
    this.count = sources.length;

    this.returnCount = 0;
    this.statusCount = 0;
    this.returns = [];
    this.features = []
    this.statuses = [];
    this.scale = null;
}

OverlayBaton.prototype.completed = function(index, status, features, scale) {
    if (this.scale == null || index == 0) 
	   this.scale = scale;

    if (this.returns[index])
	   throw 'Multiple returns for source ' + index;

    this.returns[index] = true;
    this.returnCount++;

    this.features[index] = features;

    if (status) {
    	this.statuses[index] = status;
    	this.statusCount++;
    }


    if (this.returnCount == this.count) {
    	if (this.statusCount > 0) {
    	    var message = '';
    	    for (var si = 0; si < this.count; ++si) {
        		var s = this.statuses[si];
        		if (s) {
        		    if (message.length > 0) 
        			message += ', ';
        		    message += s;
        		}
    	    }
    	    return this.callback(message, null, this.scale);
    	} else {
    	    this.callback(null, this.source.merge(this.features, this.sources), this.scale);
    	}
    }
}

OverlayFeatureSource.prototype.getDefaultFIPs = function(callback) {
    for (var si = 0; si < this.sources.length; ++si) {
        var s = this.sources[si];
        if (s.getDefaultFIPs)
            s.getDefaultFIPs(callback);
    }
}

OverlayFeatureSource.prototype.keyForFeature = function(feature) {
    return '' + feature.min + '..' + feature.max;
}

function OverlayFeatureSource_merge_byKey(featureSets) {
    var omaps = [];

    for (var fsi = 1; fsi < featureSets.length; ++fsi) {
        var om = {};
        var of = featureSets[fsi];
        for (var fi = 0; fi < of.length; ++fi) {
    	   om[this.keyForFeature(of[fi])] = of[fi];
        }
        omaps.push(om);
    }


    var mf = [];
    var fl = featureSets[0];
    for (var fi = 0; fi < fl.length; ++fi) {
    	var f = fl[fi];

        for (var oi = 0; oi < omaps.length; ++oi) {
            var om = omaps[oi];
        	of = om[this.keyForFeature(f)]
        	if (of) {
                for (var k in of) {
                    if (k === 'score') {
                        f.score2 = of.score;
                    } else if (k === 'min' || k === 'max' || k === 'segment' || k === '_cachedStyle') {
                        // do nothing
                    } else {
                        f[k] = of[k];
                    }
                }
        	}
        }
    	mf.push(f);
    }
    return mf;
}

function OverlayFeatureSource_merge_concat(featureSets, sources) {
    var features = [];
    for (var fsi = 0; fsi < featureSets.length; ++fsi) {
        var fs = featureSets[fsi];
        var name = sources[fsi].name;
        for (var fi = 0; fi < fs.length; ++fi) {
            var f = fs[fi];
            f.method = name;
            features.push(f);
        }
    }
    return features;
}

function _sourceAdapterIsCapable(s, cap) {
    if (!s.capabilities)
        return false;
    else 
        return s.capabilities()[cap];
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        OverlayFeatureSource: OverlayFeatureSource
    };
}



},{"./utils":49}],28:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// bedwig.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;
    var readInt = bin.readInt;

    var bbi = require('./bigwig');
    var BIG_WIG_MAGIC = bbi.BIG_WIG_MAGIC;
    var BIG_BED_MAGIC = bbi.BIG_BED_MAGIC;

    var lh3utils = require('./lh3utils');
    var unbgzf = lh3utils.unbgzf;

    var bam = require('./bam');
    var BAM_MAGIC = bam.BAM_MAGIC;
    var BAI_MAGIC = bam.BAI_MAGIC;

    var tbi = require('./tabix');
    var TABIX_MAGIC = tbi.TABIX_MAGIC;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

function probeResource(source, listener, retry) {
    var BED_REGEXP = new RegExp('^\\w+\\s[0-9]+\\s[0-9]+.*$');
    var KV_REGEXP=/([^=]+)=\"?([^\"]+)\"?/;
    var VCFHEAD_RE = /^##\s*fileformat=VCFv4\..+/;

    var fetchable;
    if (source.blob)
        fetchable = new BlobFetchable(source.blob);
    else if (source.transport == 'encode')
        fetchable = new EncodeFetchable(source.uri);
    else
        fetchable = new URLFetchable(source.uri, {credentials: source.credentials});

    fetchable.slice(0, 1<<16).salted().fetch(function(result, error) {
        if (!result) {
            if (!retry) {
                source.credentials = true;
                probeResource(source, listener, true)
            }

            return listener(source, "Couldn't fetch data");
        }

        var ba = new Uint8Array(result);
        var la = new Uint32Array(result, 0, 1);
        var magic = la[0];
        if (magic == BIG_WIG_MAGIC || magic == BIG_BED_MAGIC) {
            source.tier_type = 'bwg';
            var nameExtractPattern = new RegExp('/?([^/]+?)(.bw|.bb|.bigWig|.bigBed)?$');
            var match = nameExtractPattern.exec(source.uri || source.blob.name);
            if (match) {
                source.name = match[1];
            }

            return listener(source, null);
        } else if (magic == BAI_MAGIC) {
            source.tier_type = 'bai';
            return listener(source, null);
        } else if (ba[0] == 31 || ba[1] == 139) {
            var unc = unbgzf(result);
            var uncba = new Uint8Array(unc);
            magic = readInt(uncba, 0);
            if (magic == BAM_MAGIC) {
                source.tier_type = 'bam';
                var nameExtractPattern = new RegExp('/?([^/]+?)(.bam)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match) {
                    source.name = match[1];
                }

                return listener(source, null);
            } else if (magic == TABIX_MAGIC) {
                source.tier_type = 'tabix-index';
                return listener(source, null);
            } else if (magic == 0x69662323) {
                source.tier_type = 'tabix';
                source.payload = 'vcf';
                var nameExtractPattern = new RegExp('/?([^/]+?)(.vcf)?(.gz)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match) {
                    source.name = match[1];
                }

                return listener(source, null);
            } else {
                console.log('magic = ' + magic.toString(16));
               return listener(source, "Unsupported format");
            }
        } else {
            var text = String.fromCharCode.apply(null, ba);
            var lines = text.split("\n");

            if (lines.length > 0 && VCFHEAD_RE.test(lines[0])) {
                source.tier_type = 'memstore';
                source.payload = 'vcf';
                var nameExtractPattern = new RegExp('/?([^/]+?)(\.vcf)?$');
                var match = nameExtractPattern.exec(source.uri || source.blob.name);
                if (match && !source.name) {
                    source.name = match[1];
                }
                return listener(source, null);
            }

            for (var li = 0; li < lines.length; ++li) {
                var line = lines[li].replace('\r', '');
                if (line.length == 0) continue;

                if (line.indexOf('browser') == 0) continue;

                if (line.indexOf('track') == 0) {
                    var maybeType = 'bed';
                    var toks = line.split(/\s/);
                    for (var ti = 1; ti < toks.length; ++ti) {
                        var m = KV_REGEXP.exec(toks[ti]);
                        if (m) {
                            if (m[1] == 'type' && m[2] == 'wiggle_0') {
                                maybeType = 'wig'
                            } else if (m[0] == 'name') {
                                source.name = m[2];
                            }
                        }
                    }

                    finishProbeBedWig(source, maybeType);
                    return listener(source, null);
                }

                if (line.indexOf('fixedStep') == 0) {
                    finishProbeBedWig(source, 'wig');
                    return listener(source, null);
                }

                if (line.indexOf('variableStep') == 0) {
                    finishProbeBedWig(source, 'wig');
                    return listener(source, null);
                }

                if (BED_REGEXP.test(line)) {
                    finishProbeBedWig(source, null);
                    return listener(source, null);
                }

                break;
            }

            return listener(source, "Unsupported format");
        }
    }, {timeout: 1500});  // Timeout to catch mixed-origin case on Chromium.
}

function finishProbeBedWig(source, maybeType) {
    source.tier_type = 'memstore';
    var nameExtractPattern = new RegExp('/?([^/]+?)(.(bed|wig))?$');
    var match = nameExtractPattern.exec(source.uri || source.blob.name);
    if (match) {
        if (!source.name)
            source.name = match[1];
        if (!maybeType && match[3]) {
            maybeType = match[3];
        }
    }
    source.payload = maybeType || 'bed';
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        probeResource: probeResource
    };
}

},{"./bam":1,"./bigwig":3,"./bin":4,"./encode":12,"./lh3utils":24,"./tabix":41}],29:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// sample.js: downsampling of quantitative features
//

"use strict";

if (typeof(require) !== 'undefined') {
    var das = require('./das');
    var DASFeature = das.DASFeature;

    var parseCigar = require('./cigar').parseCigar;

    var shallowCopy = require('./utils').shallowCopy;
}

var __DS_SCALES = [1, 2, 5];

function ds_scale(n) {
    return __DS_SCALES[n % __DS_SCALES.length] * Math.pow(10, (n / __DS_SCALES.length)|0);
}


function DSBin(scale, min, max) {
    this.scale = scale;
    this.tot = 0;
    this.cnt = 0;
    this.hasScore = false;
    this.min = min; this.max = max;
    this.features = [];
}

function _featureOrder(a, b) {
    if (a.min < b.min) {
        return -1;
    } else if (a.min > b.min) {
        return 1;
    } else if (a.max < b.max) {
        return -1;
    } else if (b.max > a.max) {
        return 1;
    } else {
        return 0;
    }
}

DSBin.prototype.score = function() {
    if (this.cnt == 0) {
        return 0;
    } else if (this.hasScore) {
        return this.tot / this.cnt;
    } else {
        var features = this.features;
        features.sort(_featureOrder);

        var maxSeen = -10000000000;
        var cov=0, lap=0;

        for (var fi = 1; fi < features.length; ++fi) {
            var f = features[fi];
            var lMin = Math.max(f.min, this.min);
            var lMax = Math.min(f.max, this.max);
            lap += (lMax - lMin + 1);

            if (lMin > maxSeen) {
                cov += lMax - lMin + 1;
                maxSeen = lMax;
            } else {
                if (lMax > maxSeen) {
                    cov += (lMax - maxSeen);
                    maxSeen = lMax;
                }
            }
        }

        if (cov > 0)
            return (1.0 * lap) / cov;
        else
            return 0;
    }
}

DSBin.prototype.feature = function(f) {
    if (f.score !== undefined) {
        this.tot += f.score;
        this.hasScore = true
    }

    ++this.cnt;
    this.features.push(f);
}

function downsample(features, targetRez) {
    var sn = 0;
    while (ds_scale(sn + 1) < targetRez) {
        ++sn;
    }
    var scale = ds_scale(sn);

    var binTots = [];
    var maxBin = -10000000000;
    var minBin = 10000000000;
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (f.groups && f.groups.length > 0) {
            // Don't downsample complex features (?)
            return features;
        }

        var minLap = (f.min / scale)|0;
        var maxLap = (f.max / scale)|0;
        maxBin = Math.max(maxBin, maxLap);
        minBin = Math.min(minBin, minLap);
        for (var b = minLap; b <= maxLap; ++b) {
            var bm = binTots[b];
            if (!bm) {
                bm = new DSBin(scale, b * scale, (b + 1) * scale - 1);
                binTots[b] = bm;
            }
            bm.feature(f);
        }
    }

    var sampledFeatures = [];
    for (var b = minBin; b <= maxBin; ++b) {
        var bm = binTots[b];
        if (bm) {
            var f = new DASFeature();
            f.segment = features[0].segment;
            f.min = (b * scale) + 1;
            f.max = (b + 1) * scale;
            f.score = bm.score();
            f.type = 'density';
            sampledFeatures.push(f);
        }
    }

    var afterDS = Date.now();
    return sampledFeatures;
}

/** Data structure to store information for
a base position:

pos: position of the base.
*/
function BaseBin(pos) {

    this._pos = pos;
    this._bases = {};
    this._totalCount = 0;
}

/** Keep record for incidence of a base,
with related qual score and strand for a position.

Params
    base: base (e.g A, T, G, C, N) observed at position.
    qual: numeric quality score.
    strand: '+' or '-'.
*/
BaseBin.prototype.recordBase = function(base, qual, strand) {
    if (!this._bases[base]) {
        var strandComposition = {'+': 0, '-': 0};
        strandComposition[strand]++;
        this._bases[base] = {
            cnt: 1,
            totalQual: qual,
            strandCnt: strandComposition
        };
    } else {
        var baseComposition = this._bases[base];
        baseComposition.cnt++;
        baseComposition.totalQual += qual;
        baseComposition.strandCnt[strand]++;
    }
    this._totalCount++;
};

/** Returns count of total number of bases observed at position */
BaseBin.prototype.totalCount = function() {return this._totalCount;};

/** Returns the base position */
BaseBin.prototype.pos = function() {return this._pos;};

/** Creates a list of tag, info pairs in the form
[tag]=[info] for each base, for use in feature-popup */
BaseBin.prototype.infoList = function() {
    var info = [];
    var totalCount = this._totalCount;
    var totalCountStr = "Depth=" + totalCount.toString();
    info.push(totalCountStr);
    for (var base in this._bases) {
        var baseComposition = this._bases[base];
        var baseCnt = baseComposition.cnt;
        var basePercentage = (baseCnt * 100 / totalCount); 
        var plusStrandCnt = baseComposition.strandCnt['+'];
        var minusStrandCnt = baseComposition.strandCnt['-'];
        var meanQual = baseComposition.totalQual/baseCnt;

        var baseInfoString = [base, '=', baseCnt, ' (', basePercentage.toFixed(0), '%, ',
                              plusStrandCnt, ' +, ', minusStrandCnt, ' -, Qual: ', meanQual.toFixed(0), ')'];
        info.push(baseInfoString.join(''));
    }
    return info;
};

/** Return a list of objects for creating a
histogram showing composition of different bases at a
given location.

Current implementation is hacky: the logic involves
overlaying BoxGlyphs on top of each other, thus the score
is not meaningful, but only used to manipulate height.

Params:
  ref: reference base at position
  threshold: value between 0 and 1 representing min allele frequency
              below which the allele will be ignored in histogram.
              (interpreted as noise)
              Similar to 'allele threshold' parameter in IGV

Returns a list of objects containing 2 properties
    base: such as A, T, G, C, N, - (del)
    score: a numeric score for determining height of histogram
The list is ordered such that a preceeding object always have a
score >= the current object, and the ref base will be the last item.

Example: There are 50 T's and 40 A's (total depth = 90)
at a base where ref=A. The function will return
[T: 90, A: 40]. When creating a histogram with overlap,
this will give an appearance of 40 A's (bottom) and 50 T's (top):
#######
#  T  #
#  T  #
#  T  #
#  T  #
#  T  #
#######
#  A  #
#  A  #
#  A  #
#  A  #
#######
*/
BaseBin.prototype.baseScoreList = function(ref, threshold) {
    var baseScoreList = [];
    var totalCount = this._totalCount;
    var minCount = threshold * totalCount;
    for (var base in this._bases) {
        var baseCount = this._bases[base].cnt;
        if (baseCount < minCount || base == ref)
            continue;
        var baseScorePair = {base: base, score: totalCount};
        baseScoreList.push(baseScorePair);
        totalCount -= baseCount;
    }
    baseScoreList.push({base: ref, score: totalCount});
    return baseScoreList;
};

/** Generates an aligned read from the raw sequence of a BAM record
using given cigar string.

Params:
  rawseq: unaligned read sequence from Bam record
  rawquals: unaligned read quals from Bam record
  cigar: Bam cigar string from Bam record

Returns an object with 2 properties:
  seq: string containing aligned read
  quals: string containing printable-character representation
         of sequencing quality score
*/
function alignSeqUsingCigar(rawseq, rawquals, cigar) {
    var ops = parseCigar(cigar);
    var seq = [];
    var quals = [];
    var cursor = 0;
    for (var ci = 0; ci < ops.length; ++ci) {
        var co = ops[ci];
        if (co.op == 'M') {
            seq.push(rawseq.substr(cursor, co.cnt));
            quals.push(rawquals.substr(cursor, co.cnt));
            cursor += co.cnt;
        } else if (co.op == 'D') {
            for (var oi = 0; oi < co.cnt; ++oi) {
                seq.push('-');
                quals.push('Z');
            }
        } else if (co.op == 'I') {
            cursor += co.cnt;
        } else if (co.op == 'S') {
            cursor += co.cnt;
        } else {
            console.log('unknown cigop' + co.op);
        }
    }
    var processedSeq = {seq: seq.join(''), quals: quals.join('')};
    return processedSeq;
}

/** Constructs the reference sequence for a given window.

Params
    currentSequence: DasSequence object containing ref sequence
                     in current browser view.
    min, max: min and max position for window.

Returns a string containing the refseq, padded with 'N' where sequence is not
    available.
*/
function getRefSeq(currentSequence, min, max) {
    var refSeq = [];
    if (currentSequence) {
        var csStart = currentSequence.start|0;
        var csEnd = currentSequence.end|0;
        if (csStart <= max && csEnd >= min) {
            var sfMin = Math.max(min, csStart);
            var sfMax = Math.min(max, csEnd);

            for (var i = 0; i < sfMin - min; i++)
                refSeq.push('N');
            refSeq.push(currentSequence.seq.substr(sfMin - csStart, sfMax - sfMin + 1));
            for (var i = 0; i < max - sfMax; i++)
                refSeq.push('N');
        }
    }
    return refSeq.join('');
}

/** Constructs features necessary for a coverage track showing
base composition for BAM reads

Params
    features: a list of features from BAM records.
    currentRefSeq: a DASSequence object containing reference sequence.
    baseColors: an object mapping base to desired colors.

Returns a list of features of type base-coverage.
*/
function getBaseCoverage(features, currentRefSeq, baseColors) {
    var minBin = null;
    var maxBin = null;

    var allBins = [];

    // Populate BaseBins
    for (var fi = 0; fi < features.length; ++fi) {
        var f = features[fi];
        if (f.groups && f.groups.length > 0) {
            // Don't downsample complex features
            return features;
        }
        var processedSeq = alignSeqUsingCigar(f.seq, f.quals, f.cigar);
        var seq = processedSeq.seq;
        var quals = processedSeq.quals;
        var strand = f.orientation;
        var minForFeature = f.min || 0;
        var maxForFeature = f.max || 0;
        var ind = 0;

        for (var b = minForFeature; b <= maxForFeature; ++b) {
            var bm = allBins[b];
            if (!bm) {
                bm = new BaseBin(b);
                allBins[b] = bm;
            }
            var base = seq.charAt(ind);
            var qual = quals.charCodeAt(ind) - 33; // Generate numeric qual score
            bm.recordBase(base, qual, strand);
            ind++;
        }

        if (!minBin)
            minBin = minForFeature;
        else
            minBin = Math.min(minBin, minForFeature);
        if (!maxBin)
            maxBin = maxForFeature;
        else
            maxBin = Math.max(maxBin, maxForFeature);
    }

    // Generate coverage features
    var refSeq = getRefSeq(currentRefSeq, minBin, maxBin);
    var baseFeatures = [];
    var ind = 0;
    for (var b = minBin; b <= maxBin; ++b) {
        var bm = allBins[b];
        if (bm) {
            var f = new DASFeature();
            f.segment = features[0].segment;
            f.min = bm.pos();
            f.max = f.min;
            f.notes = [];
            f.notes = f.notes.concat(bm.infoList());
            f.type = 'base-coverage';
            f.suppressScore = true;
            if (refSeq) {
                var refBase = refSeq.charAt(ind);
                var refString = 'Ref=' + refBase;
                f.notes.unshift(refString);
                var baseScoreList = bm.baseScoreList(refBase, 0.2);
                // TODO: shift 0.2 threshold to a config parameter
                for (var i = 0; i < baseScoreList.length; i++) {
                    var base = baseScoreList[i].base;
                    var score = baseScoreList[i].score;
                    var fBase = shallowCopy(f);
                    fBase.score = score;
                    // Color by baseColor when mismatch occurs
                    // otherwise, BoxGlyph to COLOR1 in style
                    if (baseScoreList.length > 1 || base != refBase)
                        fBase.itemRgb = baseColors[base];

                    baseFeatures.push(fBase);
                }
            } else {
                // No refSeq, only show coverage height.
                baseFeatures.push(f);
            }
        }
        ind ++;
    }
    return baseFeatures;
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        downsample: downsample,
        getBaseCoverage: getBaseCoverage
    };
}

},{"./cigar":8,"./das":10,"./utils":49}],30:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// bin.js general binary data support
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;

    var connectTrix = require('./trix').connectTrix;
}

var REGION_PATTERN = /^([\d+,\w,\.,\_,\-]+):([0-9,\.]+?)([KkMmGg])?((-|\.\.)+([0-9,\.]+)([KkMmGg])?)?$/;

function parseLocCardinal(n, m) {
    var i = parseFloat(n.replace(/,/g, ''));
    if (m === 'k' || m === 'K') {
        return (i * 1000)|0;
    } else if (m == 'm' || m === 'M') {
        return (i * 1000000)|0;
    } else {
        return i|0;
    }
}

Browser.prototype.search = function(g, statusCallback) {
    var thisB = this;
    var m = REGION_PATTERN.exec(g);

    if (m) {
        var chr = m[1], start, end;
        if (m[6]) {
            start = parseLocCardinal(m[2],  m[3]);
            end = parseLocCardinal(m[6], m[7]);
        } else {
            var width = this.viewEnd - this.viewStart + 1;
            start = (parseLocCardinal(m[2], m[3]) - (width/2))|0;
            end = start + width - 1;
        }
        this.setLocation(chr, start, end, statusCallback);
    } else {
        if (!g || g.length == 0) {
            return false;
        }

        var searchCount = 0;
        var foundLatch = false;

        var searchCallback = function(found, err) {
            --searchCount;
            if (err) {
                return statusCallback(err);
            }

            if (!found) found = [];
            var min = 500000000, max = -100000000;
            var nchr = null;
            for (var fi = 0; fi < found.length; ++fi) {
                var f = found[fi];
            
                if (nchr == null) {
                    nchr = f.segment;
                }
                min = Math.min(min, f.min);
                max = Math.max(max, f.max);
            }

            if (!nchr) {
                if (searchCount == 0 && !foundLatch)
                    return statusCallback("no match for '" + g + "'");
            } else {
                foundLatch = true;
                thisB.highlightRegion(nchr, min, max);
            
                var padding = Math.max(2500, (0.3 * (max - min + 1))|0);
                thisB.setLocation(nchr, min - padding, max + padding, statusCallback);
            }
        }

        var doTrixSearch = function(tier, trix) {
            trix.lookup(g, function(result, status) {
                if (result == null || result.length < 2) {
                    return tier.featureSource.search(g, searchCallback);
                } else {
                    var hit = result[1].split(',')[0];
                    return tier.featureSource.search(hit, searchCallback);
                }
            });
        }

        if (this.searchEndpoint) {
            searchCount = 1;
            return this.doDasSearch(thisB.searchEndpoint, g, searchCallback);
        }

        for (var ti = 0; ti < this.tiers.length; ++ti) {
            (function(tier) {
                if (thisB.sourceAdapterIsCapable(tier.featureSource, 'search')) {
                    if (tier.dasSource.trixURI) {
                        ++searchCount;
                        if (tier.trix) {
                            doTrixSearch(tier, tier.trix);
                        } else {
                            connectTrix(new URLFetchable(tier.dasSource.trixURI), new URLFetchable(tier.dasSource.trixURI + 'x'), function(trix) {
                                tier.trix = trix;
                                doTrixSearch(tier, trix);
                            });
                        }
                    } else {
                        ++searchCount;
                        tier.featureSource.search(g, searchCallback);
                    }
                } else if (tier.dasSource.provides_search) {
                    ++searchCount;
                    thisB.doDasSearch(tier.dasSource, g, searchCallback);
                }
            })(this.tiers[ti]);
        }
    }
}

Browser.prototype.doDasSearch = function(source, g, searchCallback) {
    var thisB = this;
    source.features(null, {group: g, type: 'transcript'}, function(found) {
        if (!found) found = [];
        var min = 500000000, max = -100000000;
        var nchr = null;

        var found2 = [];
        for (var fi = 0; fi < found.length; ++fi) {
            var f = found[fi];
            
            if (f.label.toLowerCase() != g.toLowerCase()) {
                // ...because Dazzle can return spurious overlapping features.
                continue;
            }
            found2.push(f);
        }

        return searchCallback(found2);
    }, false);
}
},{"./bin":4,"./cbrowser":6,"./trix":47}],31:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2012
//
// sequence-draw.js: renderers for sequence-related data
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var formatLongInt = utils.formatLongInt;
    var makeElementNS = utils.makeElementNS;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;

    var nf = require('./numformats');
    var formatLongInt = nf.formatLongInt;
}

var MIN_TILE = 100;
var rulerTileColors = ['black', 'white'];

var steps = [1,2,5];


var NS_SVG = 'http://www.w3.org/2000/svg';


function tileSizeForScale(scale, min)
{
    if (!min) {
        min = MIN_TILE;
    }

    function ts(p) {
        return steps[p % steps.length] * Math.pow(10, (p / steps.length)|0);
    }
    var pow = steps.length;
    while (scale * ts(pow) < min) {
        ++pow;
    }
    return ts(pow);
}

function drawSeqTier(tier, seq) {
    var gc = tier.viewport.getContext('2d');
    var retina = tier.browser.retina && window.devicePixelRatio > 1;
    var desiredWidth = tier.browser.featurePanelWidth + 2000;
    if (retina) {
        desiredWidth *= 2;
    }
    var fpw = tier.viewport.width|0; // this.browser.featurePanelWidth;
    if (fpw < desiredWidth - 50) {
        tier.viewport.width = fpw = desiredWidth;
    }

    var height = 50;
    if (seq && seq.seq) {
        height += 25;
    }

    var canvasHeight = height;
    if (retina) 
        canvasHeight *= 2;

    tier.viewport.height = canvasHeight;
    tier.viewport.style.height = '' + height + 'px';
    tier.viewport.style.width = retina ? ('' + (fpw/2) + 'px') : ('' + fpw + 'px');
    tier.layoutHeight = height;
    tier.updateHeight();

    
    if (tier.background) {
        gc.fillStyle = tier.background;
        gc.fillRect(0, 0, fpw, tier.viewport.height);
    }
    if (retina) {
        gc.scale(2, 2);
    }

    gc.translate(1000,0);
    drawSeqTierGC(tier, seq, gc);
    tier.norigin = tier.browser.viewStart;
    tier.viewportHolder.style.left = '-1000px';
}

function drawSeqTierGC(tier, seq, gc)
{
    var scale = tier.browser.scale, knownStart = tier.browser.viewStart - (1000/scale)|0, knownEnd = tier.browser.viewEnd + (2000/scale), currentSeqMax = tier.browser.currentSeqMax;

    var seqTierMax = knownEnd;
    if (currentSeqMax > 0 && currentSeqMax < knownEnd) {
        seqTierMax = currentSeqMax;
    }
    var tile = tileSizeForScale(scale);
    var pos = Math.max(0, ((knownStart / tile)|0) * tile);
    
    var origin = tier.browser.viewStart;

    while (pos <= seqTierMax) {
		gc.fillStyle = ((pos / tile) % 2 == 0) ? 'white' : 'black';
		gc.strokeStyle = 'black';
		gc.fillRect((pos - origin) * scale,
			    8,
			    tile*scale,
			    3);
		gc.strokeRect((pos - origin) * scale,
			      8,
			      tile*scale,
			      3);

		gc.fillStyle = 'black';
		gc.fillText(formatLongInt(pos), ((pos - origin) * scale), 22);
		

		pos += tile;
    }

    if (seq && seq.seq) {
		for (var p = knownStart; p <= knownEnd; ++p) {
		    if (p >= seq.start && p <= seq.end) {
				var base = seq.seq.substr(p - seq.start, 1).toUpperCase();
				var color = tier.browser.baseColors[base];
				if (!color) {
		            color = 'gray';
				}

				gc.fillStyle = color;

				if (scale >= 8) {
                    var w = gc.measureText(base).width;
                    // console.log(scale-w);
				    gc.fillText(base, (p - origin) * scale + ((scale-w)*0.5) , 52);
				} else {
				    gc.fillRect((p - origin) * scale, 42, scale, 12); 
				}
		    }
		}
    }
}

function svgSeqTier(tier, seq) {
    var scale = tier.browser.scale, knownStart = tier.browser.viewStart - (1000/scale)|0, knownEnd = tier.browser.viewEnd + (2000/scale), currentSeqMax = tier.browser.currentSeqMax;

    var fpw = tier.viewport.width|0; 

    var seqTierMax = knownEnd;
    if (currentSeqMax > 0 && currentSeqMax < knownEnd) {
        seqTierMax = currentSeqMax;
    }
    var tile = tileSizeForScale(scale);
    var pos = Math.max(0, ((knownStart / tile)|0) * tile);
    
    var origin = tier.browser.viewStart;

    var  g = makeElementNS(NS_SVG, 'g', [], {fontSize: '8pt'}); 
    while (pos <= seqTierMax) {
    	g.appendChild(
    	    makeElementNS(
    		NS_SVG, 'rect',
    		null,
    		{x: (pos-origin)*scale,
    		 y: 8,
    		 width: tile*scale,
    		 height: 3,
    		 fill: ((pos / tile) % 2 == 0) ? 'white' : 'black',
    		 stroke: 'black'}));

    	g.appendChild(
    	    makeElementNS(
    		NS_SVG, 'text',
    		formatLongInt(pos),
    		{x: (pos-origin)*scale,
    		 y: 28,
    		 fill: 'black', stroke: 'none'}));
    	
    	pos += tile;
    }

    if (seq && seq.seq) {
    	for (var p = knownStart; p <= knownEnd; ++p) {
    	    if (p >= seq.start && p <= seq.end) {
        		var base = seq.seq.substr(p - seq.start, 1).toUpperCase();
        		var color = tier.browser.baseColors[base];
        		if (!color) {
                    color = 'gray';
        		}

        		if (scale >= 8) {
        		    g.appendChild(
        			makeElementNS(NS_SVG, 'text', base, {
        			    x: (0.5+p-origin)*scale,
        			    y: 52,
                        textAnchor: 'middle',
        			    fill: color}));
        		} else {
        		    g.appendChild(
        			makeElementNS(NS_SVG, 'rect', null, {
        			    x: (p - origin)*scale,
        			    y: 42,
        			    width: scale,
        			    height: 12,
        	            fill: color}));

        		}
    	    }
    	}
    } 

    return g;
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        drawSeqTier: drawSeqTier,
        drawSeqTierGC: drawSeqTierGC,
        svgSeqTier: svgSeqTier
    };
}

},{"./numformats":26,"./svg-utils":39,"./utils":49}],32:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// session.js
//

"use strict";

if (typeof(require) != 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var sc = require('./sourcecompare');
    var sourceDataURI = sc.sourceDataURI;
    var sourcesAreEqual = sc.sourcesAreEqual;

    var VERSION = require('./version');

    var utils = require('./utils');
    var miniJSONify = utils.miniJSONify;

    var sha1 = require('./sha1');
    var hex_sha1 = sha1.hex_sha1;
}

Browser.prototype.nukeStatus = function() {
    delete localStorage['dalliance.' + this.cookieKey + '.view-chr'];
    delete localStorage['dalliance.' + this.cookieKey + '.view-start'];
    delete localStorage['dalliance.' + this.cookieKey + '.view-end'];
    delete localStorage['dalliance.' + this.cookieKey + '.current-seq-length'];
    delete localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'];
    delete localStorage['dalliance.' + this.cookieKey + '.saved-zoom'];

    delete localStorage['dalliance.' + this.cookieKey + '.sources'];
    delete localStorage['dalliance.' + this.cookieKey + '.hubs'];
    delete localStorage['dalliance.' + this.cookieKey + '.version'];

    delete localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'];
    delete localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'];
    delete localStorage['dalliance.' + this.cookieKey + '.ruler-location'];
}

Browser.prototype.storeStatus = function() {
    this.storeViewStatus();
    this.storeTierStatus();
}

Browser.prototype.storeViewStatus = function() {
    if (!this.cookieKey || this.noPersist || this.noPersistView) {
        return;
    }

    localStorage['dalliance.' + this.cookieKey + '.view-chr'] = this.chr;
    localStorage['dalliance.' + this.cookieKey + '.view-start'] = this.viewStart|0;
    localStorage['dalliance.' + this.cookieKey + '.view-end'] = this.viewEnd|0
    localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'] = '' + this.isSnapZooming;
    localStorage['dalliance.' + this.cookieKey + '.saved-zoom'] = this.savedZoom;
    if (this.currentSeqMax) {
	   localStorage['dalliance.' + this.cookieKey + '.current-seq-length'] = this.currentSeqMax;
    }
}


Browser.prototype.storeTierStatus = function() {
    if (!this.cookieKey || this.noPersist) {
        return;
    }

    var currentSourceList = [];
    for (var t = 0; t < this.tiers.length; ++t) {
        var tt = this.tiers[t];
        var ts = tt.dasSource;
        if (!ts.noPersist) {
            currentSourceList.push({source: tt.dasSource, config: tt.config || {}});
        }
    }
    localStorage['dalliance.' + this.cookieKey + '.sources'] = JSON.stringify(currentSourceList);


    var coveredHubURLs = {};
    var currentHubList = [];
    for (var hi = 0; hi < this.hubObjects.length; ++hi) {
        var tdb = this.hubObjects[hi];
        var hc = {url: tdb.hub.url, genome: tdb.genome};
        if (tdb.credentials)
            hc.credentials = tdb.credentials;
        if (tdb.mapping)
            hc.mapping = tdb.mapping;
        coveredHubURLs[hc.url] = true;
        currentHubList.push(hc);
    }

    // Needed to handle hubs that failed to connect, or hubs that haven't
    // connected yet when we're called soon after startup.
    for (var hi = 0; hi < this.hubs.length; ++hi) {
        var hc = this.hubs[hi];
        if (typeof hc === 'string')
            hc = {url: hc};
        if (!coveredHubURLs[hc.url])
            currentHubList.push(hc);
    }

    localStorage['dalliance.' + this.cookieKey + '.hubs'] = JSON.stringify(currentHubList);

    localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'] = this.reverseScrolling;
    localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'] = this.reverseKeyScrolling;
    localStorage['dalliance.' + this.cookieKey + '.single-base-highlight'] = this.singleBaseHighlight;
    localStorage['dalliance.' + this.cookieKey + '.ruler-location'] = this.rulerLocation;

    localStorage['dalliance.' + this.cookieKey + '.export-ruler'] = this.exportRuler;
    localStorage['dalliance.' + this.cookieKey + '.export-highlights'] = this.exportHighlights;
    
    localStorage['dalliance.' + this.cookieKey + '.version'] = VERSION.CONFIG;
}

Browser.prototype.restoreStatus = function() {
    if (this.noPersist)
        return;
    
    var storedConfigVersion = localStorage['dalliance.' + this.cookieKey + '.version'];
    if (storedConfigVersion) {
        storedConfigVersion = storedConfigVersion|0;
    } else {
        storedConfigVersion = -100;
    }
    if (VERSION.CONFIG != storedConfigVersion) {
        return;
    }

    var storedConfigHash = localStorage['dalliance.' + this.cookieKey + '.configHash'] || '';
    var pageConfigHash = hex_sha1(miniJSONify({sources: this.sources, hubs: this.hubs}));
    if (pageConfigHash != storedConfigHash) {
        localStorage['dalliance.' + this.cookieKey + '.configHash'] = pageConfigHash;
        return;
    }

    var defaultSourcesByURI = {};
    for (var si = 0; si < this.sources.length; ++si) {
        var source = this.sources[si];
        if (!source)
            continue;

        var uri = sourceDataURI(source);
        var ul = defaultSourcesByURI[uri];
        if (!ul)
            defaultSourcesByURI[uri] = ul = [];
        ul.push(source);
        
    }

    if (!this.noPersistView) {
        var qChr = localStorage['dalliance.' + this.cookieKey + '.view-chr'];
        var qMin = localStorage['dalliance.' + this.cookieKey + '.view-start']|0;
        var qMax = localStorage['dalliance.' + this.cookieKey + '.view-end']|0;
        if (qChr && qMin && qMax) {
        	this.chr = qChr;
        	this.viewStart = qMin;
        	this.viewEnd = qMax;
        	
        	var csm = localStorage['dalliance.' + this.cookieKey + '.current-seq-length'];
        	if (csm) {
        	    this.currentSeqMax = csm|0;
        	}

            this.isSnapZooming = (localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom']) == 'true';

            var sz = parseFloat(localStorage['dalliance.' + this.cookieKey + '.saved-zoom']);
            if (typeof sz === 'number' && !isNaN(sz)) {
                this.savedZoom = sz;
            }
        }
    }

    var rs = localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'];
    this.reverseScrolling = (rs && rs == 'true');
    var rks = localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'];
    this.reverseKeyScrolling = (rks && rks == 'true');
    var sbh = localStorage['dalliance.' + this.cookieKey + '.single-base-highlight'];
    this.singleBaseHighlight = (sbh && sbh == 'true');
 
    var rl = localStorage['dalliance.' + this.cookieKey + '.ruler-location'];
    if (rl)
        this.rulerLocation = rl;

    var x = localStorage['dalliance.' + this.cookieKey + '.export-ruler'];
    if (x)
        this.exportRuler = (x === 'true');
    var x = localStorage['dalliance.' + this.cookieKey + '.export-highlights'];
    if (x)
        this.exportHighlights = (x === 'true');

    var sourceStr = localStorage['dalliance.' + this.cookieKey + '.sources'];
    if (sourceStr) {
	    var storedSources = JSON.parse(sourceStr);
        this.sources = [];
        this.restoredConfigs = [];
        for (var si = 0; si < storedSources.length; ++si) {
            var source = this.sources[si] = storedSources[si].source;
            this.restoredConfigs[si] = storedSources[si].config;
            var uri = sourceDataURI(source);
            var ul = defaultSourcesByURI[uri] || [];
            for (var osi = 0; osi < ul.length; ++osi) {    
                var oldSource = ul[osi];
                if (sourcesAreEqual(source, oldSource)) {
                    for (var k in oldSource) {
                        if (oldSource.hasOwnProperty(k) && 
                            (typeof(oldSource[k]) === 'function' || oldSource[k] instanceof Blob))
                        {
                            source[k] = oldSource[k];
                        }
                    }
                }
            }
        }
    }

    var hubStr = localStorage['dalliance.' + this.cookieKey + '.hubs'];
    if (hubStr) {
        this.hubs = JSON.parse(hubStr);
    }

    return true;
}

Browser.prototype.reset = function() {
    for (var i = this.tiers.length - 1; i >= 0; --i) {
       this.nn_removeTier({index: i}, true);
    }
    for (var i = 0; i < this.defaultSources.length; ++i) {
        var s = this.defaultSources[i];
        if (!s.disabled) 
            this.addTier(this.defaultSources[i]);
    }

    this.highlights.splice(0, this.highlights.length);

    this.setLocation(this.defaultChr, this.defaultStart, this.defaultEnd);
}

},{"./cbrowser":6,"./sha1":33,"./sourcecompare":35,"./utils":49,"./version":51}],33:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS 180-1
 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

 "use strict";

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }
function b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }
function any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }
function hex_hmac_sha1(k, d)
  { return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_sha1(k, d)
  { return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_sha1(k, d, e)
  { return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA1 of a raw string
 */
function rstr_sha1(s)
{
  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
}

/*
 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
 */
function rstr_hmac_sha1(key, data)
{
  var bkey = rstr2binb(key);
  if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  // try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  // try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var remainders = Array();
  var i, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. We stop when the dividend is zero.
   * All remainders are stored for later use.
   */
  while(dividend.length > 0)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[remainders.length] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  /* Append leading zero equivalents */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)))
  for(i = output.length; i < full_length; i++)
    output = encoding[0] + output;

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of big-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binb(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
  return output;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function binb_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = bit_rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

if (typeof(module) !== 'undefined') {
  module.exports = {
    b64_sha1: b64_sha1,
    hex_sha1: hex_sha1
  }
}

},{}],34:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// sourceadapters.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var tier = require('./tier');
    var DasTier = tier.DasTier;

    var utils = require('./utils')
    var Awaited = utils.Awaited;
    var arrayIndexOf = utils.arrayIndexOf;
    var shallowCopy = utils.shallowCopy;
    var resolveUrlToPage = utils.resolveUrlToPage;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;
    var DASFeature = das.DASFeature;
    var DASSequence = das.DASSequence;
    var DASLink = das.DASLink;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;

    var twoBit = require('./twoBit');
    var makeTwoBit = twoBit.makeTwoBit;

    var bbi = require('./bigwig');
    var makeBwg = bbi.makeBwg;

    var bam = require('./bam');
    var makeBam = bam.makeBam;
    var BamFlags = bam.BamFlags;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;

    var parseCigar = require('./cigar').parseCigar;

    var OverlayFeatureSource = require('./overlay').OverlayFeatureSource;

    var JBrowseStore = require('./jbjson').JBrowseStore;

    var Chainset = require('./chainset').Chainset;

    var style = require('./style');
    var StyleFilterSet = style.StyleFilterSet;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

var __dalliance_sourceAdapterFactories = {};

function dalliance_registerSourceAdapterFactory(type, factory) {
    __dalliance_sourceAdapterFactories[type] = factory;
};


var __dalliance_parserFactories = {};

function dalliance_registerParserFactory(type, factory) {
    __dalliance_parserFactories[type] = factory;
};

function dalliance_makeParser(type) {
    if (__dalliance_parserFactories[type]) {
        return __dalliance_parserFactories[type](type);
    }
};


DasTier.prototype.initSources = function() {
    var thisTier = this;

    var sources = this.browser.createSources(this.dasSource);
    this.featureSource = sources.features || new DummyFeatureSource();
    this.sequenceSource = sources.sequence;

    if (this.featureSource && this.featureSource.addChangeListener) {
        this.featureSource.addChangeListener(function() {
            thisTier.browser.refreshTier(thisTier);
        });
    }
}

Browser.prototype.createSources = function(config) {
    var sources = this.sourceCache.get(config);
    if (sources)
        return sources;

    var fs, ss;

    if (config.tier_type == 'sequence' || config.twoBitURI || config.twoBitBlob) {
        if (config.twoBitURI || config.twoBitBlob) {
            ss = new TwoBitSequenceSource(config);
        } else {
            ss = new DASSequenceSource(config);
        }
    } else if (config.tier_type && __dalliance_sourceAdapterFactories[config.tier_type]) {
        var saf = __dalliance_sourceAdapterFactories[config.tier_type];
        var ns = saf(config);
        fs = ns.features;
        ss = ns.sequence;
    } else if (config.bwgURI || config.bwgBlob) {
        var worker = this.getWorker();
        if (worker)
            fs = new RemoteBWGFeatureSource(config, worker);
        else
            fs = new BWGFeatureSource(config);
    } else if (config.bamURI || config.bamBlob) {
        var worker = this.getWorker();
        if (worker)
            fs = new RemoteBAMFeatureSource(config, worker);
        else
            fs = new BAMFeatureSource(config);
    } else if (config.jbURI) {
        fs = new JBrowseFeatureSource(config);
    } else if (config.uri || config.features_uri) {
        fs = new DASFeatureSource(config);
    }

    if (config.overlay) {
        var sources = [];
        if (fs)
            sources.push(new CachingFeatureSource(fs));

        for (var oi = 0; oi < config.overlay.length; ++oi) {
            var cs = this.createSources(config.overlay[oi]);
            if (cs && cs.features)
                sources.push(cs.features);
        }
        fs = new OverlayFeatureSource(sources, config);
    }

    if (config.sequenceAliases) {
        fs = new MappedFeatureSource(fs, new Chainset({type: 'alias', sequenceAliases: config.sequenceAliases}));
    }

    if (config.mapping) {
        fs = new MappedFeatureSource(fs, this.chains[config.mapping]);
    }

    if (config.name && fs && !fs.name) {
        fs.name = config.name;
    }

    if (fs != null) {
        fs = new CachingFeatureSource(fs);
    }

    if (fs != null || ss != null) {
        sources = {
            features: fs,
            sequence: ss
        };
        this.sourceCache.put(config, sources);
    }

    return sources;
}

DasTier.prototype.fetchStylesheet = function(cb) {
    var ssSource;
    // Somewhat ugly workaround for the special case of DAS sources...
    if (this.dasSource.stylesheet_uri || (
        !this.dasSource.tier_type &&
        !this.dasSource.bwgURI &&
        !this.dasSource.bwgBlob &&
        !this.dasSource.bamURI &&
        !this.dasSource.bamBlob &&
        !this.dasSource.twoBitURI &&
        !this.dasSource.twoBitBlob &&
        !this.dasSource.jbURI &&
        !this.dasSource.overlay))
    {
        ssSource = new DASFeatureSource(this.dasSource);
    } else {
        ssSource = this.getSource();
    }
    ssSource.getStyleSheet(cb);
}

var __cfs_id_seed = 0;

function CachingFeatureSource(source) {
    var thisB = this;

    this.source = source;
    this.cfsid = 'cfs' + (++__cfs_id_seed);
    if (source.name) {
        this.name = source.name;
    }
    if (source.addChangeListener) {
        source.addChangeListener(function() {
            thisB.cfsid = 'cfs' + (++__cfs_id_seed);
        });
    }
}

CachingFeatureSource.prototype.addReadinessListener = function(listener) {
    if (this.source.addReadinessListener)
        return this.source.addReadinessListener(listener);
    else
        listener(null);
}

CachingFeatureSource.prototype.removeReadinessListener = function(listener) {
    if (this.source.removeReadinessListener)
        return this.source.removeReadinessListener(listener);
}

CachingFeatureSource.prototype.search = function(query, callback) {
    if (this.source.search)
        return this.source.search(query, callback);
}

CachingFeatureSource.prototype.getDefaultFIPs = function(callback) {
    if (this.source.getDefaultFIPs)
        return this.source.getDefaultFIPs(callback); 
}

CachingFeatureSource.prototype.getStyleSheet = function(callback) {
    this.source.getStyleSheet(callback);
}

CachingFeatureSource.prototype.getScales = function() {
    return this.source.getScales();
}

CachingFeatureSource.prototype.addActivityListener = function(l) {
    if (this.source.addActivityListener) {
        this.source.addActivityListener(l);
    }
}

CachingFeatureSource.prototype.removeActivityListener = function(l) {
    if (this.source.removeActivityListener) {
        this.source.removeActivityListener(l);
    }
}

CachingFeatureSource.prototype.addChangeListener = function(l) {
    if (this.source.addChangeListener)
        this.source.addChangeListener(l);
}

CachingFeatureSource.prototype.removeChangeListener = function(l) {
    if (this.source.removeChangeListener)
        this.source.removeChangeListener(l);
}

CachingFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {
    this.source.findNextFeature(chr, pos, dir, callback);
}

CachingFeatureSource.prototype.quantFindNextFeature = function(chr, pos, dir, threshold, callback) {
    this.source.quantFindNextFeature(chr, pos, dir, threshold, callback);
}

CachingFeatureSource.prototype.capabilities = function() {
    if (this.source.capabilities) {
        return this.source.capabilities();
    } else {
        return {};
    }
}

CachingFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback, styleFilters) {
    if (!pool) {
        throw Error('Fetch pool is null');
    }

    var self = this;
    var cacheKey = this.cfsid;

    var awaitedFeatures = pool.awaitedFeatures[cacheKey];
    if (awaitedFeatures && awaitedFeatures.started) {
        if (awaitedFeatures.styleFilters.doesNotContain(styleFilters)) {
            // console.log('Fetch already started with wrong parameters, skipping cache.');
            self.source.fetch(chr, min, max, scale, types, pool, callback, styleFilters);
            return;
        }
    } else if (awaitedFeatures) {
        awaitedFeatures.styleFilters.addAll(styleFilters);
    } else {
        awaitedFeatures = new Awaited();
        awaitedFeatures.styleFilters = styleFilters;
        pool.awaitedFeatures[cacheKey] = awaitedFeatures;

        pool.requestsIssued.then(function() {
            awaitedFeatures.started = true;
            self.source.fetch(
                chr, 
                min, 
                max, 
                scale, 
                awaitedFeatures.styleFilters.typeList(), 
                pool, 
                function(status, features, scale, coverage) {
                    if (!awaitedFeatures.res)
                        awaitedFeatures.provide({status: status, features: features, scale: scale, coverage: coverage});
                }, 
                awaitedFeatures.styleFilters);
        }).catch(function(err) {
            console.log(err);
        });
    } 

    awaitedFeatures.await(function(af) {
        callback(af.status, af.features, af.scale, af.coverage);
    });
}
    
function FeatureSourceBase() {
    this.busy = 0;
    this.activityListeners = [];
    this.readinessListeners = [];
    this.readiness = null;
}

FeatureSourceBase.prototype.addReadinessListener = function(listener) {
    this.readinessListeners.push(listener);
    listener(this.readiness);
}

FeatureSourceBase.prototype.removeReadinessListener = function(listener) {
    var idx = arrayIndexOf(this.readinessListeners, listener);
    if (idx >= 0) {
        this.readinessListeners.splice(idx, 1);
    }
}

FeatureSourceBase.prototype.notifyReadiness = function() {
    for (var li = 0; li < this.readinessListeners.length; ++li) {
        try {
            this.readinessListeners[li](this.readiness);
        } catch (e) {
            console.log(e);
        }
    }
}

FeatureSourceBase.prototype.addActivityListener = function(listener) {
    this.activityListeners.push(listener);
}

FeatureSourceBase.prototype.removeActivityListener = function(listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0) {
        this.activityListeners.splice(idx, 1);
    }
}

FeatureSourceBase.prototype.notifyActivity = function() {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
}

FeatureSourceBase.prototype.getScales = function() {
    return null;
}

FeatureSourceBase.prototype.fetch = function(chr, min, max, scale, types, pool, cnt) {
    return cnt(null, [], 1000000000);
}

FeatureSourceBase.prototype.getStyleSheet = function(callback) {
    var stylesheet = new DASStylesheet();
    var defStyle = new DASStyle();
    defStyle.glyph = 'BOX';
    defStyle.BGCOLOR = 'blue';
    defStyle.FGCOLOR = 'black';
    stylesheet.pushStyle({type: 'default'}, null, defStyle);
    return callback(stylesheet);
}



function DASFeatureSource(dasSource) {
    this.dasSource = new DASSource(dasSource);
    this.busy = 0;
    this.activityListeners = [];
}

DASFeatureSource.prototype.addActivityListener = function(listener) {
    this.activityListeners.push(listener);
}

DASFeatureSource.prototype.removeActivityListener = function(listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0)
        this.activityListeners.splice(idx, 1);
}


DASFeatureSource.prototype.notifyActivity = function() {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
}

DASFeatureSource.prototype.getStyleSheet = function(callback) {
    this.dasSource.stylesheet(function(stylesheet) {
	callback(stylesheet);
    }, function() {
	callback(null, "Couldn't fetch DAS stylesheet");
    });
}

DASFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {
    if (types && types.length == 0) {
        callback(null, [], scale);
        return;
    }

    if (!this.dasSource.uri && !this.dasSource.features_uri) {
        // FIXME should this be making an error callback???
        return;
    }

    if (this.dasSource.dasStaticFeatures && this.cachedStaticFeatures) {
        return callback(null, this.cachedStaticFeatures, this.cachedStaticScale);
    }

    var tryMaxBins = (this.dasSource.maxbins !== false);
    var fops = {
        type: types
    };
    if (tryMaxBins) {
        fops.maxbins = 1 + (((max - min) / scale) | 0);
    }
    
    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();

    this.dasSource.features(
        new DASSegment(chr, min, max),
        fops,
        function(features, status) {
            
            thisB.busy--;
            thisB.notifyActivity();

            var retScale = scale;
            if (!tryMaxBins) {
                retScale = 0.1;
            }
            if (!status && thisB.dasSource.dasStaticFeatures) {
                thisB.cachedStaticFeatures = features;
                thisB.cachedStaticScale = retScale;
            }
            callback(status, features, retScale);
        }
    );
}

DASFeatureSource.prototype.findNextFeature = this.sourceFindNextFeature = function(chr, pos, dir, callback) {
    if (this.dasSource.capabilities && arrayIndexOf(this.dasSource.capabilities, 'das1:adjacent-feature') >= 0) {
        var thisB = this;
        if (this.dasAdjLock) {
            return console.log('Already looking for a next feature, be patient!');
        }
        this.dasAdjLock = true;
        var fops = {
            adjacent: chr + ':' + (pos|0) + ':' + (dir > 0 ? 'F' : 'B')
        }
        var types = thisTier.getDesiredTypes(thisTier.browser.scale);
        if (types) {
            fops.types = types;
        }
        thisTier.dasSource.features(null, fops, function(res) {
            thisB.dasAdjLock = false;
            if (res.length > 0 && res[0] != null) {
                callback(res[0]);
            }
        });
    }
};

function DASSequenceSource(dasSource) {
    this.dasSource = new DASSource(dasSource);
    this.awaitedEntryPoints = new Awaited();

    var thisB = this;
    this.dasSource.entryPoints(
        function(ep) {
            thisB.awaitedEntryPoints.provide(ep);
        });
}


DASSequenceSource.prototype.fetch = function(chr, min, max, pool, callback) {
    this.dasSource.sequence(
        new DASSegment(chr, min, max),
        function(seqs) {
            if (seqs.length == 1) {
                return callback(null, seqs[0]);
            } else {
                return callback("Didn't get sequence");
            }
        }
    );
}

DASSequenceSource.prototype.getSeqInfo = function(chr, cnt) {
    this.awaitedEntryPoints.await(function(ep) {
        for (var epi = 0; epi < ep.length; ++epi) {
            if (ep[epi].name == chr) {
                return cnt({length: ep[epi].end});
            }
        }
        return cnt();
    });
}
    

function TwoBitSequenceSource(source) {
    var thisB = this;
    this.source = source;
    this.twoBit = new Awaited();
    var data;
    if (source.twoBitURI) {
        data = new URLFetchable(source.twoBitURI);
    } else if (source.twoBitBlob) {
        data = new BlobFetchable(source.twoBitBlob);
    } else {
        throw Error("No twoBitURI or twoBitBlob parameter");
    }

    makeTwoBit(data, function(tb, error) {
        if (error) {
            console.log(error);
        } else {
            thisB.twoBit.provide(tb);
        }
    });
}

TwoBitSequenceSource.prototype.fetch = function(chr, min, max, pool, callback) {
        this.twoBit.await(function(tb) {
            tb.fetch(chr, min, max,
                     function(seq, err) {
                         if (err) {
                             return callback(err, null);
                         } else {
                             var sequence = new DASSequence(chr, min, max, 'DNA', seq);
                             return callback(null, sequence);
                         }
                     })
        });
}

TwoBitSequenceSource.prototype.getSeqInfo = function(chr, cnt) {
    this.twoBit.await(function(tb) {
        var seq = tb.getSeq(chr);
        if (seq) {
            tb.getSeq(chr).length(function(l) {
                cnt({length: l});
            });
        } else {
            cnt();
        }
    });
}

DASFeatureSource.prototype.getScales = function() {
    return [];
}

var bwg_preflights = {};

function BWGFeatureSource(bwgSource) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.readiness = 'Connecting';
    this.bwgSource = this.opts = bwgSource;    
    thisB.bwgHolder = new Awaited();

    if (this.opts.preflight) {
        var pfs = bwg_preflights[this.opts.preflight];
        if (!pfs) {
            pfs = new Awaited();
            bwg_preflights[this.opts.preflight] = pfs;

            var req = new XMLHttpRequest();
            req.onreadystatechange = function() {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        pfs.provide('success');
                    } else {
                        pfs.provide('failure');
                    }
                }
            };
            req.open('get', this.opts.preflight + '?' + hex_sha1('salt' + Date.now()), true);    // Instead, ensure we always preflight a unique URI.
            if (this.opts.credentials) {
                req.withCredentials = true;
            }
            req.send('');
        }
        pfs.await(function(status) {
            if (status === 'success') {
                thisB.init();
            }
        });
    } else {
        thisB.init();
    }
}

BWGFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

BWGFeatureSource.prototype.init = function() {
    var thisB = this;
    var arg;

    var uri = this.bwgSource.uri || this.bwgSource.bwgURI;
    if (uri) {
        if (this.bwgSource.transport === 'encode') {
            arg = new EncodeFetchable(uri, {credentials: this.opts.credentials});
        } else {
            arg = new URLFetchable(uri, {credentials: this.opts.credentials});
        }
    } else {
        arg = new BlobFetchable(this.bwgSource.bwgBlob);
    }

    makeBwg(arg, function(bwg, err) {
        if (err) {
            thisB.error = err;
            thisB.readiness = null;
            thisB.notifyReadiness();
            thisB.bwgHolder.provide(null);
        } else {
            thisB.bwgHolder.provide(bwg);
            thisB.readiness = null;
            thisB.notifyReadiness();
            if (bwg.type == 'bigbed') {
                bwg.getExtraIndices(function(ei) {
                    thisB.extraIndices = ei;
                });
            }
        }
    });
}

BWGFeatureSource.prototype.capabilities = function() {
    var caps = {leap: true};
    if (this.bwgHolder.res && this.bwgHolder.res.type == 'bigwig')
        caps.quantLeap = true;
    if (this.extraIndices && this.extraIndices.length > 0) {
        caps.search = [];
        for (var eii = 0; eii < this.extraIndices.length; ++eii) {
            caps.search.push(this.extraIndices[eii].field);
        }
    }
    return caps;
}

BWGFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {
    var thisB = this;
    this.bwgHolder.await(function(bwg) {
        if (bwg == null) {
            return callback(thisB.error || "Can't access binary file", null, null);
        }

        var data;
        var wantDensity = !types || types.length == 0 || arrayIndexOf(types, 'density') >= 0;
        if (thisB.opts.clientBin) {
            wantDensity = false;
        }
        if (bwg.type == 'bigwig' || wantDensity || (typeof thisB.opts.forceReduction !== 'undefined')) {
            var zoom = -1;
            for (var z = 0; z < bwg.zoomLevels.length; ++z) {
                if (bwg.zoomLevels[z].reduction <= scale) {
                    zoom = z;
                } else {
                    break;
                }
            }
            if (typeof thisB.opts.forceReduction !== 'undefined') {
                zoom = thisB.opts.forceReduction;
            }

            if (zoom < 0) {
                data = bwg.getUnzoomedView();
            } else {
                data = bwg.getZoomedView(zoom);
            }
        } else {
            data = bwg.getUnzoomedView();
        }
        
        thisB.busy++;
        thisB.notifyActivity();
        data.readWigData(chr, min, max, function(features) {
            thisB.busy--;
            thisB.notifyActivity();

            var fs = 1000000000;
            if (bwg.type === 'bigwig') {
                var is = (max - min) / features.length / 2;
                if (is < fs) {
                    fs = is;
                }
            }
            if (thisB.opts.link) {
                for (var fi = 0; fi < features.length; ++fi) {
                    var f = features[fi];
                    if (f.label) {
                        f.links = [new DASLink('Link', thisB.opts.link.replace(/\$\$/, f.label))];
                    }
                }
            }
            callback(null, features, fs);
        });
    });
}

BWGFeatureSource.prototype.quantFindNextFeature = function(chr, pos, dir, threshold, callback) {
    // var beforeQFNF = Date.now()|0;
    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();
    this.bwgHolder.res.thresholdSearch(chr, pos, dir, threshold, function(a, b) {
        thisB.busy--;
        thisB.notifyActivity();
        // var afterQFNF = Date.now()|0;
        // console.log('QFNF took ' + (afterQFNF - beforeQFNF) + 'ms');
        return callback(a, b);
    });
}

BWGFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {
    var thisB = this;
    thisB.busy++;
    thisB.notifyActivity();
    this.bwgHolder.res.getUnzoomedView().getFirstAdjacent(chr, pos, dir, function(res) {
        thisB.busy--;
        thisB.notifyActivity();
        if (res.length > 0 && res[0] != null) {
            callback(res[0]);
        }
    });
}

BWGFeatureSource.prototype.getScales = function() {
    var bwg = this.bwgHolder.res;
    if (bwg /* && bwg.type == 'bigwig' */) {
        var scales = [1];  // Can we be smarter about inferring baseline scale?
        for (var z = 0; z < bwg.zoomLevels.length; ++z) {
            scales.push(bwg.zoomLevels[z].reduction);
        }
        return scales;
    } else {
        return null;
    }
}

BWGFeatureSource.prototype.search = function(query, callback) {
    if (!this.extraIndices || this.extraIndices.length == 0) {
        return callback(null, 'No indices available');
    }

    var index = this.extraIndices[0];
    return index.lookup(query, callback);
}

BWGFeatureSource.prototype.getDefaultFIPs = function(callback) {
    if (this.opts.noExtraFeatureInfo)
        return true;

    this.bwgHolder.await(function(bwg) {
        if (!bwg) return;

        if (bwg.schema && bwg.definedFieldCount < bwg.schema.fields.length) {
            var fip = function(feature, featureInfo) {
                for (var hi = 0; hi < featureInfo.hit.length; ++hi) {
                    if (featureInfo.hit[hi].isSuperGroup)
                        return;
                }
                for (var fi = bwg.definedFieldCount; fi < bwg.schema.fields.length; ++fi) {
                    var f = bwg.schema.fields[fi];
                    featureInfo.add(f.comment, feature[f.name]);
                }
            };

            callback(fip);
        } else {
            // No need to do anything.
        }
    });
}

BWGFeatureSource.prototype.getStyleSheet = function(callback) {
    var thisB = this;

    this.bwgHolder.await(function(bwg) {
        if (!bwg) {
            return callback(null, 'bbi error');
        }

    	var stylesheet = new DASStylesheet();
        if (bwg.type == 'bigbed') {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'blue'
            wigStyle.HEIGHT = 8;
            wigStyle.BUMP = true;
            wigStyle.LABEL = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({type: 'bigbed'}, null, wigStyle);
	    
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'red'
            wigStyle.HEIGHT = 10;
            wigStyle.BUMP = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({type: 'translation'}, null, wigStyle);
                    
            var tsStyle = new DASStyle();
            tsStyle.glyph = 'BOX';
            tsStyle.FGCOLOR = 'black';
            tsStyle.BGCOLOR = 'white';
            tsStyle.HEIGHT = 10;
            tsStyle.ZINDEX = 10;
            tsStyle.BUMP = true;
            tsStyle.LABEL = true;
            stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);

            var densStyle = new DASStyle();
            densStyle.glyph = 'HISTOGRAM';
            densStyle.COLOR1 = 'white';
            densStyle.COLOR2 = 'black';
            densStyle.HEIGHT=30;
            stylesheet.pushStyle({type: 'density'}, null, densStyle);
        } else {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'HISTOGRAM';
            wigStyle.COLOR1 = 'white';
            wigStyle.COLOR2 = 'black';
            wigStyle.HEIGHT=30;
            stylesheet.pushStyle({type: 'default'}, null, wigStyle);
        }

        if (bwg.definedFieldCount == 12 && bwg.fieldCount >= 14) {
            stylesheet.geneHint = true;
        }

    	return callback(stylesheet);
    });
}

function RemoteBWGFeatureSource(bwgSource, worker) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.worker = worker;
    this.readiness = 'Connecting';
    this.bwgSource = this.opts = bwgSource;
    this.keyHolder = new Awaited();

    this.init();
}

RemoteBWGFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

RemoteBWGFeatureSource.prototype.init = function() {
    var thisB = this;
    var uri = this.uri || this.bwgSource.uri || this.bwgSource.bwgURI;
    var blob = this.bwgSource.blob || this.bwgSource.bwgBlob;

    var cnt = function(key, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (key) {
            thisB.worker.postCommand({command: 'meta', connection: key}, function(meta, err) {
                if (err) {
                    thisB.error = err;
                    thisB.keyHolder.provide(null);
                } else {
                    thisB.meta = meta;
                    thisB.keyHolder.provide(key);
                }
            });
        } else {
            thisB.error = err;
            thisB.keyHolder.provide(null);
        }
    };

    if (blob) {
        this.worker.postCommand({command: 'connectBBI', blob: blob}, cnt);
    } else {
        this.worker.postCommand({
            command: 'connectBBI', 
            uri: resolveUrlToPage(uri), 
            transport: this.bwgSource.transport,
            credentials: this.bwgSource.credentials}, 
          cnt); 
    }
}

RemoteBWGFeatureSource.prototype.capabilities = function() {
    var caps = {leap: true};

    if (this.meta && this.meta.type == 'bigwig')
        caps.quantLeap = true;
    if (this.meta && this.meta.extraIndices && this.meta.extraIndices.length > 0) {
        caps.search = [];
        for (var eii = 0; eii < this.meta.extraIndices.length; ++eii) {
            caps.search.push(this.meta.extraIndices[eii].field);
        }
    }
    return caps;
}

RemoteBWGFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {
    var thisB = this;

    thisB.busy++;
    thisB.notifyActivity();

    this.keyHolder.await(function(key) {
        if (!key) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Can't access binary file", null, null);
        }

        var zoom = -1;
        var wantDensity = !types || types.length == 0 || arrayIndexOf(types, 'density') >= 0;
        if (thisB.opts.clientBin) {
            wantDensity = false;
        }
        if (thisB.meta.type == 'bigwig' || wantDensity || (typeof thisB.opts.forceReduction !== 'undefined')) {
            for (var z = 1; z < thisB.meta.zoomLevels.length; ++z) {
                if (thisB.meta.zoomLevels[z] <= scale) {
                    zoom = z - 1; // Scales returned in metadata start at 1, unlike "real" zoom levels.
                } else {
                    break;
                }
            }
            if (typeof thisB.opts.forceReduction !== 'undefined') {
                zoom = thisB.opts.forceReduction;
            }
        }
        
        thisB.worker.postCommand({command: 'fetch', connection: key, chr: chr, min: min, max: max, zoom: zoom}, function(features, error) {
            thisB.busy--;
            thisB.notifyActivity();

            var fs = 1000000000;
            if (thisB.meta.type === 'bigwig') {
                var is = (max - min) / features.length / 2;
                if (is < fs) {
                    fs = is;
                }
            } 
            if (thisB.opts.link) {
                for (var fi = 0; fi < features.length; ++fi) {
                    var f = features[fi];
                    if (f.label) {
                        f.links = [new DASLink('Link', thisB.opts.link.replace(/\$\$/, f.label))];
                    }
                }
            } 
            callback(error, features, fs);
        });
    });
}


RemoteBWGFeatureSource.prototype.quantFindNextFeature = function(chr, pos, dir, threshold, callback) {
    var thisB = this;
    this.busy++;
    this.notifyActivity();
    this.worker.postCommand({command: 'quantLeap', connection: this.keyHolder.res, chr: chr, pos: pos, dir: dir, threshold: threshold, under: false}, function(result, err) {
        console.log(result, err);
        thisB.busy--;
        thisB.notifyActivity();
        return callback(result, err);
    });
}

RemoteBWGFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {
    var thisB = this;
    this.busy++;
    this.notifyActivity();
    this.worker.postCommand({command: 'leap', connection: this.keyHolder.res, chr: chr, pos: pos, dir: dir}, function(result, err) {
        thisB.busy--;
        thisB.notifyActivity();
        if (result.length > 0 && result[0] != null) {
            callback(result[0]);
        }
    });
}

RemoteBWGFeatureSource.prototype.getScales = function() {
    var meta = this.meta;
    if (meta) {
        return meta.zoomLevels;
    } else {
        return null;
    }
}

RemoteBWGFeatureSource.prototype.search = function(query, callback) {
    if (!this.meta.extraIndices || this.meta.extraIndices.length == 0) {
        return callback(null, 'No indices available');
    }

    var thisB = this;
    this.busy++;
    this.notifyActivity();
    var index = this.meta.extraIndices[0];
    this.worker.postCommand({command: 'search', connection: this.keyHolder.res, query: query, index: index}, function(result, err) {
        thisB.busy--;
        thisB.notifyActivity();

        callback(result, err);
    });
}

RemoteBWGFeatureSource.prototype.getDefaultFIPs = function(callback) {
    if (this.opts.noExtraFeatureInfo)
        return true;

    var thisB = this;
    this.keyHolder.await(function(key) {
        var bwg = thisB.meta;
        if (!bwg) return;

        if (bwg.schema && bwg.definedFieldCount < bwg.schema.fields.length) {
            var fip = function(feature, featureInfo) {
                for (var hi = 0; hi < featureInfo.hit.length; ++hi) {
                    if (featureInfo.hit[hi].isSuperGroup)
                        return;
                }
                for (var fi = bwg.definedFieldCount; fi < bwg.schema.fields.length; ++fi) {
                    var f = bwg.schema.fields[fi];
                    featureInfo.add(f.comment, feature[f.name]);
                }
            };

            callback(fip);
        } else {
            // No need to do anything.
        }
    });
} 

RemoteBWGFeatureSource.prototype.getStyleSheet = function(callback) {
    var thisB = this;

    this.keyHolder.await(function(key) {
        var bwg = thisB.meta;
        if (!bwg) {
            return callback(null, 'bbi error');
        } 

        var stylesheet = new DASStylesheet();
        if (bwg.type == 'bigbed') {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'blue'
            wigStyle.HEIGHT = 8;
            wigStyle.BUMP = true;
            wigStyle.LABEL = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({type: 'bigbed'}, null, wigStyle);
        
            wigStyle.glyph = 'BOX';
            wigStyle.FGCOLOR = 'black';
            wigStyle.BGCOLOR = 'red'
            wigStyle.HEIGHT = 10;
            wigStyle.BUMP = true;
            wigStyle.ZINDEX = 20;
            stylesheet.pushStyle({type: 'translation'}, null, wigStyle);
                    
            var tsStyle = new DASStyle();
            tsStyle.glyph = 'BOX';
            tsStyle.FGCOLOR = 'black';
            tsStyle.BGCOLOR = 'white';
            tsStyle.HEIGHT = 10;
            tsStyle.ZINDEX = 10;
            tsStyle.BUMP = true;
            tsStyle.LABEL = true;
            stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);

            var densStyle = new DASStyle();
            densStyle.glyph = 'HISTOGRAM';
            densStyle.COLOR1 = 'white';
            densStyle.COLOR2 = 'black';
            densStyle.HEIGHT=30;
            stylesheet.pushStyle({type: 'density'}, null, densStyle);
        } else {
            var wigStyle = new DASStyle();
            wigStyle.glyph = 'HISTOGRAM';
            wigStyle.COLOR1 = 'white';
            wigStyle.COLOR2 = 'black';
            wigStyle.HEIGHT=30;
            stylesheet.pushStyle({type: 'default'}, null, wigStyle);
        }


        if (bwg.definedFieldCount == 12 && bwg.fieldCount >= 14) {
            stylesheet.geneHint = true;
        } 

        return callback(stylesheet);
    });
}

function bamRecordToFeature(r, group) {
    if (r.flag & BamFlags.SEGMENT_UNMAPPED)
        return; 
    
    var len;
    if (r.seq)
        len = r.seq.length;
    else 
        len = r.seqLength;
    
    if (r.cigar) {
        len = 0;
        var ops = parseCigar(r.cigar);
        for (var ci = 0; ci < ops.length; ++ci) {
            var co = ops[ci];
            if (co.op == 'M' || co.op == 'D')
                len += co.cnt;
        }
    }

    var f = new DASFeature();
    f.min = r.pos + 1;
    f.max = r.pos + len;
    f.segment = r.segment;
    f.type = 'bam';
    f.id = r.readName;
    f.notes = [/* 'Sequence=' + r.seq, 'CIGAR=' + r.cigar, */ 'MQ=' + r.mq];
    f.cigar = r.cigar;
    f.seq = r.seq;
    f.quals = r.quals;
    f.orientation = (r.flag & BamFlags.REVERSE_COMPLEMENT) ? '-' : '+';
    f.bamRecord = r;

    if (group && (r.flag & BamFlags.MULTIPLE_SEGMENTS)) {
        f.groups = [{id: r.readName, 
                     type: 'readpair'}];
    }

    return f;
}

function BAMFeatureSource(bamSource) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.bamSource = bamSource;
    this.opts = {credentials: bamSource.credentials, preflight: bamSource.preflight, bamGroup: bamSource.bamGroup};
    this.bamHolder = new Awaited();
    
    if (this.opts.preflight) {
        var pfs = bwg_preflights[this.opts.preflight];
        if (!pfs) {
            pfs = new Awaited();
            bwg_preflights[this.opts.preflight] = pfs;

            var req = new XMLHttpRequest();
            req.onreadystatechange = function() {
                if (req.readyState == 4) {
                    if (req.status == 200) {
                        pfs.provide('success');
                    } else {
                        pfs.provide('failure');
                    }
                }
            };
            // req.setRequestHeader('cache-control', 'no-cache');    /* Doesn't work, not an allowed request header in CORS */
            req.open('get', this.opts.preflight + '?' + hex_sha1('salt' + Date.now()), true);    // Instead, ensure we always preflight a unique URI.
            if (this.opts.credentials) {
                req.withCredentials = 'true';
            }
            req.send('');
        }
        pfs.await(function(status) {
            if (status === 'success') {
                thisB.init();
            }
        });
    } else {
        thisB.init();
    }
}

BAMFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

BAMFeatureSource.prototype.init = function() {
    var thisB = this;
    var bamF, baiF;
    if (this.bamSource.bamBlob) {
        bamF = new BlobFetchable(this.bamSource.bamBlob);
        baiF = new BlobFetchable(this.bamSource.baiBlob);
    } else {
        bamF = new URLFetchable(this.bamSource.bamURI, {credentials: this.opts.credentials});
        baiF = new URLFetchable(this.bamSource.baiURI || (this.bamSource.bamURI + '.bai'), {credentials: this.opts.credentials});
    }
    makeBam(bamF, baiF, null, function(bam, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (bam) {
            thisB.bamHolder.provide(bam);
        } else {
            thisB.error = err;
            thisB.bamHolder.provide(null);
        }
    });
}

BAMFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {
    var light = types && (types.length == 1) && (types[0] == 'density');

    var thisB = this;
    
    thisB.busy++;
    thisB.notifyActivity();
    
    this.bamHolder.await(function(bam) {
        if (!bam) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Couldn't fetch BAM");
        }

        bam.fetch(chr, min, max, function(bamRecords, error) {
            thisB.busy--;
            thisB.notifyActivity();

            if (error) {
                callback(error, null, null);
            } else {
                var features = [];
                for (var ri = 0; ri < bamRecords.length; ++ri) {
                    var r = bamRecords[ri];

                    var f = bamRecordToFeature(r, thisB.opts.bamGroup);
                    if (f)
                        features.push(f);
                }
                callback(null, features, 1000000000);
            }
        }, {light: light});
    });
}

BAMFeatureSource.prototype.getScales = function() {
    return 1000000000;
}

BAMFeatureSource.prototype.getStyleSheet = function(callback) {
    this.bamHolder.await(function(bam) {
	    var stylesheet = new DASStylesheet();
                
        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'black';
        densStyle.COLOR2 = 'red';
        densStyle.HEIGHT=30;
        stylesheet.pushStyle({type: 'density'}, 'low', densStyle);
        stylesheet.pushStyle({type: 'density'}, 'medium', densStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = '__SEQUENCE';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue'
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = false;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({type: 'bam'}, 'high', wigStyle);

	    return callback(stylesheet);
    });
}


function RemoteBAMFeatureSource(bamSource, worker) {
    FeatureSourceBase.call(this);

    var thisB = this;
    this.bamSource = bamSource;
    this.worker = worker;
    this.opts = {credentials: bamSource.credentials, preflight: bamSource.preflight, bamGroup: bamSource.bamGroup};
    this.keyHolder = new Awaited();
    
    this.init();
}

RemoteBAMFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

RemoteBAMFeatureSource.prototype.init = function() {    var thisB = this;
    var uri = this.bamSource.uri || this.bamSource.bamURI;
    var indexUri = this.bamSource.indexUri || this.bamSource.baiURI || uri + '.bai';

    var blob = this.bamSource.bamBlob || this.bamSource.blob;
    var indexBlob = this.bamSource.baiBlob || this.bamSource.indexBlob;

    var cnt = function(result, err) {
        thisB.readiness = null;
        thisB.notifyReadiness();

        if (result) {
            thisB.keyHolder.provide(result);
        } else {
            thisB.error = err;
            thisB.keyHolder.provide(null);
        }
    };

    if (blob) {
        this.worker.postCommand({command: 'connectBAM', blob: blob, indexBlob: indexBlob}, cnt);
    } else {
        this.worker.postCommand({
            command: 'connectBAM', 
            uri: resolveUrlToPage(uri), 
            indexUri: resolveUrlToPage(indexUri),
            credentials: this.bamSource.credentials,
            indexChunks: this.bamSource.indexChunks},
          cnt); 
    }
}

RemoteBAMFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {
    var light = types && (types.length == 1) && (types[0] == 'density');
    var thisB = this;
    
    thisB.busy++;
    thisB.notifyActivity();
    
    this.keyHolder.await(function(key) {
        if (!key) {
            thisB.busy--;
            thisB.notifyActivity();
            return callback(thisB.error || "Couldn't fetch BAM");
        }

        thisB.worker.postCommand({command: 'fetch', connection: key, chr: chr, min: min, max: max, opts: {light: light}}, function(bamRecords, error) {
            // console.log('retrieved ' + bamRecords.length + ' via worker.');

            thisB.busy--;
            thisB.notifyActivity();

            if (error) {
                callback(error, null, null);
            } else {
                var features = [];
                for (var ri = 0; ri < bamRecords.length; ++ri) {
                    var r = bamRecords[ri];
                    var f = bamRecordToFeature(r, thisB.opts.bamGroup);
                    if (f)
                        features.push(f);
                }
                callback(null, features, 1000000000);
            }
        });
    });
}

RemoteBAMFeatureSource.prototype.getScales = function() {
    return 1000000000;
}

RemoteBAMFeatureSource.prototype.getStyleSheet = function(callback) {
    this.keyHolder.await(function(bam) {
        var stylesheet = new DASStylesheet();
                
        var densStyle = new DASStyle();
        densStyle.glyph = 'HISTOGRAM';
        densStyle.COLOR1 = 'black';
        densStyle.COLOR2 = 'red';
        densStyle.HEIGHT=30;
        stylesheet.pushStyle({type: 'density'}, 'low', densStyle);
        stylesheet.pushStyle({type: 'density'}, 'medium', densStyle);

        var wigStyle = new DASStyle();
        wigStyle.glyph = '__SEQUENCE';
        wigStyle.FGCOLOR = 'black';
        wigStyle.BGCOLOR = 'blue'
        wigStyle.HEIGHT = 8;
        wigStyle.BUMP = true;
        wigStyle.LABEL = false;
        wigStyle.ZINDEX = 20;
        stylesheet.pushStyle({type: 'bam'}, 'high', wigStyle);
        return callback(stylesheet);
    });
}


function MappedFeatureSource(source, mapping) {
    this.source = source;
    this.mapping = mapping;
    
    this.activityListeners = [];
    this.busy = 0;
}

MappedFeatureSource.prototype.addActivityListener = function(listener) {
    this.activityListeners.push(listener);
}

MappedFeatureSource.prototype.removeActivityListener = function(listener) {
    var idx = arrayIndexOf(this.activityListeners, listener);
    if (idx >= 0)
        this.activityListeners.splice(idx, 0);
}

MappedFeatureSource.prototype.notifyActivity = function() {
    for (var li = 0; li < this.activityListeners.length; ++li) {
        try {
            this.activityListeners[li](this.busy);
        } catch (e) {
            console.log(e);
        }
    }
}

MappedFeatureSource.prototype.getStyleSheet = function(callback) {
    return this.source.getStyleSheet(callback);
}

MappedFeatureSource.prototype.getScales = function() {
    return this.source.getScales();
}

MappedFeatureSource.prototype.getDefaultFIPs = function(callback) {
    if (this.source.getDefaultFIPs)
        return this.source.getDefaultFIPs(callback);
}

MappedFeatureSource.prototype.simplifySegments = function(segs, minGap) {
    if (segs.length == 0) return segs;

    segs.sort(function(s1, s2) {
        var d = s1.name - s2.name;
        if (d)
            return d;
        d = s1.start - s2.start;
        if (d)
            return d;
        return s1.end - s2.end;   // Should never come to this...?
    });

    var ssegs = [];
    var currentSeg = segs[0];
    for (var si = 0; si < segs.length; ++si) {
        var ns = segs[si];

        // console.log(ns.name + ' ' + ns.start + ' ' + ns.end);
        if (ns.name != currentSeg.name || ns.start > (currentSeg.end + minGap)) {
            ssegs.push(currentSeg);
            currentSeg = ns;
        } else {
            currentSeg = new DASSegment(currentSeg.name, Math.min(currentSeg.start, ns.start), Math.max(currentSeg.end, ns.end));
        }
    }
    ssegs.push(currentSeg);
    return ssegs;
}

MappedFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback, styleFilters) {
    var thisB = this;
    var fetchLength = max - min + 1;

    thisB.busy++;
    thisB.notifyActivity();

    this.mapping.sourceBlocksForRange(chr, min, max, function(mseg) {
        if (mseg.length == 0) {
            thisB.busy--;
            thisB.notifyActivity();

            callback("No mapping available for this regions", [], scale);
        } else {
            mseg = thisB.simplifySegments(mseg, Math.max(100, 0.05 * fetchLength));

            var mappedFeatures = [];
            var mappedLoc = null;
            var count = mseg.length;
            var finalStatus;

            mseg.map(function(seg) {
                thisB.source.fetch(seg.name, seg.start, seg.end, scale, types, pool, function(status, features, fscale) {
                    if (status && !finalStatus)
                        finalStatus = status;

                    if (features) {
                        for (var fi = 0; fi < features.length; ++fi) {
                            var f = features[fi];
                            var sn = f.segment;
                            if (sn.indexOf('chr') == 0) {
                                sn = sn.substr(3);
                            }

                            var mappings = thisB.mapping.mapSegment(sn, f.min, f.max);

                            if (mappings.length == 0) {
                                if (f.parts && f.parts.length > 0) {
                                     mappedFeatures.push(f);
                                }
                            } else {
                                for (var mi = 0; mi < mappings.length; ++mi) {
                                    var m = mappings[mi];
                                    var mf = shallowCopy(f);
                                    mf.segment = m.segment;
                                    mf.min = m.min;
                                    mf.max = m.max;
                                    if (m.partialMin)
                                        mf.partialMin = m.partialMin;
                                    if (m.partialMax)
                                        mf.partialMax = m.partialMax;

                                    if (m.flipped) {
                                        if (f.orientation == '-') {
                                            mf.orientation = '+';
                                        } else if (f.orientation == '+') {
                                            mf.orientation = '-';
                                        }
                                    }
                                    mappedFeatures.push(mf);
                                }
                            }
                        }
                    }

                    var m1 = thisB.mapping.mapPoint(seg.name, seg.start);
                    var m2 = thisB.mapping.mapPoint(seg.name, seg.end);

                    if (m1 && m2) {
                        var segDestCoverage = new Range(m1.pos, m2.pos);
                        if (mappedLoc)
                            mappedLoc = union(mappedLoc, segDestCoverage);
                        else
                            mappedLoc = segDestCoverage;
                    }

                    --count;
                    if (count == 0) {
                        thisB.busy--;
                        thisB.notifyActivity();
                        callback(finalStatus, mappedFeatures, fscale, mappedLoc);
                    }
                }, styleFilters);
            });
        }
    });
}

function DummyFeatureSource() {
}

DummyFeatureSource.prototype.getScales = function() {
    return null;
}

DummyFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, cnt) {
    return cnt(null, [], 1000000000);
}

DummyFeatureSource.prototype.getStyleSheet = function(callback) {
    var stylesheet = new DASStylesheet();
    var defStyle = new DASStyle();
    defStyle.glyph = 'BOX';
    defStyle.BGCOLOR = 'blue';
    defStyle.FGCOLOR = 'black';
    stylesheet.pushStyle({type: 'default'}, null, defStyle);
    return callback(stylesheet);
}

function DummySequenceSource() {
}

DummySequenceSource.prototype.fetch = function(chr, min, max, pool, cnt) {
    return cnt(null, null);
}

function JBrowseFeatureSource(source) {
    this.store = new JBrowseStore(source.jbURI, source.jbQuery);
}

JBrowseFeatureSource.prototype.getScales = function() {
    return null;
}

JBrowseFeatureSource.prototype.getStyleSheet = function(callback) {
    var stylesheet = new DASStylesheet();
    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = 'green'
    wigStyle.HEIGHT = 8;
    wigStyle.BUMP = true;
    wigStyle.LABEL = true;
    wigStyle.ZINDEX = 20;
    stylesheet.pushStyle({type: 'default'}, null, wigStyle);

    return callback(stylesheet);
}

JBrowseFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {
    if (types && types.length == 0) {
        callback(null, [], scale);
        return;
    }
    
    var fops = {};

    this.store.features(
        new DASSegment(chr, min, max),
        fops,
        function(features, status) {
            callback(status, features, 100000);
        }
    );
}

Browser.prototype.sourceAdapterIsCapable = function(s, cap) {
    if (!s.capabilities)
        return false;
    else return s.capabilities()[cap];
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        FeatureSourceBase: FeatureSourceBase,

        TwoBitSequenceSource: TwoBitSequenceSource,
        DASSequenceSource: DASSequenceSource,
        MappedFeatureSource: MappedFeatureSource,
        CachingFeatureSource: CachingFeatureSource,
        BWGFeatureSource: BWGFeatureSource,
        RemoteBWGFeatureSource: RemoteBWGFeatureSource,
        BAMFeatureSource: BAMFeatureSource,
        RemoteBAMFeatureSource: RemoteBAMFeatureSource,
        DummyFeatureSource: DummyFeatureSource,
        DummySequenceSource: DummySequenceSource,

        registerSourceAdapterFactory: dalliance_registerSourceAdapterFactory,
        registerParserFactory: dalliance_registerParserFactory,
        makeParser: dalliance_makeParser
    }

    // Standard set of plugins.
    require('./ensembljson');
    require('./tabix-source');
    require('./memstore');
    require('./bedwig');
    require('./vcf');
}

},{"./bam":1,"./bedwig":2,"./bigwig":3,"./bin":4,"./cbrowser":6,"./chainset":7,"./cigar":8,"./das":10,"./encode":12,"./ensembljson":13,"./jbjson":22,"./memstore":25,"./overlay":27,"./spans":36,"./style":37,"./tabix-source":40,"./tier":45,"./twoBit":48,"./utils":49,"./vcf":50}],35:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2015
//
// sourcecompare.js
//


function sourceDataURI(conf) {
    if (conf.uri) {
        return conf.uri;
    } else if (conf.blob) {
        return 'file:' + conf.blob.name;
    } else if (conf.bwgBlob) {
        return 'file:' + conf.bwgBlob.name;
    } else if (conf.bamBlob) {
        return 'file:' + conf.bamBlob.name;
    } else if (conf.twoBitBlob) {
        return 'file:' + conf.twoBitBlob.name;
    }

    return conf.bwgURI || conf.bamURI || conf.jbURI || conf.twoBitURI || 'https://www.biodalliance.org/magic/no_uri';
}

function sourceStyleURI(conf) {
    if (conf.stylesheet_uri)
        return conf.stylesheet_uri;
    else if (conf.tier_type == 'sequence' || conf.twoBitURI || conf.twoBitBlob)
        return 'https://www.biodalliance.org/magic/sequence'
    else
        return sourceDataURI(conf);
}

function sourcesAreEqualModuloStyle(a, b) {
    if (sourceDataURI(a) != sourceDataURI(b))
        return false;

    if (a.mapping != b.mapping)
        return false;

    if (a.tier_type != b.tier_type)
        return false;

    if (a.overlay) {
        if (!b.overlay || b.overlay.length != a.overlay.length)
            return false;
        for (var oi = 0; oi < a.overlay.length; ++oi) {
            if (!sourcesAreEqualModuloStyle(a.overlay[oi], b.overlay[oi]))
                return false;
        }
    } else {
        if (b.overlay)
            return false;
    }

    return true;
}

function sourcesAreEqual(a, b) {
    if (sourceDataURI(a) != sourceDataURI(b) ||
        sourceStyleURI(a) != sourceStyleURI(b))
        return false;

    if (a.mapping != b.mapping)
        return false;

    if (a.tier_type != b.tier_type)
        return false;

    if (a.overlay) {
        if (!b.overlay || b.overlay.length != a.overlay.length)
            return false;
        for (var oi = 0; oi < a.overlay.length; ++oi) {
            if (!sourcesAreEqual(a.overlay[oi], b.overlay[oi]))
                return false;
        }
    } else {
        if (b.overlay)
            return false;
    }

    return true;
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        sourcesAreEqual: sourcesAreEqual,
        sourcesAreEqualModuloStyle: sourcesAreEqualModuloStyle,
        sourceDataURI: sourceDataURI,
        sourceStyleURI: sourceStyleURI
    };
}

},{}],36:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// spans.js: JavaScript Intset/Location port.
//

"use strict";


function Range(min, max)
{
    if (typeof(min) != 'number' || typeof(max) != 'number')
        throw 'Bad range ' + min + ',' + max;
    this._min = min;
    this._max = max;
}

Range.prototype.min = function() {
    return this._min;
}

Range.prototype.max = function() {
    return this._max;
}

Range.prototype.contains = function(pos) {
    return pos >= this._min && pos <= this._max;
}

Range.prototype.isContiguous = function() {
    return true;
}

Range.prototype.ranges = function() {
    return [this];
}

Range.prototype._pushRanges = function(ranges) {
    ranges.push(this);
}

Range.prototype.toString = function() {
    return '[' + this._min + '-' + this._max + ']';
}

function _Compound(ranges) {
    // given: a set of unsorted possibly overlapping ranges
    // sort the input ranges
    var sorted = ranges.sort(_rangeOrder);
    // merge overlaps between adjacent ranges
    var merged = [];
    var current = sorted.shift();
    sorted.forEach(function(range) {
        if (range._min <= current._max) {
            if (range._max > current._max) {
                current._max = range._max;
            }
        }
        else {
            merged.push(current);
            current = range;
        }
    });
    merged.push(current);
    this._ranges = merged;
}

_Compound.prototype.min = function() {
    return this._ranges[0].min();
}

_Compound.prototype.max = function() {
    return this._ranges[this._ranges.length - 1].max();
}

// returns the index of the first range that is not less than pos
_Compound.prototype.lower_bound = function(pos) {
    // first check if pos is out of range
    var r = this.ranges();
    if (pos > this.max()) return r.length;
    if (pos < this.min()) return 0;
    // do a binary search
    var a=0, b=r.length - 1;
    while (a <= b) {
        var m = Math.floor((a+b)/2);
        if (pos > r[m]._max) {
            a = m+1;
        }
        else if (pos < r[m]._min) {
            b = m-1;
        }
        else {
            return m;
        }
    }
    return a;
}

_Compound.prototype.contains = function(pos) {
    var lb = this.lower_bound(pos);
    if (lb < this._ranges.length && this._ranges[lb].contains(pos)) {
        return true;
    }
    return false;
}

_Compound.prototype.insertRange = function(range) {
    var lb = this.lower_bound(range._min);
    if (lb === this._ranges.length) { // range follows this
        this._ranges.push(range);
        return;
    }
    
    var r = this.ranges();
    if (range._max < r[lb]._min) { // range preceeds lb
        this._ranges.splice(lb,0,range);
        return;
    }

    // range overlaps lb (at least)
    if (r[lb]._min < range._min) range._min = r[lb]._min;
    var ub = lb+1;
    while (ub < r.length && r[ub]._min <= range._max) {
        ub++;
    }
    ub--;
    // ub is the upper bound of the new range
    if (r[ub]._max > range._max) range._max = r[ub]._max;
    
    // splice range into this._ranges
    this._ranges.splice(lb,ub-lb+1,range);
    return;
}

_Compound.prototype.isContiguous = function() {
    return this._ranges.length > 1;
}

_Compound.prototype.ranges = function() {
    return this._ranges;
}

_Compound.prototype._pushRanges = function(ranges) {
    for (var ri = 0; ri < this._ranges.length; ++ri)
        ranges.push(this._ranges[ri]);
}

_Compound.prototype.toString = function() {
    var s = '';
    for (var r = 0; r < this._ranges.length; ++r) {
        if (r>0) {
            s = s + ',';
        }
        s = s + this._ranges[r].toString();
    }
    return s;
}

function union(s0, s1) {
    if (! (s0 instanceof _Compound)) {
        if (! (s0 instanceof Array))
            s0 = [s0];
        s0 = new _Compound(s0);
    }
    
    if (s1)
        s0.insertRange(s1);

    return s0;
}

function intersection(s0, s1) {
    var r0 = s0.ranges();
    var r1 = s1.ranges();
    var l0 = r0.length, l1 = r1.length;
    var i0 = 0, i1 = 0;
    var or = [];

    while (i0 < l0 && i1 < l1) {
        var s0 = r0[i0], s1 = r1[i1];
        var lapMin = Math.max(s0.min(), s1.min());
        var lapMax = Math.min(s0.max(), s1.max());
        if (lapMax >= lapMin) {
            or.push(new Range(lapMin, lapMax));
        }
        if (s0.max() > s1.max()) {
            ++i1;
        } else {
            ++i0;
        }
    }
    
    if (or.length == 0) {
        return null; // FIXME
    } else if (or.length == 1) {
        return or[0];
    } else {
        return new _Compound(or);
    }
}

function coverage(s) {
    var tot = 0;
    var rl = s.ranges();
    for (var ri = 0; ri < rl.length; ++ri) {
        var r = rl[ri];
        tot += (r.max() - r.min() + 1);
    }
    return tot;
}



function rangeOrder(a, b)
{
    if (a.min() < b.min()) {
        return -1;
    } else if (a.min() > b.min()) {
        return 1;
    } else if (a.max() < b.max()) {
        return -1;
    } else if (b.max() > a.max()) {
        return 1;
    } else {
        return 0;
    }
}

function _rangeOrder(a, b)
{
    if (a._min < b._min) {
        return -1;
    } else if (a._min > b._min) {
        return 1;
    } else if (a._max < b._max) {
        return -1;
    } else if (b._max > a._max) {
        return 1;
    } else {
        return 0;
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        Range: Range,
        union: union,
        intersection: intersection,
        coverage: coverage,
        rangeOver: rangeOrder,
        _rangeOrder: _rangeOrder
    }
}
},{}],37:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2014
//
// style.js
//

"use strict";

function StyleFilter(type, method, label) {
    this.type = type;
    this.method = method;
    this.label = label;
}

StyleFilter.prototype.equals = function(o) {
    return this.type == o.type && this.method == o.method && this.label == o.label;
}

StyleFilter.prototype.toString = function() {
    var fs = [];
    if (this.type) 
        fs.push('type=' + this.type);
    if (this.method)
        fs.push('method=' + this.method);
    if (this.label)
        fs.push('label=' + this.label);
    return 'StyleFilter<' + fs.join(';') + '>';
}

function StyleFilterSet(filters) {
    this._filters = {};
    if (filters) {
        for (var fi = 0; fi < filters.length; ++fi) {
            this.add(filters[fi]);
        }
    }
}

StyleFilterSet.prototype.add = function(filter) {
    var fs = filter.toString();
    if (!this._filters[fs]) {
        this._filters[fs] = filter;
        this._list = null;
    }
}

StyleFilterSet.prototype.addAll = function(filterSet) {
    var l = filterSet.list();
    for (var fi = 0; fi < l.length; ++fi) {
        this.add(l[fi]);
    }
}

StyleFilterSet.prototype.doesNotContain = function(filterSet) {
    var l = filterSet.list();
    for (var fi = 0; fi < l.length; ++fi) {
        if (!this._filters[fi.toString()])
            return true;
    }
    return false
}

StyleFilterSet.prototype.list = function() {
    if (!this._list) {
        this._list = [];
        for (var k in this._filters) {
            if (this._filters.hasOwnProperty(k)) {
                this._list.push(this._filters[k]);
            }
        }
    }
    return this._list;
}

StyleFilterSet.prototype.typeList = function() {
    var types = [];
    var list = this.list();
    for (var fi = 0; fi < list.length; ++fi) {
        var filter = list[fi];
        var type = filter.type;
        if (!type || type == 'default')
            return null;
        if (types.indexOf(type) < 0)
            types.push(type);
    }
    return types;
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        StyleFilter: StyleFilter,
        StyleFilterSet: StyleFilterSet
    };
}

},{}],38:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// svg-export.js
//

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var makeElementNS = utils.makeElementNS;

    var VERSION = require('./version');

    var svgSeqTier = require('./sequence-draw').svgSeqTier;

    var svgu = require('./svg-utils');
    var NS_SVG = svgu.NS_SVG;
    var NS_XLINK = svgu.NS_XLINK;
    var SVGPath = svgu.SVGPath;

    var nf = require('./numformats');
    var formatQuantLabel = nf.formatQuantLabel;
}


Browser.prototype.makeSVG = function(opts) {
    opts = opts || {};
    var minTierHeight = opts.minTierHeight || 20;
    var padding = 3;

    var b = this;
    var saveDoc = document.implementation.createDocument(NS_SVG, 'svg', null);

    var saveRoot = makeElementNS(NS_SVG, 'g', null, {
        fontFamily: 'helvetica',
        fontSize: '8pt'
    });
    saveDoc.documentElement.appendChild(saveRoot);

    var margin = 200;

    var dallianceAnchor = makeElementNS(NS_SVG, 'a',
       makeElementNS(NS_SVG, 'text', 'Graphics from Dalliance ' + VERSION, {
           x: (b.featurePanelWidth + margin + 20)/2,
           y: 30,
           strokeWidth: 0,
           fontSize: '12pt',
	       textAnchor: 'middle',
	       fill: 'blue'
       }));
    dallianceAnchor.setAttribute('xmlns:xlink', NS_XLINK);
    dallianceAnchor.setAttribute('xlink:href', 'http://www.biodalliance.org/');
  
    saveRoot.appendChild(dallianceAnchor);
    
    var clipRect = makeElementNS(NS_SVG, 'rect', null, {
    	x: margin,
    	y: 50,
    	width: b.featurePanelWidth,
    	height: 100000
    });
    var clip = makeElementNS(NS_SVG, 'clipPath', clipRect, {id: 'featureClip'});
    saveRoot.appendChild(clip);

    var pos = 70;
    var tierHolder = makeElementNS(NS_SVG, 'g', null, {});

    for (var ti = 0; ti < b.tiers.length; ++ti) {
        var tier = b.tiers[ti];
    	var tierSVG = makeElementNS(NS_SVG, 'g', null, {clipPath: 'url(#featureClip)', clipRule: 'nonzero'});
    	var tierLabels = makeElementNS(NS_SVG, 'g');
    	var tierTopPos = pos;

    	var tierBackground = makeElementNS(NS_SVG, 'rect', null, {x: 0, y: tierTopPos, width: '10000', height: 50, fill: tier.background});
    	tierSVG.appendChild(tierBackground);

    	if (tier.sequenceSource) {
    	    var seqTrack = svgSeqTier(tier, tier.currentSequence);
    	    
    	    tierSVG.appendChild(makeElementNS(NS_SVG, 'g', seqTrack, {transform: 'translate(' + (margin) + ', ' + pos + ')'}));
    	    pos += 80;
    	} else {
            if (!tier.subtiers) {
    		   continue;
            }
    	
    	    var offset = ((tier.glyphCacheOrigin - b.viewStart) * b.scale);
            var hasQuant = false;
            for (var sti = 0; sti < tier.subtiers.length; ++sti) {
                pos += padding;
        		var subtier = tier.subtiers[sti];
                    
        		var glyphElements = [];
        		for (var gi = 0; gi < subtier.glyphs.length; ++gi) {
                    var glyph = subtier.glyphs[gi];
                    glyphElements.push(glyph.toSVG());
        		}

    		    tierSVG.appendChild(makeElementNS(NS_SVG, 'g', glyphElements, {transform: 'translate(' + (margin+offset) + ', ' + pos + ')'}));

        		if (subtier.quant) {
                    hasQuant = true;
        		    var q = subtier.quant;
                    var h = subtier.height;

                    var numTics = 2;
                    if (h > 40) {
                        numTics = 1 + ((h/20) | 0);
                    }
                    var ticSpacing = h / (numTics - 1);
                    var ticInterval = (q.max - q.min) / (numTics - 1);

        		    var path = new SVGPath();
        		    path.moveTo(margin + 5, pos);
        		    path.lineTo(margin, pos);
        		    path.lineTo(margin, pos + subtier.height);
        		    path.lineTo(margin + 5, pos + subtier.height);
                    for (var t = 1; t < numTics-1; ++t) {
                        var ty = t*ticSpacing;
                        path.moveTo(margin, pos + ty);
                        path.lineTo(margin+3, pos + ty);
                    }

        		    tierLabels.appendChild(makeElementNS(NS_SVG, 'path', null, {d: path.toPathData(), fill: 'none', stroke: 'black', strokeWidth: '2px'}));
        		    tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(q.max), {x: margin - 3, y: pos + 7, textAnchor: 'end'}));
        		    tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(q.min), {x: margin - 3, y: pos +  subtier.height, textAnchor: 'end'}));
                    for (var t = 1; t < numTics-1; ++t) {
                        var ty = t*ticSpacing;
                        tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel((1.0*q.max) - (t*ticInterval)), 
                            {x: margin - 3, y: pos +  ty + 3, textAnchor: 'end'}));
                    }
        		}

    		    pos += subtier.height + padding;
            }

            if (pos - tierTopPos < minTierHeight) {
                pos = tierTopPos + minTierHeight;
            }
    	}

        var labelName;
        if (typeof tier.config.name === 'string')
            labelName = tier.config.name;
        else
            labelName = tier.dasSource.name;
    	tierLabels.appendChild(
    	    makeElementNS(
    		NS_SVG, 'text',
    		labelName,
    		{x: margin - (hasQuant ? 20 : 12), y: (pos+tierTopPos+8)/2, fontSize: '10pt', textAnchor: 'end'}));

    	
    	tierBackground.setAttribute('height', pos - tierTopPos);
    	tierHolder.appendChild(makeElementNS(NS_SVG, 'g', [tierSVG, tierLabels]));
    }

    if (opts.highlights) {
        var highlights = this.highlights || [];
        for (var hi = 0; hi < highlights.length; ++hi) {
            var h = highlights[hi];
            if ((h.chr == this.chr || h.chr == ('chr' + this.chr)) && h.min < this.viewEnd && h.max > this.viewStart) {
                var tmin = (Math.max(h.min, this.viewStart) - this.viewStart) * this.scale;
                var tmax = (Math.min(h.max, this.viewEnd) - this.viewStart) * this.scale;

                tierHolder.appendChild(makeElementNS(NS_SVG, 'rect', null, {x: margin + tmin, y: 70, width: (tmax-tmin), height: pos-70,
                                                                      stroke: 'none', fill: this.defaultHighlightFill, fillOpacity: this.defaultHighlightAlpha}));
            }
        }
    }

    var rulerPos = -1; 
    if (opts.ruler == 'center') {
        rulerPos = margin + ((this.viewEnd - this.viewStart)*this.scale) / 2;
    } else if (opts.ruler == 'left') {
        rulerPos = margin;
    } else if (opts.ruler == 'right') {
        rulerPos = margin + ((this.viewEnd - this.viewStart)*this.scale);
    }
    if (rulerPos >= 0) {
        tierHolder.appendChild(makeElementNS(NS_SVG, 'line', null, {x1: rulerPos, y1: 70, x2: rulerPos, y2: pos,
                                                              stroke: 'blue'}));
    }

    saveRoot.appendChild(tierHolder);
    saveDoc.documentElement.setAttribute('width', b.featurePanelWidth + 20 + margin);
    saveDoc.documentElement.setAttribute('height', pos + 50);

    var svgBlob = new Blob([new XMLSerializer().serializeToString(saveDoc)], {type: 'image/svg+xml'});
    return svgBlob;
}

},{"./cbrowser":6,"./numformats":26,"./sequence-draw":31,"./svg-utils":39,"./utils":49,"./version":51}],39:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// svg-utils.js
//

var NS_SVG = 'http://www.w3.org/2000/svg';
var NS_XLINK = 'http://www.w3.org/1999/xlink';

function SVGPath() {
    this.ops = [];
}

SVGPath.prototype.moveTo = function(x, y) {
    this.ops.push('M ' + x + ' ' + y);
}

SVGPath.prototype.lineTo = function(x, y) {
    this.ops.push('L ' + x + ' ' + y);
}

SVGPath.prototype.closePath = function() {
    this.ops.push('Z');
}

SVGPath.prototype.toPathData = function() {
    return this.ops.join(' ');
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        NS_SVG: NS_SVG,
        NS_XLINK: NS_XLINK,
        SVGPath: SVGPath
    }
}
},{}],40:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tabix-source.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;
    var dalliance_makeParser = sa.makeParser;
    var FeatureSourceBase = sa.FeatureSourceBase;

    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;

    var utils = require('./utils');
    var Awaited = utils.Awaited;

    var connectTabix = require('./tabix').connectTabix;
}

function TabixFeatureSource(source) {
    FeatureSourceBase.call(this);
    this.readiness = 'Connecting';
    this.source = source;

    this.tabixHolder = new Awaited();
    var thisB = this;


    var parser = dalliance_makeParser(source.payload);
    if (!parser) {
        throw 'Unsuported tabix payload ' + source.payload;
    } else {
        this.parser = parser;
    }

    var data, index;
    if (this.source.blob) {
        data = new BlobFetchable(this.source.blob);
        index = new BlobFetchable(this.source.indexBlob);
    } else {
        data = new URLFetchable(this.source.uri, {credentials: this.source.credentials});
        index = new URLFetchable(this.source.indexURI || (this.source.uri + '.tbi'), {credentials: this.source.credentials});
    }
    connectTabix(data, index, function(tabix, err) {
        thisB.tabixHolder.provide(tabix);
        tabix.fetchHeader(function(lines, err) {
            if (lines) {
                var session = parser.createSession(function() { /* Null sink because we shouldn't get records */ });
                for (var li = 0; li < lines.length; ++li) {
                    session.parse(lines[li]);
                }
                session.flush();
            }
        });
        thisB.readiness = null
        thisB.notifyReadiness();
    });
}

TabixFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);

TabixFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {
    var thisB = this;
    
    thisB.busy++;
    thisB.notifyActivity();
    
    this.tabixHolder.await(function(tabix) {
        tabix.fetch(chr, min, max, function(records, error) {
            thisB.busy--;
            thisB.notifyActivity();

            var features = [];
            var session = thisB.parser.createSession(function(f) {features.push(f)});
            for (var ri = 0; ri < records.length; ++ri) {
                var f = session.parse(records[ri]);
            }
            session.flush();
            callback(null, features, 1000000000);
        });
    });
}


TabixFeatureSource.prototype.getStyleSheet = function(callback) {
    if (this.parser && this.parser.getStyleSheet)
        this.parser.getStyleSheet(callback)
}

TabixFeatureSource.prototype.getDefaultFIPs = function(callback) {
    if (this.parser && this.parser.getDefaultFIPs)
        this.parser.getDefaultFIPs(callback);
}


dalliance_registerSourceAdapterFactory('tabix', function(source) {
    return {features: new TabixFeatureSource(source)};
});
},{"./bin":4,"./sourceadapters":34,"./tabix":41,"./utils":49}],41:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2011
//
// tabix.js: basic support for tabix-indexed flatfiles
//

"use strict";

var TABIX_MAGIC = 0x01494254;

if (typeof(require) !== 'undefined') {
    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;

    var bin = require('./bin');
    var readInt = bin.readInt;
    var readShort = bin.readShort;
    var readByte = bin.readByte;
    var readInt64 = bin.readInt64;
    var readFloat = bin.readFloat;

    var lh3utils = require('./lh3utils');
    var readVob = lh3utils.readVob;
    var unbgzf = lh3utils.unbgzf;
    var reg2bins = lh3utils.reg2bins;
    var Chunk = lh3utils.Chunk;
}

function TabixFile() {
}

function connectTabix(data, tbi, callback) {
    var tabix = new TabixFile();
    tabix.data = data;
    tabix.tbi = tbi;

    tabix.tbi.fetch(function(header) {   // Do we really need to fetch the whole thing? :-(
        if (!header) {
            return callback(null, "Couldn't access Tabix");
        }

        var unchead = unbgzf(header, header.byteLength);
        var uncba = new Uint8Array(unchead);
        var magic = readInt(uncba, 0);
        if (magic != TABIX_MAGIC) {
            return callback(null, 'Not a tabix index');
        }

        var nref = readInt(uncba, 4);
        tabix.format = readInt(uncba, 8);
        tabix.colSeq = readInt(uncba, 12);
        tabix.colStart = readInt(uncba, 16);
        tabix.colEnd = readInt(uncba, 20);
        tabix.meta = readInt(uncba, 24);
        tabix.skip = readInt(uncba, 28);
        var nameLength = readInt(uncba, 32);

        tabix.indices = [];

        var p = 36;
        tabix.chrToIndex = {};
        tabix.indexToChr = [];
        for (var i = 0; i < nref; ++i) {
            var name = ''

            while (true) {
                var ch = uncba[p++];
                if (ch == 0)
                    break;

                name += String.fromCharCode(ch);
            }

            tabix.chrToIndex[name] = i;
            if (name.indexOf('chr') == 0) {
                tabix.chrToIndex[name.substring(3)] = i;
            } else {
                tabix.chrToIndex['chr' + name] = i;
            }
            tabix.indexToChr.push(name);
        }

        var minBlockIndex = 1000000000;
        for (var ref = 0; ref < nref; ++ref) {
            var blockStart = p;
            var nbin = readInt(uncba, p); p += 4;
            for (var b = 0; b < nbin; ++b) {
                var bin = readInt(uncba, p);
                var nchnk = readInt(uncba, p+4);
                p += 8 + (nchnk * 16);
            }
            var nintv = readInt(uncba, p); p += 4;
            
            var q = p;
            for (var i = 0; i < nintv; ++i) {
                var v = readVob(uncba, q); q += 8;
                if (v) {
                    var bi = v.block;
                    if (v.offset > 0)
                        bi += 65536;

                    if (bi < minBlockIndex)
                        minBlockIndex = bi;
                    break;
                }
            }
            p += (nintv * 8);


            var ub = uncba;
            if (nbin > 0) {
                tabix.indices[ref] = new Uint8Array(unchead, blockStart, p - blockStart);
            }                     
        }

        tabix.headerMax = minBlockIndex;

        callback(tabix);
    }, {timeout: 5000});
}

// Copy-paste from BamFile

TabixFile.prototype.blocksForRange = function(refId, min, max) {
    var index = this.indices[refId];
    if (!index) {
        return [];
    }

    var intBinsL = reg2bins(min, max);
    var intBins = [];
    for (var i = 0; i < intBinsL.length; ++i) {
        intBins[intBinsL[i]] = true;
    }
    var leafChunks = [], otherChunks = [];

    var nbin = readInt(index, 0);
    var p = 4;
    for (var b = 0; b < nbin; ++b) {
        var bin = readInt(index, p);
        var nchnk = readInt(index, p+4);
        p += 8;
        if (intBins[bin]) {
            for (var c = 0; c < nchnk; ++c) {
                var cs = readVob(index, p);
                var ce = readVob(index, p + 8);
                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));
                p += 16;
            }
        } else {
            p +=  (nchnk * 16);
        }
    }

    var nintv = readInt(index, p);
    var lowest = null;
    var minLin = Math.min(min>>14, nintv - 1), maxLin = Math.min(max>>14, nintv - 1);
    for (var i = minLin; i <= maxLin; ++i) {
        var lb =  readVob(index, p + 4 + (i * 8));
        if (!lb) {
            continue;
        }
        if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {
            lowest = lb;
        }
    }
    
    var prunedOtherChunks = [];
    if (lowest != null) {
        for (var i = 0; i < otherChunks.length; ++i) {
            var chnk = otherChunks[i];
            if (chnk.maxv.block >= lowest.block && chnk.maxv.offset >= lowest.offset) {
                prunedOtherChunks.push(chnk);
            }
        }
    } 
    otherChunks = prunedOtherChunks;

    var intChunks = [];
    for (var i = 0; i < otherChunks.length; ++i) {
        intChunks.push(otherChunks[i]);
    }
    for (var i = 0; i < leafChunks.length; ++i) {
        intChunks.push(leafChunks[i]);
    }

    intChunks.sort(function(c0, c1) {
        var dif = c0.minv.block - c1.minv.block;
        if (dif != 0) {
            return dif;
        } else {
            return c0.minv.offset - c1.minv.offset;
        }
    });
    var mergedChunks = [];
    if (intChunks.length > 0) {
        var cur = intChunks[0];
        for (var i = 1; i < intChunks.length; ++i) {
            var nc = intChunks[i];
            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) { // no point splitting mid-block
                cur = new Chunk(cur.minv, nc.maxv);
            } else {
                mergedChunks.push(cur);
                cur = nc;
            }
        }
        mergedChunks.push(cur);
    }

    return mergedChunks;
}

TabixFile.prototype.fetch = function(chr, min, max, callback) {
    var thisB = this;

    var chrId = this.chrToIndex[chr];
    if (chrId == undefined)
        return callback([]);

    var canonicalChr = this.indexToChr[chrId];

    var chunks;
    if (chrId === undefined) {
        chunks = [];
    } else {
        chunks = this.blocksForRange(chrId, min, max);
        if (!chunks) {
            callback(null, 'Error in index fetch');
        }
    }

    var records = [];
    var index = 0;
    var data;

    function tramp() {
        if (index >= chunks.length) {
            return callback(records);
        } else if (!data) {
            var c = chunks[index];
            var fetchMin = c.minv.block;
            var fetchMax = c.maxv.block + (1<<16); // *sigh*
            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function(r) {
                data = unbgzf(r, c.maxv.block - c.minv.block + 1);
                return tramp();
            });
        } else {
            var ba = new Uint8Array(data);
            thisB.readRecords(ba, chunks[index].minv.offset, records, min, max, canonicalChr);
            data = null;
            ++index;
            return tramp();
        }
    }
    tramp();
}

TabixFile.prototype.readRecords = function(ba, offset, sink, min, max, chr) {
   LINE_LOOP:
    while (true) {
        var line = '';
        while (offset < ba.length) {
            var ch = ba[offset++];
            if (ch == 10) {
                var toks = line.split('\t');

                if (toks[this.colSeq - 1] == chr) {
                    var fmin = parseInt(toks[this.colStart - 1]);
                    var fmax = fmin;
                    if (this.colEnd > 0)
                        fmax = parseInt(toks[this.colEnd - 1]);
                    if (this.format & 0x10000) ++fmin;

                    if (fmin <= max && fmax >= min)
                        sink.push(line);
                }
                continue LINE_LOOP;
            } else {
                line += String.fromCharCode(ch);
            }
        }
        return;
    }
}

TabixFile.prototype.fetchHeader = function(callback) {
    var self = this;
    var fetchPtr = 0, ptr = 0, line='';
    var lines = [];

    self.data.slice(0, self.headerMax).fetch(function(chnk) {
        if (!chnk) {
            return callback(null, "Fetch failed");
        }
        var ba = new Uint8Array(unbgzf(chnk, chnk.byteLength));
        var ptr = 0, line = '', lines = [];
        while (ptr < ba.length) {
            var ch = ba[ptr++]
            if (ch == 10) {
                if (line.charCodeAt(0) == self.meta) {
                    lines.push(line);
                    line = '';
                } else {
                    return callback(lines);
                }
            } else {
                line += String.fromCharCode(ch);
            }
        }
        callback(lines);
    });
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        connectTabix: connectTabix,
        TABIX_MAGIC: TABIX_MAGIC
    };
}

},{"./bin":4,"./lh3utils":24,"./spans":36}],42:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// thub.js: support for track-hub style registries
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var textXHR = utils.textXHR;
    var relativeURL = utils.relativeURL;
    var shallowCopy = utils.shallowCopy;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
}

var THUB_STANZA_REGEXP = /\n\s*\n/;
var THUB_PARSE_REGEXP  = /(\w+) +(.+)\n?/;
var THUB_SUBGROUP_REGEXP = /subGroup[1-9]/;

var THUB_PENNANT_PREFIX = 'http://genome.ucsc.edu/images/';

function TrackHub(url) {
    this.genomes = {};
    this.url = url;
}

function TrackHubTrack() {
}

TrackHubTrack.prototype.get = function(k) {
    if (this[k])
        return this[k];
    else if (this._parent) 
        return this._parent.get(k);
}

function TrackHubDB(hub) {
    this.hub = hub;
}

TrackHubDB.prototype.getTracks = function(callback) {
    var thisB = this;
    if (this._tracks) {
        return callback(this._tracks);
    } 
    
    textXHR(this.absURL, function(trackFile, err) {
        if (err) {
            return callback(null, err);
        }
        
        // trackFile = trackFile.replace(/\#.*/g, '');
        trackFile = trackFile.replace('\\\n', ' ');

        var tracks = [];
        var tracksById = {};
        var stanzas = trackFile.split(THUB_STANZA_REGEXP);
        for (var s = 0; s < stanzas.length; ++s) {
            var toks = stanzas[s].replace(/\#.*/g, '').split(THUB_PARSE_REGEXP);
            var track = new TrackHubTrack();
            track._db = thisB;
            for (var l = 0; l < toks.length - 2; l += 3) {
                var k = toks[l+1], v = toks[l+2];
                if (k.match(THUB_SUBGROUP_REGEXP)) {
                    if (!track.subgroups)
                        track.subgroups = {};
                    var sgtoks = v.split(/\s/);
                    var sgtag = sgtoks[0];
                    var sgrecord = {name: sgtoks[1], tags: [], titles: []};
                    for (var sgti = 2; sgti < sgtoks.length; ++sgti) {
                        var grp = sgtoks[sgti].split(/=/);
                        sgrecord.tags.push(grp[0]);
                        sgrecord.titles.push(grp[1]);
                    }
                    track.subgroups[sgtag] = sgrecord;
                } else if (k === 'subGroups') {
                    var sgtoks = v.split(/(\w+)=(\w+)/);
                    track.sgm = {};
                    for (var sgti = 0; sgti < sgtoks.length - 2; sgti += 3) {
                        track.sgm[sgtoks[sgti+1]] = sgtoks[sgti + 2];
                    }
                } else {
                    track[toks[l+1]] = toks[l+2];
                }
            }

            if (track.track && (track.type || track.container || track.view || track.bigDataUrl)) {
                tracks.push(track);
                tracksById[track.track] = track;
            } else {
                // console.log('skipping ', track);
            }
        }
        
        var toplevels = [];
        var composites = [];
        for (var ti = 0; ti < tracks.length; ++ti) {
            var track = tracks[ti];
            var top = true;
            if (track.parent) {
                var ptoks = track.parent.split(/\s+/);
                var parent = tracksById[ptoks[0]];
                if (parent) {
                    track._parent = parent;

                    if (!parent.children)
                        parent.children = [];
                    parent.children.push(track);

                    if (parent)
                        top = false;
                } else {
                    console.log("Couldn't find parent " + ptoks[0] + '(' + track.parent + ')');
                }
               
            }
            if (track.compositeTrack) {
                composites.push(track);
            } else if (top) {
                toplevels.push(track);
            }
        }

        for (var ci = 0; ci < composites.length; ++ci) {
            var comp = composites[ci];
            if (!comp.children)
                continue;

            var parentOfViews = false;
            for (var ki = 0; ki < comp.children.length; ++ki) {
                var k = comp.children[ki];
                if (k.view) {
                    k.shortLabel = comp.shortLabel + ": " + k.shortLabel;
                    toplevels.push(k);
                    parentOfViews = true;
                }
            }
            if (!parentOfViews)
                toplevels.push(comp);
        }
            
        thisB._tracks = toplevels;
        return callback(thisB._tracks, null);
    }, {credentials: this.credentials, salt: true});
}

function connectTrackHub(hubURL, callback, opts) {
    opts = opts || {};
    opts.salt = true;

    textXHR(hubURL, function(hubFile, err) {
        if (err) {
            return callback(null, err);
        }

        var toks = hubFile.split(THUB_PARSE_REGEXP);
        var hub = new TrackHub(hubURL);
        if (opts.credentials) {
            hub.credentials = opts.credentials;
        }
        for (var l = 0; l < toks.length - 2; l += 3) {
            hub[toks[l+1]] = toks[l+2];
        }
        
        
        if (hub.genomesFile) {
            var genURL = relativeURL(hubURL, hub.genomesFile);
            textXHR(genURL, function(genFile, err) {
                if (err) {
                    return callback(null, err);
                }

                var stanzas = genFile.split(THUB_STANZA_REGEXP);
                for (var s = 0; s < stanzas.length; ++s) {
                    var toks = stanzas[s].split(THUB_PARSE_REGEXP);
                    var gprops = new TrackHubDB(hub);
                    if (opts.credentials) {
                        gprops.credentials = opts.credentials;
                    }

                    for (var l = 0; l < toks.length - 2; l += 3) {
                        gprops[toks[l+1]] = toks[l+2];
                    }

                    if (gprops.twoBitPath) {
                        gprops.twoBitPath = relativeURL(genURL, gprops.twoBitPath);
                    }

                    if (gprops.genome && gprops.trackDb) {
                        gprops.absURL = relativeURL(genURL, gprops.trackDb);
                        hub.genomes[gprops.genome] = gprops;
                    }
                }

                callback(hub);
                        
            }, opts);
        } else {
            callback(null, 'No genomesFile');
        }
    }, opts);
}


TrackHubTrack.prototype.toDallianceSource = function() {
    var source = {
        name: this.shortLabel,
        desc: this.longLabel
    };
    if (this._db.mapping) {
        source.mapping = this._db.mapping;
    }

    var pennantIcon = this.get('pennantIcon');
    if (pennantIcon) {
        var ptoks = pennantIcon.split(/\s+/);
        source.pennant = THUB_PENNANT_PREFIX + ptoks[0];
    }

    var searchTrix = this.get('searchTrix');
    if (searchTrix) {
        source.trixURI = relativeURL(this._db.absURL, searchTrix);
    }

    if (this.container == 'multiWig') {
        source.merge = 'concat';
        source.overlay = [];
        var children = this.children || [];
        source.style = [];
        source.noDownsample = true;

        for (var ci = 0; ci < children.length; ++ci) {
            var ch = children[ci];
            var cs = ch.toDallianceSource()
            source.overlay.push(cs);

            if (cs.style) {
                for (var si = 0; si < cs.style.length; ++si) {
                    var style = cs.style[si];
                    style.method = ch.shortLabel;  // FIXME
                    if (this.aggregate == 'transparentOverlay')
                        style.style.ALPHA = 0.5;
                    source.style.push(style);
                }
            }
        }
        return source;       
    } else {
        var type = this.type;
        if (!type) {
            var p = this;
            while (p._parent && !p.type) {
                p = p._parent;
            }
            type = p.type;
        }
        if (!type)
            return;
        var typeToks = type.split(/\s+/);
        if (typeToks[0] == 'bigBed' && this.bigDataUrl) {
            var bedTokens = typeToks[1]|0
            var bedPlus = typeToks[2] == '+';

            source.bwgURI = relativeURL(this._db.absURL, this.bigDataUrl);
            source.style = this.bigbedStyles();
            if (this._db.credentials) {
                source.credentials = true;
            }
            if (bedTokens >= 12 && bedPlus)
                source.collapseSuperGroups = true;
            return source;
        } else if (typeToks[0] == 'bigWig' && this.bigDataUrl) {
            source.bwgURI = relativeURL(this._db.absURL, this.bigDataUrl);
            source.style = this.bigwigStyles();
            source.noDownsample = true;     // FIXME seems like a blunt instrument...
            
            if (this.yLineOnOff && this.yLineOnOff == 'on') {
                source.quantLeapThreshold = this.yLineMark !== undefined ? (1.0 * this.yLineMark) : 0.0;
            }

            if (this._db.credentials) {
                source.credentials = true;
            }

            return source;
        } else if (typeToks[0] == 'bam'  && this.bigDataUrl) {
            source.bamURI = relativeURL(this._db.absURL, this.bigDataUrl);
            if (this._db.credentials) {
                source.credentials = true;
            }
            return source;
        } else if (typeToks[0] == 'vcfTabix' && this.bigDataUrl) {
            source.uri = relativeURL(this._db.absURL, this.bigDataUrl);
            source.tier_type = 'tabix';
            source.payload = 'vcf';
            if (this._db.credentials) {
                source.credentials = true;
            }
            return source;
        } else {
            console.log('Unsupported ' + this.type);
        }
    }
}

TrackHubTrack.prototype.bigwigStyles = function() {
    var type = this.type;
    if (!type) {
        var p = this;
        while (p._parent && !p.type) {
            p = p._parent;
        }
        type = p.type;
    }
    if (!type)
        return;
    var typeToks = type.split(/\s+/);

    var min, max;
    if (typeToks.length >= 3) {
        min = 1.0 * typeToks[1];
        max = 1.0 * typeToks[2];
    }

    var height;
    if (this.maxHeightPixels) {
        var mhpToks = this.maxHeightPixels.split(/:/);
        if (mhpToks.length == 3) {
            height = mhpToks[1] | 0;
        } else {
            console.log('maxHeightPixels should be of the form max:default:min');
        }
    }
    
    var gtype = 'bars';
    if (this.graphTypeDefault) {
        gtype = this.graphTypeDefault;
    }
    
    var color = 'black';
    var altColor = null;
    if (this.color) {
        color = 'rgb(' + this.color + ')';
    }
    if (this.altColor) {
        altColor = 'rgb(' + this.altColor + ')';
    }
    
    var stylesheet = new DASStylesheet();
    var wigStyle = new DASStyle();
    if (gtype == 'points') {
        wigStyle.glyph = 'POINT';
    } else {
        wigStyle.glyph = 'HISTOGRAM';
    }

    if (altColor) {
        wigStyle.COLOR1 = color;
        wigStyle.COLOR2 = altColor;
    } else {
        wigStyle.BGCOLOR = color;
    }
    wigStyle.HEIGHT = height || 30;
    if (min || max) {
        wigStyle.MIN = min;
        wigStyle.MAX = max;
    }
    stylesheet.pushStyle({type: 'default'}, null, wigStyle);
    return stylesheet.styles;
}

TrackHubTrack.prototype.bigbedStyles = function() {
    var itemRgb = (''+this.get('itemRgb')).toLowerCase() == 'on';
    var visibility = this.get('visibility') || 'full';
    var color = this.get('color');
    if (color)
        color = 'rgb(' + color + ')';
    else 
        color = 'blue';
    
    var stylesheet = new DASStylesheet();
    var wigStyle = new DASStyle();
    wigStyle.glyph = 'BOX';
    wigStyle.FGCOLOR = 'black';
    wigStyle.BGCOLOR = color;
    wigStyle.HEIGHT = (visibility == 'full' || visibility == 'pack') ? 12 : 8;
    wigStyle.BUMP = (visibility == 'full' || visibility == 'pack');
    wigStyle.LABEL = (visibility == 'full' || visibility == 'pack');
    wigStyle.ZINDEX = 20;
    if (itemRgb)
        wigStyle.BGITEM = true;

    var cbs = this.get('colorByStrand');
    if (cbs) {
        var cbsToks = cbs.split(/\s+/);
        
        var plus = shallowCopy(wigStyle);
        plus.BGCOLOR = 'rgb(' + cbsToks[0] + ')';
        stylesheet.pushStyle({type: 'bigbed', orientation: '+'}, null, plus);

        var minus = shallowCopy(wigStyle);
        minus.BGCOLOR = 'rgb(' + cbsToks[1] + ')';
        stylesheet.pushStyle({type: 'bigbed', orientation: '-'}, null, minus);
    } else {
        stylesheet.pushStyle({type: 'bigbed'}, null, wigStyle);
    }   
    
    var tlStyle = new DASStyle();
    tlStyle.glyph = 'BOX';
    tlStyle.FGCOLOR = 'black';
    if (itemRgb)
        tlStyle.BGITEM = true;
    tlStyle.BGCOLOR = 'red'
    tlStyle.HEIGHT = 10;
    tlStyle.BUMP = true;
    tlStyle.ZINDEX = 20;
    stylesheet.pushStyle({type: 'translation'}, null, tlStyle);
    
    var tsStyle = new DASStyle();
    tsStyle.glyph = 'BOX';
    tsStyle.FGCOLOR = 'black';
    tsStyle.BGCOLOR = 'white';
    tsStyle.HEIGHT = 10;
    tsStyle.ZINDEX = 10;
    tsStyle.BUMP = true;
    tsStyle.LABEL = true;
    stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);

    return stylesheet.styles;
}

function THUB_COMPARE(g, h) {
    if (g.priority && h.priority) {
        return (1.0 * g.priority) - (1.0 * h.priority)
    } else if (g.priority) {
        return 1;
    } else if (h.priority) {
        return -1;
    } else {
        return g.shortLabel.localeCompare(h.shortLabel);
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        connectTrackHub: connectTrackHub,
        THUB_COMPARE: THUB_COMPARE
    };
}

},{"./das":10,"./utils":49}],43:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tier-actions.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var shallowCopy = utils.shallowCopy;
}

Browser.prototype.mergeSelectedTiers = function() {
    var sources = [];
    var styles = [];

    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {
        var tier = this.tiers[this.selectedTiers[sti]];
	    sources.push(shallowCopy(tier.dasSource));
        var ss = tier.stylesheet.styles;
        for (var si = 0; si < ss.length; ++si) {
            var sh = ss[si];
            var nsh = shallowCopy(sh);
            nsh.method = tier.dasSource.name.replace(/[()+*?]/g, '\\$&');
            nsh._methodRE = null;
            nsh.style = shallowCopy(sh.style);
            if (nsh.style.ZINDEX === undefined)
                nsh.style.ZINDEX = sti;

            if (tier.forceMin) {
                nsh.style.MIN = tier.forceMin;
            }
            if (tier.forceMax) {
                nsh.style.MAX = tier.forceMax;
            }

            styles.push(nsh);
        }
    }
    
    this.addTier(
	{name: 'Merged',
	 merge: 'concat',
	 overlay: sources,
	 noDownsample: true,
     style: styles});

    this.setSelectedTier(this.tiers.length - 1);
}

},{"./cbrowser":6,"./utils":49}],44:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2013
//
// tier-edit.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var utils = require('./utils');
    var makeElement = utils.makeElement;

    var das = require('./das');
    var isDasBooleanTrue = das.isDasBooleanTrue;
    var isDasBooleanNotFalse = das.isDasBooleanNotFalse;
    var copyStylesheet = das.copyStylesheet;

    var color = require('./color');
    var dasColourForName = color.dasColourForName;

    var sourceDataURI = require('./sourcecompare').sourceDataURI;
}

var __dalliance_smallGlyphs = {
    DOT: true, 
    EX: true, 
    STAR: true, 
    SQUARE: true, 
    CROSS: true, 
    TRIANGLE: true, 
    PLIMSOLL: true
};

Browser.prototype.openTierPanel = function(tier) {
    var b = this;

    if (this.uiMode === 'tier' && this.manipulatingTier === tier) {
        this.hideToolPanel();
        this.setUiMode('none');
    } else if (!tier) {
        return;
    } else {
        var setStyleColors = function(style) {
            if (style.BGGRAD)
                return;

            if (numColors == 1) {
                if (style.glyph == 'LINEPLOT' || __dalliance_smallGlyphs[style.glyph]) {
                    style.FGCOLOR = tierColorField.value;
                } else {
                    style.BGCOLOR = tierColorField.value;
                }
                style.COLOR1 = style.COLOR2 = style.COLOR3 = null;
            } else {
                style.COLOR1 = tierColorField.value;
                style.COLOR2 = tierColorField2.value;
                if (numColors > 2) {
                    style.COLOR3 = tierColorField3.value;
                } else {
                    style.COLOR3 = null;
                }
            }
            style._gradient = null;
            style._plusColor = tierPlusColorField.value;
            style._minusColor = tierMinusColorField.value;
        }

        var mutateStylesheet = function(visitor) {
            var nss = copyStylesheet(tier.stylesheet);
            var ssScale = tier.browser.zoomForCurrentScale();

            for (var i = 0; i < nss.styles.length; ++i) {
                var sh = nss.styles[i];
                if (sh.zoom && sh.zoom != ssScale) {
                    continue;
                }

                visitor(sh.style);
            }

            return nss;
        }

        var changeColor = function(ev) {
            tier.mergeStylesheet(mutateStylesheet(setStyleColors));
        }
        
        this.manipulatingTier = tier;

        var tierForm = makeElement('div', null, {className: 'tier-edit'});

        var aboutBanner = makeElement('div', "About '" + (tier.config.Name || tier.dasSource.name) + "'", null,
                {background: 'gray', paddingBottom: '5px', marginBottom: '5px', textAlign: 'center'});
        tierForm.appendChild(aboutBanner);

        var about = makeElement('div', 
            [makeElement('p', tier.dasSource.desc)]
        );
        var aboutNotes = [];
        var sduri = sourceDataURI(tier.dasSource);
        if (sduri &&
            (sduri.indexOf('http://') == 0 ||
             sduri.indexOf('https://') == 0 ||
             sduri.indexOf('//') == 0) &&
            sduri !== 'https://www.biodalliance.org/magic/no_uri')
        {
            aboutNotes.push(makeElement('li', makeElement('a', '(Download data)', {href: sduri})));
        }

        if (tier.dasSource.mapping) {
            var coords = this.chains[tier.dasSource.mapping].coords;
            aboutNotes.push(makeElement('li',  'Mapped from ' + coords.auth + coords.version));
        }

        if (aboutNotes.length > 0) {
            about.appendChild(makeElement('ul', aboutNotes));
        }
        
        tierForm.appendChild(about);

        var semanticBanner = makeElement('span', ' (styles for current zoom level)', null, {display: 'none'});
        var editBanner = makeElement('div', ['Edit', semanticBanner], null,
              {background: 'gray', paddingBottom: '5px', marginBottom: '5px', textAlign: 'center'});
        tierForm.appendChild(editBanner);

        var tierNameField = makeElement('input', null, {type: 'text'});
        var tierPinnedToggle = makeElement('input', null, {type: 'checkbox', disabled: this.disablePinning});

        var glyphField = makeElement('select');
        glyphField.appendChild(makeElement('option', 'Histogram', {value: 'HISTOGRAM'}));
        glyphField.appendChild(makeElement('option', 'Line Plot', {value: 'LINEPLOT'}));
        glyphField.appendChild(makeElement('option', 'Ribbon', {value: 'GRADIENT'}));
        glyphField.appendChild(makeElement('option', 'Scatter', {value: 'SCATTER'}));

        var tierColorField = makeElement('input', null, {type: 'text', value: '#dd00dd'});
        var tierColorField2 = makeElement('input', null, {type: 'text', value: '#dd00dd'});
        var tierColorField3 = makeElement('input', null, {type: 'text', value: '#dd00dd'});

        var tierPlusColorField = makeElement('input', null, {type: 'text', value: '#ffa07a'});
        var tierMinusColorField = makeElement('input', null, {type: 'text', value: '#87cefa'});

        try {
            tierColorField.type = tierColorField2.type = tierColorField3.type = 'color';
            tierPlusColorField.type = tierMinusColorField.type = 'color';
        } catch (e) {
            // IE throws if attempt to set type to 'color'.
        }

        var tierColorFields = [tierColorField, tierColorField2, tierColorField3];
        var colorListPlus = makeElement('i', null, {className: 'fa fa-plus-circle'});
        var colorListMinus = makeElement('i', null, {className: 'fa fa-minus-circle'});
        var numColors = 1;
        var colorListElement = makeElement('td', tierColorFields);
        var setNumColors = function(n) {
            numColors = n;
            for (var i = 0; i < n; ++i) 
                tierColorFields[i].style.display = 'block';
            for (var i = n; i < tierColorFields.length; ++i)
                tierColorFields[i].style.display = 'none';
        }
        colorListPlus.addEventListener('click', function(ev) {
            if (numColors < 3) {
                setNumColors(numColors + 1);
                changeColor(null);
            }
        }, false);
        colorListMinus.addEventListener('click', function(ev) {
            if (numColors > 1) {
                setNumColors(numColors - 1);
                changeColor(null);
            }
        }, false);

        var tierMinField = makeElement('input', null, {type: 'text', value: '0.0'});
        var tierMaxField = makeElement('input', null, {type: 'text', value: '10.0'});
        var tierMinToggle = makeElement('input', null, {type: 'checkbox'});
        var tierMaxToggle = makeElement('input', null, {type: 'checkbox'});

        var quantLeapToggle = makeElement('input', null, {type: 'checkbox', checked: tier.quantLeapThreshold !== undefined});
        var quantLeapThreshField = makeElement('input', null, {type: 'text', value: tier.quantLeapThreshold, disabled: !quantLeapToggle.checked});

        var tierHeightField = makeElement('input', null, {type: 'text', value: '50'});

        var bumpToggle = makeElement('input', null, {type: 'checkbox'});
        var bumpLimit = makeElement('input', null, {type: 'text'});
        var labelToggle = makeElement('input', null, {type: 'checkbox'});

        var mainStyle = null;
        if (tier.stylesheet.styles.length > 0) {
            var s = mainStyle = tier.stylesheet.styles[0].style;
        }

        var refresh = function() {
            if (typeof tier.config.name === 'string')
                tierNameField.value = tier.config.name;
            else 
                tierNameField.value = tier.dasSource.name;

            tierPinnedToggle.checked = tier.pinned;

            if (tier.forceHeight) {
                tierHeightField.value = '' + tier.forceHeight;
            } else if (mainStyle && mainStyle.HEIGHT) {
                tierHeightField.value = '' + mainStyle.HEIGHT;
            }

            if (typeof tier.quantLeapThreshold == 'number') {
                quantLeapToggle.checked = true;
                quantLeapThreshField.disabled = false;
                if (parseFloat(quantLeapThreshField.value) != tier.quantLeapThreshold)
                    quantLeapThreshField.value = tier.quantLeapThreshold;
            } else {
                quantLeapToggle.checked = false;
                quantLeapThreshField.disabled = true;
            }

            if (typeof tier.subtierMax == 'number') {
                bumpLimit.value = '' + tier.subtierMax;
            } else {
                bumpLimit.value = '' + (tier.dasSource.subtierMax || tier.browser.defaultSubtierMax);
            }

            if (tier.stylesheet.styles.length > 0) {
                var s = null;
                var isQuantitative=false, isSimpleQuantitative = false;
                var ssScale = tier.browser.zoomForCurrentScale();
                var activeStyleCount = 0;

                for (var si = 0; si < tier.stylesheet.styles.length; ++si) {
                    var sh = tier.stylesheet.styles[si];  
                    if (sh.zoom && sh.zoom != ssScale) {
                        continue;
                    }
                    ++activeStyleCount;
                    var ss = tier.stylesheet.styles[si].style;

                    if (!s) {
                        s = mainStyle = ss;
                    }
                    
                    if (ss.glyph == 'LINEPLOT' || ss.glyph == 'HISTOGRAM' || ss.glyph == 'GRADIENT' || isDasBooleanTrue(ss.SCATTER)) {
                        if (!isQuantitative)
                            s = mainStyle = ss;
                        isQuantitative = true;
                    }
                }
                if (!s) {
                    return;
                }

                semanticBanner.style.display = (activeStyleCount == tier.stylesheet.styles.length) ? 'none' : 'inline';

                isSimpleQuantitative = isQuantitative && activeStyleCount == 1;
                var isGradient = s.COLOR2 || s.BGGRAD;

                if (isQuantitative) {
                    minRow.style.display = 'table-row';
                    maxRow.style.display = 'table-row';
                    bumpRow.style.display = 'none';
                    labelRow.style.display = 'none';
                } else {
                    minRow.style.display = 'none';
                    maxRow.style.display = 'none';
                    bumpRow.style.display = 'table-row';
                    bumpToggle.checked = isDasBooleanTrue(mainStyle.BUMP);
                    bumpLimit.disabled = !isDasBooleanTrue(mainStyle.BUMP);
                    labelRow.style.display = 'table-row';
                    labelToggle.checked = isDasBooleanTrue(mainStyle.LABEL);
                }

                if (isSimpleQuantitative) {
                    styleRow.style.display = 'table-row';
                    colorRow.style.display = 'table-row';
                } else {
                    styleRow.style.display = 'none';
                    colorRow.style.display = 'none';

                }

                var numColors = 1;
                if (s.COLOR1) {
                    tierColorField.value = dasColourForName(s.COLOR1).toHexString();
                    if (s.COLOR2) {
                        tierColorField2.value = dasColourForName(s.COLOR2).toHexString();
                        if (s.COLOR3) {
                            tierColorField3.value = dasColourForName(s.COLOR3).toHexString();
                            numColors = 3;
                        } else {
                            numColors = 2;
                        }
                    }
                } else {
                    if (s.glyph == 'LINEPLOT' || s.glyph == 'DOT' && s.FGCOLOR) {
                        tierColorField.value = dasColourForName(s.FGCOLOR).toHexString();
                    } else if (s.BGCOLOR) {
                        tierColorField.value = dasColourForName(s.BGCOLOR).toHexString();
                    }
                } 
                setNumColors(numColors);

                if (s._plusColor)
                    tierPlusColorField.value = dasColourForName(s._plusColor).toHexString() || s._plusColor;
                if (s._minusColor)
                    tierMinusColorField.value = dasColourForName(s._minusColor).toHexString() || s._minusColor;
                if (isDasBooleanTrue(s.SCATTER)) {
                    glyphField.value = 'SCATTER';
                } else {
                    glyphField.value = s.glyph;
                } 

                var setMinValue, setMaxValue;
                if (s.MIN !== undefined) {
                    var x = parseFloat(s.MIN);
                    if (!isNaN(x))
                        setMinValue = x;
                }
                if (!tier.forceMinDynamic && (s.MIN !== undefined || tier.forceMin !== undefined)) {
                    tierMinToggle.checked = true;
                    tierMinField.disabled = false;
                } else {
                    tierMinToggle.checked = false;
                    tierMinField.disabled = true;
                }

                if (s.MAX !== undefined) {
                    var x = parseFloat(s.MAX)
                    if (!isNaN(x))
                        setMaxValue = x;
                }
                if (!tier.forceMaxDynamic && (s.MAX !== undefined || tier.forceMax !== undefined)) {
                    tierMaxToggle.checked = true;
                    tierMaxField.disabled = false;
                } else {
                    tierMaxToggle.checked = false;
                    tierMaxField.disabled = true;
                }

                if (tier.forceMin != undefined) {
                    setMinValue = tier.forceMin;
                }
                if (tier.forceMax != undefined) {
                    setMaxValue = tier.forceMax;
                }
                if (typeof(setMinValue) == 'number' && setMinValue != parseFloat(tierMinField.value)) {
                    tierMinField.value = setMinValue;
                }
                if (typeof(setMaxValue) == 'number' && setMaxValue != parseFloat(tierMaxField.value)) {
                    tierMaxField.value = setMaxValue;
                }

                var seqStyle = getSeqStyle(tier.stylesheet);
                if (seqStyle) {
                    seqMismatchRow.style.display = 'table-row';
                    seqMismatchToggle.checked = (seqStyle.__SEQCOLOR === 'mismatch');
                    seqInsertRow.style.display = 'table-row';
                    seqInsertToggle.checked =  isDasBooleanTrue(seqStyle.__INSERTIONS);
                    seqIgnoreQualsRow.style.display = 'table-row';
                    seqIgnoreQualsToggle.checked = (seqStyle.__disableQuals === undefined || seqStyle.__disableQuals === false);
                    console.log(seqStyle.__disableQuals);
                } else {
                    seqMismatchRow.style.display = 'none';
                    seqInsertRow.style.display = 'none';
                    seqIgnoreQualsRow.style.display = 'none';
                }

                if (seqStyle && seqMismatchToggle.checked && !isSimpleQuantitative) {
                    plusStrandColorRow.style.display = 'table-row';
                    minusStrandColorRow.style.display = 'table-row';
                } else {
                    plusStrandColorRow.style.display = 'none';
                    minusStrandColorRow.style.display = 'none';
                }
            }

            if (isQuantitative && tier.browser.sourceAdapterIsCapable(tier.featureSource, 'quantLeap'))
                quantLeapRow.style.display = 'table-row';
            else 
                quantLeapRow.style.display = 'none';
        }

        var seqMismatchToggle = makeElement('input', null, {type: 'checkbox'});
        var seqMismatchRow = makeElement('tr',
            [makeElement('th', 'Highlight mismatches & strands'),
             makeElement('td', seqMismatchToggle)]);
        seqMismatchToggle.addEventListener('change', function(ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__SEQCOLOR = seqMismatchToggle.checked ? 'mismatch' : 'base';
            tier.mergeStylesheet(nss);
        });

        var seqInsertToggle = makeElement('input', null, {type: 'checkbox'});
        var seqInsertRow = makeElement('tr',
            [makeElement('th', 'Show insertions'),
             makeElement('td', seqInsertToggle)]);
        seqInsertToggle.addEventListener('change', function(ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__INSERTIONS = seqInsertToggle.checked ? 'yes' : 'no';
            tier.mergeStylesheet(nss);
        });

        var seqIgnoreQualsToggle = makeElement('input', null, {type: 'checkbox'});
        var seqIgnoreQualsRow = makeElement('tr',
            [makeElement('th', 'Reflect base quality as base color transparency'),
             makeElement('td', seqIgnoreQualsToggle)]);
        seqIgnoreQualsToggle.addEventListener('change', function(ev) {
            var nss = copyStylesheet(tier.stylesheet);
            var seqStyle = getSeqStyle(nss);
            seqStyle.__disableQuals = !seqIgnoreQualsToggle.checked;
            console.log(seqStyle.__disableQuals);
            tier.mergeStylesheet(nss);
        });

        var styleRow = makeElement('tr',
                [makeElement('th', 'Style'),
                 makeElement('td', glyphField)]);
        var colorRow = makeElement('tr',
                [makeElement('th', ['Colour(s)', colorListPlus, colorListMinus]),
                 colorListElement]);
        var plusStrandColorRow = makeElement('tr',
                [makeElement('th', 'Plus Strand Color'),
                 makeElement('td', tierPlusColorField)]);
        var minusStrandColorRow = makeElement('tr',
                [makeElement('th', 'Minus Strand Color'),
                 makeElement('td', tierMinusColorField)]);
        var minRow = makeElement('tr',
                [makeElement('th', 'Min value'),
                 makeElement('td', [tierMinToggle, ' ', tierMinField])]);
        var maxRow = makeElement('tr',
                [makeElement('th', 'Max value'),
                 makeElement('td', [tierMaxToggle, ' ', tierMaxField])]);
        var quantLeapRow = 
             makeElement('tr',
                [makeElement('th', 'Threshold leap:'),
                 makeElement('td', [quantLeapToggle, ' ', quantLeapThreshField])]);
        var bumpRow = makeElement('tr',
                [makeElement('th', 'Bump overlaps'),
                 makeElement('td', [bumpToggle, ' limit: ', bumpLimit])]);
        var labelRow = makeElement('tr',
                [makeElement('th', 'Label features'),
                 makeElement('td', labelToggle)]);


        var tierTable = makeElement('table',
            [makeElement('tr',
                [makeElement('th', 'Name', {}, {width: '150px', textAlign: 'right'}),
                 tierNameField]),

             makeElement('tr',
                [makeElement('th', 'Pin to top'),
                 tierPinnedToggle]),

             makeElement('tr',
                [makeElement('th', 'Height'),
                 makeElement('td', tierHeightField)]),

            styleRow,
            colorRow,
            plusStrandColorRow,
            minusStrandColorRow,
            minRow,
            maxRow,
            quantLeapRow,
            bumpRow,
            labelRow,
            seqMismatchRow,
            seqInsertRow,
            seqIgnoreQualsRow
             ]);


        refresh();

        tierForm.appendChild(tierTable);

        var resetButton = makeElement('button', 'Reset track', {className: 'btn'}, {marginLeft: 'auto', marginRight: 'auto', display: 'block'});
        resetButton.addEventListener('click', function(ev) {
            tier.setConfig({});
        }, false);
        tierForm.appendChild(resetButton);

        tierNameField.addEventListener('input', function(ev) {
            tier.mergeConfig({name: tierNameField.value});
        }, false);

        tierPinnedToggle.addEventListener('change', function(ev) {
            tier.mergeConfig({pinned: tierPinnedToggle.checked});
        }, false);

        for (var ci = 0; ci < tierColorFields.length; ++ci) {
            tierColorFields[ci].addEventListener('change', changeColor, false);
        }

        tierPlusColorField.addEventListener('change', changeColor, false);
        tierMinusColorField.addEventListener('change', changeColor, false);

        glyphField.addEventListener('change', function(ev) {
            var nss = mutateStylesheet(function(ts) {
                if (glyphField.value === 'SCATTER') {
                    ts.SCATTER = true;
                    ts.glyph = 'DOT';
                    ts.SIZE = '3';
                } else {
                    ts.glyph = glyphField.value;
                    ts.SCATTER = undefined;
                }
                setStyleColors(ts);
            });
            tier.mergeStylesheet(nss);
        }, false);

        tierMinToggle.addEventListener('change', function(ev) {
            var conf = {forceMinDynamic: !tierMinToggle.checked};
            tierMinField.disabled = !tierMinToggle.checked;
            var x = parseFloat(tierMinField.value);
            if (tierMinToggle.checked && typeof(x) == 'number' && !isNaN(x))
                conf.forceMin = parseFloat(x);
            tier.mergeConfig(conf);
        });
        tierMinField.addEventListener('input', function(ev) {
            var x = parseFloat(tierMinField.value);
            if (typeof(x) == 'number' && !isNaN(x))
                tier.mergeConfig({forceMin: x});
        }, false);

        tierMaxToggle.addEventListener('change', function(ev) {
            var conf = {forceMaxDynamic: !tierMaxToggle.checked};
            tierMaxField.disabled = !tierMaxToggle.checked;
            var x = parseFloat(tierMaxField.value);
            if (tierMaxToggle.checked && typeof(x) == 'number' && !isNaN(x))
                conf.forceMax = parseFloat(x);
            tier.mergeConfig(conf);
        });
        tierMaxField.addEventListener('input', function(ev) {
            var x = parseFloat(tierMaxField.value);
            if (typeof(x) == 'number' && !isNaN(x))
                tier.mergeConfig({forceMax: x});
        }, false);

        tierHeightField.addEventListener('input', function(ev) {
            var x = parseFloat(tierHeightField.value);
            if (typeof(x) == 'number' && !isNaN(x))
                tier.mergeConfig({height: Math.min(500, x|0)});
        }, false);

        var updateQuant = function() {
            quantLeapThreshField.disabled = !quantLeapToggle.checked;
            if (quantLeapToggle.checked) {
                var x = parseFloat(quantLeapThreshField.value);
                if (typeof(x) == 'number' && !isNaN(x)) {
                    tier.mergeConfig({quantLeapThreshold: parseFloat(quantLeapThreshField.value)});
                }
            } else {
                tier.mergeConfig({quantLeapThreshold: null});
            }
        }
        quantLeapToggle.addEventListener('change', function(ev) {
            updateQuant();
        }, false);
        quantLeapThreshField.addEventListener('input', function(ev) {
            updateQuant();
        }, false);

        labelToggle.addEventListener('change', function(ev) {
            var nss = mutateStylesheet(function(style) {
                style.LABEL = labelToggle.checked ? 'yes' : 'no';
            });
            tier.mergeStylesheet(nss);
        }, false);
        bumpToggle.addEventListener('change', function(ev) {
            var nss = mutateStylesheet(function(style) {
                style.BUMP = bumpToggle.checked ? 'yes' : 'no';
            });
            tier.mergeStylesheet(nss);
        }, false);
        bumpLimit.addEventListener('input', function(ev) {
            var x = parseInt(bumpLimit.value);
            if (typeof(x) == 'number' && x > 0) {
                tier.mergeConfig({subtierMax: x});
            }
        }, false);


        this.showToolPanel(tierForm);
        this.setUiMode('tier');

        tier.addTierListener(refresh);

        var currentScale = tier.browser.scale;
        tier.browser.addViewListener(function() {
            if (tier.browser.scale != currentScale) {
                currentScale = tier.browser.scale;
                refresh();
            }
        });
    }
}

function getSeqStyle(stylesheet) {
    for (var si = 0; si < stylesheet.styles.length; ++si) {
        var ss = stylesheet.styles[si].style;
        if (ss.glyph === '__SEQUENCE') {
            return ss;
        }
    }
}


},{"./cbrowser":6,"./color":9,"./das":10,"./sourcecompare":35,"./utils":49}],45:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// tier.js: (try) to encapsulate the functionality of a browser tier.
//

"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var shallowCopy = utils.shallowCopy;
    var pushnew = utils.pushnew;
    var miniJSONify = utils.miniJSONify;
    var arrayIndexOf = utils.arrayIndexOf;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;

    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;

    var style = require('./style');
    var StyleFilter = style.StyleFilter;
    var StyleFilterSet = style.StyleFilterSet;

    var sc = require('./sourcecompare');
    var sourceDataURI = sc.sourceDataURI;
}

var __tier_idSeed = 0;

function DasTier(browser, source, config, background)
{
    this.config = config || {};
    this.id = 'tier' + (++__tier_idSeed);
    this.browser = browser;
    this.dasSource = shallowCopy(source);
    this.background = background;

    this.viewport = makeElement('canvas', null, 
                                {width: '' + ((this.browser.featurePanelWidth|0) + 2000), 
                                 height: "30",
                                 className: 'viewport_12_5'},
                                {position: 'inline-block',
                                 margin: '0px', border: '0px'});
    this.viewportHolder = makeElement('div', this.viewport, {className: 'viewport-holder_12_5'}, 
                                      {background: background,
                                       position: 'absolute',
                                       padding: '0px', margin: '0px',
                                       border: '0px',
                                       left: '-1000px',
                                       minHeight: '200px'});
    this.overlay = makeElement('canvas', null,
         {width: + ((this.browser.featurePanelWidth|0)), 
          height: "30",
          className: 'viewport-overlay'});

    this.notifier = makeElement('div', '', {className: 'notifier'});
    this.notifierHolder = makeElement('div', this.notifier, {className: 'notifier-holder'});
    this.quantOverlay = makeElement(
        'canvas', null, 
        {width: '50', height: "56",
         className: 'quant-overlay'});

    this.removeButton = makeElement('i', null, {className: 'fa fa-times'});
    this.bumpButton = makeElement('i', null, {className: 'fa fa-plus-circle'});
    this.loaderButton = browser.makeLoader(16);
    this.loaderButton.style.display = 'none';
    this.infoElement = makeElement('div', this.dasSource.desc, {className: 'track-label-info'});
    this.nameButton = makeElement('div', [], {className: 'tier-tab'});
    this.nameButton.appendChild(this.removeButton);
    if (source.pennant) {
        this.nameButton.appendChild(makeElement('img', null, {src: source.pennant, width: '16', height: '16'}))
    } else if (source.mapping) {
        var version = null;
        if (this.browser.chains[source.mapping])
            version = this.browser.chains[source.mapping].coords.version;
        if (version)
            this.nameButton.appendChild(makeElement('span', '' + version, null, {fontSize: '8pt', background: 'black', color: 'white', paddingLeft: '3px', paddingRight: '3px', paddingTop: '1px', paddingBottom: '1px', marginLeft: '2px', borderRadius: '10px'}));
    }
    this.nameElement = makeElement('span', source.name);
    this.nameButton.appendChild(makeElement('span', [this.nameElement, this.infoElement], {className: 'track-name-holder'}));
    this.nameButton.appendChild(this.bumpButton);
    this.nameButton.appendChild(this.loaderButton);

    this.label = makeElement('span',
       [this.nameButton],
       {className: 'btn-group track-label'});

    var classes = 'tier' + (source.className ? ' ' + source.className : '');
    this.row = makeElement('div', [this.viewportHolder,
                                   this.overlay,
                                   this.quantOverlay],
                            {className: classes});

    if (!background) {
        this.row.style.background = 'none';
    }

    if (!browser.noDefaultLabels)
        this.row.appendChild(this.label);
    this.row.appendChild(this.notifierHolder);
    
    this.layoutHeight = 25;
    this.bumped = true;
    this.styleIdSeed = 0;
    if (source.quantLeapThreshold) {
        this.quantLeapThreshold = source.quantLeapThreshold;
    }
    if (this.dasSource.collapseSuperGroups) {
        this.bumped = false;
    }
    this.layoutWasDone = false;

    if (source.featureInfoPlugin) {
        this.addFeatureInfoPlugin(source.featureInfoPlugin);
    }

    this.initSources();

    var thisB = this;
    if (this.featureSource && this.featureSource.getDefaultFIPs && !source.noSourceFeatureInfo) {
        this.featureSource.getDefaultFIPs(function(fip) {
            if (fip)
                thisB.addFeatureInfoPlugin(fip);
        });
    }

    if (this.featureSource && this.featureSource.addReadinessListener) {
        this.readinessListener = function(ready) {
            thisB.notify(ready, -1);
        };
        this.featureSource.addReadinessListener(this.readinessListener);
    }

    if (this.featureSource && this.featureSource.addActivityListener) {
        this.activityListener = function(busy) {
            if (busy > 0) {
                thisB.loaderButton.style.display = 'inline-block';
            } else {
                thisB.loaderButton.style.display = 'none';
            }
            thisB.browser.pingActivity();
        };
        this.featureSource.addActivityListener(this.activityListener);
    }

    this.listeners = [];
    this.featuresLoadedListeners = [];
}

DasTier.prototype.destroy = function() {
    if (this.featureSource.removeReadinessListener) {
        this.featureSource.removeReadinessListener(this.readinessListener);
    }
    if (this.featureSource.removeActivityListener) {
        this.featureSource.removeActivityListener(this.activityListener);
    }
}

DasTier.prototype.setBackground = function(b) {
    this.background = b;
    this.viewportHolder.style.background = b;
}

DasTier.prototype.toString = function() {
    return this.id;
}

DasTier.prototype.addFeatureInfoPlugin = function(p) {
    if (!this.featureInfoPlugins) 
        this.featureInfoPlugins = [];
    this.featureInfoPlugins.push(p);
}

DasTier.prototype.init = function() {
    var tier = this;

    if (tier.dasSource.style) {
        this.setStylesheet({styles: tier.dasSource.style});
        this.browser.refreshTier(this);
    } else {
        tier.status = 'Fetching stylesheet';
        tier.fetchStylesheet(function(ss, err) {
            if (err || !ss) {
                tier.error = 'No stylesheet';
                var ss = new DASStylesheet();
                var defStyle = new DASStyle();
                defStyle.glyph = 'BOX';
                defStyle.BGCOLOR = 'blue';
                defStyle.FGCOLOR = 'black';
                ss.pushStyle({type: 'default'}, null, defStyle);
                tier.setStylesheet(ss);
                tier.browser.refreshTier(tier);
            } else {
                tier.setStylesheet(ss);
                if (ss.geneHint) {
                    tier.dasSource.collapseSuperGroups = true;
                    tier.bumped = false;
                    tier.updateLabel();
                }
                tier._updateFromConfig();
                tier.browser.refreshTier(tier);
            }
        });
    }
}

DasTier.prototype.setStylesheet = function(ss) {
    this.baseStylesheet = shallowCopy(ss);
    for (var si = 0; si < this.baseStylesheet.styles.length; ++si) {
        var sh = this.baseStylesheet.styles[si] = shallowCopy(this.baseStylesheet.styles[si]);
        sh._methodRE = sh._labelRE = sh._typeRE = null;
        sh.style = shallowCopy(sh.style);
        sh.style.id = 'style' + (++this.styleIdSeed);
    }
    this.baseStylesheetValidity = b64_sha1(miniJSONify(this.baseStylesheet));
    this._updateFromConfig();
}

DasTier.prototype.getSource = function() {
    return this.featureSource;
}

DasTier.prototype.getDesiredTypes = function(scale) {
    var sfs = this.getActiveStyleFilters(scale);
    if (sfs)
        return sfs.typeList();
}

DasTier.prototype.getActiveStyleFilters = function(scale) {
    var ssScale = this.browser.zoomForCurrentScale();

    if (this.stylesheet) {
        var styles = new StyleFilterSet();
        var ss = this.stylesheet.styles;
        for (var si = 0; si < ss.length; ++si) {
            var sh = ss[si];
            if (!sh.zoom || sh.zoom == ssScale) {
                styles.add(new StyleFilter(sh.type, sh.method, sh.label));
            }
        }
        return styles;
    }
}

DasTier.prototype.needsSequence = function(scale ) {
    if (this.sequenceSource && scale < 5) {
        return true;
    } else if ((this.dasSource.bamURI || this.dasSource.bamBlob || this.dasSource.bwgURI || this.dasSource.bwgBlob)
                 && scale < 20) {
        return true
    }
    return false;
}

DasTier.prototype.viewFeatures = function(chr, coverage, scale, features, sequence) {
    this.currentFeatures = features;
    this.currentSequence = sequence;
    this.notifyFeaturesLoaded();
    
    this.knownChr = chr;
    this.knownCoverage = coverage;

    if (this.status) {
        this.status = null;
        this._notifierToStatus();
    }

    this.draw();
}

DasTier.prototype.draw = function() {
    var features = this.currentFeatures;
    var seq = this.currentSequence;
    if (this.sequenceSource) {
        drawSeqTier(this, seq); 
    } else {
        drawFeatureTier(this);
    }
    this.paint();
    this.originHaxx = 0;
    this.browser.arrangeTiers();
}

DasTier.prototype.findNextFeature = function(chr, pos, dir, fedge, callback) {
    if (this.quantLeapThreshold) {
        var width = this.browser.viewEnd - this.browser.viewStart + 1;
        pos = (pos +  ((width * dir) / 2))|0
        this.featureSource.quantFindNextFeature(chr, pos, dir, this.quantLeapThreshold, callback);
    } else {
        if (this.knownCoverage && pos >= this.knownCoverage.min() && pos <= this.knownCoverage.max()) {
            if (this.currentFeatures) {
                var bestFeature = null;
                for (var fi = 0; fi < this.currentFeatures.length; ++fi) {
                    var f = this.currentFeatures[fi];
                    if (!f.min || !f.max) {
                        continue;
                    }
                    if (f.parents && f.parents.length > 0) {
                        continue;
                    }
                    if (dir < 0) {
                        if (fedge == 1 && f.max >= pos && f.min < pos) {
                            if (!bestFeature || f.min > bestFeature.min ||
                                (f.min == bestFeature.min && f.max < bestFeature.max)) {
                                bestFeature = f;
                            }
                        } else if (f.max < pos) {
                            if (!bestFeature || f.max > bestFeature.max || 
                                (f.max == bestFeature.max && f.min < bestFeature.min) ||
                                (f.min == bestFeature.mmin && bestFeature.max >= pos)) {
                                bestFeature = f;
                            } 
                        }
                    } else {
                        if (fedge == 1 && f.min <= pos && f.max > pos) {
                            if (!bestFeature || f.max < bestFeature.max ||
                                (f.max == bestFeature.max && f.min > bestFeature.min)) {
                                bestFeature = f;
                            }
                        } else if (f.min > pos) {
                            if (!bestFeature || f.min < bestFeature.min ||
                                (f.min == bestFeature.min && f.max > bestFeature.max) ||
                                (f.max == bestFeature.max && bestFeature.min <= pos)) {
                                bestFeature = f;
                            }
                        }
                    }
                }
                if (bestFeature) {
                    return callback(bestFeature);
                }
                if (dir < 0) {
                    pos = this.browser.knownSpace.min;
                } else {
                    pos = this.browser.knownSpace.max;
                }
            }
        }

        this.trySourceFNF(chr, pos, dir, callback);
    }
}

DasTier.prototype.trySourceFNF = function(chr, pos, dir, callback) {
    var self = this;
    this.featureSource.findNextFeature(chr, pos, dir, function(feature) {
        if (!feature)
            callback(feature);

        var ss = self.browser.getSequenceSource();
        if (!ss) // We're probably in trouble, but return anyway.
            callback(feature)

        ss.getSeqInfo(feature.segment, function(si) {
            if (si)
                callback(feature);
            else
                self.trySourceFNF(feature.segment, dir > 0 ? 10000000000 : 0, dir, callback);
        });
    });
}


DasTier.prototype.updateLabel = function() {
   this.bumpButton.className = this.bumped ? 'fa fa-minus-circle' : 'fa fa-plus-circle';
   if (this.dasSource.collapseSuperGroups) {
        this.bumpButton.style.display = 'inline-block';
    } else {
        this.bumpButton.style.display = 'none';
    }
}

DasTier.prototype.updateHeight = function() {
    this.currentHeight = Math.max(Math.max(this.layoutHeight, this.label.clientHeight + 2), this.browser.minTierHeight);
    this.row.style.height = '' + this.currentHeight + 'px';
    this.browser.updateHeight();
 }


DasTier.prototype.drawOverlay = function() {
    var t = this;
    var b = this.browser;
    var retina = b.retina && window.devicePixelRatio > 1;
    
    t.overlay.height = t.viewport.height;
    t.overlay.width = retina ? b.featurePanelWidth * 2 : b.featurePanelWidth;

    var g = t.overlay.getContext('2d');
    if (retina) {
        g.scale(2, 2);
    }
    
    var origin = b.viewStart;
    var visStart = b.viewStart;
    var visEnd = b.viewEnd;

    if (this.overlayLabelCanvas) {
        var offset = ((this.glyphCacheOrigin - this.browser.viewStart)*this.browser.scale);
        g.save();
        g.translate(offset, 0);
        var drawStart = -offset + 2;
        if (this.dasSource.tierGroup)
            drawStart += 15;
        this.overlayLabelCanvas.draw(g, drawStart, b.featurePanelWidth-offset);
        g.restore();
    }

    for (var hi = 0; hi < b.highlights.length; ++hi) {
        var h = b.highlights[hi];
        if (((h.chr === b.chr) || (h.chr === ('chr' + b.chr))) && h.min < visEnd && h.max > visStart) {
            g.globalAlpha = b.defaultHighlightAlpha;
            g.fillStyle = b.defaultHighlightFill;
            g.fillRect((h.min - origin) * b.scale,
                       0,
                       (h.max - h.min) * b.scale,
                       t.overlay.height);
        }
    } 

    // t.oorigin = b.viewStart;
    t.overlay.style.width = b.featurePanelWidth;
    t.overlay.style.height = t.viewport.style.height;
    t.overlay.style.left = '0px';
}


DasTier.prototype.updateStatus = function(status) {
    var self = this;
    if (status) {
        this.status = status;
        this._notifierToStatus();
        var sd = sourceDataURI(this.dasSource);
        if (window.location.protocol === 'https:' && sourceDataURI(this.dasSource).indexOf('http:') == 0 && !this.checkedHTTP) {
            this.checkedHTTP = true;
            this.browser.canFetchPlainHTTP().then(
                function(can) {
                    if (!can) {
                        self.warnHTTP = true;
                        self._notifierToStatus();
                    }
                }
            );
        }
    } else {
        if (this.status) {
            this.status = null
            this._notifierToStatus();
        }
    }
}

DasTier.prototype.notify = function(message, timeout) {
    if (typeof(timeout) !== 'number')
        timeout = 2000;

    if (this.notifierFadeTimeout) {
        clearTimeout(this.notifierFadeTimeout);
        this.notifierFadeTimeout = null;
    }

    if (message) {
        this._notifierOn(message);
        if (timeout > 0) {
            var thisB = this;
            this.notifierFadeTimeout = setTimeout(function() {
                thisB._notifierToStatus();
            }, timeout);
        }
    } else {
        this._notifierToStatus();
    }
}

DasTier.prototype._notifierOn = function(message, warnHTTP) {
    removeChildren(this.notifier);
    if (warnHTTP) {
        this.notifier.appendChild(
            makeElement(
                'span',
                [makeElement('a', '[HTTP Warning] ', {href: this.browser.httpWarningURL, target: "_blank"}),
                 message]
            )
        );
    } else {
        this.notifier.textContent = message;
    }
    this.notifier.style.opacity = 0.8;
}

DasTier.prototype._notifierOff = function() {
    this.notifier.style.opacity = 0;
}

DasTier.prototype._notifierToStatus = function() {
    if (this.status) {
        this._notifierOn(this.status, this.warnHTTP)
    } else {
        this._notifierOff();
    }
}

DasTier.prototype.setConfig = function(config) {
    this.config = config || {};
    this._updateFromConfig();
    this.notifyTierListeners();
}

DasTier.prototype.mergeStylesheet = function(newStyle) {
    this.mergeConfig({
        stylesheet: newStyle, 
        stylesheetValidity: this.baseStylesheetValidity
    });
}

DasTier.prototype.mergeConfig = function(newConfig) {
    for (var k in newConfig) {
        this.config[k] = newConfig[k];
    }
    this._updateFromConfig();
    this.notifyTierListeners();
}

DasTier.prototype._updateFromConfig = function() {
    var needsRefresh = false;
    var needsReorder = false;

    if (typeof this.config.name === 'string')
        this.nameElement.textContent = this.config.name;
    else
        this.nameElement.textContent = this.dasSource.name;

    var wantedHeight = this.config.height || this.dasSource.forceHeight;
    if (wantedHeight != this.forceHeight) {
        this.forceHeight = wantedHeight;
        needsRefresh = true;
    }

    if (this.forceMinDynamic != this.config.forceMinDynamic) {
        this.forceMinDynamic = this.config.forceMinDynamic;
        needsRefresh = true;
    }

    var forceMin = this.config.forceMin != undefined ? this.config.forceMin : this.dasSource.forceMin;
    if (this.forceMin != forceMin) {
        this.forceMin = forceMin;
        needsRefresh = true;
    }

    if (this.forceMaxDynamic != this.config.forceMaxDynamic) {
        this.forceMaxDynamic = this.config.forceMaxDynamic;
        needsRefresh = true;
    }
    
    var forceMax = this.config.forceMax != undefined ? this.config.forceMax : this.dasSource.forceMax;
    if (this.forceMax != forceMax) {
        this.forceMax = forceMax;
        needsRefresh = true;
    }

    var quantLeapThreshold = null;
    if (this.config.quantLeapThreshold !== undefined)
        quantLeapThreshold = this.config.quantLeapThreshold;
    else if (this.dasSource.quantLeapThreshold !== undefined)
        quantLeapThreshold = this.dasSource.quantLeapThreshold;
    if (quantLeapThreshold != this.quantLeapThreshold) {
        this.quantLeapThreshold = quantLeapThreshold;
        needsRefresh = true;
    }
    
    // Possible FIXME -- are there cases where style IDs need to be reassigned?
    var stylesheet = null;
    if (this.config.stylesheetValidity == this.baseStylesheetValidity)
        stylesheet = this.config.stylesheet;
    stylesheet = stylesheet || this.baseStylesheet;
    if (this.stylesheet !== stylesheet) {
        this.stylesheet = stylesheet;
        needsRefresh = true;
    }

    var wantedPinned = this.config.pinned !== undefined ? this.config.pinned : this.dasSource.pinned;
    if (wantedPinned !== this.pinned) {
        this.pinned = wantedPinned;
        needsReorder = true;
    }

    var wantedSubtierMax = (typeof(this.config.subtierMax === 'number') ? 
        this.config.subtierMax : this.dasSource.subtierMax || this.browser.defaultSubtierMax);
    if (wantedSubtierMax != this.subtierMax) {
        this.subtierMax = wantedSubtierMax;
        needsRefresh = true;
    }

    var wantedBumped;
    if (this.config.bumped !== undefined) {
        wantedBumped = this.config.bumped;
    } else if (this.dasSource.bumped !== undefined) {
        wantedBumped = this.dasSource.bumped;
    } else {
        wantedBumped = this.dasSource.collapseSuperGroups ? false : true;
    }
    if (wantedBumped !== this.bumped) {
        this.bumped = wantedBumped;
        needsRefresh = true;
        this.updateLabel();
    }

    if (needsRefresh)
        this.scheduleRedraw();

    if (needsReorder)
        this.browser.reorderTiers();
}

DasTier.prototype.scheduleRedraw = function() {
    if (!this.currentFeatures)
        return;
    
    var tier = this;

    if (!this.redrawTimeout) {
        this.redrawTimeout = setTimeout(function() {
            tier.draw();
            tier.redrawTimeout = null;
        }, 10);
    }
}
DasTier.prototype.clearTierListeners = function() {
	this.listeners = [];
}


DasTier.prototype.addTierListener = function(l) {
    this.listeners.push(l);
}

DasTier.prototype.removeTierListener = function(l) {
    var idx = arrayIndexOf(this.listeners, l);
    if (idx >= 0) {
        this.listeners.splice(idx, 1);
    }
}

DasTier.prototype.notifyTierListeners = function(change) {
    for (var li = 0; li < this.listeners.length; ++li) {
        try {
            this.listeners[li](change);
        } catch (e) {
            console.log(e);
        }
    }
    this.browser.notifyTier();
}

DasTier.prototype.clearFeaturesLoadedListeners = function() {
  this.featuresLoadedListeners = [];
}

DasTier.prototype.addFeaturesLoadedListener = function(handler) {
    this.featuresLoadedListeners.push(handler);
}

DasTier.prototype.removeFeaturesLoadedListener = function(handler) {
    var idx = arrayIndexOf(this.featuresLoadedListeners, handler);
    if (idx >= 0) {
        this.featuresLoadedListeners.splice(idx, 1);
    }
}


DasTier.prototype.notifyFeaturesLoaded = function() {
    for (var li = 0; li < this.featuresLoadedListeners.length; ++li) {
        try {
            this.featuresLoadedListeners[li].call(this);
        } catch (e) {
            console.log(e);
        }
    }
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        DasTier: DasTier
    };

    // Imported for side effects
    var fd = require('./feature-draw');
    var drawFeatureTier = fd.drawFeatureTier;
    var sd = require('./sequence-draw');
    var drawSeqTier = sd.drawSeqTier;
    // require('./sourceadapters');  /* Done in cbrowser instead */
}

},{"./das":10,"./feature-draw":18,"./sequence-draw":31,"./sha1":33,"./sourcecompare":35,"./style":37,"./utils":49}],46:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// track-adder.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var browser = require('./cbrowser');
    var Browser = browser.Browser;

    var sc = require('./sourcecompare');
    var sourcesAreEqual = sc.sourcesAreEqual;

    var utils = require('./utils');
    var makeElement = utils.makeElement;
    var removeChildren = utils.removeChildren;
    var Observed = utils.Observed;

    var thub = require('./thub');
    var THUB_COMPARE = thub.THUB_COMPARE;
    var connectTrackHub = thub.connectTrackHub;

    var domui = require('./domui');
    var makeTreeTableSection = domui.makeTreeTableSection;

    var probeResource = require('./probe').probeResource;


    // Most of this could disappear if we leave all probing to the probe module...
    var bin = require('./bin');
    var URLFetchable = bin.URLFetchable;
    var BlobFetchable = bin.BlobFetchable;
    var readInt = bin.readInt;

    var lh3utils = require('./lh3utils');
    var unbgzf = lh3utils.unbgzf;

    var bam = require('./bam');
    var BAM_MAGIC = bam.BAM_MAGIC;
    var BAI_MAGIC = bam.BAI_MAGIC;

    var tbi = require('./tabix');
    var TABIX_MAGIC = tbi.TABIX_MAGIC;

    var das = require('./das');
    var DASSource = das.DASSource;
    var DASSegment = das.DASSegment;
    var DASRegistry = das.DASRegistry;
    var coordsMatch = das.coordsMatch;

    var EncodeFetchable = require('./encode').EncodeFetchable;
}

Browser.prototype.currentlyActive = function(source) {
    for (var ti = 0; ti < this.tiers.length; ++ti) {
        if (sourcesAreEqual(this.tiers[ti].dasSource, source))
            return this.tiers[ti];
    }
    return false;
}

Browser.prototype.makeButton = function(name, tooltip) {
    var regButton = makeElement('a', name, {href: '#'});
    if (tooltip) {
        this.makeTooltip(regButton, tooltip);
    }
    return makeElement('li', regButton);
}

function activateButton(addModeButtons, which) {
    for (var i = 0; i < addModeButtons.length; ++i) {
        var b = addModeButtons[i];
        if (b === which) {
            b.classList.add('active');
        } else {
            b.classList.remove('active');
        }
    }
}

Browser.prototype.showTrackAdder = function(ev) {
    if (this.uiMode === 'add') {
        this.hideToolPanel();
        this.setUiMode('none');
        return;
    }

    var thisB = this;

    var popup = makeElement('div', null, {className: 'dalliance'} , {width: '100%', display: 'inline-block', boxSizing: 'border-box', MozBoxSizing: 'border-box', verticalAlign: 'top', paddingRight: '15px'});

    var addModeButtons = [];
    var makeStab, makeStabObserver;


    if (!this.noRegistryTabs) {
        var regButton = this.makeButton('Registry', 'Browse compatible datasources from the DAS registry');
        addModeButtons.push(regButton);
        
        for (var m in this.mappableSources) {
            var mf  = function(mm) {
                var mapButton = thisB.makeButton(thisB.chains[mm].srcTag, 'Browse datasources mapped from ' + thisB.chains[mm].srcTag);
                addModeButtons.push(mapButton);
                mapButton.addEventListener('click', function(ev) {
                    ev.preventDefault(); ev.stopPropagation();
                    activateButton(addModeButtons, mapButton);
                    makeStab(thisB.mappableSources[mm], mm);
                }, false);
            }; mf(m);
        }
    }

    var groupedDefaults = {};
    for (var si = 0; si < this.defaultSources.length; ++si) {
        var s = this.defaultSources[si];
        var g = s.group || 'Defaults';
        if (groupedDefaults[g]) {
            groupedDefaults[g].push(s);
        } else {
            groupedDefaults[g] = [s];
        }
    }
    

    var makeHubButton = function(tdb) {
        var hub = tdb.hub;
        var hubMenuButton = makeElement('i', null, {className: 'fa fa-list-alt'}, {cursor: 'context-menu'});
        var label = hub.altLabel || hub.shortLabel || 'Unknown';
        if (tdb.mapping)
            label = label + ' (' + tdb.genome + ')';
        var hbContent = makeElement('span', [label, ' ', hubMenuButton]);
        var hubButton = thisB.makeButton(hbContent, hub.longLabel);
        hubButton.hub = tdb;
        addModeButtons.push(hubButton);
        
        hubButton.addEventListener('click', function(ev) {
            ev.preventDefault(); ev.stopPropagation();
            activateButton(addModeButtons, hubButton);
            removeChildren(stabHolder);
            var loader = thisB.makeLoader(24);
            loader.style.marginLeft = 'auto';
            loader.style.marginRight = 'auto';
            loader.style.marginTop = '100px';
            stabHolder.appendChild(makeElement('div', loader, null, {textAlign: 'center'}));

            refreshButton.style.display = 'none';
            addButton.style.display = 'none';
            canButton.style.display = 'none';

            tdb.getTracks(function(tracks, err) {
                if (err) {
                    console.log(err);
                }
                
                makeHubStab(tracks);
            });
        }, false);

        hubMenuButton.addEventListener('click', function(ev) {
            ev.preventDefault(); ev.stopPropagation();
            
            var removeHubItem = makeElement('li', makeElement('a', 'Remove hub'));
            var allOnItem = makeElement('li',  makeElement('a', 'Enable all'));
            var allOffItem = makeElement('li',  makeElement('a', 'Disable all'));
            var hubMenu = makeElement('ul', [removeHubItem, allOnItem, allOffItem], {className: 'dropdown-menu'}, {display: 'block'});

            var mx =  ev.clientX, my = ev.clientY;
            mx +=  document.documentElement.scrollLeft || document.body.scrollLeft;
            my +=  document.documentElement.scrollTop || document.body.scrollTop;

            hubMenu.style.position = 'absolute';
            hubMenu.style.top = '' + (my+10) + 'px';
            hubMenu.style.left = '' + (mx-30) + 'px';
            thisB.hPopupHolder.appendChild(hubMenu);

            var clickCatcher = function(ev) {
                console.log('cc');
                document.body.removeEventListener('click', clickCatcher, true);
                thisB.hPopupHolder.removeChild(hubMenu);
            };
            document.body.addEventListener('click', clickCatcher, true);

            removeHubItem.addEventListener('click', function(ev) {
                for (var hi = 0; hi < thisB.hubObjects.length; ++hi) {
                    if (thisB.hubObjects[hi].absURL == tdb.absURL) {
                        thisB.hubObjects.splice(hi, 1);
                        break;
                    }
                }
                for (var hi = 0; hi < thisB.hubs.length; ++hi) {
                    var hc = thisB.hubs[hi];
                    if (typeof hc === 'string')
                        hc = {url: hc};
                    if (hc.url == tdb.hub.url && !hc.genome || hc.genome == tdb.genome) {
                        thisB.hubs.splice(hi, 1);
                        break;
                    }

                }

                thisB.notifyTier();

                modeButtonHolder.removeChild(hubButton);
                activateButton(addModeButtons, addHubButton);
                switchToHubConnectMode();
            }, false);


            allOnItem.addEventListener('click', function(ev) {
                tdb.getTracks(function(tracks, err) {
                    if (err) {
                        console.log(err);
                    }
                    
                    for (var ti = 0; ti < tracks.length; ++ti) {
                        var ds = tracks[ti].toDallianceSource();
                        if (!thisB.currentlyActive(ds)) {
                            thisB.addTier(ds);
                        }
                    }
                });
            }, false);

            allOffItem.addEventListener('click', function(ev) {
                tdb.getTracks(function(tracks, err) {
                    if (err) {
                        console.log(err);
                    }
                    
                    for (var ti = 0; ti < tracks.length; ++ti) {
                        var ds = tracks[ti].toDallianceSource();
                        if (thisB.currentlyActive(ds)) {
                            thisB.removeTier(ds);
                        }
                    }
                });
            }, false);
        }, false);

        return hubButton;
    }

    var firstDefButton = null;
    var firstDefSources = null;
    for (var g in groupedDefaults) {
        (function(g, ds) {
            var defButton = thisB.makeButton(g, 'Browse the default set of data for this browser');
            defButton.addEventListener('click', function(ev) {
                ev.preventDefault(); ev.stopPropagation();
                activateButton(addModeButtons, defButton);
                makeStab(new Observed(ds));
            }, false);
            addModeButtons.push(defButton);

            if (!firstDefButton) {
                firstDefButton = defButton;
                firstDefSources = ds;
            }
        })(g, groupedDefaults[g]);
    }   
    var custButton = this.makeButton('DAS', 'Add arbitrary DAS data');
    addModeButtons.push(custButton);
    var binButton = this.makeButton('Binary', 'Add data in bigwig or bigbed format');
    addModeButtons.push(binButton);


    for (var hi = 0; hi < this.hubObjects.length; ++hi) {
        var hub = this.hubObjects[hi];
        makeHubButton(hub);
    }

    var addHubButton = this.makeButton('+', 'Connect to a new track-hub');
    addModeButtons.push(addHubButton);


    var modeButtonHolder = makeElement('ul', addModeButtons, {className: 'nav nav-tabs'}, {marginBottom: '0px'});
    popup.appendChild(modeButtonHolder);
    
    var custURL, custName, custCS, custQuant, custFile, custUser, custPass;
    var customMode = false;
    var dataToFinalize = null;

    var asform = makeElement('form', null, {}, {display: 'inline-block', width: '100%'});
    asform.addEventListener('submit', function(ev) {
            ev.stopPropagation(); ev.preventDefault();
            doAdd();
            return false;
    }, true); 
    var stabHolder = makeElement('div');
    stabHolder.style.position = 'relative';
    stabHolder.style.overflow = 'scroll';
    // stabHolder.style.height = '500px';
    asform.appendChild(stabHolder);

    var __mapping;
    var __sourceHolder;


    makeStab = function(msources, mapping) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'none';
        canButton.style.display = 'none';
        if (__sourceHolder) {
            __sourceHolder.removeListener(makeStabObserver);
        }
        __mapping = mapping;
        __sourceHolder = msources;
        __sourceHolder.addListenerAndFire(makeStabObserver);
    }

    makeStabObserver = function(msources) {
        customMode = false;
        var buttons = [];
        removeChildren(stabHolder);
        if (!msources) {
            stabHolder.appendChild(makeElement('p', 'Dalliance was unable to retrieve data source information from the DAS registry, please try again later'));
            return;
        }
        
        var stabBody = makeElement('tbody', null, {className: 'table table-striped table-condensed'}, {width: '100%'});
        var stab = makeElement('table', stabBody, {className: 'table table-striped table-condensed'}, {width: '100%', tableLayout: 'fixed'}); 
        var idx = 0;

        var sources = [];
        for (var i = 0; i < msources.length; ++i) {
            sources.push(msources[i]);
        }
        
        sources.sort(function(a, b) {
            return a.name.toLowerCase().trim().localeCompare(b.name.toLowerCase().trim());
        });

        for (var i = 0; i < sources.length; ++i) {
            var source = sources[i];
            var r = makeElement('tr');

            var bd = makeElement('td', null, {}, {width: '30px'});
            bd.style.textAlign = 'center';
            if (!source.props || source.props.cors) {
                var b = makeElement('input');
                b.type = 'checkbox';
                b.dalliance_source = source;
                if (__mapping) {
                    b.dalliance_mapping = __mapping;
                }
                // b.checked = thisB.currentlyActive(source);
                bd.appendChild(b);
                buttons.push(b);
                b.addEventListener('change', function(ev) {
                    if (ev.target.checked) {
                        thisB.addTier(ev.target.dalliance_source);
                    } else {
                        thisB.removeTier(ev.target.dalliance_source);
                    }
                });
            } else {
                bd.appendChild(document.createTextNode('!'));
                thisB.makeTooltip(bd, makeElement('span', ["This data source isn't accessible because it doesn't support ", makeElement('a', "CORS", {href: 'http://www.w3.org/TR/cors/'}), "."]));
            }
            r.appendChild(bd);
            var ld = makeElement('td');
            ld.appendChild(document.createTextNode(source.name));
            if (source.desc && source.desc.length > 0) {
                thisB.makeTooltip(ld, source.desc);
            }
            r.appendChild(ld);
            stabBody.appendChild(r);
            ++idx;
        }

        var setChecks = function() {
            for (var bi = 0; bi < buttons.length; ++bi) {
                var b = buttons[bi];
                var t = thisB.currentlyActive(b.dalliance_source);
                if (t) {
                    b.checked = true;
                } else {
                    b.checked = false;
                }
            }
        }
        setChecks();
        thisB.addTierListener(function(l) {
            setChecks();
        });

        stabHolder.appendChild(stab);
    };

    function makeHubStab(tracks) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'none';
        canButton.style.display = 'none';

        customMode = false;
        removeChildren(stabHolder);
        
        var ttab = makeElement('div', null, {}, {width: '100%'});
        var sources = [];
        for (var i = 0; i < tracks.length; ++i) {
            sources.push(tracks[i]);
        }
        
        sources.sort(function(a, b) {
            return a.shortLabel.toLowerCase().trim().localeCompare(b.shortLabel.toLowerCase().trim());
        });

        var groups = [];
        var tops = [];
        
        for (var ti = 0; ti < sources.length; ++ti) {
            var track = sources[ti];
            if (track.children && track.children.length > 0 && track.container != 'multiWig') {
                groups.push(track);
            } else {
                tops.push(track);
            }
        }
        if (tops.length > 0) {
            groups.push({
                shortLabel: 'Others',
                priority: -100000000,
                children: tops});
        }

        groups.sort(THUB_COMPARE);
        
        var buttons = [];
        for (var gi = 0; gi < groups.length; ++gi) {
            var group = groups[gi];
            var dg = group;
            if (!dg.dimensions && dg._parent && dg._parent.dimensions)
                dg = dg._parent;

            var dprops = {}
            if (dg.dimensions) {
                var dtoks = dg.dimensions.split(/(\w+)=(\w+)/);
                for (var dti = 0; dti < dtoks.length - 2; dti += 3) {
                    dprops[dtoks[dti + 1]] = dtoks[dti + 2];
                }
            }

            if (dprops.dimX && dprops.dimY) {
                var dimX = dprops.dimX, dimY = dprops.dimY;
                var sgX = dg.subgroups[dimX];
                var sgY = dg.subgroups[dimY];
                
                var trks = {};
                for (var ci = 0; ci < group.children.length; ++ci) {
                    var child = group.children[ci];
                    var vX = child.sgm[dimX], vY = child.sgm[dimY];
                    if (!trks[vX])
                        trks[vX] = {};
                    trks[vX][vY] = child;
                }

                var matrix = makeElement('table', null, {className: 'table table-striped table-condensed'}, {tableLayout: 'fixed'});
                {
                    var header = makeElement('tr');
                    header.appendChild(makeElement('th', null, {}, {width: '150px', height: '100px'}));   // blank corner element
                    for (var si = 0; si < sgX.titles.length; ++si) {
                        var h = makeElement('th', makeElement('div', sgX.titles[si], {}, {transform: 'rotate(-60deg)', 
                                                                       transformOrigin: '0% 100%', 
                                                                       webkitTransform: 'rotate(-60deg) translate(20px,10px)', 
                                                                       webkitTransformOrigin: '0% 100%',
                                                                       textAlign: 'left'}), {}, {width: '35px',
                                                                                                 height: '100px',
                                                                                                 verticalAlign: 'bottom'})
                        header.appendChild(h);
                    }
                    matrix.appendChild(header);
                }

                var mbody = makeElement('tbody', null, {className: 'table table-striped table-condensed'})
                for (var yi = 0; yi < sgY.titles.length; ++yi) {
                    var vY = sgY.tags[yi];
                    var row = makeElement('tr');
                    row.appendChild(makeElement('th', sgY.titles[yi]), {});
                    
                    for (var xi = 0; xi < sgX.titles.length; ++xi) {
                        var vX = sgX.tags[xi];
                        var cell = makeElement('td');
                        if (trks[vX] && trks[vX][vY]) {
                            var track = trks[vX][vY];
                            var ds = track.toDallianceSource();
                            if (!ds)
                                continue;
                            
                            var r = makeElement('tr');
                            var bd = makeElement('td');
                            bd.style.textAlign = 'center';
                            
                            var b = makeElement('input');
                            b.type = 'checkbox';
                            b.dalliance_source = ds;
                            if (__mapping) {
                                b.dalliance_mapping = __mapping;
                            }
                            buttons.push(b);
                            cell.appendChild(b);
                            b.addEventListener('change', function(ev) {
                                if (ev.target.checked) {
                                    thisB.addTier(ev.target.dalliance_source);
                                } else {
                                    thisB.removeTier(ev.target.dalliance_source);
                                }
                            });

                        }
                        row.appendChild(cell);
                    } 
                    mbody.appendChild(row);
                }
                matrix.appendChild(mbody);
                ttab.appendChild(makeTreeTableSection(group.shortLabel, matrix, gi==0));                
            } else {
                var stabBody = makeElement('tbody', null, {className: 'table table-striped table-condensed'});
                var stab = makeElement('table', stabBody, {className: 'table table-striped table-condensed'}, {width: '100%', tableLayout: 'fixed'}); 
                var idx = 0;
            
                group.children.sort(THUB_COMPARE);
                for (var i = 0; i < group.children.length; ++i) {
                    var track = group.children[i];
                    var ds = track.toDallianceSource();
                    if (!ds)
                        continue;

                    var r = makeElement('tr');
                    var bd = makeElement('td', null, {}, {width: '30px'});
                    bd.style.textAlign = 'center';
                    
                    var b = makeElement('input');
                    b.type = 'checkbox';
                    b.dalliance_source = ds;
                    if (__mapping) {
                        b.dalliance_mapping = __mapping;
                    }
                    buttons.push(b);
                    bd.appendChild(b);
                    b.addEventListener('change', function(ev) {
                        if (ev.target.checked) {
                            thisB.addTier(ev.target.dalliance_source);
                        } else {
                            thisB.removeTier(ev.target.dalliance_source);
                        }
                    });

                    r.appendChild(bd);
                    var ld = makeElement('td');
                    ld.appendChild(document.createTextNode(track.shortLabel));
                    if (track.longLabel && track.longLabel.length > 0) {
                        thisB.makeTooltip(ld, track.longLabel);
                    }
                    r.appendChild(ld);
                    stabBody.appendChild(r);
                    ++idx;
                }

                if (groups.length > 1 || group.shortLabel !== 'Others') {
                    ttab.appendChild(makeTreeTableSection(group.shortLabel, stab, gi==0));
                } else {
                    ttab.appendChild(stab);
                }
                
            }
        }

        var setChecks = function() {
            for (var bi = 0; bi < buttons.length; ++bi) {
                var b = buttons[bi];
                var t = thisB.currentlyActive(b.dalliance_source);
                if (t) {
                    b.checked = true;
                    b.disabled = t.sequenceSource != null;
                } else {
                    b.checked = false;
                }
            }
        }
        setChecks();
        thisB.addTierListener(function(l) {
            setChecks();
        });
        
        stabHolder.appendChild(ttab);
    }

    if (regButton) {
        regButton.addEventListener('click', function(ev) {
            ev.preventDefault(); ev.stopPropagation();
            activateButton(addModeButtons, regButton);
            makeStab(thisB.availableSources);
        }, false);
    }
 
    binButton.addEventListener('click', function(ev) {
        ev.preventDefault(); ev.stopPropagation();
        switchToBinMode();
    }, false);
    addHubButton.addEventListener('click', function(ev) {
        ev.preventDefault(); ev.stopPropagation();
        switchToHubConnectMode();
    }, false);


    function switchToBinMode() {
        activateButton(addModeButtons, binButton);
        customMode = 'bin';

        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        removeChildren(stabHolder);
        var pageHolder = makeElement('div', null, {}, {paddingLeft: '10px', paddingRight: '10px'});
        pageHolder.appendChild(makeElement('h3', 'Add custom URL-based data'));
        pageHolder.appendChild(makeElement('p', ['You can add indexed binary data hosted on an web server that supports CORS (', makeElement('a', 'full details', {href: 'http://www.biodalliance.org/bin.html'}), ').  Currently supported formats are bigwig, bigbed, and indexed BAM.']));

        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(document.createTextNode('URL: '));
        custURL = makeElement('input', '', {size: 80, value: 'http://www.biodalliance.org/datasets/ensGene.bb'}, {width: '100%'});
        pageHolder.appendChild(custURL);
        
        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(makeElement('b', '- or -'));
        pageHolder.appendChild(makeElement('br'));
        pageHolder.appendChild(document.createTextNode('File: '));
        custFile = makeElement('input', null, {type: 'file', multiple: 'multiple'});
        pageHolder.appendChild(custFile);
        
        pageHolder.appendChild(makeElement('p', 'Clicking the "Add" button below will initiate a series of test queries.'));

        stabHolder.appendChild(pageHolder);
        custURL.focus();
    }

    function switchToHubConnectMode() {
        activateButton(addModeButtons, addHubButton);
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        customMode = 'hub-connect';
        refreshButton.style.visibility = 'hidden';

        removeChildren(stabHolder);

        var pageHolder = makeElement('div', null, {}, {paddingLeft: '10px', paddingRight: '10px'});
        pageHolder.appendChild(makeElement('h3', 'Connect to a track hub.'));
        pageHolder.appendChild(makeElement('p', ['Enter the top-level URL (usually points to a file called "hub.txt") of a UCSC-style track hub']));
        
        custURL = makeElement('input', '', {size: 120, value: 'http://www.biodalliance.org/datasets/testhub/hub.txt'}, {width: '100%'});
        pageHolder.appendChild(custURL);
        
        stabHolder.appendChild(pageHolder);
        
        custURL.focus();
    }

    custButton.addEventListener('click', function(ev) {
        ev.preventDefault(); ev.stopPropagation();
        switchToCustomMode();
    }, false);

    function switchToCustomMode() {
        activateButton(addModeButtons, custButton);
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'none';

        customMode = 'das';

        removeChildren(stabHolder);

        var customForm = makeElement('div', null, {},  {paddingLeft: '10px', paddingRight: '10px'});
        customForm.appendChild(makeElement('h3', 'Add custom DAS data'));
        customForm.appendChild(makeElement('p', 'This interface is intended for adding custom or lab-specific data.  Public data can be added more easily via the registry interface.'));
                
        customForm.appendChild(document.createTextNode('URL: '));
        customForm.appendChild(makeElement('br'));
        custURL = makeElement('input', '', {size: 80, value: 'http://www.derkholm.net:8080/das/medipseq_reads/'}, {width: '100%'});
        customForm.appendChild(custURL);

        customForm.appendChild(makeElement('p', 'Clicking the "Add" button below will initiate a series of test queries.  If the source is password-protected, you may be prompted to enter credentials.'));
        stabHolder.appendChild(customForm);

        custURL.focus();
    }



    var addButton = makeElement('button', 'Add', {className: 'btn btn-primary'});
    addButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();
        doAdd();
    }, false);

    function doAdd() {
        if (customMode) {
            if (customMode === 'das') {
                var curi = custURL.value.trim();
                if (!/^.+:\/\//.exec(curi)) {
                    curi = 'http://' + curi;
                }
                var nds = new DASSource({name: 'temporary', uri: curi});
                tryAddDAS(nds);
            } else if (customMode === 'bin') {
                var fileList = custFile.files;

                if (fileList && fileList.length > 0) {
                    tryAddMultiple(fileList);
                } else {
                    var curi = custURL.value.trim();
                    if (!/^.+:\/\//.exec(curi)) {
                        curi = 'http://' + curi;
                    }
                    var source = {uri: curi};
                    var lcuri = curi.toLowerCase();
                    if (lcuri.indexOf("https://www.encodeproject.org/") == 0 &&
                        lcuri.indexOf("@@download") >= 0) 
                    {
                        source.transport = 'encode';
                    }
                    tryAddBin(source);
                }
            } else if (customMode === 'reset') {
                switchToCustomMode();
            } else if (customMode === 'reset-bin') {
                switchToBinMode(); 
            } else if (customMode === 'reset-hub') {
                switchToHubConnectMode();
            } else if (customMode === 'prompt-bai') {
                var fileList = custFile.files;
                if (fileList && fileList.length > 0 && fileList[0]) {
                    dataToFinalize.baiBlob = fileList[0];
                    completeBAM(dataToFinalize);
                } else {
                    promptForBAI(dataToFinalize);
                }
            } else if (customMode === 'prompt-tbi') {
                var fileList = custFile.files;
                if (fileList && fileList.length > 0 && fileList[0]) {
                    dataToFinalize.indexBlob = fileList[0];
                    completeTabixVCF(dataToFinalize);
                } else {
                    promptForTabix(dataToFinalize);
                }
            } else if (customMode === 'finalize' || customMode === 'finalize-bin') {
                dataToFinalize.name = custName.value;
                var m = custCS.value;
                if (m != '__default__') {
                    dataToFinalize.mapping = m;
                } else {
                    dataToFinalize.mapping = undefined;
                }
                if (custQuant) {
                    dataToFinalize.maxbins = custQuant.checked;
                }

                if (custUser.value.length > 1 && custPass.value.length > 1) {
                    dataToFinalize.xUser = custUser.value;
                    dataToFinalize.xPass = custPass.value;
                }

                thisB.addTier(dataToFinalize);

                if (customMode == 'finalize-bin')
                    switchToBinMode();
                else
                    switchToCustomMode();
            } else if (customMode === 'hub-connect') {
                var curi = custURL.value.trim();
                if (!/^.+:\/\//.exec(curi)) {
                    curi = 'http://' + curi;
                }
                
                tryAddHub(curi);
            } else if (customMode === 'multiple') {
                for (var mi = 0; mi < multipleSet.length; ++mi) {
                    var s = multipleSet[mi];
                    if (s.hidden)
                        continue;

                    if (s.tier_type == 'bam' && !s.indexBlob && !s.indexUri)
                        continue;
                    if (s.tier_type == 'tabix' && !s.indexBlob && !s.indexUri)
                        continue;

                    var nds = makeSourceConfig(s);
                    if (nds) {
                        nds.noPersist = true;
                        thisB.addTier(nds);
                    }
                }

                switchToBinMode();
            }
        } else {
            thisB.removeAllPopups();
        }
    };

    function tryAddHub(curi, opts, retry) {
        opts = opts || {};
        for (var hi = 0; hi < thisB.hubObjects.length; ++hi) {
            var h = thisB.hubObjects[hi];
            if (h.hub.url == curi) {
                for (var bi = 0; bi < addModeButtons.length; ++bi) {
                    if (addModeButtons[bi].hub == h) {
                        activateButton(addModeButtons, addModeButtons[bi]);
                    }
                }
                h.getTracks(function(tracks, err) {
                    if (err) {
                        console.log(err);
                    }
                    makeHubStab(tracks);
                });
                return;
            }

        }
        
        connectTrackHub(curi, function(hub, err) {
            if (err) {
                if (!retry) {
                    return tryAddHub(curi, {credentials: true}, true);
                }
                removeChildren(stabHolder);
                stabHolder.appendChild(makeElement('h2', 'Error connecting to track hub'))
                stabHolder.appendChild(makeElement('p', err));
                customMode = 'reset-hub';
                return;
            } else {
                var bestHub = null;
                var bestHubButton = null;
                for (var genome in hub.genomes) {
                    var mapping = null;
                    var okay = false;

                    if (genome == thisB.coordSystem.ucscName) {
                        okay = true;
                    } else {
                         for (var mid in thisB.chains) {
                            var m = thisB.chains[mid];
                            if (genome == m.coords.ucscName) {
                                mapping = mid;
                                okay = true;
                            }
                         }
                    }

                    if (okay) {
                        var hc = {url: curi, genome: genome};
                        if (opts.credentials)
                            hc.credentials = true;
                        if (mapping) {
                            hc.mapping = mapping;
                            hub.genomes[genome].mapping = mapping;
                        }
                        thisB.hubs.push(hc);
                        thisB.hubObjects.push(hub.genomes[genome]);
                        
                        var hubButton = makeHubButton(hub.genomes[genome]);
                        modeButtonHolder.appendChild(hubButton);

                        if (!mapping || !bestHub) {
                            bestHub = hub.genomes[genome];
                            bestHubButton = hubButton;
                        }
                    }
                }

                if (bestHub) {
                    thisB.notifyTier();
                    activateButton(addModeButtons, bestHubButton);
                    bestHub.getTracks(function(tracks, err) {
                        makeHubStab(tracks);
                    });
                } else {
                    removeChildren(stabHolder);
                    stabHolder.appendChild(makeElement('h2', 'No data for this genome'))
                    stabHolder.appendChild(makeElement('p', 'This URL appears to be a valid track-hub, but it doesn\'t contain any data for the coordinate system of this browser'));
                    stabHolder.appendChild(makeElement('p', 'coordSystem.ucscName = ' + thisB.coordSystem.ucscName));
                    customMode = 'reset-hub';
                    return;
                }
            }
        }, opts);
    }

    var tryAddDAS = function(nds, retry) {
        var knownSpace = thisB.knownSpace;
        if (!knownSpace) {
            alert("Can't confirm track-addition to an uninit browser.");
            return;
        }
        var tsm = Math.max(knownSpace.min, (knownSpace.min + knownSpace.max - 100) / 2)|0;
        var testSegment = new DASSegment(knownSpace.chr, tsm, Math.min(tsm + 99, knownSpace.max));
        nds.features(testSegment, {}, function(features, status) {
            if (status) {
                if (!retry) {
                    nds.credentials = true;
                    tryAddDAS(nds, true);
                } else {
                    removeChildren(stabHolder);
                    stabHolder.appendChild(makeElement('h2', 'Custom data not found'));
                    stabHolder.appendChild(makeElement('p', 'DAS uri: ' + nds.uri + ' is not answering features requests'));
                    customMode = 'reset';
                    return;
                }
            } else {
                var nameExtractPattern = new RegExp('/([^/]+)/?$');
                var match = nameExtractPattern.exec(nds.uri);
                if (match) {
                    nds.name = match[1];
                }

                tryAddDASxSources(nds);
                return;
            }
        });
    }

    function tryAddDASxSources(nds, retry) {
        var uri = nds.uri;
        if (retry) {
            var match = /(.+)\/[^\/]+\/?/.exec(uri);
            if (match) {
                uri = match[1] + '/sources';
            }
        }
        function sqfail() {
            if (!retry) {
                return tryAddDASxSources(nds, true);
            } else {
                return addDasCompletionPage(nds);
            }
        }
        new DASRegistry(uri, {credentials: nds.credentials}).sources(
            function(sources) {
                if (!sources || sources.length == 0) {
                    return sqfail();
                } 

                var fs = null;
                if (sources.length == 1) {
                    fs = sources[0];
                } else {
                    for (var i = 0; i < sources.length; ++i) {
                        if (sources[i].uri === nds.uri) {
                            fs = sources[i];
                            break;
                        }
                    }
                }

                var coordsDetermined = false, quantDetermined = false;
                if (fs) {
                    nds.name = fs.name;
                    nds.desc = fs.desc;
                    if (fs.maxbins) {
                        nds.maxbins = true;
                    } else {
                        nds.maxbins = false;
                    }
                    if (fs.capabilities) {
                        nds.capabilities = fs.capabilities;
                    }
                    quantDetermined = true
                    
                    if (fs.coords && fs.coords.length == 1) {
                        var coords = fs.coords[0];
                        if (coordsMatch(coords, thisB.coordSystem)) {
                            coordsDetermined = true;
                        } else if (thisB.chains) {
                            for (var k in thisB.chains) {
                                if (coordsMatch(coords, thisB.chains[k].coords)) {
                                    nds.mapping = k;
                                    coordsDetermined = true;
                                }
                            }
                        }
                    }
                    
                }
                return addDasCompletionPage(nds, coordsDetermined, quantDetermined);
            },
            function() {
                return sqfail();
            }
        );
    }

    var makeSourceConfig = function(s) {
        var nds = {name: s.name};
        if (s.credentials)
            nds.credentials = s.credentials;
        
        if (s.mapping && s.mapping != '__default__')
            nds.mapping = s.mapping;

        if (s.transport)
            nds.transport = s.transport;

        if (s.tier_type == 'bwg') {
            if (s.blob)
                nds.bwgBlob = s.blob;
            else if (s.uri)
                nds.bwgURI = s.uri;
            return nds;
        } else if (s.tier_type == 'bam') {
            if (s.blob) {
                nds.bamBlob = s.blob;
                nds.baiBlob = s.indexBlob;
            } else {
                nds.bamURI = s.uri;
                nds.baiURI = s.indexUri;
            }
            return nds;
        } else if (s.tier_type == 'tabix') {
            nds.tier_type = 'tabix';
            nds.payload = s.payload;
            if (s.blob) {
                nds.blob = s.blob;
                nds.indexBlob = s.indexBlob;
            } else {
                nds.uri = s.uri;
                nds.indexUri = s.indexUri;
            }
            return nds;
        } else if (s.tier_type == 'memstore') {
            nds.tier_type = 'memstore';
            nds.payload = s.payload;
            if (s.blob)
                nds.blob = s.blob;
            else
                nds.uri = s.uri;
            return nds;
        }
    }

    var tryAddBin = function(source) {
        probeResource(source, function(source, err) {
            if (err) {
                removeChildren(stabHolder);
                var tabError = makeElement('div');
                tabError.appendChild(makeElement('h2', "Couldn't access custom data"));
                tabError.appendChild(makeElement('p', '' + err));
                stabHolder.appendChild(tabError);
                console.log(source);
                if (window.location.protocol === 'https:' && source.uri.indexOf('http:') == 0) {
                    thisB.canFetchPlainHTTP().then(
                        function(can) {
                            if (!can) {
                                tabError.appendChild(
                                    makeElement('p', [
                                        makeElement('strong', 'HTTP warning: '),
                                        'you may not be able to access HTTP resources from an instance of Biodalliance which you are accessing via HTTPS.',
                                        makeElement('a', '[More info]', {href: thisB.httpWarningURL, target: "_blank"})
                                      ]
                                   )
                                );
                            }
                        }
                    );
                }
                customMode = 'reset-bin';
            } else {
                var nds = makeSourceConfig(source);
                if (source.tier_type == 'bam') {
                    return completeBAM(nds);
                } else if (source.tier_type == 'tabix') {
                    return completeTabixVCF(nds);
                } else {
                    return addDasCompletionPage(nds, false, false, true);
                }
            }
        });
    }

    function promptForBAI(nds) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        customMode = 'prompt-bai'
        stabHolder.appendChild(makeElement('h2', 'Select an index file'));
        stabHolder.appendChild(makeElement('p', 'Dalliance requires a BAM index (.bai) file when displaying BAM data.  These normally accompany BAM files.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate BAI file'));

        stabHolder.appendChild(document.createTextNode('Index file: '));
        custFile = makeElement('input', null, {type: 'file'});
        stabHolder.appendChild(custFile);
        dataToFinalize = nds;
    }

    function promptForTabix(nds) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        customMode = 'prompt-tbi'
        stabHolder.appendChild(makeElement('h2', 'Select an index file'));
        stabHolder.appendChild(makeElement('p', 'Dalliance requires a Tabix index (.tbi) file when displaying VCF data.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate BAI file'));

        stabHolder.appendChild(document.createTextNode('Index file: '));
        custFile = makeElement('input', null, {type: 'file'});
        stabHolder.appendChild(custFile);
        dataToFinalize = nds;
    }

    function completeBAM(nds) {
        var indexF;
        if (nds.baiBlob) 
            indexF = new BlobFetchable(nds.baiBlob);
        else if (nds.transport == 'encode')
            indexF = new EncodeFetchable(nds.bamURI + '.bai');
        else
            indexF = new URLFetchable(nds.bamURI + '.bai', {credentials: nds.credentials});

        indexF.slice(0, 256).fetch(function(r) {
                var hasBAI = false;
                if (r) {
                    var ba = new Uint8Array(r);
                    var magic2 = readInt(ba, 0);
                    hasBAI = (magic2 == BAI_MAGIC);
                }
                if (hasBAI) {
                    return addDasCompletionPage(nds, false, false, true);
                } else {
                    return binFormatErrorPage('You have selected a valid BAM file, but a corresponding index (.bai) file was not found.  Please index your BAM (samtools index) and place the BAI file in the same directory');
                }
        });
    }

    function completeTabixVCF(nds) {
        var indexF;
        if (nds.indexBlob) {
            indexF = new BlobFetchable(nds.indexBlob);
        } else {
            indexF = new URLFetchable(nds.uri + '.tbi');
        }
        indexF.slice(0, 1<<16).fetch(function(r) {
            var hasTabix = false;
            if (r) {
                var ba = new Uint8Array(r);
                if (ba[0] == 31 || ba[1] == 139) {
                    var unc = unbgzf(r);
                    ba = new Uint8Array(unc);
                    var m2 = readInt(ba, 0);
                    hasTabix = (m2 == TABIX_MAGIC);
                }
            }
            if (hasTabix) {
                return addDasCompletionPage(nds, false, false, true);
            } else {
                return binFormatErrorPage('You have selected a valid VCF file, but a corresponding index (.tbi) file was not found.  Please index your VCF ("tabix -p vcf -f myfile.vcf.gz") and place the .tbi file in the same directory');
            }
        });
    }

    function binFormatErrorPage(message) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        message = message || 'Custom data format not recognized';
        stabHolder.appendChild(makeElement('h2', 'Error adding custom data'));
        stabHolder.appendChild(makeElement('p', message));
        stabHolder.appendChild(makeElement('p', 'Currently supported formats are bigBed, bigWig, and BAM.'));
        customMode = 'reset-bin';
        return;
    }
                     
    var addDasCompletionPage = function(nds, coordsDetermined, quantDetermined, quantIrrelevant) {
        refreshButton.style.display = 'none';
        addButton.style.display = 'inline';
        canButton.style.display = 'inline';

        removeChildren(stabHolder);
        stabHolder.appendChild(makeElement('h2', 'Add custom data: step 2'));
        stabHolder.appendChild(document.createTextNode('Label: '));
        custName = makeElement('input', '', {value: nds.name});
        stabHolder.appendChild(custName);


        // stabHolder.appendChild(document.createTextNode('User: '));
        custUser = makeElement('input', '');
        // stabHolder.appendChild(custUser);
        //stabHolder.appendChild(document.createTextNode('Pass: '));
        custPass = makeElement('input', '');
        // stabHolder.appendChild(custPass);
        

        stabHolder.appendChild(makeElement('br'));
        stabHolder.appendChild(makeElement('br'));
        stabHolder.appendChild(makeElement('h4', 'Coordinate system: '));
        custCS = makeElement('select', null);
        custCS.appendChild(makeElement('option', thisB.nameForCoordSystem(thisB.coordSystem), {value: '__default__'}));
        if (thisB.chains) {
            for (var csk in thisB.chains) {
                var cs = thisB.chains[csk].coords;
                custCS.appendChild(makeElement('option', thisB.nameForCoordSystem(cs), {value: csk}));
            }
        }
        custCS.value = nds.mapping || '__default__';
        stabHolder.appendChild(custCS);

        if (coordsDetermined) {
            stabHolder.appendChild(makeElement('p', "(Based on server response, probably doesn't need changing.)"));
        } else {
            stabHolder.appendChild(makeElement('p', [makeElement('b', 'Warning: '), "unable to determine the correct value from server responses.  Please check carefully."]));
            stabHolder.appendChild(makeElement('p', "If you don't see the mapping you're looking for, please contact thomas@biodalliance.org"));
        }

        if (!quantIrrelevant) {
            stabHolder.appendChild(document.createTextNode('Quantitative: '));
            custQuant = makeElement('input', null, {type: 'checkbox', checked: true});
            if (typeof nds.maxbins !== 'undefined') {
                custQuant.checked = nds.maxbins;
            }
            stabHolder.appendChild(custQuant);
            if (quantDetermined) {
                stabHolder.appendChild(makeElement('p', "(Based on server response, probably doesn't need changing.)"));
            } else {
                stabHolder.appendChild(makeElement('p', [makeElement('b', "Warning: "), "unable to determine correct value.  If in doubt, leave checked."]));
            }
        }

        if (nds.bwgBlob) {
            stabHolder.appendChild(makeElement('p', [makeElement('b', 'Warning: '), 'data added from local file.  Due to the browser security model, the track will disappear if you reload Dalliance.']));
        }

        custName.focus();

        if (customMode === 'bin' || customMode === 'prompt-bai' || customMode === 'prompt-tbi')
            customMode = 'finalize-bin';
        else
            customMode = 'finalize';
        dataToFinalize = nds;
    }

    var multipleSet = null;
    var tryAddMultiple = function(fileList) {
        var newSources = multipleSet = [];
        customMode = 'multiple';
        for (var fi = 0; fi < fileList.length; ++fi) {
            var f = fileList[fi];
            if (f) {
                newSources.push({blob: f});
            }
        }

        for (var fi = 0; fi < newSources.length; ++fi) {
            probeMultiple(newSources[fi]);
        }
        updateMultipleStatus();
    }

    var probeMultiple = function(ns) {
        probeResource(ns, function(source, err) {
            if (err) {
                source.error = err;
            }

            var usedIndices = [];
            var bams = {}, tabixes = {};
            for (var si = 0; si < multipleSet.length; ++si) {
                var s = multipleSet[si];
                if (s.tier_type == 'bam' && !s.indexBlob) {
                    bams[s.blob.name] = s;
                }
                if (s.tier_type == 'tabix' && !s.indexBlob) {
                    tabixes[s.blob.name] = s;
                }
            }

            for (var si = 0; si < multipleSet.length; ++si) {
                var s = multipleSet[si];
                if (s.tier_type === 'bai') {
                    var baiPattern = new RegExp('(.+)\\.bai$');
                    var match = baiPattern.exec(s.blob.name);
                    if (match && bams[match[1]]) {
                        bams[match[1]].indexBlob = s.blob;
                        usedIndices.push(si);
                    }
                } else if (s.tier_type === 'tabix-index') {
                    var tbiPattern = new RegExp('(.+)\\.tbi$');
                    var match = tbiPattern.exec(s.blob.name);
                    if (match && tabixes[match[1]]) {
                        tabixes[match[1]].indexBlob = s.blob;
                        usedIndices.push(si);
                    }
                }
            }

            for (var bi = usedIndices.length - 1; bi >= 0; --bi) {
                multipleSet.splice(usedIndices[bi], 1);
            }

            updateMultipleStatus();
        });
    }

    var updateMultipleStatus = function() {
        removeChildren(stabHolder);
        var needsIndex = false;
        var multTable = makeElement('table', multipleSet
          .filter(function(s) {return !s.hidden})
          .map(function(s) {
            var row = makeElement('tr');
            row.appendChild(makeElement('td', s.name || s.blob.name));
            var typeContent;
            if (s.error) {
                typeContent = makeElement('span', 'Error', null, {color: 'red'});
            } else if (s.tier_type) {
                typeContent = s.payload || s.tier_type;
            } else {
                typeContent = thisB.makeLoader(16);
            }

            var ccs;
            var state = 'unknown';
            if (s.tier_type == 'bwg' || s.tier_type == 'memstore') {
                state = 'okay';
            } else if (s.tier_type == 'bam') {
                state = s.indexBlob ? 'okay' : 'needs-index';
            } else if (s.tier_type == 'tabix') {
                state = s.indexBlob ? 'okay' : 'needs-index';
            }

            if (state == 'okay') {
                ccs = makeElement('select', null, null, {width: '150px'});
                ccs.appendChild(makeElement('option', thisB.nameForCoordSystem(thisB.coordSystem), {value: '__default__'}));
                if (thisB.chains) {
                    for (var csk in thisB.chains) {
                        var cs = thisB.chains[csk].coords;
                        ccs.appendChild(makeElement('option', thisB.nameForCoordSystem(cs), {value: csk}));
                    }
                }
                ccs.value = s.mapping || '__default__';

                ccs.addEventListener('change', function(ev) {
                    s.mapping = ccs.value;
                    console.log(s);
                }, false);
            } else if (state == 'needs-index') {
                ccs = makeElement('span', 'Needs index', {}, {color: 'red'});
                needsIndex = true;
            }

            return makeElement('tr', [makeElement('td', s.name || s.blob.name),
                                      makeElement('td', typeContent),
                                      makeElement('td', ccs)]);

        }), {className: 'table table-striped table-condensed'});
        stabHolder.appendChild(multTable);

        if (needsIndex) {
            stabHolder.appendChild(makeElement('p', 'Some of these files are missing required index (.bai or .tbi) files.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate index file'));
            stabHolder.appendChild(document.createTextNode('Index file(s): '));
            var indexFile = makeElement('input', null, {type: 'file', multiple: 'multiple'});
            stabHolder.appendChild(indexFile);
            indexFile.addEventListener('change', function(ev) {
                console.log('fileset changed');
                var fileList = indexFile.files || [];
                for (var fi = 0; fi < fileList.length; ++fi) {
                    var f = fileList[fi];
                    if (f) {
                        var ns = {blob: f, hidden: true};
                        multipleSet.push(ns);
                        probeMultiple(ns);
                    }
                }
            }, false);
        }
    }

    var canButton = makeElement('button', 'Cancel', {className: 'btn'});
    canButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();
        if (customMode === 'finalize-bin')
            switchToBinMode();
        else
            switchToCustomMode();
    }, false);

    var refreshButton = makeElement('button', 'Refresh', {className: 'btn'});
    refreshButton.addEventListener('click', function(ev) {
        ev.stopPropagation(); ev.preventDefault();
        thisB.queryRegistry(__mapping);
    }, false);
    this.makeTooltip(refreshButton, 'Click to re-fetch data from the DAS registry');

    var buttonHolder = makeElement('div', [addButton, ' ', canButton, ' ', refreshButton]);
    buttonHolder.style.margin = '10px';
    asform.appendChild(buttonHolder);

    popup.appendChild(asform);
    makeStab(thisB.availableSources);

    this.showToolPanel(popup);
    this.setUiMode('add');

    if (firstDefButton) {
        activateButton(addModeButtons, firstDefButton);
        makeStab(new Observed(firstDefSources));
    }
}

},{"./bam":1,"./bin":4,"./cbrowser":6,"./das":10,"./domui":11,"./encode":12,"./lh3utils":24,"./probe":28,"./sourcecompare":35,"./tabix":41,"./thub":42,"./utils":49}],47:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// trix.js: UCSC-style free text indices
//

"use strict";

function connectTrix(ix, ixx, callback) {
    ixx.fetchAsText(function(ixxData) {
        if (!ixxData) 
            return callback(null, "Couldn't fetch index-index");

        var toks = ixxData.split(/(.+)([0-9A-F]{10})\n/);

        var keys = [];
        var offsets = [];
        for (var ti = 1; ti < toks.length; ti += 3) {
            keys.push(toks[ti]);
            offsets.push(parseInt(toks[ti+1], 16));
        }

        return callback(new TrixIndex(keys, offsets, ix));
    });
}

function TrixIndex(keys, offsets, ix) {
    this.keys = keys;
    this.offsets = offsets;
    this.ix = ix;
}

TrixIndex.prototype.lookup = function(query, callback) {
    var ixslice;

    var qtag = (query + '     ').substring(0,5).toLowerCase();
    for (var i = 0; i < this.keys.length; ++i) {
        if (qtag.localeCompare(this.keys[i]) < 0) {
            ixslice = this.ix.slice(this.offsets[i - 1], this.offsets[i] - this.offsets[i - 1]);
            break;
        }
    }

    if (!ixslice) {
        ixslice = this.ix.slice(this.offsets[this.offsets.length - 1]);
    }

    ixslice.fetchAsText(function(ist) {
        var lines = ist.split('\n');
        for (var li = 0; li < lines.length; ++li) {
            if (lines[li].indexOf(query.toLowerCase() + ' ') == 0) {
                return callback(lines[li].split(' '));
            }
        }
        return callback(null);
    });
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        connectTrix: connectTrix
    };
}
},{}],48:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// twoBit.js: packed-binary reference sequences
//

"use strict";

if (typeof(require) !== 'undefined') {
    var bin = require('./bin');
    var readInt = bin.readInt;
    var readIntBE = bin.readIntBE;

    var spans = require('./spans');
    var Range = spans.Range;
    var union = spans.union;
    var intersection = spans.intersection;
}

var TWOBIT_MAGIC = 0x1a412743;
var TWOBIT_MAGIC_BE = 0x4327411a;

function TwoBitFile() {
}

function makeTwoBit(fetchable, cnt) {
    var tb = new TwoBitFile();
    tb.data = fetchable;
    var headerBlockSize = 12500;

    tb.data.slice(0, headerBlockSize).fetch(function(r) {
        if (!r) {
            return cnt(null, "Couldn't access data");
        }
        var ba = new Uint8Array(r);
        var magic = readInt(ba, 0);
        if (magic == TWOBIT_MAGIC) {
            tb.readInt = readInt;
        } else if (magic == TWOBIT_MAGIC_BE) {
            tb.readInt = readIntBE;
        } else {
            return cnt(null, "Not a .2bit file, magic=0x" + magic.toString(16));
        }

        var version = tb.readInt(ba, 4);
        if (version != 0) {
            return cnt(null, 'Unsupported version ' + version);
        }

        tb.seqCount = tb.readInt(ba, 8);
        tb.seqDict = {};

        var p = 16, i=0;
        var o = 0;  // Offset of the current block if we need to fetch multiple header blocks.

        var parseSeqInfo = function() {
            while (i < tb.seqCount) {
                var ns = ba[p];
                if (p + ns + 6 >= ba.length) {
                    return tb.data.slice(o + p, headerBlockSize).fetch(function (r) {
                        o += p;
                        p = 0;
                        ba = new Uint8Array(r);
                        parseSeqInfo();
                    });
                } else {
                    ++p;
                    var name = '';
                    for (var j = 1; j <= ns; ++j) {
                        name += String.fromCharCode(ba[p++]);
                    }
                    var offset = tb.readInt(ba, p);
                    p += 4;
                    tb.seqDict[name] = new TwoBitSeq(tb, offset);
                    ++i;
                }
            }
            return cnt(tb);
        }

        parseSeqInfo();
        
    });
}

TwoBitFile.prototype.getSeq = function(chr) {
    var seq = this.seqDict[chr];
    if (!seq) {
        seq = this.seqDict['chr' + chr];
    }
    return seq;
}

TwoBitFile.prototype.fetch = function(chr, min, max, cnt) {
    var seq = this.getSeq(chr);
    if (!seq) {
        return cnt(null, "Couldn't find " + chr);
    } else if (max <= min) {
        return cnt('');
    } else {
        seq.fetch(min, max, cnt);
    }
}

function TwoBitSeq(tbf, offset) {
    this.tbf = tbf;
    this.offset = offset;
}

TwoBitSeq.prototype.init = function(cnt) {
    if (this.seqOffset) {
        return cnt();
    }

    var thisB = this;
    thisB.tbf.data.slice(thisB.offset, 8).fetch(function(r1) {
        if (!r1) {
            return cnt('Fetch failed');
        }
        var ba = new Uint8Array(r1);
        thisB._length = thisB.tbf.readInt(ba, 0);
        thisB.nBlockCnt = thisB.tbf.readInt(ba, 4);
        thisB.tbf.data.slice(thisB.offset + 8, thisB.nBlockCnt*8 + 4).fetch(function(r2) {
            if (!r2) {
                return cnt('Fetch failed');
            }
            var ba = new Uint8Array(r2);
            var nbs = null;
            for (var b = 0; b < thisB.nBlockCnt; ++b) {
                var nbMin = thisB.tbf.readInt(ba, b * 4);
                var nbLen = thisB.tbf.readInt(ba, (b + thisB.nBlockCnt) * 4);
                var nb = new Range(nbMin, nbMin + nbLen - 1);
                if (!nbs) {
                    nbs = nb;
                } else {
                    nbs = union(nbs, nb);
                }
            }
            thisB.nBlocks = nbs;
            thisB.mBlockCnt = thisB.tbf.readInt(ba, thisB.nBlockCnt*8);
            thisB.seqLength = ((thisB._length + 3)/4)|0;
            thisB.seqOffset = thisB.offset + 16 + ((thisB.nBlockCnt + thisB.mBlockCnt) * 8);
            return cnt();
        });
    });
}

var TWOBIT_TABLE = ['T', 'C', 'A', 'G'];

TwoBitSeq.prototype.fetch = function(min, max, cnt) {
    --min; --max;       // Switch to zero-based.
    var thisB = this;
    this.init(function(error) {
        if (error) {
            return cnt(null, error);
        }

        var fetchMin = min >> 2;
        var fetchMax = max + 3 >> 2;
        if (fetchMin < 0 || fetchMax > thisB.seqLength) {
            return cnt('Coordinates out of bounds: ' + min + ':' + max);
        }

        thisB.tbf.data.slice(thisB.seqOffset + fetchMin, fetchMax - fetchMin).salted().fetch(function(r) {
            if (r == null) {
                return cnt('SeqFetch failed');
            }
            var seqData = new Uint8Array(r);

            var nSpans = [];
            if (thisB.nBlocks) {
                var intr = intersection(new Range(min, max), thisB.nBlocks);
                if (intr) {
                    nSpans = intr.ranges();
                }
            }
            
            var seqstr = '';
            var ptr = min;
            function fillSeq(fsm) {
                while (ptr <= fsm) {
                    var bb = (ptr >> 2) - fetchMin;
                    var ni = ptr & 0x3;
                    var bv = seqData[bb];
                    var n;
                    if (ni == 0) {
                        n = (bv >> 6) & 0x3;
                    } else if (ni == 1) {
                        n = (bv >> 4) & 0x3;
                    } else if (ni == 2) {
                        n = (bv >> 2) & 0x3;
                    } else {
                        n = (bv) & 0x3;
                    }
                    seqstr += TWOBIT_TABLE[n];
                    ++ptr;
                }
            }
            
            for (var b = 0; b < nSpans.length; ++b) {
                var nb = nSpans[b];
                if (ptr > nb.min()) {
                    throw 'N mismatch...';
                }
                if (ptr < nb.min()) {
                    fillSeq(nb.min() - 1);
                }
                while (ptr <= nb.max()) {
                    seqstr += 'N';
                    ++ptr;
                }
            }
            if (ptr <= max) {
                fillSeq(max);
            }
            return cnt(seqstr);
        });
    });
}

TwoBitSeq.prototype.length = function(cnt) {
    var thisB = this;
    this.init(function(error) {
        if (error) {
            return cnt(null, error);
        } else {
            return cnt(thisB._length);
        }
    });
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        makeTwoBit: makeTwoBit
    };
}

},{"./bin":4,"./spans":36}],49:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// utils.js: odds, sods, and ends.
//

"use strict";

if (typeof(require) !== 'undefined') {
    var sha1 = require('./sha1');
    var b64_sha1 = sha1.b64_sha1;
}

var NUM_REGEXP = new RegExp('[0-9]+');

function stringToNumbersArray(str) {
    var nums = new Array();
    var m;
    while (m = NUM_REGEXP.exec(str)) {
        nums.push(m[0]);
        str=str.substring(m.index + (m[0].length));
    }
    return nums;
}

var STRICT_NUM_REGEXP = new RegExp('^[0-9]+$');

function stringToInt(str) {
    str = str.replace(new RegExp(',', 'g'), '');
    if (!STRICT_NUM_REGEXP.test(str)) {
        return null;
    }
    return str|0;
}

function pushnew(a, v) {
    for (var i = 0; i < a.length; ++i) {
        if (a[i] == v) {
            return;
        }
    }
    a.push(v);
}

function pusho(obj, k, v) {
    if (obj[k]) {
        obj[k].push(v);
    } else {
        obj[k] = [v];
    }
}

function pushnewo(obj, k, v) {
    var a = obj[k];
    if (a) {
        for (var i = 0; i < a.length; ++i) {    // indexOf requires JS16 :-(.
            if (a[i] == v) {
                return;
            }
        }
        a.push(v);
    } else {
        obj[k] = [v];
    }
}


function pick(a, b, c, d)
{
    if (a) {
        return a;
    } else if (b) {
        return b;
    } else if (c) {
        return c;
    } else if (d) {
        return d;
    }
}

function pushnew(l, o)
{
    for (var i = 0; i < l.length; ++i) {
        if (l[i] == o) {
            return;
        }
    }
    l.push(o);
}



function arrayIndexOf(a, x) {
    if (!a) {
        return -1;
    }

    for (var i = 0; i < a.length; ++i) {
        if (a[i] === x) {
            return i;
        }
    }
    return -1;
}

function arrayRemove(a, x) {
    var i = arrayIndexOf(a, x);
    if (i >= 0) {
        a.splice(i, 1);
        return true;
    }
    return false;
}

//
// DOM utilities
//


function makeElement(tag, children, attribs, styles)
{
    var ele = document.createElement(tag);
    if (children) {
        if (! (children instanceof Array)) {
            children = [children];
        }
        for (var i = 0; i < children.length; ++i) {
            var c = children[i];
            if (c) {
                if (typeof c == 'string') {
                    c = document.createTextNode(c);
                } else if (typeof c == 'number') {
                    c = document.createTextNode('' + c);
                }
                ele.appendChild(c);
            }
        }
    }
    
    if (attribs) {
        for (var l in attribs) {
            try {
                ele[l] = attribs[l];
            } catch (e) {
                console.log('error setting ' + l);
                throw(e);
            }
        }
    }
    if (styles) {
        for (var l in styles) {
            ele.style[l] = styles[l];
        }
    }
    return ele;
}

function makeElementNS(namespace, tag, children, attribs)
{
    var ele = document.createElementNS(namespace, tag);
    if (children) {
        if (! (children instanceof Array)) {
            children = [children];
        }
        for (var i = 0; i < children.length; ++i) {
            var c = children[i];
            if (typeof c == 'string') {
                c = document.createTextNode(c);
            }
            ele.appendChild(c);
        }
    }
    
    setAttrs(ele, attribs);
    return ele;
}

var attr_name_cache = {};

function setAttr(node, key, value)
{
    var attr = attr_name_cache[key];
    if (!attr) {
        var _attr = '';
        for (var c = 0; c < key.length; ++c) {
            var cc = key.substring(c, c+1);
            var lcc = cc.toLowerCase();
            if (lcc != cc) {
                _attr = _attr + '-' + lcc;
            } else {
                _attr = _attr + cc;
            }
        }
        attr_name_cache[key] = _attr;
        attr = _attr;
    }
    node.setAttribute(attr, value);
}

function setAttrs(node, attribs)
{
    if (attribs) {
        for (var l in attribs) {
            setAttr(node, l, attribs[l]);
        }
    }
}



function removeChildren(node)
{
    if (!node || !node.childNodes) {
        return;
    }

    while (node.childNodes.length > 0) {
        node.removeChild(node.firstChild);
    }
}



//
// WARNING: not for general use!
//

function miniJSONify(o, exc) {
    if (typeof o === 'undefined') {
        return 'undefined';
    } else if (o == null) {
        return 'null';
    } else if (typeof o == 'string') {
        return "'" + o + "'";
    } else if (typeof o == 'number') {
        return "" + o;
    } else if (typeof o == 'boolean') {
        return "" + o;
    } else if (typeof o == 'object') {
        if (o instanceof Array) {
            var s = null;
            for (var i = 0; i < o.length; ++i) {
                s = (s == null ? '' : (s + ', ')) + miniJSONify(o[i], exc);
            }
            return '[' + (s?s:'') + ']';
        } else {
            exc = exc || {};
            var s = null;
            for (var k in o) {
                if (exc[k])
                    continue;
                if (k != undefined && typeof(o[k]) != 'function') {
                    s = (s == null ? '' : (s + ', ')) + k + ': ' + miniJSONify(o[k], exc);
                }
            }
            return '{' + (s?s:'') + '}';
        }
    } else {
        return (typeof o);
    }
}

function shallowCopy(o) {
    var n = {};
    for (var k in o) {
        n[k] = o[k];
    }
    return n;
}

function Observed(x) {
    this.value = x;
    this.listeners = [];
}

Observed.prototype.addListener = function(f) {
    this.listeners.push(f);
}

Observed.prototype.addListenerAndFire = function(f) {
    this.listeners.push(f);
    f(this.value);
}

Observed.prototype.removeListener = function(f) {
    arrayRemove(this.listeners, f);
}

Observed.prototype.get = function() {
    return this.value;
}

Observed.prototype.set = function(x) {
    this.value = x;
    for (var i = 0; i < this.listeners.length; ++i) {
        this.listeners[i](x);
    }
}

function Awaited() {
    this.queue = [];
}

Awaited.prototype.provide = function(x) {
    if (this.res !== undefined) {
        throw "Resource has already been provided.";
    }

    this.res = x;
    for (var i = 0; i < this.queue.length; ++i) {
        this.queue[i](x);
    }
    this.queue = null;   // avoid leaking closures.
}

Awaited.prototype.await = function(f) {
    if (this.res !== undefined) {
        f(this.res);
        return this.res;
    } else {
        this.queue.push(f);
    }
}

var __dalliance_saltSeed = 0;

function saltURL(url) {
    return url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++__dalliance_saltSeed));
}

function textXHR(url, callback, opts) {
    if (opts && opts.salt) 
        url = saltURL(url);

    try {
        var timeout;
        if (opts.timeout) {
            timeout = setTimeout(
                function() {
                    console.log('timing out ' + url);
                    req.abort();
                    return callback(null, 'Timeout');
                },
                opts.timeout
            );
        }

        var req = new XMLHttpRequest();
        req.onreadystatechange = function() {
    	    if (req.readyState == 4) {
                if (timeout)
                    clearTimeout(timeout);
    	        if (req.status < 200 || req.status >= 300) {
    		    callback(null, 'Error code ' + req.status);
    	        } else {
    		    callback(req.responseText);
    	        }
    	    }
        };
        
        req.open('GET', url, true);
        req.responseType = 'text';

        if (opts && opts.credentials) {
            req.withCredentials = true;
        }
        req.send('');
    } catch (e) {
        callback(null, 'Exception ' + e);
    }
}

function relativeURL(base, rel) {
    // FIXME quite naive -- good enough for trackhubs?

    if (rel.indexOf('http:') == 0 || rel.indexOf('https:') == 0) {
        return rel;
    }

    var li = base.lastIndexOf('/');
    if (li >= 0) {
        return base.substr(0, li + 1) + rel;
    } else {
        return rel;
    }
}

var AMINO_ACID_TRANSLATION = {
    'TTT': 'F',
    'TTC': 'F',
    'TTA': 'L',
    'TTG': 'L',
    'CTT': 'L',
    'CTC': 'L',
    'CTA': 'L',
    'CTG': 'L',
    'ATT': 'I',
    'ATC': 'I',
    'ATA': 'I',
    'ATG': 'M',
    'GTT': 'V',
    'GTC': 'V',
    'GTA': 'V',
    'GTG': 'V',
    'TCT': 'S',
    'TCC': 'S',
    'TCA': 'S',
    'TCG': 'S',
    'CCT': 'P',
    'CCC': 'P',
    'CCA': 'P',
    'CCG': 'P',
    'ACT': 'T',
    'ACC': 'T',
    'ACA': 'T',
    'ACG': 'T',
    'GCT': 'A',
    'GCC': 'A',
    'GCA': 'A',
    'GCG': 'A',
    'TAT': 'Y',
    'TAC': 'Y',
    'TAA': '*',  // stop
    'TAG': '*',  // stop
    'CAT': 'H',
    'CAC': 'H',
    'CAA': 'Q',
    'CAG': 'Q',
    'AAT': 'N',
    'AAC': 'N',
    'AAA': 'K',
    'AAG': 'K',
    'GAT': 'D',
    'GAC': 'D',
    'GAA': 'E',
    'GAG': 'E',
    'TGT': 'C',
    'TGC': 'C',
    'TGA': '*',  // stop
    'TGG': 'W',
    'CGT': 'R',
    'CGC': 'R',
    'CGA': 'R',
    'CGG': 'R',
    'AGT': 'S',
    'AGC': 'S',
    'AGA': 'R',
    'AGG': 'R',
    'GGT': 'G',
    'GGC': 'G',
    'GGA': 'G',
    'GGG': 'G'
}

function resolveUrlToPage(rel) {
    return makeElement('a', null, {href: rel}).href;
}

//
// Missing APIs
// 

if (!('trim' in String.prototype)) {
    String.prototype.trim = function() {
        return this.replace(/^\s+/, '').replace(/\s+$/, '');
    };
}

if (typeof(module) !== 'undefined') {
    module.exports = {
        textXHR: textXHR,
        relativeURL: relativeURL,
        resolveUrlToPage: resolveUrlToPage,
        shallowCopy: shallowCopy,
        pusho: pusho,
        pushnew: pushnew,
        pushnewo: pushnewo,
        arrayIndexOf: arrayIndexOf,
        pick: pick,

        makeElement: makeElement,
        makeElementNS: makeElementNS,
        removeChildren: removeChildren,

        miniJSONify: miniJSONify,

        Observed: Observed,
        Awaited: Awaited,

        AMINO_ACID_TRANSLATION: AMINO_ACID_TRANSLATION
    }
}

},{"./sha1":33}],50:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// vcf.js
//

"use strict";

if (typeof(require) !== 'undefined') {
    var sa = require('./sourceadapters');
    var dalliance_registerParserFactory = sa.registerParserFactory;

    var das = require('./das');
    var DASStylesheet = das.DASStylesheet;
    var DASStyle = das.DASStyle;
    var DASFeature = das.DASFeature;
    var DASGroup = das.DASGroup;
}

function VCFParser() {
    this.info = [];
}

var VCF_INFO_RE = /([^;=]+)(=([^;]+))?;?/;
var VCF_INFO_HEADER = /##INFO=<([^>]+)>/;
var VCF_INFO_HEADER_TOK = /([^,=]+)=([^,]+|"[^"]+"),?/

VCFParser.prototype.createSession = function(sink) {
    return new VCFParseSession(this, sink);
}

function VCFParseSession(parser, sink) {
    this.parser = parser;
    this.sink  = sink;
}

VCFParseSession.prototype.parse = function(line) {
    if (line.length == 0)
        return;
    if (line[0] == '#') {
        if (line.length > 1 && line[1] == '#') {
            var m = VCF_INFO_HEADER.exec(line);
            if (m) {
                var toks = m[1].split(VCF_INFO_HEADER_TOK);
                var id = null, desc = null;
                for (var ti = 0; ti < toks.length - 1; ti += 3) {
                    var key = toks[ti + 1];
                    var value = toks[ti + 2].replace(/"/g, '');
                    if (key == 'ID') {
                        id = value;
                    } else if (key == 'Description') {
                        desc = value;
                    }
                }
                if (id && desc) {
                    this.parser.info.push(
                        {id: id,
                         desc: desc}
                    );
                }
            }
            return;
        } else {
            return;
        }
    }

    var toks = line.split('\t');
    var f = new DASFeature();
    f.segment = toks[0];
    f.id = toks[2]
    f.refAllele = toks[3];
    f.altAlleles = toks[4].split(',');
    f.min = parseInt(toks[1]);
    f.max = f.min + f.refAllele.length - 1;

    var infoToks = toks[7].split(VCF_INFO_RE);
    f.info = {};
    for (var ti = 0; ti < infoToks.length; ti += 4) {
        f.info[infoToks[ti + 1]] = infoToks[ti + 3];
    }


    var alt = f.altAlleles[0];
    var ref = f.refAllele;
    if (alt.length > ref.length) {
        f.type = "insertion";
        if (alt.indexOf(ref) == 0) {
            f.insertion = alt.substr(ref.length);
            f.min += ref.length;
            f.max = f.min - 1; // Effectively "between" bases.
        } else {
            f.insertion = alt;
        }
    } else if (alt.length < ref.length) {
        f.type = "deletion";
    } else {
        f.type = 'substitution';
    }

    this.sink(f);
}

VCFParseSession.prototype.flush = function() {};

VCFParser.prototype.getStyleSheet = function(callback) {
    var stylesheet = new DASStylesheet();

    {
        var varStyle = new DASStyle();
        varStyle.glyph = '__INSERTION';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({type: 'insertion'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(255, 60, 60)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({type: 'deletion'}, null, varStyle);
    }
    {
        var varStyle = new DASStyle();
        varStyle.glyph = 'PLIMSOLL';
        varStyle.BUMP = 'yes';
        varStyle.LABEL = 'no';
        varStyle.FGCOLOR = 'rgb(50,80,255)';
        varStyle.BGCOLOR = '#888888';
        varStyle.STROKECOLOR = 'black';
        stylesheet.pushStyle({type: 'default'}, null, varStyle);
    }

    return callback(stylesheet);
}

VCFParser.prototype.getDefaultFIPs = function(callback) {
    var self = this;
    var fip = function(feature, featureInfo) {
        featureInfo.add("Ref. allele", feature.refAllele);
        featureInfo.add("Alt. alleles", feature.altAlleles.join(','));

        if (feature.info) {
            for (var ii = 0; ii < self.info.length; ++ii) {
                var info = self.info[ii];
                var val = feature.info[info.id];
                if (val !== undefined) {
                    featureInfo.add(info.desc, val);
                }
            }
        }
    };
    callback(fip);
}

dalliance_registerParserFactory('vcf', function() {return new VCFParser()});

},{"./das":10,"./sourceadapters":34}],51:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2010
//
// version.js
//

"use strict";

var VERSION = {
    CONFIG: 5,
    MAJOR:  0,
    MINOR:  13,
    MICRO:  7,
    BRANCH: ''
};

VERSION.toString = function() {
    var vs = '' + this.MAJOR + '.' + this.MINOR + '.' + this.MICRO;
    if (this.PATCH) {
        vs = vs + this.PATCH;
    }
    if (this.BRANCH && this.BRANCH != '') {
        vs = vs + '-' + this.BRANCH;
    }
    return vs;
}

if (typeof(module) !== 'undefined') {
    module.exports = VERSION;
}

},{}],52:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Dalliance Genome Explorer
// (c) Thomas Down 2006-2014
//
// zoomslider.js: custom slider component
//


"use strict";

if (typeof(require) !== 'undefined') {
    var utils = require('./utils');
    var makeElement = utils.makeElement;
}

function makeZoomSlider() {
    var track = makeElement('hr', null, {className: 'slider-track'});
    var thumb = makeElement('hr', null, {className: 'slider-thumb active'});
    var thumb2 = makeElement('hr', null, {className: 'slider-thumb'});
    var slider = makeElement('div', [track, thumb, thumb2], {className: 'slider'});
    var minPos = 0, maxPos = 200;
    var min = 0, max = 200;
    var pos = 50, pos2 = 100;
    var labels = [];

    slider.removeLabels = function() {
        for (var li = 0; li < labels.length; ++li) {
            slider.removeChild(labels[li]);
        }
        labels = [];
    }

    slider.addLabel = function(val, txt) {
        var pos = (minPos + ((val - min) * (maxPos - minPos))/(max-min))|0;
        var label = makeElement('div', txt, {className: 'slider-label'}, {
            left: '' + ((minPos + ((val - min) * (maxPos - minPos))/(max-min))|0) + 'px'
        });
        slider.appendChild(label);
        labels.push(label);
    }

    var onChange = document.createEvent('HTMLEvents');
    onChange.initEvent('change', true, false);

    function setPos(np) {
        np = Math.min(np, maxPos);
        np = Math.max(np, minPos);
        pos = np;
        thumb.style.left = '' + pos + 'px';
    }

    function setPos2(np) {
        np = Math.min(np, maxPos);
        np = Math.max(np, minPos);
        pos2 = np;
        thumb2.style.left = '' + pos2 + 'px';
    }

    Object.defineProperty(slider, 'value', {
        get: function()  {return min + (((pos-minPos) * (max-min)) / (maxPos - minPos));},
        set: function(v) {
          var np = minPos + ((v-min) * (maxPos-minPos))/(max-min);
          setPos(np);
        }
    });

    Object.defineProperty(slider, 'value2', {
        get: function()  {return min + (((pos2-minPos) * (max-min)) / (maxPos - minPos));},
        set: function(v) {
          var np = minPos + ((v-min) * (maxPos-minPos))/(max-min);
          setPos2(np);
        }
    });

    Object.defineProperty(slider, 'active', {
        get: function() {return thumb.classList.contains('active') ? 1 : 2},
        set: function(x) {
            if (x == 1) {
                thumb.classList.add('active');
                thumb2.classList.remove('active');
            } else {
                thumb2.classList.add('active');
                thumb.classList.remove('active');
            }
        }
    });

    Object.defineProperty(slider, 'min', {
      get: function() {return min},
      set: function(v) {min = v}
    });

    Object.defineProperty(slider, 'max', {
      get: function() {return max},
      set: function(v) {max = v}
    });

    var offset;
    var which;

    var thumbMouseDown = function(ev) {
        which = this == thumb ? 1 : 2;
        if (which != slider.active) {
            slider.active = which;
            slider.dispatchEvent(onChange);
        }
        ev.stopPropagation(); ev.preventDefault();
        window.addEventListener('mousemove', thumbDragHandler, false);
        window.addEventListener('mouseup', thumbDragEndHandler, false);
        offset = ev.clientX - (which == 1 ? pos : pos2);
    };

    thumb.addEventListener('mousedown', thumbMouseDown, false);
    thumb2.addEventListener('mousedown', thumbMouseDown, false);

    var thumbDragHandler = function(ev) {
        if (which == 1)
            setPos(ev.clientX - offset);
        else
            setPos2(ev.clientX - offset);
        slider.dispatchEvent(onChange);
    };

    var thumbDragEndHandler = function(ev) {
        window.removeEventListener('mousemove', thumbDragHandler, false);
        window.removeEventListener('mouseup', thumbDragEndHandler, false);
    }

    return slider;
}

if (typeof(module) !== 'undefined') {
    module.exports = makeZoomSlider;
}

},{"./utils":49}],53:[function(require,module,exports){
"use strict";
var Promise = require("./promise/promise").Promise;
var polyfill = require("./promise/polyfill").polyfill;
exports.Promise = Promise;
exports.polyfill = polyfill;
},{"./promise/polyfill":58,"./promise/promise":59}],54:[function(require,module,exports){
"use strict";
/* global toString */

var isArray = require("./utils").isArray;
var isFunction = require("./utils").isFunction;

/**
  Returns a promise that is fulfilled when all the given promises have been
  fulfilled, or rejected if any of them become rejected. The return promise
  is fulfilled with an array that gives all the values in the order they were
  passed in the `promises` array argument.

  Example:

  ```javascript
  var promise1 = RSVP.resolve(1);
  var promise2 = RSVP.resolve(2);
  var promise3 = RSVP.resolve(3);
  var promises = [ promise1, promise2, promise3 ];

  RSVP.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `RSVP.all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  var promise1 = RSVP.resolve(1);
  var promise2 = RSVP.reject(new Error("2"));
  var promise3 = RSVP.reject(new Error("3"));
  var promises = [ promise1, promise2, promise3 ];

  RSVP.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @for RSVP
  @param {Array} promises
  @param {String} label
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
*/
function all(promises) {
  /*jshint validthis:true */
  var Promise = this;

  if (!isArray(promises)) {
    throw new TypeError('You must pass an array to all.');
  }

  return new Promise(function(resolve, reject) {
    var results = [], remaining = promises.length,
    promise;

    if (remaining === 0) {
      resolve([]);
    }

    function resolver(index) {
      return function(value) {
        resolveAll(index, value);
      };
    }

    function resolveAll(index, value) {
      results[index] = value;
      if (--remaining === 0) {
        resolve(results);
      }
    }

    for (var i = 0; i < promises.length; i++) {
      promise = promises[i];

      if (promise && isFunction(promise.then)) {
        promise.then(resolver(i), reject);
      } else {
        resolveAll(i, promise);
      }
    }
  });
}

exports.all = all;
},{"./utils":63}],55:[function(require,module,exports){
(function (process,global){
"use strict";
var browserGlobal = (typeof window !== 'undefined') ? window : {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var local = (typeof global !== 'undefined') ? global : (this === undefined? window:this);

// node
function useNextTick() {
  return function() {
    process.nextTick(flush);
  };
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function() {
    node.data = (iterations = ++iterations % 2);
  };
}

function useSetTimeout() {
  return function() {
    local.setTimeout(flush, 1);
  };
}

var queue = [];
function flush() {
  for (var i = 0; i < queue.length; i++) {
    var tuple = queue[i];
    var callback = tuple[0], arg = tuple[1];
    callback(arg);
  }
  queue = [];
}

var scheduleFlush;

// Decide what async method to use to triggering processing of queued callbacks:
if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else {
  scheduleFlush = useSetTimeout();
}

function asap(callback, arg) {
  var length = queue.push([callback, arg]);
  if (length === 1) {
    // If length is 1, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    scheduleFlush();
  }
}

exports.asap = asap;
}).call(this,require("1YiZ5S"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"1YiZ5S":64}],56:[function(require,module,exports){
"use strict";
/**
  `RSVP.Promise.cast` returns the same promise if that promise shares a constructor
  with the promise being casted.

  Example:

  ```javascript
  var promise = RSVP.resolve(1);
  var casted = RSVP.Promise.cast(promise);

  console.log(promise === casted); // true
  ```

  In the case of a promise whose constructor does not match, it is assimilated.
  The resulting promise will fulfill or reject based on the outcome of the
  promise being casted.

  In the case of a non-promise, a promise which will fulfill with that value is
  returned.

  Example:

  ```javascript
  var value = 1; // could be a number, boolean, string, undefined...
  var casted = RSVP.Promise.cast(value);

  console.log(value === casted); // false
  console.log(casted instanceof RSVP.Promise) // true

  casted.then(function(val) {
    val === value // => true
  });
  ```

  `RSVP.Promise.cast` is similar to `RSVP.resolve`, but `RSVP.Promise.cast` differs in the
  following ways:
  * `RSVP.Promise.cast` serves as a memory-efficient way of getting a promise, when you
  have something that could either be a promise or a value. RSVP.resolve
  will have the same effect but will create a new promise wrapper if the
  argument is a promise.
  * `RSVP.Promise.cast` is a way of casting incoming thenables or promise subclasses to
  promises of the exact class specified, so that the resulting object's `then` is
  ensured to have the behavior of the constructor you are calling cast on (i.e., RSVP.Promise).

  @method cast
  @for RSVP
  @param {Object} object to be casted
  @return {Promise} promise that is fulfilled when all properties of `promises`
  have been fulfilled, or rejected if any of them become rejected.
*/


function cast(object) {
  /*jshint validthis:true */
  if (object && typeof object === 'object' && object.constructor === this) {
    return object;
  }

  var Promise = this;

  return new Promise(function(resolve) {
    resolve(object);
  });
}

exports.cast = cast;
},{}],57:[function(require,module,exports){
"use strict";
var config = {
  instrument: false
};

function configure(name, value) {
  if (arguments.length === 2) {
    config[name] = value;
  } else {
    return config[name];
  }
}

exports.config = config;
exports.configure = configure;
},{}],58:[function(require,module,exports){
(function (global){
"use strict";
/*global self*/
var RSVPPromise = require("./promise").Promise;
var isFunction = require("./utils").isFunction;

function polyfill() {
  var local;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof window !== 'undefined' && window.document) {
    local = window;
  } else {
    local = self;
  }

  var es6PromiseSupport = 
    "Promise" in local &&
    // Some of these methods are missing from
    // Firefox/Chrome experimental implementations
    "cast" in local.Promise &&
    "resolve" in local.Promise &&
    "reject" in local.Promise &&
    "all" in local.Promise &&
    "race" in local.Promise &&
    // Older version of the spec had a resolver object
    // as the arg rather than a function
    (function() {
      var resolve;
      new local.Promise(function(r) { resolve = r; });
      return isFunction(resolve);
    }());

  if (!es6PromiseSupport) {
    local.Promise = RSVPPromise;
  }
}

exports.polyfill = polyfill;
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./promise":59,"./utils":63}],59:[function(require,module,exports){
"use strict";
var config = require("./config").config;
var configure = require("./config").configure;
var objectOrFunction = require("./utils").objectOrFunction;
var isFunction = require("./utils").isFunction;
var now = require("./utils").now;
var cast = require("./cast").cast;
var all = require("./all").all;
var race = require("./race").race;
var staticResolve = require("./resolve").resolve;
var staticReject = require("./reject").reject;
var asap = require("./asap").asap;

var counter = 0;

config.async = asap; // default async is asap;

function Promise(resolver) {
  if (!isFunction(resolver)) {
    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
  }

  if (!(this instanceof Promise)) {
    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
  }

  this._subscribers = [];

  invokeResolver(resolver, this);
}

function invokeResolver(resolver, promise) {
  function resolvePromise(value) {
    resolve(promise, value);
  }

  function rejectPromise(reason) {
    reject(promise, reason);
  }

  try {
    resolver(resolvePromise, rejectPromise);
  } catch(e) {
    rejectPromise(e);
  }
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value, error, succeeded, failed;

  if (hasCallback) {
    try {
      value = callback(detail);
      succeeded = true;
    } catch(e) {
      failed = true;
      error = e;
    }
  } else {
    value = detail;
    succeeded = true;
  }

  if (handleThenable(promise, value)) {
    return;
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (failed) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    resolve(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

var PENDING   = void 0;
var SEALED    = 0;
var FULFILLED = 1;
var REJECTED  = 2;

function subscribe(parent, child, onFulfillment, onRejection) {
  var subscribers = parent._subscribers;
  var length = subscribers.length;

  subscribers[length] = child;
  subscribers[length + FULFILLED] = onFulfillment;
  subscribers[length + REJECTED]  = onRejection;
}

function publish(promise, settled) {
  var child, callback, subscribers = promise._subscribers, detail = promise._detail;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    invokeCallback(settled, child, callback, detail);
  }

  promise._subscribers = null;
}

Promise.prototype = {
  constructor: Promise,

  _state: undefined,
  _detail: undefined,
  _subscribers: undefined,

  then: function(onFulfillment, onRejection) {
    var promise = this;

    var thenPromise = new this.constructor(function() {});

    if (this._state) {
      var callbacks = arguments;
      config.async(function invokePromiseCallback() {
        invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
      });
    } else {
      subscribe(this, thenPromise, onFulfillment, onRejection);
    }

    return thenPromise;
  },

  'catch': function(onRejection) {
    return this.then(null, onRejection);
  }
};

Promise.all = all;
Promise.cast = cast;
Promise.race = race;
Promise.resolve = staticResolve;
Promise.reject = staticReject;

function handleThenable(promise, value) {
  var then = null,
  resolved;

  try {
    if (promise === value) {
      throw new TypeError("A promises callback cannot return that same promise.");
    }

    if (objectOrFunction(value)) {
      then = value.then;

      if (isFunction(then)) {
        then.call(value, function(val) {
          if (resolved) { return true; }
          resolved = true;

          if (value !== val) {
            resolve(promise, val);
          } else {
            fulfill(promise, val);
          }
        }, function(val) {
          if (resolved) { return true; }
          resolved = true;

          reject(promise, val);
        });

        return true;
      }
    }
  } catch (error) {
    if (resolved) { return true; }
    reject(promise, error);
    return true;
  }

  return false;
}

function resolve(promise, value) {
  if (promise === value) {
    fulfill(promise, value);
  } else if (!handleThenable(promise, value)) {
    fulfill(promise, value);
  }
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) { return; }
  promise._state = SEALED;
  promise._detail = value;

  config.async(publishFulfillment, promise);
}

function reject(promise, reason) {
  if (promise._state !== PENDING) { return; }
  promise._state = SEALED;
  promise._detail = reason;

  config.async(publishRejection, promise);
}

function publishFulfillment(promise) {
  publish(promise, promise._state = FULFILLED);
}

function publishRejection(promise) {
  publish(promise, promise._state = REJECTED);
}

exports.Promise = Promise;
},{"./all":54,"./asap":55,"./cast":56,"./config":57,"./race":60,"./reject":61,"./resolve":62,"./utils":63}],60:[function(require,module,exports){
"use strict";
/* global toString */
var isArray = require("./utils").isArray;

/**
  `RSVP.race` allows you to watch a series of promises and act as soon as the
  first promise given to the `promises` argument fulfills or rejects.

  Example:

  ```javascript
  var promise1 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve("promise 1");
    }, 200);
  });

  var promise2 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve("promise 2");
    }, 100);
  });

  RSVP.race([promise1, promise2]).then(function(result){
    // result === "promise 2" because it was resolved before promise1
    // was resolved.
  });
  ```

  `RSVP.race` is deterministic in that only the state of the first completed
  promise matters. For example, even if other promises given to the `promises`
  array argument are resolved, but the first completed promise has become
  rejected before the other promises became fulfilled, the returned promise
  will become rejected:

  ```javascript
  var promise1 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      resolve("promise 1");
    }, 200);
  });

  var promise2 = new RSVP.Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error("promise 2"));
    }, 100);
  });

  RSVP.race([promise1, promise2]).then(function(result){
    // Code here never runs because there are rejected promises!
  }, function(reason){
    // reason.message === "promise2" because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  @method race
  @for RSVP
  @param {Array} promises array of promises to observe
  @param {String} label optional string for describing the promise returned.
  Useful for tooling.
  @return {Promise} a promise that becomes fulfilled with the value the first
  completed promises is resolved with if the first completed promise was
  fulfilled, or rejected with the reason that the first completed promise
  was rejected with.
*/
function race(promises) {
  /*jshint validthis:true */
  var Promise = this;

  if (!isArray(promises)) {
    throw new TypeError('You must pass an array to race.');
  }
  return new Promise(function(resolve, reject) {
    var results = [], promise;

    for (var i = 0; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
  });
}

exports.race = race;
},{"./utils":63}],61:[function(require,module,exports){
"use strict";
/**
  `RSVP.reject` returns a promise that will become rejected with the passed
  `reason`. `RSVP.reject` is essentially shorthand for the following:

  ```javascript
  var promise = new RSVP.Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  var promise = RSVP.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @for RSVP
  @param {Any} reason value that the returned promise will be rejected with.
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise that will become rejected with the given
  `reason`.
*/
function reject(reason) {
  /*jshint validthis:true */
  var Promise = this;

  return new Promise(function (resolve, reject) {
    reject(reason);
  });
}

exports.reject = reject;
},{}],62:[function(require,module,exports){
"use strict";
/**
  `RSVP.resolve` returns a promise that will become fulfilled with the passed
  `value`. `RSVP.resolve` is essentially shorthand for the following:

  ```javascript
  var promise = new RSVP.Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  var promise = RSVP.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @for RSVP
  @param {Any} value value that the returned promise will be resolved with
  @param {String} label optional string for identifying the returned promise.
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve(value) {
  /*jshint validthis:true */
  var Promise = this;
  return new Promise(function(resolve, reject) {
    resolve(value);
  });
}

exports.resolve = resolve;
},{}],63:[function(require,module,exports){
"use strict";
function objectOrFunction(x) {
  return isFunction(x) || (typeof x === "object" && x !== null);
}

function isFunction(x) {
  return typeof x === "function";
}

function isArray(x) {
  return Object.prototype.toString.call(x) === "[object Array]";
}

// Date.now is not available in browsers < IE9
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
var now = Date.now || function() { return new Date().getTime(); };


exports.objectOrFunction = objectOrFunction;
exports.isFunction = isFunction;
exports.isArray = isArray;
exports.now = now;
},{}],64:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],65:[function(require,module,exports){
/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */

// 
// Javascript ZLib
// By Thomas Down 2010-2011
//
// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in
// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.
//
// inflate.js: ZLib inflate code
//

//
// Shared constants
//

var MAX_WBITS=15; // 32K LZ77 window
var DEF_WBITS=MAX_WBITS;
var MAX_MEM_LEVEL=9;
var MANY=1440;
var BMAX = 15;

// preset dictionary flag in zlib header
var PRESET_DICT=0x20;

var Z_NO_FLUSH=0;
var Z_PARTIAL_FLUSH=1;
var Z_SYNC_FLUSH=2;
var Z_FULL_FLUSH=3;
var Z_FINISH=4;

var Z_DEFLATED=8;

var Z_OK=0;
var Z_STREAM_END=1;
var Z_NEED_DICT=2;
var Z_ERRNO=-1;
var Z_STREAM_ERROR=-2;
var Z_DATA_ERROR=-3;
var Z_MEM_ERROR=-4;
var Z_BUF_ERROR=-5;
var Z_VERSION_ERROR=-6;

var METHOD=0;   // waiting for method byte
var FLAG=1;     // waiting for flag byte
var DICT4=2;    // four dictionary check bytes to go
var DICT3=3;    // three dictionary check bytes to go
var DICT2=4;    // two dictionary check bytes to go
var DICT1=5;    // one dictionary check byte to go
var DICT0=6;    // waiting for inflateSetDictionary
var BLOCKS=7;   // decompressing blocks
var CHECK4=8;   // four check bytes to go
var CHECK3=9;   // three check bytes to go
var CHECK2=10;  // two check bytes to go
var CHECK1=11;  // one check byte to go
var DONE=12;    // finished check, done
var BAD=13;     // got an error--stay here

var inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];

var IB_TYPE=0;  // get type bits (3, including end bit)
var IB_LENS=1;  // get lengths for stored
var IB_STORED=2;// processing stored block
var IB_TABLE=3; // get table lengths
var IB_BTREE=4; // get bit lengths tree for a dynamic block
var IB_DTREE=5; // get length, distance trees for a dynamic block
var IB_CODES=6; // processing fixed or dynamic block
var IB_DRY=7;   // output remaining window bytes
var IB_DONE=8;  // finished last block, done
var IB_BAD=9;   // ot a data error--stuck here

var fixed_bl = 9;
var fixed_bd = 5;

var fixed_tl = [
    96,7,256, 0,8,80, 0,8,16, 84,8,115,
    82,7,31, 0,8,112, 0,8,48, 0,9,192,
    80,7,10, 0,8,96, 0,8,32, 0,9,160,
    0,8,0, 0,8,128, 0,8,64, 0,9,224,
    80,7,6, 0,8,88, 0,8,24, 0,9,144,
    83,7,59, 0,8,120, 0,8,56, 0,9,208,
    81,7,17, 0,8,104, 0,8,40, 0,9,176,
    0,8,8, 0,8,136, 0,8,72, 0,9,240,
    80,7,4, 0,8,84, 0,8,20, 85,8,227,
    83,7,43, 0,8,116, 0,8,52, 0,9,200,
    81,7,13, 0,8,100, 0,8,36, 0,9,168,
    0,8,4, 0,8,132, 0,8,68, 0,9,232,
    80,7,8, 0,8,92, 0,8,28, 0,9,152,
    84,7,83, 0,8,124, 0,8,60, 0,9,216,
    82,7,23, 0,8,108, 0,8,44, 0,9,184,
    0,8,12, 0,8,140, 0,8,76, 0,9,248,
    80,7,3, 0,8,82, 0,8,18, 85,8,163,
    83,7,35, 0,8,114, 0,8,50, 0,9,196,
    81,7,11, 0,8,98, 0,8,34, 0,9,164,
    0,8,2, 0,8,130, 0,8,66, 0,9,228,
    80,7,7, 0,8,90, 0,8,26, 0,9,148,
    84,7,67, 0,8,122, 0,8,58, 0,9,212,
    82,7,19, 0,8,106, 0,8,42, 0,9,180,
    0,8,10, 0,8,138, 0,8,74, 0,9,244,
    80,7,5, 0,8,86, 0,8,22, 192,8,0,
    83,7,51, 0,8,118, 0,8,54, 0,9,204,
    81,7,15, 0,8,102, 0,8,38, 0,9,172,
    0,8,6, 0,8,134, 0,8,70, 0,9,236,
    80,7,9, 0,8,94, 0,8,30, 0,9,156,
    84,7,99, 0,8,126, 0,8,62, 0,9,220,
    82,7,27, 0,8,110, 0,8,46, 0,9,188,
    0,8,14, 0,8,142, 0,8,78, 0,9,252,
    96,7,256, 0,8,81, 0,8,17, 85,8,131,
    82,7,31, 0,8,113, 0,8,49, 0,9,194,
    80,7,10, 0,8,97, 0,8,33, 0,9,162,
    0,8,1, 0,8,129, 0,8,65, 0,9,226,
    80,7,6, 0,8,89, 0,8,25, 0,9,146,
    83,7,59, 0,8,121, 0,8,57, 0,9,210,
    81,7,17, 0,8,105, 0,8,41, 0,9,178,
    0,8,9, 0,8,137, 0,8,73, 0,9,242,
    80,7,4, 0,8,85, 0,8,21, 80,8,258,
    83,7,43, 0,8,117, 0,8,53, 0,9,202,
    81,7,13, 0,8,101, 0,8,37, 0,9,170,
    0,8,5, 0,8,133, 0,8,69, 0,9,234,
    80,7,8, 0,8,93, 0,8,29, 0,9,154,
    84,7,83, 0,8,125, 0,8,61, 0,9,218,
    82,7,23, 0,8,109, 0,8,45, 0,9,186,
    0,8,13, 0,8,141, 0,8,77, 0,9,250,
    80,7,3, 0,8,83, 0,8,19, 85,8,195,
    83,7,35, 0,8,115, 0,8,51, 0,9,198,
    81,7,11, 0,8,99, 0,8,35, 0,9,166,
    0,8,3, 0,8,131, 0,8,67, 0,9,230,
    80,7,7, 0,8,91, 0,8,27, 0,9,150,
    84,7,67, 0,8,123, 0,8,59, 0,9,214,
    82,7,19, 0,8,107, 0,8,43, 0,9,182,
    0,8,11, 0,8,139, 0,8,75, 0,9,246,
    80,7,5, 0,8,87, 0,8,23, 192,8,0,
    83,7,51, 0,8,119, 0,8,55, 0,9,206,
    81,7,15, 0,8,103, 0,8,39, 0,9,174,
    0,8,7, 0,8,135, 0,8,71, 0,9,238,
    80,7,9, 0,8,95, 0,8,31, 0,9,158,
    84,7,99, 0,8,127, 0,8,63, 0,9,222,
    82,7,27, 0,8,111, 0,8,47, 0,9,190,
    0,8,15, 0,8,143, 0,8,79, 0,9,254,
    96,7,256, 0,8,80, 0,8,16, 84,8,115,
    82,7,31, 0,8,112, 0,8,48, 0,9,193,

    80,7,10, 0,8,96, 0,8,32, 0,9,161,
    0,8,0, 0,8,128, 0,8,64, 0,9,225,
    80,7,6, 0,8,88, 0,8,24, 0,9,145,
    83,7,59, 0,8,120, 0,8,56, 0,9,209,
    81,7,17, 0,8,104, 0,8,40, 0,9,177,
    0,8,8, 0,8,136, 0,8,72, 0,9,241,
    80,7,4, 0,8,84, 0,8,20, 85,8,227,
    83,7,43, 0,8,116, 0,8,52, 0,9,201,
    81,7,13, 0,8,100, 0,8,36, 0,9,169,
    0,8,4, 0,8,132, 0,8,68, 0,9,233,
    80,7,8, 0,8,92, 0,8,28, 0,9,153,
    84,7,83, 0,8,124, 0,8,60, 0,9,217,
    82,7,23, 0,8,108, 0,8,44, 0,9,185,
    0,8,12, 0,8,140, 0,8,76, 0,9,249,
    80,7,3, 0,8,82, 0,8,18, 85,8,163,
    83,7,35, 0,8,114, 0,8,50, 0,9,197,
    81,7,11, 0,8,98, 0,8,34, 0,9,165,
    0,8,2, 0,8,130, 0,8,66, 0,9,229,
    80,7,7, 0,8,90, 0,8,26, 0,9,149,
    84,7,67, 0,8,122, 0,8,58, 0,9,213,
    82,7,19, 0,8,106, 0,8,42, 0,9,181,
    0,8,10, 0,8,138, 0,8,74, 0,9,245,
    80,7,5, 0,8,86, 0,8,22, 192,8,0,
    83,7,51, 0,8,118, 0,8,54, 0,9,205,
    81,7,15, 0,8,102, 0,8,38, 0,9,173,
    0,8,6, 0,8,134, 0,8,70, 0,9,237,
    80,7,9, 0,8,94, 0,8,30, 0,9,157,
    84,7,99, 0,8,126, 0,8,62, 0,9,221,
    82,7,27, 0,8,110, 0,8,46, 0,9,189,
    0,8,14, 0,8,142, 0,8,78, 0,9,253,
    96,7,256, 0,8,81, 0,8,17, 85,8,131,
    82,7,31, 0,8,113, 0,8,49, 0,9,195,
    80,7,10, 0,8,97, 0,8,33, 0,9,163,
    0,8,1, 0,8,129, 0,8,65, 0,9,227,
    80,7,6, 0,8,89, 0,8,25, 0,9,147,
    83,7,59, 0,8,121, 0,8,57, 0,9,211,
    81,7,17, 0,8,105, 0,8,41, 0,9,179,
    0,8,9, 0,8,137, 0,8,73, 0,9,243,
    80,7,4, 0,8,85, 0,8,21, 80,8,258,
    83,7,43, 0,8,117, 0,8,53, 0,9,203,
    81,7,13, 0,8,101, 0,8,37, 0,9,171,
    0,8,5, 0,8,133, 0,8,69, 0,9,235,
    80,7,8, 0,8,93, 0,8,29, 0,9,155,
    84,7,83, 0,8,125, 0,8,61, 0,9,219,
    82,7,23, 0,8,109, 0,8,45, 0,9,187,
    0,8,13, 0,8,141, 0,8,77, 0,9,251,
    80,7,3, 0,8,83, 0,8,19, 85,8,195,
    83,7,35, 0,8,115, 0,8,51, 0,9,199,
    81,7,11, 0,8,99, 0,8,35, 0,9,167,
    0,8,3, 0,8,131, 0,8,67, 0,9,231,
    80,7,7, 0,8,91, 0,8,27, 0,9,151,
    84,7,67, 0,8,123, 0,8,59, 0,9,215,
    82,7,19, 0,8,107, 0,8,43, 0,9,183,
    0,8,11, 0,8,139, 0,8,75, 0,9,247,
    80,7,5, 0,8,87, 0,8,23, 192,8,0,
    83,7,51, 0,8,119, 0,8,55, 0,9,207,
    81,7,15, 0,8,103, 0,8,39, 0,9,175,
    0,8,7, 0,8,135, 0,8,71, 0,9,239,
    80,7,9, 0,8,95, 0,8,31, 0,9,159,
    84,7,99, 0,8,127, 0,8,63, 0,9,223,
    82,7,27, 0,8,111, 0,8,47, 0,9,191,
    0,8,15, 0,8,143, 0,8,79, 0,9,255
];
var fixed_td = [
    80,5,1, 87,5,257, 83,5,17, 91,5,4097,
    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,
    80,5,3, 88,5,513, 84,5,33, 92,5,8193,
    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,
    80,5,2, 87,5,385, 83,5,25, 91,5,6145,
    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,
    80,5,4, 88,5,769, 84,5,49, 92,5,12289,
    82,5,13, 90,5,3073, 86,5,193, 192,5,24577
];

  // Tables for deflate from PKZIP's appnote.txt.
  var cplens = [ // Copy lengths for literal codes 257..285
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
  ];

  // see note #13 above about 258
  var cplext = [ // Extra bits for literal codes 257..285
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid
  ];

 var cpdist = [ // Copy offsets for distance codes 0..29
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577
  ];

  var cpdext = [ // Extra bits for distance codes
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13];

//
// ZStream.java
//

function ZStream() {
}


ZStream.prototype.inflateInit = function(w, nowrap) {
    if (!w) {
	w = DEF_WBITS;
    }
    if (nowrap) {
	nowrap = false;
    }
    this.istate = new Inflate();
    return this.istate.inflateInit(this, nowrap?-w:w);
}

ZStream.prototype.inflate = function(f) {
    if(this.istate==null) return Z_STREAM_ERROR;
    return this.istate.inflate(this, f);
}

ZStream.prototype.inflateEnd = function(){
    if(this.istate==null) return Z_STREAM_ERROR;
    var ret=istate.inflateEnd(this);
    this.istate = null;
    return ret;
}
ZStream.prototype.inflateSync = function(){
    // if(istate == null) return Z_STREAM_ERROR;
    return istate.inflateSync(this);
}
ZStream.prototype.inflateSetDictionary = function(dictionary, dictLength){
    // if(istate == null) return Z_STREAM_ERROR;
    return istate.inflateSetDictionary(this, dictionary, dictLength);
}

/*

  public int deflateInit(int level){
    return deflateInit(level, MAX_WBITS);
  }
  public int deflateInit(int level, boolean nowrap){
    return deflateInit(level, MAX_WBITS, nowrap);
  }
  public int deflateInit(int level, int bits){
    return deflateInit(level, bits, false);
  }
  public int deflateInit(int level, int bits, boolean nowrap){
    dstate=new Deflate();
    return dstate.deflateInit(this, level, nowrap?-bits:bits);
  }
  public int deflate(int flush){
    if(dstate==null){
      return Z_STREAM_ERROR;
    }
    return dstate.deflate(this, flush);
  }
  public int deflateEnd(){
    if(dstate==null) return Z_STREAM_ERROR;
    int ret=dstate.deflateEnd();
    dstate=null;
    return ret;
  }
  public int deflateParams(int level, int strategy){
    if(dstate==null) return Z_STREAM_ERROR;
    return dstate.deflateParams(this, level, strategy);
  }
  public int deflateSetDictionary (byte[] dictionary, int dictLength){
    if(dstate == null)
      return Z_STREAM_ERROR;
    return dstate.deflateSetDictionary(this, dictionary, dictLength);
  }

*/

/*
  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  void flush_pending(){
    int len=dstate.pending;

    if(len>avail_out) len=avail_out;
    if(len==0) return;

    if(dstate.pending_buf.length<=dstate.pending_out ||
       next_out.length<=next_out_index ||
       dstate.pending_buf.length<(dstate.pending_out+len) ||
       next_out.length<(next_out_index+len)){
      System.out.println(dstate.pending_buf.length+", "+dstate.pending_out+
			 ", "+next_out.length+", "+next_out_index+", "+len);
      System.out.println("avail_out="+avail_out);
    }

    System.arraycopy(dstate.pending_buf, dstate.pending_out,
		     next_out, next_out_index, len);

    next_out_index+=len;
    dstate.pending_out+=len;
    total_out+=len;
    avail_out-=len;
    dstate.pending-=len;
    if(dstate.pending==0){
      dstate.pending_out=0;
    }
  }

  // Read a new buffer from the current input stream, update the adler32
  // and total number of bytes read.  All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  int read_buf(byte[] buf, int start, int size) {
    int len=avail_in;

    if(len>size) len=size;
    if(len==0) return 0;

    avail_in-=len;

    if(dstate.noheader==0) {
      adler=_adler.adler32(adler, next_in, next_in_index, len);
    }
    System.arraycopy(next_in, next_in_index, buf, start, len);
    next_in_index  += len;
    total_in += len;
    return len;
  }

  public void free(){
    next_in=null;
    next_out=null;
    msg=null;
    _adler=null;
  }
}
*/


//
// Inflate.java
//

function Inflate() {
    this.was = [0];
}

Inflate.prototype.inflateReset = function(z) {
    if(z == null || z.istate == null) return Z_STREAM_ERROR;
    
    z.total_in = z.total_out = 0;
    z.msg = null;
    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;
    z.istate.blocks.reset(z, null);
    return Z_OK;
}

Inflate.prototype.inflateEnd = function(z){
    if(this.blocks != null)
      this.blocks.free(z);
    this.blocks=null;
    return Z_OK;
}

Inflate.prototype.inflateInit = function(z, w){
    z.msg = null;
    this.blocks = null;

    // handle undocumented nowrap option (no zlib header or check)
    nowrap = 0;
    if(w < 0){
      w = - w;
      nowrap = 1;
    }

    // set window size
    if(w<8 ||w>15){
      this.inflateEnd(z);
      return Z_STREAM_ERROR;
    }
    this.wbits=w;

    z.istate.blocks=new InfBlocks(z, 
				  z.istate.nowrap!=0 ? null : this,
				  1<<w);

    // reset state
    this.inflateReset(z);
    return Z_OK;
  }

Inflate.prototype.inflate = function(z, f){
    var r, b;

    if(z == null || z.istate == null || z.next_in == null)
      return Z_STREAM_ERROR;
    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
    r = Z_BUF_ERROR;
    while (true){
      switch (z.istate.mode){
      case METHOD:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){
          z.istate.mode = BAD;
          z.msg="unknown compression method";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }
        if((z.istate.method>>4)+8>z.istate.wbits){
          z.istate.mode = BAD;
          z.msg="invalid window size";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }
        z.istate.mode=FLAG;
      case FLAG:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        b = (z.next_in[z.next_in_index++])&0xff;

        if((((z.istate.method << 8)+b) % 31)!=0){
          z.istate.mode = BAD;
          z.msg = "incorrect header check";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }

        if((b&PRESET_DICT)==0){
          z.istate.mode = BLOCKS;
          break;
        }
        z.istate.mode = DICT4;
      case DICT4:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;
        z.istate.mode=DICT3;
      case DICT3:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;
        z.istate.mode=DICT2;
      case DICT2:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;
        z.istate.mode=DICT1;
      case DICT1:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need += (z.next_in[z.next_in_index++]&0xff);
        z.adler = z.istate.need;
        z.istate.mode = DICT0;
        return Z_NEED_DICT;
      case DICT0:
        z.istate.mode = BAD;
        z.msg = "need dictionary";
        z.istate.marker = 0;       // can try inflateSync
        return Z_STREAM_ERROR;
      case BLOCKS:

        r = z.istate.blocks.proc(z, r);
        if(r == Z_DATA_ERROR){
          z.istate.mode = BAD;
          z.istate.marker = 0;     // can try inflateSync
          break;
        }
        if(r == Z_OK){
          r = f;
        }
        if(r != Z_STREAM_END){
          return r;
        }
        r = f;
        z.istate.blocks.reset(z, z.istate.was);
        if(z.istate.nowrap!=0){
          z.istate.mode=DONE;
          break;
        }
        z.istate.mode=CHECK4;
      case CHECK4:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;
        z.istate.mode=CHECK3;
      case CHECK3:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;
        z.istate.mode = CHECK2;
      case CHECK2:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;
        z.istate.mode = CHECK1;
      case CHECK1:

        if(z.avail_in==0)return r;r=f;

        z.avail_in--; z.total_in++;
        z.istate.need+=(z.next_in[z.next_in_index++]&0xff);

        if(((z.istate.was[0])) != ((z.istate.need))){
          z.istate.mode = BAD;
          z.msg = "incorrect data check";
          z.istate.marker = 5;       // can't try inflateSync
          break;
        }

        z.istate.mode = DONE;
      case DONE:
        return Z_STREAM_END;
      case BAD:
        return Z_DATA_ERROR;
      default:
        return Z_STREAM_ERROR;
      }
    }
  }


Inflate.prototype.inflateSetDictionary = function(z,  dictionary, dictLength) {
    var index=0;
    var length = dictLength;
    if(z==null || z.istate == null|| z.istate.mode != DICT0)
      return Z_STREAM_ERROR;

    if(z._adler.adler32(1, dictionary, 0, dictLength)!=z.adler){
      return Z_DATA_ERROR;
    }

    z.adler = z._adler.adler32(0, null, 0, 0);

    if(length >= (1<<z.istate.wbits)){
      length = (1<<z.istate.wbits)-1;
      index=dictLength - length;
    }
    z.istate.blocks.set_dictionary(dictionary, index, length);
    z.istate.mode = BLOCKS;
    return Z_OK;
  }

//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};
var mark = [0, 0, 255, 255]

Inflate.prototype.inflateSync = function(z){
    var n;       // number of bytes to look at
    var p;       // pointer to bytes
    var m;       // number of marker bytes found in a row
    var r, w;   // temporaries to save total_in and total_out

    // set up
    if(z == null || z.istate == null)
      return Z_STREAM_ERROR;
    if(z.istate.mode != BAD){
      z.istate.mode = BAD;
      z.istate.marker = 0;
    }
    if((n=z.avail_in)==0)
      return Z_BUF_ERROR;
    p=z.next_in_index;
    m=z.istate.marker;

    // search
    while (n!=0 && m < 4){
      if(z.next_in[p] == mark[m]){
        m++;
      }
      else if(z.next_in[p]!=0){
        m = 0;
      }
      else{
        m = 4 - m;
      }
      p++; n--;
    }

    // restore
    z.total_in += p-z.next_in_index;
    z.next_in_index = p;
    z.avail_in = n;
    z.istate.marker = m;

    // return no joy or set up to restart on a new block
    if(m != 4){
      return Z_DATA_ERROR;
    }
    r=z.total_in;  w=z.total_out;
    this.inflateReset(z);
    z.total_in=r;  z.total_out = w;
    z.istate.mode = BLOCKS;
    return Z_OK;
}

  // Returns true if inflate is currently at the end of a block generated
  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
  // but removes the length bytes of the resulting empty stored block. When
  // decompressing, PPP checks that at the end of input packet, inflate is
  // waiting for these length bytes.
Inflate.prototype.inflateSyncPoint = function(z){
    if(z == null || z.istate == null || z.istate.blocks == null)
      return Z_STREAM_ERROR;
    return z.istate.blocks.sync_point();
}


//
// InfBlocks.java
//

var INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

function InfBlocks(z, checkfn, w) {
    this.hufts=new Int32Array(MANY*3);
    this.window=new Uint8Array(w);
    this.end=w;
    this.checkfn = checkfn;
    this.mode = IB_TYPE;
    this.reset(z, null);

    this.left = 0;            // if STORED, bytes left to copy 

    this.table = 0;           // table lengths (14 bits) 
    this.index = 0;           // index into blens (or border) 
    this.blens = null;         // bit lengths of codes 
    this.bb=new Int32Array(1); // bit length tree depth 
    this.tb=new Int32Array(1); // bit length decoding tree 

    this.codes = new InfCodes();

    this.last = 0;            // true if this block is the last block 

  // mode independent information 
    this.bitk = 0;            // bits in bit buffer 
    this.bitb = 0;            // bit buffer 
    this.read = 0;            // window read pointer 
    this.write = 0;           // window write pointer 
    this.check = 0;          // check on output 

    this.inftree=new InfTree();
}




InfBlocks.prototype.reset = function(z, c){
    if(c) c[0]=this.check;
    if(this.mode==IB_CODES){
      this.codes.free(z);
    }
    this.mode=IB_TYPE;
    this.bitk=0;
    this.bitb=0;
    this.read=this.write=0;

    if(this.checkfn)
      z.adler=this.check=z._adler.adler32(0, null, 0, 0);
  }

 InfBlocks.prototype.proc = function(z, r){
    var t;              // temporary storage
    var b;              // bit buffer
    var k;              // bits in bit buffer
    var p;              // input data pointer
    var n;              // bytes available there
    var q;              // output window write pointer
    var m;              // bytes to end of window or read pointer

    // copy input/output information to locals (UPDATE macro restores)
    {p=z.next_in_index;n=z.avail_in;b=this.bitb;k=this.bitk;}
    {q=this.write;m=(q<this.read ? this.read-q-1 : this.end-q);}

    // process input based on current state
    while(true){
      switch (this.mode){
      case IB_TYPE:

	while(k<(3)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}
	t = (b & 7);
	this.last = t & 1;

	switch (t >>> 1){
        case 0:                         // stored 
          {b>>>=(3);k-=(3);}
          t = k & 7;                    // go to byte boundary

          {b>>>=(t);k-=(t);}
          this.mode = IB_LENS;                  // get length of stored block
          break;
        case 1:                         // fixed
          {
              var bl=new Int32Array(1);
	      var bd=new Int32Array(1);
              var tl=[];
	      var td=[];

	      inflate_trees_fixed(bl, bd, tl, td, z);
              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);
          }

          {b>>>=(3);k-=(3);}

          this.mode = IB_CODES;
          break;
        case 2:                         // dynamic

          {b>>>=(3);k-=(3);}

          this.mode = IB_TABLE;
          break;
        case 3:                         // illegal

          {b>>>=(3);k-=(3);}
          this.mode = BAD;
          z.msg = "invalid block type";
          r = Z_DATA_ERROR;

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z,r);
	}
	break;
      case IB_LENS:
	while(k<(32)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	if ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){
	  this.mode = BAD;
	  z.msg = "invalid stored block lengths";
	  r = Z_DATA_ERROR;

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z,r);
	}
	this.left = (b & 0xffff);
	b = k = 0;                       // dump bits
	this.mode = this.left!=0 ? IB_STORED : (this.last!=0 ? IB_DRY : IB_TYPE);
	break;
      case IB_STORED:
	if (n == 0){
	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return this.inflate_flush(z,r);
	}

	if(m==0){
	  if(q==end&&read!=0){
	    q=0; m=(q<this.read ? this.read-q-1 : this.end-q);
	  }
	  if(m==0){
	    this.write=q; 
	    r=this.inflate_flush(z,r);
	    q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);
	    if(q==this.end && this.read != 0){
	      q=0; m = (q < this.read ? this.read-q-1 : this.end-q);
	    }
	    if(m==0){
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    }
	  }
	}
	r=Z_OK;

	t = this.left;
	if(t>n) t = n;
	if(t>m) t = m;
	arrayCopy(z.next_in, p, this.window, q, t);
	p += t;  n -= t;
	q += t;  m -= t;
	if ((this.left -= t) != 0)
	  break;
	this.mode = (this.last != 0 ? IB_DRY : IB_TYPE);
	break;
      case IB_TABLE:

	while(k<(14)){
	  if(n!=0){
	    r=Z_OK;
	  }
	  else{
	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;
	    z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  };
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.table = t = (b & 0x3fff);
	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
	  {
	    this.mode = IB_BAD;
	    z.msg = "too many length or distance symbols";
	    r = Z_DATA_ERROR;

	    this.bitb=b; this.bitk=k; 
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    this.write=q;
	    return this.inflate_flush(z,r);
	  }
	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
	if(this.blens==null || this.blens.length<t){
	    this.blens=new Int32Array(t);
	}
	else{
	  for(var i=0; i<t; i++){
              this.blens[i]=0;
          }
	}

	{b>>>=(14);k-=(14);}

	this.index = 0;
	mode = IB_BTREE;
      case IB_BTREE:
	while (this.index < 4 + (this.table >>> 10)){
	  while(k<(3)){
	    if(n!=0){
	      r=Z_OK;
	    }
	    else{
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;
	      z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    };
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;
	    k+=8;
	  }

	  this.blens[INFBLOCKS_BORDER[this.index++]] = b&7;

	  {b>>>=(3);k-=(3);}
	}

	while(this.index < 19){
	  this.blens[INFBLOCKS_BORDER[this.index++]] = 0;
	}

	this.bb[0] = 7;
	t = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);
	if (t != Z_OK){
	  r = t;
	  if (r == Z_DATA_ERROR){
	    this.blens=null;
	    this.mode = IB_BAD;
	  }

	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  write=q;
	  return this.inflate_flush(z,r);
	}

	this.index = 0;
	this.mode = IB_DTREE;
      case IB_DTREE:
	while (true){
	  t = this.table;
	  if(!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){
	    break;
	  }

	  var h; //int[]
	  var i, j, c;

	  t = this.bb[0];

	  while(k<(t)){
	    if(n!=0){
	      r=Z_OK;
	    }
	    else{
	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;
	      z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    };
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;
	    k+=8;
	  }

//	  if (this.tb[0]==-1){
//            dlog("null...");
//	  }

	  t=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+1];
	  c=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+2];

	  if (c < 16){
	    b>>>=(t);k-=(t);
	    this.blens[this.index++] = c;
	  }
	  else { // c == 16..18
	    i = c == 18 ? 7 : c - 14;
	    j = c == 18 ? 11 : 3;

	    while(k<(t+i)){
	      if(n!=0){
		r=Z_OK;
	      }
	      else{
		this.bitb=b; this.bitk=k; 
		z.avail_in=n;
		z.total_in+=p-z.next_in_index;z.next_in_index=p;
		this.write=q;
		return this.inflate_flush(z,r);
	      };
	      n--;
	      b|=(z.next_in[p++]&0xff)<<k;
	      k+=8;
	    }

	    b>>>=(t);k-=(t);

	    j += (b & inflate_mask[i]);

	    b>>>=(i);k-=(i);

	    i = this.index;
	    t = this.table;
	    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
		(c == 16 && i < 1)){
	      this.blens=null;
	      this.mode = IB_BAD;
	      z.msg = "invalid bit length repeat";
	      r = Z_DATA_ERROR;

	      this.bitb=b; this.bitk=k; 
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      this.write=q;
	      return this.inflate_flush(z,r);
	    }

	    c = c == 16 ? this.blens[i-1] : 0;
	    do{
	      this.blens[i++] = c;
	    }
	    while (--j!=0);
	    this.index = i;
	  }
	}

	this.tb[0]=-1;
	{
	    var bl=new Int32Array(1);
	    var bd=new Int32Array(1);
	    var tl=new Int32Array(1);
	    var td=new Int32Array(1);
	    bl[0] = 9;         // must be <= 9 for lookahead assumptions
	    bd[0] = 6;         // must be <= 9 for lookahead assumptions

	    t = this.table;
	    t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), 
					      1 + ((t >> 5) & 0x1f),
					      this.blens, bl, bd, tl, td, this.hufts, z);

	    if (t != Z_OK){
	        if (t == Z_DATA_ERROR){
	            this.blens=null;
	            this.mode = BAD;
	        }
	        r = t;

	        this.bitb=b; this.bitk=k; 
	        z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	        this.write=q;
	        return this.inflate_flush(z,r);
	    }
	    this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);
	}
	this.mode = IB_CODES;
      case IB_CODES:
	this.bitb=b; this.bitk=k;
	z.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;

	if ((r = this.codes.proc(this, z, r)) != Z_STREAM_END){
	  return this.inflate_flush(z, r);
	}
	r = Z_OK;
	this.codes.free(z);

	p=z.next_in_index; n=z.avail_in;b=this.bitb;k=this.bitk;
	q=this.write;m = (q < this.read ? this.read-q-1 : this.end-q);

	if (this.last==0){
	  this.mode = IB_TYPE;
	  break;
	}
	this.mode = IB_DRY;
      case IB_DRY:
	this.write=q; 
	r = this.inflate_flush(z, r); 
	q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);
	if (this.read != this.write){
	  this.bitb=b; this.bitk=k; 
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  this.write=q;
	  return this.inflate_flush(z, r);
	}
	mode = DONE;
      case IB_DONE:
	r = Z_STREAM_END;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);
      case IB_BAD:
	r = Z_DATA_ERROR;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);

      default:
	r = Z_STREAM_ERROR;

	this.bitb=b; this.bitk=k; 
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	this.write=q;
	return this.inflate_flush(z, r);
      }
    }
  }

InfBlocks.prototype.free = function(z){
    this.reset(z, null);
    this.window=null;
    this.hufts=null;
}

InfBlocks.prototype.set_dictionary = function(d, start, n){
    arrayCopy(d, start, window, 0, n);
    this.read = this.write = n;
}

  // Returns true if inflate is currently at the end of a block generated
  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
InfBlocks.prototype.sync_point = function(){
    return this.mode == IB_LENS;
}

  // copy as much as possible from the sliding window to the output area
InfBlocks.prototype.inflate_flush = function(z, r){
    var n;
    var p;
    var q;

    // local copies of source and destination pointers
    p = z.next_out_index;
    q = this.read;

    // compute number of bytes to copy as far as end of window
    n = ((q <= this.write ? this.write : this.end) - q);
    if (n > z.avail_out) n = z.avail_out;
    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;

    // update counters
    z.avail_out -= n;
    z.total_out += n;

    // update check information
    if(this.checkfn != null)
      z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);

    // copy as far as end of window
    arrayCopy(this.window, q, z.next_out, p, n);
    p += n;
    q += n;

    // see if more to copy at beginning of window
    if (q == this.end){
      // wrap pointers
      q = 0;
      if (this.write == this.end)
        this.write = 0;

      // compute bytes to copy
      n = this.write - q;
      if (n > z.avail_out) n = z.avail_out;
      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;

      // update counters
      z.avail_out -= n;
      z.total_out += n;

      // update check information
      if(this.checkfn != null)
	z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);

      // copy
      arrayCopy(this.window, q, z.next_out, p, n);
      p += n;
      q += n;
    }

    // update pointers
    z.next_out_index = p;
    this.read = q;

    // done
    return r;
  }

//
// InfCodes.java
//

var IC_START=0;  // x: set up for LEN
var IC_LEN=1;    // i: get length/literal/eob next
var IC_LENEXT=2; // i: getting length extra (have base)
var IC_DIST=3;   // i: get distance next
var IC_DISTEXT=4;// i: getting distance extra
var IC_COPY=5;   // o: copying bytes in window, waiting for space
var IC_LIT=6;    // o: got literal, waiting for output space
var IC_WASH=7;   // o: got eob, possibly still output waiting
var IC_END=8;    // x: got eob and all data flushed
var IC_BADCODE=9;// x: got error

function InfCodes() {
}

InfCodes.prototype.init = function(bl, bd, tl, tl_index, td, td_index, z) {
    this.mode=IC_START;
    this.lbits=bl;
    this.dbits=bd;
    this.ltree=tl;
    this.ltree_index=tl_index;
    this.dtree = td;
    this.dtree_index=td_index;
    this.tree=null;
}

InfCodes.prototype.proc = function(s, z, r){ 
    var j;              // temporary storage
    var t;              // temporary pointer (int[])
    var tindex;         // temporary pointer
    var e;              // extra bits or operation
    var b=0;            // bit buffer
    var k=0;            // bits in bit buffer
    var p=0;            // input data pointer
    var n;              // bytes available there
    var q;              // output window write pointer
    var m;              // bytes to end of window or read pointer
    var f;              // pointer to copy strings from

    // copy input/output information to locals (UPDATE macro restores)
    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

    // process input and output based on current state
    while (true){
      switch (this.mode){
	// waiting for "i:"=input, "o:"=output, "x:"=nothing
      case IC_START:         // x: set up for LEN
	if (m >= 258 && n >= 10){

	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;
	  r = this.inflate_fast(this.lbits, this.dbits, 
			   this.ltree, this.ltree_index, 
			   this.dtree, this.dtree_index,
			   s, z);

	  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
	  q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	  if (r != Z_OK){
	    this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;
	    break;
	  }
	}
	this.need = this.lbits;
	this.tree = this.ltree;
	this.tree_index=this.ltree_index;

	this.mode = IC_LEN;
      case IC_LEN:           // i: get length/literal/eob next
	j = this.need;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--;
	  b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	tindex=(this.tree_index+(b&inflate_mask[j]))*3;

	b>>>=(this.tree[tindex+1]);
	k-=(this.tree[tindex+1]);

	e=this.tree[tindex];

	if(e == 0){               // literal
	  this.lit = this.tree[tindex+2];
	  this.mode = IC_LIT;
	  break;
	}
	if((e & 16)!=0 ){          // length
	  this.get = e & 15;
	  this.len = this.tree[tindex+2];
	  this.mode = IC_LENEXT;
	  break;
	}
	if ((e & 64) == 0){        // next table
	  this.need = e;
	  this.tree_index = tindex/3 + this.tree[tindex+2];
	  break;
	}
	if ((e & 32)!=0){               // end of block
	  this.mode = IC_WASH;
	  break;
	}
	this.mode = IC_BADCODE;        // invalid code
	z.msg = "invalid literal/length code";
	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_LENEXT:        // i: getting length extra (have base)
	j = this.get;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.len += (b & inflate_mask[j]);

	b>>=j;
	k-=j;

	this.need = this.dbits;
	this.tree = this.dtree;
	this.tree_index = this.dtree_index;
	this.mode = IC_DIST;
      case IC_DIST:          // i: get distance next
	j = this.need;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	tindex=(this.tree_index+(b & inflate_mask[j]))*3;

	b>>=this.tree[tindex+1];
	k-=this.tree[tindex+1];

	e = (this.tree[tindex]);
	if((e & 16)!=0){               // distance
	  this.get = e & 15;
	  this.dist = this.tree[tindex+2];
	  this.mode = IC_DISTEXT;
	  break;
	}
	if ((e & 64) == 0){        // next table
	  this.need = e;
	  this.tree_index = tindex/3 + this.tree[tindex+2];
	  break;
	}
	this.mode = IC_BADCODE;        // invalid code
	z.msg = "invalid distance code";
	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_DISTEXT:       // i: getting distance extra
	j = this.get;

	while(k<(j)){
	  if(n!=0)r=Z_OK;
	  else{

	    s.bitb=b;s.bitk=k;
	    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	    s.write=q;
	    return s.inflate_flush(z,r);
	  }
	  n--; b|=(z.next_in[p++]&0xff)<<k;
	  k+=8;
	}

	this.dist += (b & inflate_mask[j]);

	b>>=j;
	k-=j;

	this.mode = IC_COPY;
      case IC_COPY:          // o: copying bytes in window, waiting for space
        f = q - this.dist;
        while(f < 0){     // modulo window size-"while" instead
          f += s.end;     // of "if" handles invalid distances
	}
	while (this.len!=0){

	  if(m==0){
	    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	    if(m==0){
	      s.write=q; r=s.inflate_flush(z,r);
	      q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}

	      if(m==0){
		s.bitb=b;s.bitk=k;
		z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
		s.write=q;
		return s.inflate_flush(z,r);
	      }  
	    }
	  }

	  s.window[q++]=s.window[f++]; m--;

	  if (f == s.end)
            f = 0;
	  this.len--;
	}
	this.mode = IC_START;
	break;
      case IC_LIT:           // o: got literal, waiting for output space
	if(m==0){
	  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	  if(m==0){
	    s.write=q; r=s.inflate_flush(z,r);
	    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}
	    if(m==0){
	      s.bitb=b;s.bitk=k;
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      s.write=q;
	      return s.inflate_flush(z,r);
	    }
	  }
	}
	r=Z_OK;

	s.window[q++]=this.lit; m--;

	this.mode = IC_START;
	break;
      case IC_WASH:           // o: got eob, possibly more output
	if (k > 7){        // return unused byte, if any
	  k -= 8;
	  n++;
	  p--;             // can always return one
	}

	s.write=q; r=s.inflate_flush(z,r);
	q=s.write;m=q<s.read?s.read-q-1:s.end-q;

	if (s.read != s.write){
	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;
	  return s.inflate_flush(z,r);
	}
	this.mode = IC_END;
      case IC_END:
	r = Z_STREAM_END;
	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      case IC_BADCODE:       // x: got error

	r = Z_DATA_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);

      default:
	r = Z_STREAM_ERROR;

	s.bitb=b;s.bitk=k;
	z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	s.write=q;
	return s.inflate_flush(z,r);
      }
    }
  }

InfCodes.prototype.free = function(z){
    //  ZFREE(z, c);
}

  // Called with number of bytes left to write in window at least 258
  // (the maximum string length) and number of input bytes available
  // at least ten.  The ten bytes are six bytes for the longest length/
  // distance pair plus four bytes for overloading the bit buffer.

InfCodes.prototype.inflate_fast = function(bl, bd, tl, tl_index, td, td_index, s, z) {
    var t;                // temporary pointer
    var   tp;             // temporary pointer (int[])
    var tp_index;         // temporary pointer
    var e;                // extra bits or operation
    var b;                // bit buffer
    var k;                // bits in bit buffer
    var p;                // input data pointer
    var n;                // bytes available there
    var q;                // output window write pointer
    var m;                // bytes to end of window or read pointer
    var ml;               // mask for literal/length tree
    var md;               // mask for distance tree
    var c;                // bytes to copy
    var d;                // distance back to copy from
    var r;                // copy source pointer

    var tp_index_t_3;     // (tp_index+t)*3

    // load input, output, bit values
    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;
    q=s.write;m=q<s.read?s.read-q-1:s.end-q;

    // initialize masks
    ml = inflate_mask[bl];
    md = inflate_mask[bd];

    // do until not enough input or output space for fast loop
    do {                          // assume called with m >= 258 && n >= 10
      // get literal/length code
      while(k<(20)){              // max bits for literal/length code
	n--;
	b|=(z.next_in[p++]&0xff)<<k;k+=8;
      }

      t= b&ml;
      tp=tl; 
      tp_index=tl_index;
      tp_index_t_3=(tp_index+t)*3;
      if ((e = tp[tp_index_t_3]) == 0){
	b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	s.window[q++] = tp[tp_index_t_3+2];
	m--;
	continue;
      }
      do {

	b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	if((e&16)!=0){
	  e &= 15;
	  c = tp[tp_index_t_3+2] + (b & inflate_mask[e]);

	  b>>=e; k-=e;

	  // decode distance base of block to copy
	  while(k<(15)){           // max bits for distance code
	    n--;
	    b|=(z.next_in[p++]&0xff)<<k;k+=8;
	  }

	  t= b&md;
	  tp=td;
	  tp_index=td_index;
          tp_index_t_3=(tp_index+t)*3;
	  e = tp[tp_index_t_3];

	  do {

	    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	    if((e&16)!=0){
	      // get extra bits to add to distance base
	      e &= 15;
	      while(k<(e)){         // get extra bits (up to 13)
		n--;
		b|=(z.next_in[p++]&0xff)<<k;k+=8;
	      }

	      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);

	      b>>=(e); k-=(e);

	      // do the copy
	      m -= c;
	      if (q >= d){                // offset before dest
		//  just copy
		r=q-d;
		if(q-r>0 && 2>(q-r)){           
		  s.window[q++]=s.window[r++]; // minimum count is three,
		  s.window[q++]=s.window[r++]; // so unroll loop a little
		  c-=2;
		}
		else{
		  s.window[q++]=s.window[r++]; // minimum count is three,
		  s.window[q++]=s.window[r++]; // so unroll loop a little
		  c-=2;
		}
	      }
	      else{                  // else offset after destination
                r=q-d;
                do{
                  r+=s.end;          // force pointer in window
                }while(r<0);         // covers invalid distances
		e=s.end-r;
		if(c>e){             // if source crosses,
		  c-=e;              // wrapped copy
		  if(q-r>0 && e>(q-r)){           
		    do{s.window[q++] = s.window[r++];}
		    while(--e!=0);
		  }
		  else{
		    arrayCopy(s.window, r, s.window, q, e);
		    q+=e; r+=e; e=0;
		  }
		  r = 0;                  // copy rest from start of window
		}

	      }

	      // copy all or what's left
              do{s.window[q++] = s.window[r++];}
		while(--c!=0);
	      break;
	    }
	    else if((e&64)==0){
	      t+=tp[tp_index_t_3+2];
	      t+=(b&inflate_mask[e]);
	      tp_index_t_3=(tp_index+t)*3;
	      e=tp[tp_index_t_3];
	    }
	    else{
	      z.msg = "invalid distance code";

	      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

	      s.bitb=b;s.bitk=k;
	      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	      s.write=q;

	      return Z_DATA_ERROR;
	    }
	  }
	  while(true);
	  break;
	}

	if((e&64)==0){
	  t+=tp[tp_index_t_3+2];
	  t+=(b&inflate_mask[e]);
	  tp_index_t_3=(tp_index+t)*3;
	  if((e=tp[tp_index_t_3])==0){

	    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);

	    s.window[q++]=tp[tp_index_t_3+2];
	    m--;
	    break;
	  }
	}
	else if((e&32)!=0){

	  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;
 
	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;

	  return Z_STREAM_END;
	}
	else{
	  z.msg="invalid literal/length code";

	  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

	  s.bitb=b;s.bitk=k;
	  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
	  s.write=q;

	  return Z_DATA_ERROR;
	}
      } 
      while(true);
    } 
    while(m>=258 && n>= 10);

    // not enough input or output--restore pointers and return
    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;

    s.bitb=b;s.bitk=k;
    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;
    s.write=q;

    return Z_OK;
}

//
// InfTree.java
//

function InfTree() {
}

InfTree.prototype.huft_build = function(b, bindex, n, s, d, e, t, m, hp, hn, v) {

    // Given a list of code lengths and a maximum table size, make a set of
    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
    // if the given code set is incomplete (the tables are still built in this
    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
    // lengths), or Z_MEM_ERROR if not enough memory.

    var a;                       // counter for codes of length k
    var f;                       // i repeats in table every f entries
    var g;                       // maximum code length
    var h;                       // table level
    var i;                       // counter, current code
    var j;                       // counter
    var k;                       // number of bits in current code
    var l;                       // bits per table (returned in m)
    var mask;                    // (1 << w) - 1, to avoid cc -O bug on HP
    var p;                       // pointer into c[], b[], or v[]
    var q;                       // points to current table
    var w;                       // bits before this table == (l * h)
    var xp;                      // pointer into x
    var y;                       // number of dummy codes added
    var z;                       // number of entries in current table

    // Generate counts for each bit length

    p = 0; i = n;
    do {
      this.c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX
    }while(i!=0);

    if(this.c[0] == n){                // null input--all zero length codes
      t[0] = -1;
      m[0] = 0;
      return Z_OK;
    }

    // Find minimum and maximum length, bound *m by those
    l = m[0];
    for (j = 1; j <= BMAX; j++)
      if(this.c[j]!=0) break;
    k = j;                        // minimum code length
    if(l < j){
      l = j;
    }
    for (i = BMAX; i!=0; i--){
      if(this.c[i]!=0) break;
    }
    g = i;                        // maximum code length
    if(l > i){
      l = i;
    }
    m[0] = l;

    // Adjust last length count to fill out codes, if needed
    for (y = 1 << j; j < i; j++, y <<= 1){
      if ((y -= this.c[j]) < 0){
        return Z_DATA_ERROR;
      }
    }
    if ((y -= this.c[i]) < 0){
      return Z_DATA_ERROR;
    }
    this.c[i] += y;

    // Generate starting offsets into the value table for each length
    this.x[1] = j = 0;
    p = 1;  xp = 2;
    while (--i!=0) {                 // note that i == g from above
      this.x[xp] = (j += this.c[p]);
      xp++;
      p++;
    }

    // Make a table of values in order of bit lengths
    i = 0; p = 0;
    do {
      if ((j = b[bindex+p]) != 0){
        this.v[this.x[j]++] = i;
      }
      p++;
    }
    while (++i < n);
    n = this.x[g];                     // set n to length of v

    // Generate the Huffman codes and for each, make the table entries
    this.x[0] = i = 0;                 // first Huffman code is zero
    p = 0;                        // grab values in bit order
    h = -1;                       // no tables yet--level -1
    w = -l;                       // bits decoded == (l * h)
    this.u[0] = 0;                     // just to keep compilers happy
    q = 0;                        // ditto
    z = 0;                        // ditto

    // go through the bit lengths (k already is bits in shortest code)
    for (; k <= g; k++){
      a = this.c[k];
      while (a--!=0){
	// here i is the Huffman code of length k bits for value *p
	// make tables up to required level
        while (k > w + l){
          h++;
          w += l;                 // previous table always l bits
	  // compute minimum size table less than or equal to l bits
          z = g - w;
          z = (z > l) ? l : z;        // table size upper limit
          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table
                                      // too few codes for k-w bit table
            f -= a + 1;               // deduct codes from patterns left
            xp = k;
            if(j < z){
              while (++j < z){        // try smaller tables up to z bits
                if((f <<= 1) <= this.c[++xp])
                  break;              // enough codes to use up j bits
                f -= this.c[xp];           // else deduct codes from patterns
              }
	    }
          }
          z = 1 << j;                 // table entries for j-bit table

	  // allocate new table
          if (this.hn[0] + z > MANY){       // (note: doesn't matter for fixed)
            return Z_DATA_ERROR;       // overflow of MANY
          }
          this.u[h] = q = /*hp+*/ this.hn[0];   // DEBUG
          this.hn[0] += z;
 
	  // connect to last table, if there is one
	  if(h!=0){
            this.x[h]=i;           // save pattern for backing up
            this.r[0]=j;     // bits in this table
            this.r[1]=l;     // bits to dump before this table
            j=i>>>(w - l);
            this.r[2] = (q - this.u[h-1] - j);               // offset to this table
            arrayCopy(this.r, 0, hp, (this.u[h-1]+j)*3, 3); // connect to last table
          }
          else{
            t[0] = q;               // first table is returned result
	  }
        }

	// set up table entry in r
        this.r[1] = (k - w);
        if (p >= n){
          this.r[0] = 128 + 64;      // out of values--invalid code
	}
        else if (v[p] < s){
          this.r[0] = (this.v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block
          this.r[2] = this.v[p++];          // simple code is just the value
        }
        else{
          this.r[0]=(e[this.v[p]-s]+16+64); // non-simple--look up in lists
          this.r[2]=d[this.v[p++] - s];
        }

        // fill code-like entries with r
        f=1<<(k-w);
        for (j=i>>>w;j<z;j+=f){
          arrayCopy(this.r, 0, hp, (q+j)*3, 3);
	}

	// backwards increment the k-bit code i
        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){
          i ^= j;
	}
        i ^= j;

	// backup over finished tables
        mask = (1 << w) - 1;      // needed on HP, cc -O bug
        while ((i & mask) != this.x[h]){
          h--;                    // don't need to update q
          w -= l;
          mask = (1 << w) - 1;
        }
      }
    }
    // Return Z_BUF_ERROR if we were given an incomplete table
    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}

InfTree.prototype.inflate_trees_bits = function(c, bb, tb, hp, z) {
    var result;
    this.initWorkArea(19);
    this.hn[0]=0;
    result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);

    if(result == Z_DATA_ERROR){
      z.msg = "oversubscribed dynamic bit lengths tree";
    }
    else if(result == Z_BUF_ERROR || bb[0] == 0){
      z.msg = "incomplete dynamic bit lengths tree";
      result = Z_DATA_ERROR;
    }
    return result;
}

InfTree.prototype.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {
    var result;

    // build literal/length tree
    this.initWorkArea(288);
    this.hn[0]=0;
    result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);
    if (result != Z_OK || bl[0] == 0){
      if(result == Z_DATA_ERROR){
        z.msg = "oversubscribed literal/length tree";
      }
      else if (result != Z_MEM_ERROR){
        z.msg = "incomplete literal/length tree";
        result = Z_DATA_ERROR;
      }
      return result;
    }

    // build distance tree
    this.initWorkArea(288);
    result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);

    if (result != Z_OK || (bd[0] == 0 && nl > 257)){
      if (result == Z_DATA_ERROR){
        z.msg = "oversubscribed distance tree";
      }
      else if (result == Z_BUF_ERROR) {
        z.msg = "incomplete distance tree";
        result = Z_DATA_ERROR;
      }
      else if (result != Z_MEM_ERROR){
        z.msg = "empty distance tree with lengths";
        result = Z_DATA_ERROR;
      }
      return result;
    }

    return Z_OK;
}
/*
  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth
                                 int[] bd,  //distance desired/actual bit depth
                                 int[][] tl,//literal/length tree result
                                 int[][] td,//distance tree result 
                                 ZStream z  //for memory allocation
				 ){

*/

function inflate_trees_fixed(bl, bd, tl, td, z) {
    bl[0]=fixed_bl;
    bd[0]=fixed_bd;
    tl[0]=fixed_tl;
    td[0]=fixed_td;
    return Z_OK;
}

InfTree.prototype.initWorkArea = function(vsize){
    if(this.hn==null){
        this.hn=new Int32Array(1);
        this.v=new Int32Array(vsize);
        this.c=new Int32Array(BMAX+1);
        this.r=new Int32Array(3);
        this.u=new Int32Array(BMAX);
        this.x=new Int32Array(BMAX+1);
    }
    if(this.v.length<vsize){ 
        this.v=new Int32Array(vsize); 
    }
    for(var i=0; i<vsize; i++){this.v[i]=0;}
    for(var i=0; i<BMAX+1; i++){this.c[i]=0;}
    for(var i=0; i<3; i++){this.r[i]=0;}
//  for(int i=0; i<BMAX; i++){u[i]=0;}
    arrayCopy(this.c, 0, this.u, 0, BMAX);
//  for(int i=0; i<BMAX+1; i++){x[i]=0;}
    arrayCopy(this.c, 0, this.x, 0, BMAX+1);
}

var testArray = new Uint8Array(1);
var hasSubarray = (typeof testArray.subarray === 'function');
var hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...

function arrayCopy(src, srcOffset, dest, destOffset, count) {
    if (count == 0) {
        return;
    } 
    if (!src) {
        throw "Undef src";
    } else if (!dest) {
        throw "Undef dest";
    }

    if (srcOffset == 0 && count == src.length) {
        arrayCopy_fast(src, dest, destOffset);
    } else if (hasSubarray) {
        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset); 
    } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {
        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);
    } else { 
        arrayCopy_slow(src, srcOffset, dest, destOffset, count);
    }

}

function arrayCopy_slow(src, srcOffset, dest, destOffset, count) {

    // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);

     for (var i = 0; i < count; ++i) {
        dest[destOffset + i] = src[srcOffset + i];
    }
}

function arrayCopy_fast(src, dest, destOffset) {
    dest.set(src, destOffset);
}


  // largest prime smaller than 65536
var ADLER_BASE=65521; 
  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1
var ADLER_NMAX=5552;

function adler32(adler, /* byte[] */ buf,  index, len){
    if(buf == null){ return 1; }

    var s1=adler&0xffff;
    var s2=(adler>>16)&0xffff;
    var k;

    while(len > 0) {
      k=len<ADLER_NMAX?len:ADLER_NMAX;
      len-=k;
      while(k>=16){
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        s1+=buf[index++]&0xff; s2+=s1;
        k-=16;
      }
      if(k!=0){
        do{
          s1+=buf[index++]&0xff; s2+=s1;
        }
        while(--k!=0);
      }
      s1%=ADLER_BASE;
      s2%=ADLER_BASE;
    }
    return (s2<<16)|s1;
}



function jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {
    if (!start) {
        buffer = new Uint8Array(buffer);
    } else if (!length) {
        buffer = new Uint8Array(buffer, start, buffer.byteLength - start);
    } else {
        buffer = new Uint8Array(buffer, start, length);
    }

    var z = new ZStream();
    z.inflateInit(DEF_WBITS, true);
    z.next_in = buffer;
    z.next_in_index = 0;
    z.avail_in = buffer.length;

    var oBlockList = [];
    var totalSize = 0;
    while (true) {
        var obuf = new Uint8Array(32000);
        z.next_out = obuf;
        z.next_out_index = 0;
        z.avail_out = obuf.length;
        var status = z.inflate(Z_NO_FLUSH);
        if (status != Z_OK && status != Z_STREAM_END && status != Z_BUF_ERROR) {
            throw z.msg;
        }
        if (z.avail_out != 0) {
            var newob = new Uint8Array(obuf.length - z.avail_out);
            arrayCopy(obuf, 0, newob, 0, (obuf.length - z.avail_out));
            obuf = newob;
        }
        oBlockList.push(obuf);
        totalSize += obuf.length;
        if (status == Z_STREAM_END || status == Z_BUF_ERROR) {
            break;
        }
    }

    if (afterUncOffset) {
        afterUncOffset[0] = (start || 0) + z.next_in_index;
    }

    if (oBlockList.length == 1) {
        return oBlockList[0].buffer;
    } else {
        var out = new Uint8Array(totalSize);
        var cursor = 0;
        for (var i = 0; i < oBlockList.length; ++i) {
            var b = oBlockList[i];
            arrayCopy(b, 0, out, cursor, b.length);
            cursor += b.length;
        }
        return out.buffer;
    }
}

if (typeof(module) !== 'undefined') {
  module.exports = {
    inflateBuffer: jszlib_inflate_buffer,
    arrayCopy: arrayCopy
  };
}

},{}]},{},[17])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9yb290L2RhbGxpYW5jZS9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvYmFtLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL2JlZHdpZy5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9iaWd3aWcuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvYmluLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL2Jyb3dzZXItdWkuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvY2Jyb3dzZXIuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvY2hhaW5zZXQuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvY2lnYXIuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvY29sb3IuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvZGFzLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL2RvbXVpLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL2VuY29kZS5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9lbnNlbWJsanNvbi5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9leHBvcnQtY29uZmlnLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL2V4cG9ydC1pbWFnZS5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9leHBvcnQtdWkuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvZmFrZV82OTUzZWRlYi5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9mZWF0dXJlLWRyYXcuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvZmVhdHVyZS1wb3B1cC5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9mZWF0dXJlcy5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9nbHlwaHMuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvamJqc29uLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL2tzcGFjZS5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9saDN1dGlscy5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9tZW1zdG9yZS5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9udW1mb3JtYXRzLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL292ZXJsYXkuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvcHJvYmUuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvc2FtcGxlLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL3NlYXJjaC5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9zZXF1ZW5jZS1kcmF3LmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL3Nlc3Npb24uanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvc2hhMS5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9zb3VyY2VhZGFwdGVycy5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy9zb3VyY2Vjb21wYXJlLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL3NwYW5zLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL3N0eWxlLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL3N2Zy1leHBvcnQuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvc3ZnLXV0aWxzLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL3RhYml4LXNvdXJjZS5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy90YWJpeC5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy90aHViLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL3RpZXItYWN0aW9ucy5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy90aWVyLWVkaXQuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvdGllci5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy90cmFjay1hZGRlci5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy90cml4LmpzIiwiL3Jvb3QvZGFsbGlhbmNlL2pzL3R3b0JpdC5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy91dGlscy5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy92Y2YuanMiLCIvcm9vdC9kYWxsaWFuY2UvanMvdmVyc2lvbi5qcyIsIi9yb290L2RhbGxpYW5jZS9qcy96b29tc2xpZGVyLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2NvbW1vbmpzL21haW4uanMiLCIvcm9vdC9kYWxsaWFuY2Uvbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvY29tbW9uanMvcHJvbWlzZS9hbGwuanMiLCIvcm9vdC9kYWxsaWFuY2Uvbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvY29tbW9uanMvcHJvbWlzZS9hc2FwLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2NvbW1vbmpzL3Byb21pc2UvY2FzdC5qcyIsIi9yb290L2RhbGxpYW5jZS9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9jb21tb25qcy9wcm9taXNlL2NvbmZpZy5qcyIsIi9yb290L2RhbGxpYW5jZS9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9jb21tb25qcy9wcm9taXNlL3BvbHlmaWxsLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2NvbW1vbmpzL3Byb21pc2UvcHJvbWlzZS5qcyIsIi9yb290L2RhbGxpYW5jZS9ub2RlX21vZHVsZXMvZXM2LXByb21pc2UvZGlzdC9jb21tb25qcy9wcm9taXNlL3JhY2UuanMiLCIvcm9vdC9kYWxsaWFuY2Uvbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvY29tbW9uanMvcHJvbWlzZS9yZWplY3QuanMiLCIvcm9vdC9kYWxsaWFuY2Uvbm9kZV9tb2R1bGVzL2VzNi1wcm9taXNlL2Rpc3QvY29tbW9uanMvcHJvbWlzZS9yZXNvbHZlLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2NvbW1vbmpzL3Byb21pc2UvdXRpbHMuanMiLCIvcm9vdC9kYWxsaWFuY2Uvbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL3Jvb3QvZGFsbGlhbmNlL25vZGVfbW9kdWxlcy9qc3psaWIvanMvaW5mbGF0ZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25TQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcitFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3gxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6cERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdG1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDejRDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMVxuLy9cbi8vIGJhbS5qczogaW5kZXhlZCBiaW5hcnkgYWxpZ25tZW50c1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHNwYW5zID0gcmVxdWlyZSgnLi9zcGFucycpO1xuICAgIHZhciBSYW5nZSA9IHNwYW5zLlJhbmdlO1xuICAgIHZhciB1bmlvbiA9IHNwYW5zLnVuaW9uO1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBzcGFucy5pbnRlcnNlY3Rpb247XG5cbiAgICB2YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbiAgICB2YXIgcmVhZEludCA9IGJpbi5yZWFkSW50O1xuICAgIHZhciByZWFkU2hvcnQgPSBiaW4ucmVhZFNob3J0O1xuICAgIHZhciByZWFkQnl0ZSA9IGJpbi5yZWFkQnl0ZTtcbiAgICB2YXIgcmVhZEludDY0ID0gYmluLnJlYWRJbnQ2NDtcbiAgICB2YXIgcmVhZEZsb2F0ID0gYmluLnJlYWRGbG9hdDtcblxuICAgIHZhciBsaDN1dGlscyA9IHJlcXVpcmUoJy4vbGgzdXRpbHMnKTtcbiAgICB2YXIgcmVhZFZvYiA9IGxoM3V0aWxzLnJlYWRWb2I7XG4gICAgdmFyIHVuYmd6ZiA9IGxoM3V0aWxzLnVuYmd6ZjtcbiAgICB2YXIgcmVnMmJpbnMgPSBsaDN1dGlscy5yZWcyYmlucztcbiAgICB2YXIgQ2h1bmsgPSBsaDN1dGlscy5DaHVuaztcbn1cblxuXG52YXIgQkFNX01BR0lDID0gMHgxNGQ0MTQyO1xudmFyIEJBSV9NQUdJQyA9IDB4MTQ5NDE0MjtcblxudmFyIEJhbUZsYWdzID0ge1xuICAgIE1VTFRJUExFX1NFR01FTlRTOiAgICAgICAweDEsXG4gICAgQUxMX1NFR01FTlRTX0FMSUdOOiAgICAgIDB4MixcbiAgICBTRUdNRU5UX1VOTUFQUEVEOiAgICAgICAgMHg0LFxuICAgIE5FWFRfU0VHTUVOVF9VTk1BUFBFRDogICAweDgsXG4gICAgUkVWRVJTRV9DT01QTEVNRU5UOiAgICAgIDB4MTAsXG4gICAgTkVYVF9SRVZFUlNFX0NPTVBMRU1FTlQ6IDB4MjAsXG4gICAgRklSU1RfU0VHTUVOVDogICAgICAgICAgIDB4NDAsXG4gICAgTEFTVF9TRUdNRU5UOiAgICAgICAgICAgIDB4ODAsXG4gICAgU0VDT05EQVJZX0FMSUdOTUVOVDogICAgIDB4MTAwLFxuICAgIFFDX0ZBSUw6ICAgICAgICAgICAgICAgICAweDIwMCxcbiAgICBEVVBMSUNBVEU6ICAgICAgICAgICAgICAgMHg0MDAsXG4gICAgU1VQUExFTUVOVEFSWTogICAgICAgICAgIDB4ODAwXG59O1xuXG5mdW5jdGlvbiBCYW1GaWxlKCkge1xufVxuXG5cbi8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIEJBSSByZWYgc3RhcnRpbmcgYXQgb2Zmc2V0LlxuLy8gUmV0dXJucyB7bmJpbiwgbGVuZ3RoLCBtaW5CbG9ja0luZGV4fVxuZnVuY3Rpb24gX2dldEJhaVJlZkxlbmd0aCh1bmNiYSwgb2Zmc2V0KSB7XG4gICAgdmFyIHAgPSBvZmZzZXQ7XG4gICAgdmFyIG5iaW4gPSByZWFkSW50KHVuY2JhLCBwKTsgcCArPSA0O1xuICAgIGZvciAodmFyIGIgPSAwOyBiIDwgbmJpbjsgKytiKSB7XG4gICAgICAgIHZhciBiaW4gPSByZWFkSW50KHVuY2JhLCBwKTtcbiAgICAgICAgdmFyIG5jaG5rID0gcmVhZEludCh1bmNiYSwgcCs0KTtcbiAgICAgICAgcCArPSA4ICsgKG5jaG5rICogMTYpO1xuICAgIH1cbiAgICB2YXIgbmludHYgPSByZWFkSW50KHVuY2JhLCBwKTsgcCArPSA0O1xuXG4gICAgdmFyIG1pbkJsb2NrSW5kZXggPSAxMDAwMDAwMDAwO1xuICAgIHZhciBxID0gcDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5pbnR2OyArK2kpIHtcbiAgICAgICAgdmFyIHYgPSByZWFkVm9iKHVuY2JhLCBxKTsgcSArPSA4O1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgdmFyIGJpID0gdi5ibG9jaztcbiAgICAgICAgICAgIGlmICh2Lm9mZnNldCA+IDApXG4gICAgICAgICAgICAgICAgYmkgKz0gNjU1MzY7XG5cbiAgICAgICAgICAgIGlmIChiaSA8IG1pbkJsb2NrSW5kZXgpXG4gICAgICAgICAgICAgICAgbWluQmxvY2tJbmRleCA9IGJpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcCArPSAobmludHYgKiA4KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1pbkJsb2NrSW5kZXg6IG1pbkJsb2NrSW5kZXgsXG4gICAgICAgIG5iaW46IG5iaW4sXG4gICAgICAgIGxlbmd0aDogcCAtIG9mZnNldFxuICAgIH07XG59XG5cblxuZnVuY3Rpb24gbWFrZUJhbShkYXRhLCBiYWksIGluZGV4Q2h1bmtzLCBjYWxsYmFjaywgYXR0ZW1wdGVkKSB7XG4gICAgLy8gRG8gYW4gaW5pdGlhbCBwcm9iZSBvbiB0aGUgQkFNIGZpbGUgdG8gY2F0Y2ggYW55IG1peGVkLWNvbnRlbnQgZXJyb3JzLlxuICAgIGRhdGEuc2xpY2UoMCwgMTApLmZldGNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUJhbTIoZGF0YSwgYmFpLCBpbmRleENodW5rcywgY2FsbGJhY2ssIGF0dGVtcHRlZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgXCJDb3VsZG4ndCBhY2Nlc3MgQkFNLlwiKTtcbiAgICAgICAgfVxuICAgIH0sIHt0aW1lb3V0OiA1MDAwfSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VCYW0yKGRhdGEsIGJhaSwgaW5kZXhDaHVua3MsIGNhbGxiYWNrLCBhdHRlbXB0ZWQpIHtcbiAgICB2YXIgYmFtID0gbmV3IEJhbUZpbGUoKTtcbiAgICBiYW0uZGF0YSA9IGRhdGE7XG4gICAgYmFtLmJhaSA9IGJhaTtcbiAgICBiYW0uaW5kZXhDaHVua3MgPSBpbmRleENodW5rcztcblxuICAgIHZhciBtaW5CbG9ja0luZGV4ID0gYmFtLmluZGV4Q2h1bmtzID8gYmFtLmluZGV4Q2h1bmtzLm1pbkJsb2NrSW5kZXggOiAxMDAwMDAwMDAwO1xuXG4gICAgLy8gRmlsbHMgb3V0IGJhbS5jaHJUb0luZGV4IGFuZCBiYW0uaW5kZXhUb0NociBiYXNlZCBvbiB0aGUgZmlyc3QgZmV3IGJ5dGVzIG9mIHRoZSBCQU0uXG4gICAgZnVuY3Rpb24gcGFyc2VCYW1IZWFkZXIocikge1xuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIkNvdWxkbid0IGFjY2VzcyBCQU1cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5jID0gdW5iZ3pmKHIsIHIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZhciB1bmNiYSA9IG5ldyBVaW50OEFycmF5KHVuYyk7XG5cbiAgICAgICAgdmFyIG1hZ2ljID0gcmVhZEludCh1bmNiYSwgMCk7XG4gICAgICAgIGlmIChtYWdpYyAhPSBCQU1fTUFHSUMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIk5vdCBhIEJBTSBmaWxlLCBtYWdpYz0weFwiICsgbWFnaWMudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZExlbiA9IHJlYWRJbnQodW5jYmEsIDQpO1xuICAgICAgICB2YXIgaGVhZGVyID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZExlbjsgKytpKSB7XG4gICAgICAgICAgICBoZWFkZXIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmNiYVtpICsgOF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5SZWYgPSByZWFkSW50KHVuY2JhLCBoZWFkTGVuICsgOCk7XG4gICAgICAgIHZhciBwID0gaGVhZExlbiArIDEyO1xuXG4gICAgICAgIGJhbS5jaHJUb0luZGV4ID0ge307XG4gICAgICAgIGJhbS5pbmRleFRvQ2hyID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblJlZjsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbE5hbWUgPSByZWFkSW50KHVuY2JhLCBwKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxOYW1lLTE7ICsraikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1bmNiYVtwICsgNCArIGpdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsUmVmID0gcmVhZEludCh1bmNiYSwgcCArIGxOYW1lICsgNCk7XG4gICAgICAgICAgICBiYW0uY2hyVG9JbmRleFtuYW1lXSA9IGk7XG4gICAgICAgICAgICBpZiAobmFtZS5pbmRleE9mKCdjaHInKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYmFtLmNoclRvSW5kZXhbbmFtZS5zdWJzdHJpbmcoMyldID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFtLmNoclRvSW5kZXhbJ2NocicgKyBuYW1lXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYW0uaW5kZXhUb0Noci5wdXNoKG5hbWUpO1xuXG4gICAgICAgICAgICBwID0gcCArIDggKyBsTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYW0uaW5kaWNlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGJhbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUJhaShoZWFkZXIpIHtcbiAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkNvdWxkbid0IGFjY2VzcyBCQUlcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1bmNiYSA9IG5ldyBVaW50OEFycmF5KGhlYWRlcik7XG4gICAgICAgIHZhciBiYWlNYWdpYyA9IHJlYWRJbnQodW5jYmEsIDApO1xuICAgICAgICBpZiAoYmFpTWFnaWMgIT0gQkFJX01BR0lDKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ05vdCBhIEJBSSBmaWxlLCBtYWdpYz0weCcgKyBiYWlNYWdpYy50b1N0cmluZygxNikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5yZWYgPSByZWFkSW50KHVuY2JhLCA0KTtcblxuICAgICAgICBiYW0uaW5kaWNlcyA9IFtdO1xuXG4gICAgICAgIHZhciBwID0gODtcbiAgICAgICAgZm9yICh2YXIgcmVmID0gMDsgcmVmIDwgbnJlZjsgKytyZWYpIHtcbiAgICAgICAgICAgIHZhciBibG9ja1N0YXJ0ID0gcDtcbiAgICAgICAgICAgIHZhciBvID0gX2dldEJhaVJlZkxlbmd0aCh1bmNiYSwgYmxvY2tTdGFydCk7XG4gICAgICAgICAgICBwICs9IG8ubGVuZ3RoO1xuXG4gICAgICAgICAgICBtaW5CbG9ja0luZGV4ID0gTWF0aC5taW4oby5taW5CbG9ja0luZGV4LCBtaW5CbG9ja0luZGV4KTtcblxuICAgICAgICAgICAgdmFyIG5iaW4gPSBvLm5iaW47XG5cbiAgICAgICAgICAgIGlmIChuYmluID4gMCkge1xuICAgICAgICAgICAgICAgIGJhbS5pbmRpY2VzW3JlZl0gPSBuZXcgVWludDhBcnJheShoZWFkZXIsIGJsb2NrU3RhcnQsIHAgLSBibG9ja1N0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYmFtLmluZGV4Q2h1bmtzKSB7XG4gICAgICAgIGJhbS5iYWkuZmV0Y2goZnVuY3Rpb24oaGVhZGVyKSB7ICAgLy8gRG8gd2UgcmVhbGx5IG5lZWQgdG8gZmV0Y2ggdGhlIHdob2xlIHRoaW5nPyA6LShcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXJzZUJhaShoZWFkZXIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChiYW0uYmFpLnVybCAmJiB0eXBlb2YoYXR0ZW1wdGVkKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbHJlYWR5IGF0dGVtcHRlZCB4LmJhbS5iYWkgbm90IHRoZXJlIHNvIG5vdyB0cnlpbmcgeC5iYWlcbiAgICAgICAgICAgICAgICAgICAgYmFtLmJhaS51cmwgPSBiYW0uZGF0YS51cmwucmVwbGFjZShuZXcgUmVnRXhwKCcuYmFtJCcpLCAnLmJhaScpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgIC8vIFRydWUgbGV0cyB1cyBrbm93IHdlIGFyZSBtYWtpbmcgYSBzZWNvbmQgYXR0ZW1wdFxuICAgICAgICAgICAgICAgICAgICBtYWtlQmFtMihkYXRhLCBiYW0uYmFpLCBpbmRleENodW5rcywgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgYXR0ZW1wdGVkIHguYmFtLmJhaSAmIHguYmFpIGFuZCBub3RoaW5nIHdvcmtlZFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJhbS5kYXRhLnNsaWNlKDAsIG1pbkJsb2NrSW5kZXgpLmZldGNoKHBhcnNlQmFtSGVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7ICAgLy8gVGltZW91dCBvbiBmaXJzdCByZXF1ZXN0IHRvIGNhdGNoIENocm9tZSBtaXhlZC1jb250ZW50IGVycm9yLlxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaHVua3MgPSBiYW0uaW5kZXhDaHVua3MuY2h1bmtzO1xuICAgICAgICBiYW0uaW5kaWNlcyA9IFtdXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgIGJhbS5pbmRpY2VzW2ldID0gbnVsbDsgIC8vIFRvIGJlIGZpbGxlZCBvdXQgbGF6aWx5IGFzIG5lZWRlZFxuICAgICAgICB9XG4gICAgICAgIGJhbS5kYXRhLnNsaWNlKDAsIG1pbkJsb2NrSW5kZXgpLmZldGNoKHBhcnNlQmFtSGVhZGVyKTtcbiAgICB9XG59XG5cblxuXG5CYW1GaWxlLnByb3RvdHlwZS5ibG9ja3NGb3JSYW5nZSA9IGZ1bmN0aW9uKHJlZklkLCBtaW4sIG1heCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kaWNlc1tyZWZJZF07XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGludEJpbnNMID0gcmVnMmJpbnMobWluLCBtYXgpO1xuICAgIHZhciBpbnRCaW5zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRCaW5zTC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnRCaW5zW2ludEJpbnNMW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBsZWFmQ2h1bmtzID0gW10sIG90aGVyQ2h1bmtzID0gW107XG5cbiAgICB2YXIgbmJpbiA9IHJlYWRJbnQoaW5kZXgsIDApO1xuICAgIHZhciBwID0gNDtcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IG5iaW47ICsrYikge1xuICAgICAgICB2YXIgYmluID0gcmVhZEludChpbmRleCwgcCk7XG4gICAgICAgIHZhciBuY2huayA9IHJlYWRJbnQoaW5kZXgsIHArNCk7XG4vLyAgICAgICAgZGxvZygnYmluPScgKyBiaW4gKyAnOyBuY2huaz0nICsgbmNobmspO1xuICAgICAgICBwICs9IDg7XG4gICAgICAgIGlmIChpbnRCaW5zW2Jpbl0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgbmNobms7ICsrYykge1xuICAgICAgICAgICAgICAgIHZhciBjcyA9IHJlYWRWb2IoaW5kZXgsIHApO1xuICAgICAgICAgICAgICAgIHZhciBjZSA9IHJlYWRWb2IoaW5kZXgsIHAgKyA4KTtcbiAgICAgICAgICAgICAgICAoYmluIDwgNDY4MSA/IG90aGVyQ2h1bmtzIDogbGVhZkNodW5rcykucHVzaChuZXcgQ2h1bmsoY3MsIGNlKSk7XG4gICAgICAgICAgICAgICAgcCArPSAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHAgKz0gIChuY2huayAqIDE2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnbGVhZkNodW5rcyA9ICcgKyBtaW5pSlNPTmlmeShsZWFmQ2h1bmtzKSk7XG4gICAgLy8gY29uc29sZS5sb2coJ290aGVyQ2h1bmtzID0gJyArIG1pbmlKU09OaWZ5KG90aGVyQ2h1bmtzKSk7XG5cbiAgICB2YXIgbmludHYgPSByZWFkSW50KGluZGV4LCBwKTtcbiAgICB2YXIgbG93ZXN0ID0gbnVsbDtcbiAgICB2YXIgbWluTGluID0gTWF0aC5taW4obWluPj4xNCwgbmludHYgLSAxKSwgbWF4TGluID0gTWF0aC5taW4obWF4Pj4xNCwgbmludHYgLSAxKTtcbiAgICBmb3IgKHZhciBpID0gbWluTGluOyBpIDw9IG1heExpbjsgKytpKSB7XG4gICAgICAgIHZhciBsYiA9ICByZWFkVm9iKGluZGV4LCBwICsgNCArIChpICogOCkpO1xuICAgICAgICBpZiAoIWxiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxvd2VzdCB8fCBsYi5ibG9jayA8IGxvd2VzdC5ibG9jayB8fCBsYi5vZmZzZXQgPCBsb3dlc3Qub2Zmc2V0KSB7XG4gICAgICAgICAgICBsb3dlc3QgPSBsYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnTG93ZXN0IExCID0gJyArIGxvd2VzdCk7XG4gICAgXG4gICAgdmFyIHBydW5lZE90aGVyQ2h1bmtzID0gW107XG4gICAgaWYgKGxvd2VzdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJDaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjaG5rID0gb3RoZXJDaHVua3NbaV07XG4gICAgICAgICAgICBpZiAoY2huay5tYXh2LmJsb2NrID49IGxvd2VzdC5ibG9jayAmJiBjaG5rLm1heHYub2Zmc2V0ID49IGxvd2VzdC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBwcnVuZWRPdGhlckNodW5rcy5wdXNoKGNobmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCdwcnVuZWRPdGhlckNodW5rcyA9ICcgKyBtaW5pSlNPTmlmeShwcnVuZWRPdGhlckNodW5rcykpO1xuICAgIG90aGVyQ2h1bmtzID0gcHJ1bmVkT3RoZXJDaHVua3M7XG5cbiAgICB2YXIgaW50Q2h1bmtzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlckNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnRDaHVua3MucHVzaChvdGhlckNodW5rc1tpXSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVhZkNodW5rcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnRDaHVua3MucHVzaChsZWFmQ2h1bmtzW2ldKTtcbiAgICB9XG5cbiAgICBpbnRDaHVua3Muc29ydChmdW5jdGlvbihjMCwgYzEpIHtcbiAgICAgICAgdmFyIGRpZiA9IGMwLm1pbnYuYmxvY2sgLSBjMS5taW52LmJsb2NrO1xuICAgICAgICBpZiAoZGlmICE9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBkaWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYzAubWludi5vZmZzZXQgLSBjMS5taW52Lm9mZnNldDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBtZXJnZWRDaHVua3MgPSBbXTtcbiAgICBpZiAoaW50Q2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGN1ciA9IGludENodW5rc1swXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpbnRDaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuYyA9IGludENodW5rc1tpXTtcbiAgICAgICAgICAgIGlmIChuYy5taW52LmJsb2NrID09IGN1ci5tYXh2LmJsb2NrIC8qICYmIG5jLm1pbnYub2Zmc2V0ID09IGN1ci5tYXh2Lm9mZnNldCAqLykgeyAvLyBubyBwb2ludCBzcGxpdHRpbmcgbWlkLWJsb2NrXG4gICAgICAgICAgICAgICAgY3VyID0gbmV3IENodW5rKGN1ci5taW52LCBuYy5tYXh2KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY3VyKTtcbiAgICAgICAgICAgICAgICBjdXIgPSBuYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXJnZWRDaHVua3MucHVzaChjdXIpO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnbWVyZ2VkQ2h1bmtzID0gJyArIG1pbmlKU09OaWZ5KG1lcmdlZENodW5rcykpO1xuXG4gICAgcmV0dXJuIG1lcmdlZENodW5rcztcbn1cblxuQmFtRmlsZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBjYWxsYmFjaywgb3B0cykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICB2YXIgY2hySWQgPSB0aGlzLmNoclRvSW5kZXhbY2hyXTtcbiAgICB2YXIgY2h1bmtzO1xuICAgIGlmIChjaHJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNodW5rcyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZldGNoIHRoaXMgcG9ydGlvbiBvZiB0aGUgQkFJIGlmIGl0IGhhc24ndCBiZWVuIGxvYWRlZCB5ZXQuXG4gICAgICAgIGlmICh0aGlzLmluZGljZXNbY2hySWRdID09PSBudWxsICYmIHRoaXMuaW5kZXhDaHVua3MuY2h1bmtzW2NocklkXSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0X3N0b3AgPSB0aGlzLmluZGV4Q2h1bmtzLmNodW5rc1tjaHJJZF07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYWkuc2xpY2Uoc3RhcnRfc3RvcFswXSwgc3RhcnRfc3RvcFsxXSkuZmV0Y2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGljZXNbY2hySWRdID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKGNociwgbWluLCBtYXgsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVua3MgPSB0aGlzLmJsb2Nrc0ZvclJhbmdlKGNocklkLCBtaW4sIG1heCk7XG4gICAgICAgIGlmICghY2h1bmtzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnRXJyb3IgaW4gaW5kZXggZmV0Y2gnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB2YXIgcmVjb3JkcyA9IFtdO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGRhdGE7XG5cbiAgICBmdW5jdGlvbiB0cmFtcCgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZWNvcmRzKTtcbiAgICAgICAgfSBlbHNlIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdmFyIGMgPSBjaHVua3NbaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGZldGNoTWluID0gYy5taW52LmJsb2NrO1xuICAgICAgICAgICAgdmFyIGZldGNoTWF4ID0gYy5tYXh2LmJsb2NrICsgKDE8PDE2KTsgLy8gKnNpZ2gqXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZmV0Y2hpbmcgJyArIGZldGNoTWluICsgJzonICsgZmV0Y2hNYXgpO1xuICAgICAgICAgICAgdGhpc0IuZGF0YS5zbGljZShmZXRjaE1pbiwgZmV0Y2hNYXggLSBmZXRjaE1pbikuZmV0Y2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB1bmJnemYociwgYy5tYXh2LmJsb2NrIC0gYy5taW52LmJsb2NrICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyYW1wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICAgICAgdmFyIGZpbmlzaGVkID0gdGhpc0IucmVhZEJhbVJlY29yZHMoYmEsIGNodW5rc1tpbmRleF0ubWludi5vZmZzZXQsIHJlY29yZHMsIG1pbiwgbWF4LCBjaHJJZCwgb3B0cyk7XG4gICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICsraW5kZXg7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlY29yZHMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFtcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW1wKCk7XG59XG5cbnZhciBTRVFSRVRfREVDT0RFUiA9IFsnPScsICdBJywgJ0MnLCAneCcsICdHJywgJ3gnLCAneCcsICd4JywgJ1QnLCAneCcsICd4JywgJ3gnLCAneCcsICd4JywgJ3gnLCAnTiddO1xudmFyIENJR0FSX0RFQ09ERVIgPSBbJ00nLCAnSScsICdEJywgJ04nLCAnUycsICdIJywgJ1AnLCAnPScsICdYJywgJz8nLCAnPycsICc/JywgJz8nLCAnPycsICc/JywgJz8nXTtcblxuZnVuY3Rpb24gQmFtUmVjb3JkKCkge1xufVxuXG5CYW1GaWxlLnByb3RvdHlwZS5yZWFkQmFtUmVjb3JkcyA9IGZ1bmN0aW9uKGJhLCBvZmZzZXQsIHNpbmssIG1pbiwgbWF4LCBjaHJJZCwgb3B0cykge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBibG9ja1NpemUgPSByZWFkSW50KGJhLCBvZmZzZXQpO1xuICAgICAgICB2YXIgYmxvY2tFbmQgPSBvZmZzZXQgKyBibG9ja1NpemUgKyA0O1xuICAgICAgICBpZiAoYmxvY2tFbmQgPj0gYmEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb3JkID0gbmV3IEJhbVJlY29yZCgpO1xuXG4gICAgICAgIHZhciByZWZJRCA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDQpO1xuICAgICAgICB2YXIgcG9zID0gcmVhZEludChiYSwgb2Zmc2V0ICsgOCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgYm1uID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMTIpO1xuICAgICAgICB2YXIgYmluID0gKGJtbiAmIDB4ZmZmZjAwMDApID4+IDE2O1xuICAgICAgICB2YXIgbXEgPSAoYm1uICYgMHhmZjAwKSA+PiA4O1xuICAgICAgICB2YXIgbmwgPSBibW4gJiAweGZmO1xuXG4gICAgICAgIHZhciBmbGFnX25jID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMTYpO1xuICAgICAgICB2YXIgZmxhZyA9IChmbGFnX25jICYgMHhmZmZmMDAwMCkgPj4gMTY7XG4gICAgICAgIHZhciBuYyA9IGZsYWdfbmMgJiAweGZmZmY7XG4gICAgXG4gICAgICAgIHZhciBsc2VxID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMjApO1xuICAgICAgICBcbiAgICAgICAgdmFyIG5leHRSZWYgID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMjQpO1xuICAgICAgICB2YXIgbmV4dFBvcyA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDI4KTtcbiAgICAgICAgXG4gICAgICAgIHZhciB0bGVuID0gcmVhZEludChiYSwgb2Zmc2V0ICsgMzIpO1xuICAgIFxuICAgICAgICByZWNvcmQuc2VnbWVudCA9IHRoaXMuaW5kZXhUb0NocltyZWZJRF07XG4gICAgICAgIHJlY29yZC5mbGFnID0gZmxhZztcbiAgICAgICAgcmVjb3JkLnBvcyA9IHBvcztcbiAgICAgICAgcmVjb3JkLm1xID0gbXE7XG4gICAgICAgIGlmIChvcHRzLmxpZ2h0KVxuICAgICAgICAgICAgcmVjb3JkLnNlcUxlbmd0aCA9IGxzZXE7XG5cbiAgICAgICAgaWYgKCFvcHRzLmxpZ2h0KSB7XG4gICAgICAgICAgICBpZiAobmV4dFJlZiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkLm5leHRTZWdtZW50ID0gdGhpcy5pbmRleFRvQ2hyW25leHRSZWZdO1xuICAgICAgICAgICAgICAgIHJlY29yZC5uZXh0UG9zID0gbmV4dFBvcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJlYWROYW1lID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5sLTE7ICsraikge1xuICAgICAgICAgICAgICAgIHJlYWROYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbb2Zmc2V0ICsgMzYgKyBqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmQucmVhZE5hbWUgPSByZWFkTmFtZTtcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgcCA9IG9mZnNldCArIDM2ICsgbmw7XG5cbiAgICAgICAgICAgIHZhciBjaWdhciA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuYzsgKytjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNpZ29wID0gcmVhZEludChiYSwgcCk7XG4gICAgICAgICAgICAgICAgY2lnYXIgPSBjaWdhciArIChjaWdvcD4+NCkgKyBDSUdBUl9ERUNPREVSW2NpZ29wICYgMHhmXTtcbiAgICAgICAgICAgICAgICBwICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWNvcmQuY2lnYXIgPSBjaWdhcjtcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgc2VxID0gJyc7XG4gICAgICAgICAgICB2YXIgc2VxQnl0ZXMgPSAobHNlcSArIDEpID4+IDE7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNlcUJ5dGVzOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgc2IgPSBiYVtwICsgal07XG4gICAgICAgICAgICAgICAgc2VxICs9IFNFUVJFVF9ERUNPREVSWyhzYiAmIDB4ZjApID4+IDRdO1xuICAgICAgICAgICAgICAgIGlmIChzZXEubGVuZ3RoIDwgbHNlcSlcbiAgICAgICAgICAgICAgICAgICAgc2VxICs9IFNFUVJFVF9ERUNPREVSWyhzYiAmIDB4MGYpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgKz0gc2VxQnl0ZXM7XG4gICAgICAgICAgICByZWNvcmQuc2VxID0gc2VxO1xuXG4gICAgICAgICAgICB2YXIgcXNlcSA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsc2VxOyArK2opIHtcbiAgICAgICAgICAgICAgICBxc2VxICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcCArIGpdICsgMzMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCArPSBsc2VxO1xuICAgICAgICAgICAgcmVjb3JkLnF1YWxzID0gcXNlcTtcblxuICAgICAgICAgICAgd2hpbGUgKHAgPCBibG9ja0VuZCkge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW3BdLCBiYVtwICsgMV0pO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgMl0pO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09ICdBJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmFbcCArIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgcCArPSA0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnaScgfHwgdHlwZSA9PSAnSScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZWFkSW50KGJhLCBwICsgMyk7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ2MnIHx8IHR5cGUgPT0gJ0MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYmFbcCArIDNdO1xuICAgICAgICAgICAgICAgICAgICBwICs9IDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdzJyB8fCB0eXBlID09ICdTJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRTaG9ydChiYSwgcCArIDMpO1xuICAgICAgICAgICAgICAgICAgICBwICs9IDU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdmJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRGbG9hdChiYSwgcCArIDMpO1xuICAgICAgICAgICAgICAgICAgICBwICs9IDc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09ICdaJyB8fCB0eXBlID09ICdIJykge1xuICAgICAgICAgICAgICAgICAgICBwICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYyA9IGJhW3ArK107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2MgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnQicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0eXBlID0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwICsgM10pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWxlbiA9IHJlYWRJbnQoYmEsIHAgKyA0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW47XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHlwZSA9PSAnaScgfHwgYXR5cGUgPT0gJ0knIHx8IGF0eXBlID09ICdmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbiA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR5cGUgPT0gJ2YnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IHJlYWRGbG9hdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIgPSByZWFkSW50O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0eXBlID09ICdzJyB8fCBhdHlwZSA9PSAnUycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW4gPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZFNob3J0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0eXBlID09ICdjJyB8fCBhdHlwZSA9PSAnQycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW4gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyID0gcmVhZEJ5dGU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVW5rbm93biBhcnJheSB0eXBlICcgKyBhdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHAgKz0gODtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2gocmVhZGVyKGJhLCBwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwICs9IGVsZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyAnVW5rbm93biB0eXBlICcrIHR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY29yZFt0YWddID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW1pbiB8fCByZWNvcmQucG9zIDw9IG1heCAmJiByZWNvcmQucG9zICsgbHNlcSA+PSBtaW4pIHtcbiAgICAgICAgICAgIGlmIChjaHJJZCA9PT0gdW5kZWZpbmVkIHx8IHJlZklEID09IGNocklkKSB7XG4gICAgICAgICAgICAgICAgc2luay5wdXNoKHJlY29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY29yZC5wb3MgPiBtYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IGJsb2NrRW5kO1xuICAgIH1cblxuICAgIC8vIEV4aXRzIHZpYSB0b3Agb2YgbG9vcC5cbn07XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbWFrZUJhbTogbWFrZUJhbSxcbiAgICAgICAgQkFNX01BR0lDOiBCQU1fTUFHSUMsXG4gICAgICAgIEJBSV9NQUdJQzogQkFJX01BR0lDLFxuICAgICAgICBCYW1GbGFnczogQmFtRmxhZ3NcbiAgICB9O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIGJlZHdpZy5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHNwYW5zID0gcmVxdWlyZSgnLi9zcGFucycpO1xuICAgIHZhciBSYW5nZSA9IHNwYW5zLlJhbmdlO1xuICAgIHZhciB1bmlvbiA9IHNwYW5zLnVuaW9uO1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBzcGFucy5pbnRlcnNlY3Rpb247XG5cbiAgICB2YXIgc2EgPSByZXF1aXJlKCcuL3NvdXJjZWFkYXB0ZXJzJyk7XG4gICAgdmFyIGRhbGxpYW5jZV9yZWdpc3RlclBhcnNlckZhY3RvcnkgPSBzYS5yZWdpc3RlclBhcnNlckZhY3Rvcnk7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU3R5bGVzaGVldCA9IGRhcy5EQVNTdHlsZXNoZWV0O1xuICAgIHZhciBEQVNTdHlsZSA9IGRhcy5EQVNTdHlsZTtcbiAgICB2YXIgREFTRmVhdHVyZSA9IGRhcy5EQVNGZWF0dXJlO1xuICAgIHZhciBEQVNHcm91cCA9IGRhcy5EQVNHcm91cDtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcbn1cblxuXG5mdW5jdGlvbiBCZWRXaWdQYXJzZXIodHlwZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG59XG5cbkJlZFdpZ1BhcnNlci5wcm90b3R5cGUuY3JlYXRlU2Vzc2lvbiA9IGZ1bmN0aW9uKHNpbmspIHtcbiAgICBpZiAodGhpcy50eXBlID09ICd3aWcnKVxuICAgICAgICByZXR1cm4gbmV3IFdpZ1BhcnNlU2Vzc2lvbih0aGlzLCBzaW5rKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiBuZXcgQmVkUGFyc2VTZXNzaW9uKHRoaXMsIHNpbmspO1xufVxuXG52YXIgX19LVl9SRUdFWFA9LyhbXj1dKyk9KC4rKS87XG52YXIgX19TUEFDRV9SRUdFWFA9L1xccy87XG52YXIgQkVEX0NPTE9SX1JFR0VYUCA9IG5ldyBSZWdFeHAoXCJeWzAtOV0rLFswLTldKyxbMC05XStcIik7XG5cbmZ1bmN0aW9uIEJlZFBhcnNlU2Vzc2lvbihwYXJzZXIsIHNpbmspIHtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB0aGlzLnNpbmsgPSBzaW5rO1xufVxuXG5CZWRQYXJzZVNlc3Npb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24obGluZSkge1xuICAgIHZhciB0b2tzID0gbGluZS5zcGxpdChfX1NQQUNFX1JFR0VYUCk7XG4gICAgaWYgKHRva3MubGVuZ3RoIDwgMylcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHN0YXJ0ID0gcGFyc2VJbnQodG9rc1sxXSkgKyAxO1xuICAgIHZhciBlbmQgPSBwYXJzZUludCh0b2tzWzJdKTtcblxuICAgIHZhciBmID0ge3NlZ21lbnQ6IHRva3NbMF0sIFxuICAgICAgICAgICAgIG1pbjogc3RhcnQsXG4gICAgICAgICAgICAgbWF4OiBlbmR9O1xuXG4gICAgaWYgKHRva3MubGVuZ3RoID4gMyAmJiB0b2tzWzNdICE9PSAnLicpIHtcbiAgICAgICAgZi5sYWJlbCA9IHRva3NbM107XG4gICAgfVxuXG4gICAgaWYgKHRva3MubGVuZ3RoID4gNCkge1xuICAgICAgICBmLnNjb3JlID0gcGFyc2VGbG9hdCh0b2tzWzRdKVxuICAgIH1cblxuICAgIGlmICh0b2tzLmxlbmd0aCA+IDUpIHtcbiAgICAgICAgZi5vcmllbnRhdGlvbiA9IHRva3NbNV07XG4gICAgfVxuXG4gICAgaWYgKHRva3MubGVuZ3RoID4gOCkge1xuICAgICAgICB2YXIgY29sb3IgPSB0b2tzWzhdO1xuICAgICAgICBpZiAoQkVEX0NPTE9SX1JFR0VYUC50ZXN0KGNvbG9yKSkge1xuICAgICAgICAgICAgZi5pdGVtUmdiID0gJ3JnYignICsgY29sb3IgKyAnKSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rcy5sZW5ndGggPj0gMTIpIHtcbiAgICAgICAgdmFyIHRoaWNrU3RhcnQgPSBwYXJzZUludCh0b2tzWzZdKTtcbiAgICAgICAgdmFyIHRoaWNrRW5kICAgPSBwYXJzZUludCh0b2tzWzddKTtcbiAgICAgICAgdmFyIGJsb2NrQ291bnQgPSBwYXJzZUludCh0b2tzWzldKTtcbiAgICAgICAgdmFyIGJsb2NrU2l6ZXMgPSB0b2tzWzEwXS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbih4KSB7cmV0dXJuIHBhcnNlSW50KHgpfSk7XG4gICAgICAgIHZhciBibG9ja1N0YXJ0cyA9IHRva3NbMTFdLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uKHgpIHtyZXR1cm4gcGFyc2VJbnQoeCl9KTtcblxuICAgICAgICBmLnR5cGUgPSAndHJhbnNjcmlwdCdcbiAgICAgICAgdmFyIGdycCA9IG5ldyBEQVNHcm91cCgpO1xuICAgICAgICBncnAuaWQgPSB0b2tzWzNdO1xuICAgICAgICBncnAudHlwZSA9ICd0cmFuc2NyaXB0J1xuICAgICAgICBncnAubm90ZXMgPSBbXTtcbiAgICAgICAgZi5ncm91cHMgPSBbZ3JwXTtcblxuICAgICAgICBpZiAodG9rcy5sZW5ndGggPiAxMikge1xuICAgICAgICAgICAgdmFyIGdlbmVJZCA9IHRva3NbMTJdO1xuICAgICAgICAgICAgdmFyIGdlbmVOYW1lID0gZ2VuZUlkO1xuICAgICAgICAgICAgaWYgKHRva3MubGVuZ3RoID4gMTMpIHtcbiAgICAgICAgICAgICAgICBnZW5lTmFtZSA9IHRva3NbMTNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdnID0gbmV3IERBU0dyb3VwKCk7XG4gICAgICAgICAgICBnZy5pZCA9IGdlbmVJZDtcbiAgICAgICAgICAgIGdnLmxhYmVsID0gZ2VuZU5hbWU7XG4gICAgICAgICAgICBnZy50eXBlID0gJ2dlbmUnO1xuICAgICAgICAgICAgZi5ncm91cHMucHVzaChnZyk7XG4gICAgICAgIH0gIFxuXG4gICAgICAgIHZhciBzcGFucyA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmxvY2tDb3VudDsgKytiKSB7XG4gICAgICAgICAgICB2YXIgYm1pbiA9IGJsb2NrU3RhcnRzW2JdICsgc3RhcnQ7XG4gICAgICAgICAgICB2YXIgYm1heCA9IGJtaW4gKyBibG9ja1NpemVzW2JdO1xuICAgICAgICAgICAgdmFyIHNwYW4gPSBuZXcgUmFuZ2UoYm1pbiwgYm1heCk7XG4gICAgICAgICAgICBpZiAoc3BhbnMpIHtcbiAgICAgICAgICAgICAgICBzcGFucyA9IHVuaW9uKHNwYW5zLCBzcGFuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3BhbnMgPSBzcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgdHNMaXN0ID0gc3BhbnMucmFuZ2VzKCk7XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgdHNMaXN0Lmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICB2YXIgdHMgPSB0c0xpc3Rbc107XG4gICAgICAgICAgICB2YXIgYmYgPSBzaGFsbG93Q29weShmKTtcbiAgICAgICAgICAgIGJmLm1pbiA9IHRzLm1pbigpO1xuICAgICAgICAgICAgYmYubWF4ID0gdHMubWF4KCk7XG4gICAgICAgICAgICB0aGlzLnNpbmsoYmYpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaWNrRW5kID4gdGhpY2tTdGFydCkge1xuICAgICAgICAgICAgdmFyIGNvZGluZ1JlZ2lvbiA9IChmLm9yaWVudGF0aW9uID09ICcrJykgPyBcbiAgICAgICAgICAgICAgICBuZXcgUmFuZ2UodGhpY2tTdGFydCwgdGhpY2tFbmQgKyAzKSA6IFxuICAgICAgICAgICAgICAgIG5ldyBSYW5nZSh0aGlja1N0YXJ0IC0gMywgdGhpY2tFbmQpO1xuICAgICAgICAgICAgICAgIC8vICsvLSAzIHRvIGFjY291bnQgZm9yIHN0b3AgY29kb25cblxuICAgICAgICAgICAgdmFyIHRsID0gaW50ZXJzZWN0aW9uKHNwYW5zLCBjb2RpbmdSZWdpb24pO1xuICAgICAgICAgICAgaWYgKHRsKSB7XG4gICAgICAgICAgICAgICAgZi50eXBlID0gJ3RyYW5zbGF0aW9uJztcbiAgICAgICAgICAgICAgICB2YXIgdGxMaXN0ID0gdGwucmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlYWRpbmdGcmFtZSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCB0bExpc3QubGVuZ3RoOyArK3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjb3JkIHJlYWRpbmcgZnJhbWUgZm9yIGV2ZXJ5IGV4b25cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYub3JpZW50YXRpb24gPT0gJy0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0bExpc3QubGVuZ3RoIC0gcyAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cyA9IHRsTGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiZiA9IHNoYWxsb3dDb3B5KGYpO1xuICAgICAgICAgICAgICAgICAgICBiZi5taW4gPSB0cy5taW4oKTtcbiAgICAgICAgICAgICAgICAgICAgYmYubWF4ID0gdHMubWF4KCk7XG4gICAgICAgICAgICAgICAgICAgIGYucmVhZGZyYW1lID0gcmVhZGluZ0ZyYW1lO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdHMubWF4KCkgLSB0cy5taW4oKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZ0ZyYW1lID0gKHJlYWRpbmdGcmFtZSArIGxlbmd0aCkgJSAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpbmsoYmYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2luayhmKTtcbiAgICB9XG59XG5cbkJlZFBhcnNlU2Vzc2lvbi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHt9O1xuXG5mdW5jdGlvbiBXaWdQYXJzZVNlc3Npb24ocGFyc2VyLCBzaW5rKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5zaW5rID0gc2luaztcbiAgICB0aGlzLndpZ1N0YXRlID0gbnVsbDtcbn1cblxuV2lnUGFyc2VTZXNzaW9uLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB2YXIgdG9rcyA9IGxpbmUuc3BsaXQoX19TUEFDRV9SRUdFWFApO1xuXG4gICAgaWYgKHRva3NbMF0gPT0gJ2ZpeGVkU3RlcCcpIHtcbiAgICAgICAgdGhpcy53aWdTdGF0ZSA9ICdmaXhlZFN0ZXAnO1xuICAgICAgICB0aGlzLmNociA9IHRoaXMucG9zID0gdGhpcy5zdGVwID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcGFuID0gMTtcblxuICAgICAgICBmb3IgKHZhciB0aSA9IDE7IHRpIDwgdG9rcy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgIHZhciBtID0gX19LVl9SRUdFWFAuZXhlYyh0b2tzW3RpXSk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGlmIChtWzFdID09ICdjaHJvbScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaHIgPSBtWzJdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobVsxXSA9PSAnc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9zID0gcGFyc2VJbnQobVsyXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtWzFdID09ICdzdGVwJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0ZXAgPSBwYXJzZUludChtWzJdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1bMV0gPT0gJ3NwYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BhbiA9IHBhcnNlSW50KG1bMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rc1swXSA9PSAndmFyaWFibGVTdGVwJykge1xuICAgICAgICB0aGlzLndpZ1N0YXRlID0gJ3ZhcmlhYmxlU3RlcCc7XG4gICAgICAgIHRoaXMuY2hyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zcGFuID0gMTtcblxuICAgICAgICBmb3IgKHZhciB0aSA9IDE7IHRpIDwgdG9rcy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgIHZhciBtID0gX19LVl9SRUdFWFAuZXhlYyh0b2tzW3RpXSk7XG4gICAgICAgICAgICBpZiAobVsxXSA9PSAnY2hyb20nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaHIgPSBtWzJdO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtWzFdID09ICdzcGFuJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BhbiA9IHBhcnNlSW50KG1bMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLndpZ1N0YXRlKSB7XG4gICAgICAgICAgICBpZiAodG9rcy5sZW5ndGggPCA0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIGYgPSB7c2VnbWVudDogdG9rc1swXSwgXG4gICAgICAgICAgICAgICAgICAgICBtaW46IHBhcnNlSW50KHRva3NbMV0pICsgMSwgXG4gICAgICAgICAgICAgICAgICAgICBtYXg6IHBhcnNlSW50KHRva3NbMl0pLFxuICAgICAgICAgICAgICAgICAgICAgc2NvcmU6IHBhcnNlRmxvYXQodG9rc1szXSl9O1xuXG4gICAgICAgICAgICB0aGlzLnNpbmsoZik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy53aWdTdGF0ZSA9PSAnZml4ZWRTdGVwJykge1xuICAgICAgICAgICAgaWYgKHRva3MubGVuZ3RoICE9IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHNjb3JlID0gcGFyc2VGbG9hdCh0b2tzWzBdKTtcbiAgICAgICAgICAgIHZhciBmID0ge3NlZ21lbnQ6IHRoaXMuY2hyLCBtaW46IHRoaXMucG9zLCBtYXg6IHRoaXMucG9zICsgdGhpcy5zcGFuIC0gMSwgc2NvcmU6IHNjb3JlfTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRoaXMuc3RlcDtcbiAgICAgICAgICAgIHRoaXMuc2luayhmKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLndpZ1N0YXRlID09ICd2YXJpYWJsZVN0ZXAnKSB7XG4gICAgICAgICAgICBpZiAodG9rcy5sZW5ndGggIT0gMilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgcG9zID0gcGFyc2VJbnQodG9rc1swXSk7XG4gICAgICAgICAgICB2YXIgc2NvcmUgPSBwYXJzZUZsb2F0KHRva3NbMV0pO1xuICAgICAgICAgICAgdmFyIGYgPSB7c2VnbWVudDogdGhpcy5jaHIsIG1pbjogcG9zLCBtYXg6IHBvcyArIHRoaXMuc3BhbiAtIDEsIHNjb3JlOiBzY29yZX07XG4gICAgICAgICAgICB0aGlzLnNpbmsoZik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbldpZ1BhcnNlU2Vzc2lvbi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHt9O1xuXG5CZWRXaWdQYXJzZXIucHJvdG90eXBlLmdldFN0eWxlU2hlZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PSAnd2lnJykge1xuICAgICAgICB2YXIgd2lnU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgd2lnU3R5bGUuZ2x5cGggPSAnSElTVE9HUkFNJztcbiAgICAgICAgd2lnU3R5bGUuQkdDT0xPUiA9ICdibHVlJztcbiAgICAgICAgd2lnU3R5bGUuSEVJR0hUPTMwO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB3aWdTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgd2lnU3R5bGUuQkdDT0xPUiA9ICdibHVlJ1xuICAgICAgICB3aWdTdHlsZS5IRUlHSFQgPSA4O1xuICAgICAgICB3aWdTdHlsZS5CVU1QID0gdHJ1ZTtcbiAgICAgICAgd2lnU3R5bGUuTEFCRUwgPSB0cnVlO1xuICAgICAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZWZhdWx0J30sIG51bGwsIHdpZ1N0eWxlKTtcblxuICAgICAgICB2YXIgd2lnU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgd2lnU3R5bGUuZ2x5cGggPSAnQk9YJztcbiAgICAgICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSAncmVkJ1xuICAgICAgICB3aWdTdHlsZS5IRUlHSFQgPSAxMDtcbiAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgIHdpZ1N0eWxlLlpJTkRFWCA9IDIwO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3RyYW5zbGF0aW9uJ30sIG51bGwsIHdpZ1N0eWxlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgdmFyIHRzU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgdHNTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICB0c1N0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgICAgICB0c1N0eWxlLkJHQ09MT1IgPSAnd2hpdGUnO1xuICAgICAgICB0c1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgICAgICB0c1N0eWxlLlpJTkRFWCA9IDEwO1xuICAgICAgICB0c1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgICAgICB0c1N0eWxlLkxBQkVMID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICd0cmFuc2NyaXB0J30sIG51bGwsIHRzU3R5bGUpO1xuXG4gICAgICAgIHZhciBkZW5zU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgZGVuc1N0eWxlLmdseXBoID0gJ0hJU1RPR1JBTSc7XG4gICAgICAgIGRlbnNTdHlsZS5DT0xPUjEgPSAnd2hpdGUnO1xuICAgICAgICBkZW5zU3R5bGUuQ09MT1IyID0gJ2JsYWNrJztcbiAgICAgICAgZGVuc1N0eWxlLkhFSUdIVD0zMDtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZW5zaXR5J30sIG51bGwsIGRlbnNTdHlsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHN0eWxlc2hlZXQpO1xufVxuXG5kYWxsaWFuY2VfcmVnaXN0ZXJQYXJzZXJGYWN0b3J5KCdiZWQnLCBmdW5jdGlvbih0KSB7cmV0dXJuIG5ldyBCZWRXaWdQYXJzZXIodCl9KTtcbmRhbGxpYW5jZV9yZWdpc3RlclBhcnNlckZhY3RvcnkoJ3dpZycsIGZ1bmN0aW9uKHQpIHtyZXR1cm4gbmV3IEJlZFdpZ1BhcnNlcih0KX0pOyIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBiaWd3aWcuanM6IGluZGV4ZWQgYmluYXJ5IFdJRyAoYW5kIEJFRCkgZmlsZXNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHNwYW5zID0gcmVxdWlyZSgnLi9zcGFucycpO1xuICAgIHZhciBSYW5nZSA9IHNwYW5zLlJhbmdlO1xuICAgIHZhciB1bmlvbiA9IHNwYW5zLnVuaW9uO1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBzcGFucy5pbnRlcnNlY3Rpb247XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTRmVhdHVyZSA9IGRhcy5EQVNGZWF0dXJlO1xuICAgIHZhciBEQVNHcm91cCA9IGRhcy5EQVNHcm91cDtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcblxuICAgIHZhciBiaW4gPSByZXF1aXJlKCcuL2JpbicpO1xuICAgIHZhciByZWFkSW50ID0gYmluLnJlYWRJbnQ7XG5cbiAgICB2YXIganN6bGliID0gcmVxdWlyZSgnanN6bGliJyk7XG4gICAgdmFyIGpzemxpYl9pbmZsYXRlX2J1ZmZlciA9IGpzemxpYi5pbmZsYXRlQnVmZmVyO1xuICAgIHZhciBhcnJheUNvcHkgPSBqc3psaWIuYXJyYXlDb3B5O1xufVxuXG52YXIgQklHX1dJR19NQUdJQyA9IDB4ODg4RkZDMjY7XG52YXIgQklHX1dJR19NQUdJQ19CRSA9IDB4MjZGQzhGODg7XG52YXIgQklHX0JFRF9NQUdJQyA9IDB4ODc4OUYyRUI7XG52YXIgQklHX0JFRF9NQUdJQ19CRSA9IDB4RUJGMjg5ODc7XG5cblxudmFyIEJJR19XSUdfVFlQRV9HUkFQSCA9IDE7XG52YXIgQklHX1dJR19UWVBFX1ZTVEVQID0gMjtcbnZhciBCSUdfV0lHX1RZUEVfRlNURVAgPSAzO1xuICBcbnZhciBNMSA9IDI1NjtcbnZhciBNMiA9IDI1NioyNTY7XG52YXIgTTMgPSAyNTYqMjU2KjI1NjtcbnZhciBNNCA9IDI1NioyNTYqMjU2KjI1NjtcblxudmFyIEJFRF9DT0xPUl9SRUdFWFAgPSBuZXcgUmVnRXhwKFwiXlswLTldKyxbMC05XSssWzAtOV0rXCIpO1xuXG5mdW5jdGlvbiBid2dfcmVhZE9mZnNldChiYSwgbykge1xuICAgIHZhciBvZmZzZXQgPSBiYVtvXSArIGJhW28rMV0qTTEgKyBiYVtvKzJdKk0yICsgYmFbbyszXSpNMyArIGJhW28rNF0qTTQ7XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gQmlnV2lnKCkge1xufVxuXG5CaWdXaWcucHJvdG90eXBlLnJlYWRDaHJvbVRyZWUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy5jaHJvbXNUb0lEcyA9IHt9O1xuICAgIHRoaXMuaWRzVG9DaHJvbXMgPSB7fTtcbiAgICB0aGlzLm1heElEID0gMDtcblxuICAgIHZhciB1ZG8gPSB0aGlzLnVuem9vbWVkRGF0YU9mZnNldDtcbiAgICB2YXIgZWIgPSAodWRvIC0gdGhpcy5jaHJvbVRyZWVPZmZzZXQpICYgMztcbiAgICB1ZG8gPSB1ZG8gKyA0IC0gZWI7XG5cbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5jaHJvbVRyZWVPZmZzZXQsIHVkbyAtIHRoaXMuY2hyb21UcmVlT2Zmc2V0KS5mZXRjaChmdW5jdGlvbihicHQpIHtcbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoYnB0KTtcbiAgICAgICAgdmFyIHNhID0gbmV3IEludDE2QXJyYXkoYnB0KTtcbiAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkoYnB0KTtcbiAgICAgICAgdmFyIGJwdE1hZ2ljID0gbGFbMF07XG4gICAgICAgIHZhciBibG9ja1NpemUgPSBsYVsxXTtcbiAgICAgICAgdmFyIGtleVNpemUgPSBsYVsyXTtcbiAgICAgICAgdmFyIHZhbFNpemUgPSBsYVszXTtcbiAgICAgICAgdmFyIGl0ZW1Db3VudCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCAxNik7XG4gICAgICAgIHZhciByb290Tm9kZU9mZnNldCA9IDMyO1xuXG4gICAgICAgIHZhciBicHRSZWFkTm9kZSA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICAgICAgdmFyIG5vZGVUeXBlID0gYmFbb2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBjbnQgPSBzYVsob2Zmc2V0LzIpICsgMV07XG4gICAgICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY250OyArK24pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0ga2V5U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICAgICAgICAgICAgICBjaGlsZE9mZnNldCAtPSB0aGlzQi5jaHJvbVRyZWVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJwdFJlYWROb2RlKGNoaWxkT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtpID0gMDsga2kgPCBrZXlTaXplOyArK2tpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBiYVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hyb21JZCA9IChiYVtvZmZzZXQrM108PDI0KSB8IChiYVtvZmZzZXQrMl08PDE2KSB8IChiYVtvZmZzZXQrMV08PDgpIHwgKGJhW29mZnNldCswXSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaHJvbVNpemUgPSAoYmFbb2Zmc2V0ICsgN108PDI0KSB8IChiYVtvZmZzZXQrNl08PDE2KSB8IChiYVtvZmZzZXQrNV08PDgpIHwgKGJhW29mZnNldCs0XSk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSA4O1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLmNocm9tc1RvSURzW2tleV0gPSBjaHJvbUlkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ2NocicpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmNocm9tc1RvSURzW2tleS5zdWJzdHIoMyldID0gY2hyb21JZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzQi5pZHNUb0Nocm9tc1tjaHJvbUlkXSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IubWF4SUQgPSBNYXRoLm1heCh0aGlzQi5tYXhJRCwgY2hyb21JZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBicHRSZWFkTm9kZShyb290Tm9kZU9mZnNldCk7XG5cbiAgICAgICAgY2FsbGJhY2sodGhpc0IpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBCaWdXaWdWaWV3KGJ3ZywgY2lyVHJlZU9mZnNldCwgY2lyVHJlZUxlbmd0aCwgaXNTdW1tYXJ5KSB7XG4gICAgdGhpcy5id2cgPSBid2c7XG4gICAgdGhpcy5jaXJUcmVlT2Zmc2V0ID0gY2lyVHJlZU9mZnNldDtcbiAgICB0aGlzLmNpclRyZWVMZW5ndGggPSBjaXJUcmVlTGVuZ3RoO1xuICAgIHRoaXMuaXNTdW1tYXJ5ID0gaXNTdW1tYXJ5O1xufVxuXG5cblxuQmlnV2lnVmlldy5wcm90b3R5cGUucmVhZFdpZ0RhdGEgPSBmdW5jdGlvbihjaHJOYW1lLCBtaW4sIG1heCwgY2FsbGJhY2spIHtcbiAgICB2YXIgY2hyID0gdGhpcy5id2cuY2hyb21zVG9JRHNbY2hyTmFtZV07XG4gICAgaWYgKGNociA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vdCBhbiBlcnJvciBiZWNhdXNlIHNvbWUgLmJ3Z3Mgd29uJ3QgaGF2ZSBkYXRhIGZvciBhbGwgY2hyb21vc29tZXMuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkV2lnRGF0YUJ5SWQoY2hyLCBtaW4sIG1heCwgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuQmlnV2lnVmlldy5wcm90b3R5cGUucmVhZFdpZ0RhdGFCeUlkID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIGlmICghdGhpcy5jaXJIZWFkZXIpIHtcbiAgICAgICAgdGhpcy5id2cuZGF0YS5zbGljZSh0aGlzLmNpclRyZWVPZmZzZXQsIDQ4KS5mZXRjaChmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXNCLmNpckhlYWRlciA9IHJlc3VsdDtcbiAgICAgICAgICAgIHZhciBsYSA9IG5ldyBJbnQzMkFycmF5KHRoaXNCLmNpckhlYWRlcik7XG4gICAgICAgICAgICB0aGlzQi5jaXJCbG9ja1NpemUgPSBsYVsxXTtcbiAgICAgICAgICAgIHRoaXNCLnJlYWRXaWdEYXRhQnlJZChjaHIsIG1pbiwgbWF4LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJsb2Nrc1RvRmV0Y2ggPSBbXTtcbiAgICB2YXIgb3V0c3RhbmRpbmcgPSAwO1xuXG4gICAgdmFyIGJlZm9yZUJXRyA9IERhdGUubm93KCk7XG5cbiAgICB2YXIgZmlsdGVyID0gZnVuY3Rpb24oY2hyb21JZCwgZm1pbiwgZm1heCwgdG9rcykge1xuICAgICAgICByZXR1cm4gKChjaHIgPCAwIHx8IGNocm9tSWQgPT0gY2hyKSAmJiBmbWluIDw9IG1heCAmJiBmbWF4ID49IG1pbik7XG4gICAgfVxuXG4gICAgdmFyIGNpckZvYlJlY3VyID0gZnVuY3Rpb24ob2Zmc2V0LCBsZXZlbCkge1xuICAgICAgICBpZiAodGhpc0IuYndnLmluc3RydW1lbnQpXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbGV2ZWw9JyArIGxldmVsICsgJzsgb2Zmc2V0PScgKyBvZmZzZXQgKyAnOyB0aW1lPScgKyAoRGF0ZS5ub3coKXwwKSk7XG5cbiAgICAgICAgb3V0c3RhbmRpbmcgKz0gb2Zmc2V0Lmxlbmd0aDtcblxuICAgICAgICBpZiAob2Zmc2V0Lmxlbmd0aCA9PSAxICYmIG9mZnNldFswXSAtIHRoaXNCLmNpclRyZWVPZmZzZXQgPT0gNDggJiYgdGhpc0IuY2FjaGVkQ2lyUm9vdCkge1xuICAgICAgICAgICAgY2lyRm9iUmVjdXIyKHRoaXNCLmNhY2hlZENpclJvb3QsIDAsIGxldmVsKTtcbiAgICAgICAgICAgIC0tb3V0c3RhbmRpbmc7XG4gICAgICAgICAgICBpZiAob3V0c3RhbmRpbmcgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXNCLmZldGNoRmVhdHVyZXMoZmlsdGVyLCBibG9ja3NUb0ZldGNoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWF4Q2lyQmxvY2tTcGFuID0gNCArICAodGhpc0IuY2lyQmxvY2tTaXplICogMzIpOyAgIC8vIFVwcGVyIGJvdW5kIG9uIHNpemUsIGJhc2VkIG9uIGEgY29tcGxldGVseSBmdWxsIGxlYWYgbm9kZS5cbiAgICAgICAgdmFyIHNwYW5zO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGJsb2NrU3BhbiA9IG5ldyBSYW5nZShvZmZzZXRbaV0sIG9mZnNldFtpXSArIG1heENpckJsb2NrU3Bhbik7XG4gICAgICAgICAgICBzcGFucyA9IHNwYW5zID8gdW5pb24oc3BhbnMsIGJsb2NrU3BhbikgOiBibG9ja1NwYW47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBmZXRjaFJhbmdlcyA9IHNwYW5zLnJhbmdlcygpO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IGZldGNoUmFuZ2VzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgICAgICB2YXIgZnIgPSBmZXRjaFJhbmdlc1tyXTtcbiAgICAgICAgICAgIGNpckZvYlN0YXJ0RmV0Y2gob2Zmc2V0LCBmciwgbGV2ZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNpckZvYlN0YXJ0RmV0Y2ggPSBmdW5jdGlvbihvZmZzZXQsIGZyLCBsZXZlbCwgYXR0ZW1wdHMpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGZyLm1heCgpIC0gZnIubWluKCk7XG4gICAgICAgIHRoaXNCLmJ3Zy5kYXRhLnNsaWNlKGZyLm1pbigpLCBmci5tYXgoKSAtIGZyLm1pbigpKS5mZXRjaChmdW5jdGlvbihyZXN1bHRCdWZmZXIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2Zmc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyLmNvbnRhaW5zKG9mZnNldFtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2lyRm9iUmVjdXIyKHJlc3VsdEJ1ZmZlciwgb2Zmc2V0W2ldIC0gZnIubWluKCksIGxldmVsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAob2Zmc2V0W2ldIC0gdGhpc0IuY2lyVHJlZU9mZnNldCA9PSA0OCAmJiBvZmZzZXRbaV0gLSBmci5taW4oKSA9PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IuY2FjaGVkQ2lyUm9vdCA9IHJlc3VsdEJ1ZmZlcjtcblxuICAgICAgICAgICAgICAgICAgICAtLW91dHN0YW5kaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0c3RhbmRpbmcgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IuZmV0Y2hGZWF0dXJlcyhmaWx0ZXIsIGJsb2Nrc1RvRmV0Y2gsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNpckZvYlJlY3VyMiA9IGZ1bmN0aW9uKGNpckJsb2NrRGF0YSwgb2Zmc2V0LCBsZXZlbCkge1xuICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShjaXJCbG9ja0RhdGEpO1xuICAgICAgICB2YXIgc2EgPSBuZXcgSW50MTZBcnJheShjaXJCbG9ja0RhdGEpO1xuICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheShjaXJCbG9ja0RhdGEpO1xuXG4gICAgICAgIHZhciBpc0xlYWYgPSBiYVtvZmZzZXRdO1xuICAgICAgICB2YXIgY250ID0gc2Fbb2Zmc2V0LzIgKyAxXTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgICAgaWYgKGlzTGVhZiAhPSAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvID0gb2Zmc2V0LzQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q2hyb20gPSBsYVtsb107XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0QmFzZSA9IGxhW2xvICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGVuZENocm9tID0gbGFbbG8gKyAyXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQmFzZSA9IGxhW2xvICsgM107XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIG9mZnNldCsxNik7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCBvZmZzZXQrMjQpO1xuICAgICAgICAgICAgICAgIGlmICgoKGNociA8IDAgfHwgc3RhcnRDaHJvbSA8IGNocikgfHwgKHN0YXJ0Q2hyb20gPT0gY2hyICYmIHN0YXJ0QmFzZSA8PSBtYXgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoKGNociA8IDAgfHwgZW5kQ2hyb20gICA+IGNocikgfHwgKGVuZENocm9tID09IGNociAmJiBlbmRCYXNlID49IG1pbikpKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzVG9GZXRjaC5wdXNoKHtvZmZzZXQ6IGJsb2NrT2Zmc2V0LCBzaXplOiBibG9ja1NpemV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDMyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlY3VyT2Zmc2V0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBsbyA9IG9mZnNldC80O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydENocm9tID0gbGFbbG9dO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEJhc2UgPSBsYVtsbyArIDFdO1xuICAgICAgICAgICAgICAgIHZhciBlbmRDaHJvbSA9IGxhW2xvICsgMl07XG4gICAgICAgICAgICAgICAgdmFyIGVuZEJhc2UgPSBsYVtsbyArIDNdO1xuICAgICAgICAgICAgICAgIHZhciBibG9ja09mZnNldCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCBvZmZzZXQrMTYpO1xuICAgICAgICAgICAgICAgIGlmICgoY2hyIDwgMCB8fCBzdGFydENocm9tIDwgY2hyIHx8IChzdGFydENocm9tID09IGNociAmJiBzdGFydEJhc2UgPD0gbWF4KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNociA8IDAgfHwgZW5kQ2hyb20gICA+IGNociB8fCAoZW5kQ2hyb20gPT0gY2hyICYmIGVuZEJhc2UgPj0gbWluKSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZWN1ck9mZnNldHMucHVzaChibG9ja09mZnNldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSAyNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZWN1ck9mZnNldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNpckZvYlJlY3VyKHJlY3VyT2Zmc2V0cywgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBjaXJGb2JSZWN1cihbdGhpc0IuY2lyVHJlZU9mZnNldCArIDQ4XSwgMSk7XG59XG5cblxuQmlnV2lnVmlldy5wcm90b3R5cGUuZmV0Y2hGZWF0dXJlcyA9IGZ1bmN0aW9uKGZpbHRlciwgYmxvY2tzVG9GZXRjaCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgYmxvY2tzVG9GZXRjaC5zb3J0KGZ1bmN0aW9uKGIwLCBiMSkge1xuICAgICAgICByZXR1cm4gKGIwLm9mZnNldHwwKSAtIChiMS5vZmZzZXR8MCk7XG4gICAgfSk7XG5cbiAgICBpZiAoYmxvY2tzVG9GZXRjaC5sZW5ndGggPT0gMCkge1xuICAgICAgICBjYWxsYmFjayhbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgICAgIHZhciBjcmVhdGVGZWF0dXJlID0gZnVuY3Rpb24oY2hyLCBmbWluLCBmbWF4LCBvcHRzKSB7XG4gICAgICAgICAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGYgPSBuZXcgREFTRmVhdHVyZSgpO1xuICAgICAgICAgICAgZi5fY2hyb21JZCA9IGNocjtcbiAgICAgICAgICAgIGYuc2VnbWVudCA9IHRoaXNCLmJ3Zy5pZHNUb0Nocm9tc1tjaHJdO1xuICAgICAgICAgICAgZi5taW4gPSBmbWluO1xuICAgICAgICAgICAgZi5tYXggPSBmbWF4O1xuICAgICAgICAgICAgZi50eXBlID0gdGhpc0IuYndnLnR5cGU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gb3B0cykge1xuICAgICAgICAgICAgICAgIGZba10gPSBvcHRzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB0cmFtcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGJsb2Nrc1RvRmV0Y2gubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYWZ0ZXJCV0cgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIC8vIGRsb2coJ0JXRyBmZXRjaCB0b29rICcgKyAoYWZ0ZXJCV0cgLSBiZWZvcmVCV0cpICsgJ21zJyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmVhdHVyZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgIC8vIGp1c3QgaW4gY2FzZS4uLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBibG9ja3NUb0ZldGNoWzBdO1xuICAgICAgICAgICAgICAgIGlmIChibG9jay5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnBhcnNlRmVhdHVyZXMoYmxvY2suZGF0YSwgY3JlYXRlRmVhdHVyZSwgZmlsdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzVG9GZXRjaC5zcGxpY2UoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW1wKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZldGNoU3RhcnQgPSBibG9jay5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZXRjaFNpemUgPSBibG9jay5zaXplO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmkgPSAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYmkgPCBibG9ja3NUb0ZldGNoLmxlbmd0aCAmJiBibG9ja3NUb0ZldGNoW2JpXS5vZmZzZXQgPT0gKGZldGNoU3RhcnQgKyBmZXRjaFNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZXRjaFNpemUgKz0gYmxvY2tzVG9GZXRjaFtiaV0uc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrYmk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzQi5id2cuZGF0YS5zbGljZShmZXRjaFN0YXJ0LCBmZXRjaFNpemUpLmZldGNoKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG9mZnNldCA8IGZldGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYiA9IGJsb2Nrc1RvRmV0Y2hbYmldO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNCLmJ3Zy51bmNvbXByZXNzQnVmU2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGpzemxpYl9pbmZsYXRlX2J1ZmZlcihyZXN1bHQsIG9mZnNldCArIDIsIGZiLnNpemUgLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoZmIuc2l6ZSk7ICAgIC8vIEZJWE1FIGlzIHRoaXMgcmVhbGx5IHRoZSBiZXN0IHdlIGNhbiBkbz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXlDb3B5KG5ldyBVaW50OEFycmF5KHJlc3VsdCwgb2Zmc2V0LCBmYi5zaXplKSwgMCwgdG1wLCAwLCBmYi5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHRtcC5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZiLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBmYi5zaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrYmk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFtcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJhbXAoKTtcbiAgICB9XG59XG5cbkJpZ1dpZ1ZpZXcucHJvdG90eXBlLnBhcnNlRmVhdHVyZXMgPSBmdW5jdGlvbihkYXRhLCBjcmVhdGVGZWF0dXJlLCBmaWx0ZXIpIHtcbiAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcblxuICAgIGlmICh0aGlzLmlzU3VtbWFyeSkge1xuICAgICAgICB2YXIgc2EgPSBuZXcgSW50MTZBcnJheShkYXRhKTtcbiAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkoZGF0YSk7XG4gICAgICAgIHZhciBmYSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG5cbiAgICAgICAgdmFyIGl0ZW1Db3VudCA9IGRhdGEuYnl0ZUxlbmd0aC8zMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIGNocm9tSWQgPSAgIGxhWyhpKjgpXTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9ICAgICBsYVsoaSo4KSsxXTtcbiAgICAgICAgICAgIHZhciBlbmQgPSAgICAgICBsYVsoaSo4KSsyXTtcbiAgICAgICAgICAgIHZhciB2YWxpZENudCA9ICBsYVsoaSo4KSszXTtcbiAgICAgICAgICAgIHZhciBtaW5WYWwgICAgPSBmYVsoaSo4KSs0XTtcbiAgICAgICAgICAgIHZhciBtYXhWYWwgICAgPSBmYVsoaSo4KSs1XTtcbiAgICAgICAgICAgIHZhciBzdW1EYXRhICAgPSBmYVsoaSo4KSs2XTtcbiAgICAgICAgICAgIHZhciBzdW1TcURhdGEgPSBmYVsoaSo4KSs3XTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGZpbHRlcihjaHJvbUlkLCBzdGFydCArIDEsIGVuZCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtbWFyeU9wdHMgPSB7dHlwZTogJ2JpZ3dpZycsIHNjb3JlOiBzdW1EYXRhL3ZhbGlkQ250LCBtYXhTY29yZTogbWF4VmFsfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5id2cudHlwZSA9PSAnYmlnYmVkJykge1xuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5T3B0cy50eXBlID0gJ2RlbnNpdHknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjcmVhdGVGZWF0dXJlKGNocm9tSWQsIHN0YXJ0ICsgMSwgZW5kLCBzdW1tYXJ5T3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYndnLnR5cGUgPT0gJ2JpZ3dpZycpIHtcbiAgICAgICAgdmFyIHNhID0gbmV3IEludDE2QXJyYXkoZGF0YSk7XG4gICAgICAgIHZhciBsYSA9IG5ldyBJbnQzMkFycmF5KGRhdGEpO1xuICAgICAgICB2YXIgZmEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEpO1xuXG4gICAgICAgIHZhciBjaHJvbUlkID0gbGFbMF07XG4gICAgICAgIHZhciBibG9ja1N0YXJ0ID0gbGFbMV07XG4gICAgICAgIHZhciBibG9ja0VuZCA9IGxhWzJdO1xuICAgICAgICB2YXIgaXRlbVN0ZXAgPSBsYVszXTtcbiAgICAgICAgdmFyIGl0ZW1TcGFuID0gbGFbNF07XG4gICAgICAgIHZhciBibG9ja1R5cGUgPSBiYVsyMF07XG4gICAgICAgIHZhciBpdGVtQ291bnQgPSBzYVsxMV07XG4gICAgICAgIFxuICAgICAgICBpZiAoYmxvY2tUeXBlID09IEJJR19XSUdfVFlQRV9GU1RFUCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtQ291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IGZhW2kgKyA2XTtcbiAgICAgICAgICAgICAgICB2YXIgZm1pbiA9IGJsb2NrU3RhcnQgKyAoaSppdGVtU3RlcCkgKyAxLCBmbWF4ID0gYmxvY2tTdGFydCArIChpKml0ZW1TdGVwKSArIGl0ZW1TcGFuO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXIoY2hyb21JZCwgZm1pbiwgZm1heCkpXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZlYXR1cmUoY2hyb21JZCwgZm1pbiwgZm1heCwge3Njb3JlOiBzY29yZX0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGJsb2NrVHlwZSA9PSBCSUdfV0lHX1RZUEVfVlNURVApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbUNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBsYVsoaSoyKSArIDZdICsgMTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBpdGVtU3BhbiAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIHNjb3JlID0gZmFbKGkqMikgKyA3XTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKGNocm9tSWQsIHN0YXJ0LCBlbmQpKVxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGZWF0dXJlKGNocm9tSWQsIHN0YXJ0LCBlbmQsIHtzY29yZTogc2NvcmV9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChibG9ja1R5cGUgPT0gQklHX1dJR19UWVBFX0dSQVBIKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1Db3VudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gbGFbKGkqMykgKyA2XSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCAgID0gbGFbKGkqMykgKyA3XTtcbiAgICAgICAgICAgICAgICB2YXIgc2NvcmUgPSBmYVsoaSozKSArIDhdO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcihjaHJvbUlkLCBzdGFydCwgZW5kKSlcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRmVhdHVyZShjaHJvbUlkLCBzdGFydCwgZW5kLCB7c2NvcmU6IHNjb3JlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQ3VycmVudGx5IG5vdCBoYW5kbGluZyBid2dUeXBlPScgKyBibG9ja1R5cGUpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmJ3Zy50eXBlID09ICdiaWdiZWQnKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB2YXIgZGZjID0gdGhpcy5id2cuZGVmaW5lZEZpZWxkQ291bnQ7XG4gICAgICAgIHZhciBzY2hlbWEgPSB0aGlzLmJ3Zy5zY2hlbWE7XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGJhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNocm9tSWQgPSAoYmFbb2Zmc2V0KzNdPDwyNCkgfCAoYmFbb2Zmc2V0KzJdPDwxNikgfCAoYmFbb2Zmc2V0KzFdPDw4KSB8IChiYVtvZmZzZXQrMF0pO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gKGJhW29mZnNldCs3XTw8MjQpIHwgKGJhW29mZnNldCs2XTw8MTYpIHwgKGJhW29mZnNldCs1XTw8OCkgfCAoYmFbb2Zmc2V0KzRdKTtcbiAgICAgICAgICAgIHZhciBlbmQgPSAoYmFbb2Zmc2V0KzExXTw8MjQpIHwgKGJhW29mZnNldCsxMF08PDE2KSB8IChiYVtvZmZzZXQrOV08PDgpIHwgKGJhW29mZnNldCs4XSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTI7XG4gICAgICAgICAgICB2YXIgcmVzdCA9ICcnO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSBiYVtvZmZzZXQrK107XG4gICAgICAgICAgICAgICAgaWYgKGNoICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmZWF0dXJlT3B0cyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYmVkQ29sdW1ucztcbiAgICAgICAgICAgIGlmIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBiZWRDb2x1bW5zID0gcmVzdC5zcGxpdCgnXFx0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJlZENvbHVtbnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZWRDb2x1bW5zLmxlbmd0aCA+IDAgJiYgZGZjID4gMykge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLmxhYmVsID0gYmVkQ29sdW1uc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiZWRDb2x1bW5zLmxlbmd0aCA+IDEgJiYgZGZjID4gNCkge1xuICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IHBhcnNlSW50KGJlZENvbHVtbnNbMV0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4oc2NvcmUpKVxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlT3B0cy5zY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZENvbHVtbnMubGVuZ3RoID4gMiAmJiBkZmMgPiA1KSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZU9wdHMub3JpZW50YXRpb24gPSBiZWRDb2x1bW5zWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZENvbHVtbnMubGVuZ3RoID4gNSAmJiBkZmMgPiA4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gYmVkQ29sdW1uc1s1XTtcbiAgICAgICAgICAgICAgICBpZiAoQkVEX0NPTE9SX1JFR0VYUC50ZXN0KGNvbG9yKSkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlT3B0cy5pdGVtUmdiID0gJ3JnYignICsgY29sb3IgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmVkQ29sdW1ucy5sZW5ndGggPiBkZmMtMyAmJiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjb2wgPSBkZmMgLSAzOyBjb2wgPCBiZWRDb2x1bW5zLmxlbmd0aDsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU9wdHNbc2NoZW1hLmZpZWxkc1tjb2wrM10ubmFtZV0gPSBiZWRDb2x1bW5zW2NvbF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlsdGVyKGNocm9tSWQsIHN0YXJ0ICsgMSwgZW5kLCBiZWRDb2x1bW5zKSkge1xuICAgICAgICAgICAgICAgIGlmIChkZmMgPCAxMikge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVGZWF0dXJlKGNocm9tSWQsIHN0YXJ0ICsgMSwgZW5kLCBmZWF0dXJlT3B0cyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoaWNrU3RhcnQgPSBiZWRDb2x1bW5zWzNdfDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGlja0VuZCAgID0gYmVkQ29sdW1uc1s0XXwwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tDb3VudCA9IGJlZENvbHVtbnNbNl18MDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZXMgPSBiZWRDb2x1bW5zWzddLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9ja1N0YXJ0cyA9IGJlZENvbHVtbnNbOF0uc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZU9wdHMuZXhvbkZyYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4b25GcmFtZXMgPSBmZWF0dXJlT3B0cy5leG9uRnJhbWVzLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlT3B0cy5leG9uRnJhbWVzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlT3B0cy50eXBlID0gJ3RyYW5zY3JpcHQnXG4gICAgICAgICAgICAgICAgICAgIHZhciBncnAgPSBuZXcgREFTR3JvdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBmZWF0dXJlT3B0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JwW2tdID0gZmVhdHVyZU9wdHNba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JwLmlkID0gYmVkQ29sdW1uc1swXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JwLnNlZ21lbnQgPSB0aGlzLmJ3Zy5pZHNUb0Nocm9tc1tjaHJvbUlkXTtcbiAgICAgICAgICAgICAgICAgICAgZ3JwLm1pbiA9IHN0YXJ0ICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZ3JwLm1heCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZ3JwLm5vdGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLmdyb3VwcyA9IFtncnBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmluZyB0b3dhcmRzIHVzaW5nIGJpZ0dlbmVQcmVkIG1vZGVsLCBidXQgd2lsbFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCBzdXBwb3J0IG9sZCBEYWxsaWFuY2Utc3R5bGUgQkVEMTIrZ2VuZS1uYW1lIGZvciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yZXNlZWFibGUgZnV0dXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoYmVkQ29sdW1ucy5sZW5ndGggPiA5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ2VuZUlkID0gZmVhdHVyZU9wdHMuZ2VuZU5hbWUgfHwgYmVkQ29sdW1uc1s5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZW5lTmFtZSA9IGdlbmVJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZWRDb2x1bW5zLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZU5hbWUgPSBiZWRDb2x1bW5zWzEwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlT3B0cy5nZW5lTmFtZTIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZU5hbWUgPSBmZWF0dXJlT3B0cy5nZW5lTmFtZTI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZyA9IHNoYWxsb3dDb3B5KGdycCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZy5pZCA9IGdlbmVJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdnLmxhYmVsID0gZ2VuZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZy50eXBlID0gJ2dlbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU9wdHMuZ3JvdXBzLnB1c2goZ2cpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW5MaXN0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgYmxvY2tDb3VudDsgKytiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm1pbiA9IChibG9ja1N0YXJ0c1tiXXwwKSArIHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJtYXggPSBibWluICsgKGJsb2NrU2l6ZXNbYl18MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IG5ldyBSYW5nZShibWluLCBibWF4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW5MaXN0LnB1c2goc3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW5zID0gdW5pb24oc3Bhbkxpc3QpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRzTGlzdCA9IHNwYW5zLnJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRzTGlzdC5sZW5ndGg7ICsrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRzID0gdHNMaXN0W3NdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRmVhdHVyZShjaHJvbUlkLCB0cy5taW4oKSArIDEsIHRzLm1heCgpLCBmZWF0dXJlT3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpY2tFbmQgPiB0aGlja1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kaW5nUmVnaW9uID0gKGZlYXR1cmVPcHRzLm9yaWVudGF0aW9uID09ICcrJykgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBSYW5nZSh0aGlja1N0YXJ0LCB0aGlja0VuZCArIDMpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUmFuZ2UodGhpY2tTdGFydCAtIDMsIHRoaWNrRW5kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyArLy0gMyB0byBhY2NvdW50IGZvciBzdG9wIGNvZG9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bCA9IGludGVyc2VjdGlvbihzcGFucywgY29kaW5nUmVnaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLnR5cGUgPSAndHJhbnNsYXRpb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bExpc3QgPSB0bC5yYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZGluZ0ZyYW1lID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRsTGlzdFswXS5taW4oKSA+IHRzTGlzdFt0bE9mZnNldF0ubWF4KCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRsT2Zmc2V0Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBzID0gMDsgcyA8IHRsTGlzdC5sZW5ndGg7ICsrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgcmVhZGluZyBmcmFtZSBmb3IgZXZlcnkgZXhvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZU9wdHMub3JpZW50YXRpb24gPT0gJy0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0bExpc3QubGVuZ3RoIC0gcyAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cyA9IHRsTGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVPcHRzLnJlYWRmcmFtZSA9IHJlYWRpbmdGcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4b25GcmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBicmYgPSBwYXJzZUludChleG9uRnJhbWVzW2luZGV4ICsgdGxPZmZzZXRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoYnJmKSA9PT0gJ251bWJlcicgJiYgYnJmID49IDAgJiYgYnJmIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlT3B0cy5yZWFkZnJhbWUgPSBicmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU9wdHMucmVhZGZyYW1lRXhwbGljaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0cy5tYXgoKSAtIHRzLm1pbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkaW5nRnJhbWUgPSAocmVhZGluZ0ZyYW1lICsgbGVuZ3RoKSAlIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUZlYXR1cmUoY2hyb21JZCwgdHMubWluKCkgKyAxLCB0cy5tYXgoKSwgZmVhdHVyZU9wdHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiRG9uJ3Qga25vdyB3aGF0IHRvIGRvIHdpdGggXCIgKyB0aGlzLmJ3Zy50eXBlKTtcbiAgICB9XG59XG5cbi8vXG4vLyBuYXN0eSBjdXQvcGFzdGUsIHNob3VsZCByb2xsIGJhY2sgaW4hXG4vL1xuXG5CaWdXaWdWaWV3LnByb3RvdHlwZS5nZXRGaXJzdEFkamFjZW50ID0gZnVuY3Rpb24oY2hyTmFtZSwgcG9zLCBkaXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGNociA9IHRoaXMuYndnLmNocm9tc1RvSURzW2Nock5hbWVdO1xuICAgIGlmIChjaHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOb3QgYW4gZXJyb3IgYmVjYXVzZSBzb21lIC5id2dzIHdvbid0IGhhdmUgZGF0YSBmb3IgYWxsIGNocm9tb3NvbWVzLlxuICAgICAgICByZXR1cm4gY2FsbGJhY2soW10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0Rmlyc3RBZGphY2VudEJ5SWQoY2hyLCBwb3MsIGRpciwgY2FsbGJhY2spO1xuICAgIH1cbn1cblxuQmlnV2lnVmlldy5wcm90b3R5cGUuZ2V0Rmlyc3RBZGphY2VudEJ5SWQgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCBjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgaWYgKCF0aGlzLmNpckhlYWRlcikge1xuICAgICAgICB0aGlzLmJ3Zy5kYXRhLnNsaWNlKHRoaXMuY2lyVHJlZU9mZnNldCwgNDgpLmZldGNoKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpc0IuY2lySGVhZGVyID0gcmVzdWx0O1xuICAgICAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkodGhpc0IuY2lySGVhZGVyKTtcbiAgICAgICAgICAgIHRoaXNCLmNpckJsb2NrU2l6ZSA9IGxhWzFdO1xuICAgICAgICAgICAgdGhpc0IuZ2V0Rmlyc3RBZGphY2VudEJ5SWQoY2hyLCBwb3MsIGRpciwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBibG9ja1RvRmV0Y2ggPSBudWxsO1xuICAgIHZhciBiZXN0QmxvY2tDaHIgPSAtMTtcbiAgICB2YXIgYmVzdEJsb2NrT2Zmc2V0ID0gLTE7XG5cbiAgICB2YXIgb3V0c3RhbmRpbmcgPSAwO1xuXG4gICAgdmFyIGJlZm9yZUJXRyA9IERhdGUubm93KCk7XG5cbiAgICB2YXIgY2lyRm9iUmVjdXIgPSBmdW5jdGlvbihvZmZzZXQsIGxldmVsKSB7XG4gICAgICAgIG91dHN0YW5kaW5nICs9IG9mZnNldC5sZW5ndGg7XG5cbiAgICAgICAgdmFyIG1heENpckJsb2NrU3BhbiA9IDQgKyAgKHRoaXNCLmNpckJsb2NrU2l6ZSAqIDMyKTsgICAvLyBVcHBlciBib3VuZCBvbiBzaXplLCBiYXNlZCBvbiBhIGNvbXBsZXRlbHkgZnVsbCBsZWFmIG5vZGUuXG4gICAgICAgIHZhciBzcGFucztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZzZXQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBibG9ja1NwYW4gPSBuZXcgUmFuZ2Uob2Zmc2V0W2ldLCBvZmZzZXRbaV0gKyBtYXhDaXJCbG9ja1NwYW4pO1xuICAgICAgICAgICAgc3BhbnMgPSBzcGFucyA/IHVuaW9uKHNwYW5zLCBibG9ja1NwYW4pIDogYmxvY2tTcGFuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgZmV0Y2hSYW5nZXMgPSBzcGFucy5yYW5nZXMoKTtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBmZXRjaFJhbmdlcy5sZW5ndGg7ICsrcikge1xuICAgICAgICAgICAgdmFyIGZyID0gZmV0Y2hSYW5nZXNbcl07XG4gICAgICAgICAgICBjaXJGb2JTdGFydEZldGNoKG9mZnNldCwgZnIsIGxldmVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaXJGb2JTdGFydEZldGNoID0gZnVuY3Rpb24ob2Zmc2V0LCBmciwgbGV2ZWwsIGF0dGVtcHRzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBmci5tYXgoKSAtIGZyLm1pbigpO1xuICAgICAgICB0aGlzQi5id2cuZGF0YS5zbGljZShmci5taW4oKSwgZnIubWF4KCkgLSBmci5taW4oKSkuZmV0Y2goZnVuY3Rpb24ocmVzdWx0QnVmZmVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9mZnNldC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmIChmci5jb250YWlucyhvZmZzZXRbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNpckZvYlJlY3VyMihyZXN1bHRCdWZmZXIsIG9mZnNldFtpXSAtIGZyLm1pbigpLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgIC0tb3V0c3RhbmRpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRzdGFuZGluZyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJsb2NrVG9GZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwICYmIChjaHIgIT0gMCB8fCBwb3MgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0IuZ2V0Rmlyc3RBZGphY2VudEJ5SWQoMCwgMCwgZGlyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXIgPCAwICYmIChjaHIgIT0gdGhpc0IuYndnLm1heElEIHx8IHBvcyA8IDEwMDAwMDAwMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQi5nZXRGaXJzdEFkamFjZW50QnlJZCh0aGlzQi5id2cubWF4SUQsIDEwMDAwMDAwMDAsIGRpciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5mZXRjaEZlYXR1cmVzKGZ1bmN0aW9uKGNocngsIGZtaW4sIGZtYXgsIHRva3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRpciA8IDAgJiYgKGNocnggPCBjaHIgfHwgZm1heCA8IHBvcykpIHx8IChkaXIgPiAwICYmIChjaHJ4ID4gY2hyIHx8IGZtaW4gPiBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFtibG9ja1RvRmV0Y2hdLCBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZXN0RmVhdHVyZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJlc3RDaHIgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmVzdFBvcyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmZWF0dXJlcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmZWF0dXJlc1tmaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaHJ4ID0gZi5fY2hyb21JZCwgZm1pbiA9IGYubWluLCBmbWF4ID0gZi5tYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiZXN0RmVhdHVyZSA9PSBudWxsIHx8ICgoZGlyIDwgMCkgJiYgKGNocnggPiBiZXN0Q2hyIHx8IGZtYXggPiBiZXN0UG9zKSkgfHwgKChkaXIgPiAwKSAmJiAoY2hyeCA8IGJlc3RDaHIgfHwgZm1pbiA8IGJlc3RQb3MpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZlYXR1cmUgPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdFBvcyA9IChkaXIgPCAwKSA/IGZtYXggOiBmbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdENociA9IGNocng7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdEZlYXR1cmUgIT0gbnVsbCkgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhbYmVzdEZlYXR1cmVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNpckZvYlJlY3VyMiA9IGZ1bmN0aW9uKGNpckJsb2NrRGF0YSwgb2Zmc2V0LCBsZXZlbCkge1xuICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShjaXJCbG9ja0RhdGEpO1xuICAgICAgICB2YXIgc2EgPSBuZXcgSW50MTZBcnJheShjaXJCbG9ja0RhdGEpO1xuICAgICAgICB2YXIgbGEgPSBuZXcgSW50MzJBcnJheShjaXJCbG9ja0RhdGEpO1xuXG4gICAgICAgIHZhciBpc0xlYWYgPSBiYVtvZmZzZXRdO1xuICAgICAgICB2YXIgY250ID0gc2Fbb2Zmc2V0LzIgKyAxXTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgICAgaWYgKGlzTGVhZiAhPSAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNudDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvID0gb2Zmc2V0LzQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0Q2hyb20gPSBsYVtsb107XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0QmFzZSA9IGxhW2xvICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGVuZENocm9tID0gbGFbbG8gKyAyXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQmFzZSA9IGxhW2xvICsgM107XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIG9mZnNldCsxNik7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCBvZmZzZXQrMjQpO1xuICAgICAgICAgICAgICAgIGlmICgoZGlyIDwgMCAmJiAoKHN0YXJ0Q2hyb20gPCBjaHIgfHwgKHN0YXJ0Q2hyb20gPT0gY2hyICYmIHN0YXJ0QmFzZSA8PSBwb3MpKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgIChkaXIgPiAwICYmICgoZW5kQ2hyb20gPiBjaHIgfHwgKGVuZENocm9tID09IGNociAmJiBlbmRCYXNlID49IHBvcykpKSkpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnR290IGFuIGludGVyZXN0aW5nIGJsb2NrOiBzdGFydEJhc2U9JyArIHN0YXJ0Q2hyb20gKyAnOicgKyBzdGFydEJhc2UgKyAnOyBlbmRCYXNlPScgKyBlbmRDaHJvbSArICc6JyArIGVuZEJhc2UgKyAnOyBvZmZzZXQ9JyArIGJsb2NrT2Zmc2V0ICsgJzsgc2l6ZT0nICsgYmxvY2tTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9fcmFuZG9tLy5leGVjKHRoaXNCLmJ3Zy5pZHNUb0Nocm9tc1tzdGFydENocm9tXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRsb2coJ3NraXBwaW5nIHJhbmRvbTogJyArIHRoaXNCLmJ3Zy5pZHNUb0Nocm9tc1tzdGFydENocm9tXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2tUb0ZldGNoID09IG51bGwgfHwgKChkaXIgPCAwKSAmJiAoZW5kQ2hyb20gPiBiZXN0QmxvY2tDaHIgfHwgKGVuZENocm9tID09IGJlc3RCbG9ja0NociAmJiBlbmRCYXNlID4gYmVzdEJsb2NrT2Zmc2V0KSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZGlyID4gMCkgJiYgKHN0YXJ0Q2hyb20gPCBiZXN0QmxvY2tDaHIgfHwgKHN0YXJ0Q2hyb20gPT0gYmVzdEJsb2NrQ2hyICYmIHN0YXJ0QmFzZSA8IGJlc3RCbG9ja09mZnNldCkpKSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICBkbG9nKCdiZXN0IGlzOiBzdGFydEJhc2U9JyArIHN0YXJ0Q2hyb20gKyAnOicgKyBzdGFydEJhc2UgKyAnOyBlbmRCYXNlPScgKyBlbmRDaHJvbSArICc6JyArIGVuZEJhc2UgKyAnOyBvZmZzZXQ9JyArIGJsb2NrT2Zmc2V0ICsgJzsgc2l6ZT0nICsgYmxvY2tTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVG9GZXRjaCA9IHtvZmZzZXQ6IGJsb2NrT2Zmc2V0LCBzaXplOiBibG9ja1NpemV9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEJsb2NrT2Zmc2V0ID0gKGRpciA8IDApID8gZW5kQmFzZSA6IHN0YXJ0QmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RCbG9ja0NociA9IChkaXIgPCAwKSA/IGVuZENocm9tIDogc3RhcnRDaHJvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmVzdFJlY3VyID0gLTE7XG4gICAgICAgICAgICB2YXIgYmVzdFBvcyA9IC0xO1xuICAgICAgICAgICAgdmFyIGJlc3RDaHIgPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY250OyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG8gPSBvZmZzZXQvNDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRDaHJvbSA9IGxhW2xvXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRCYXNlID0gbGFbbG8gKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ2hyb20gPSBsYVtsbyArIDJdO1xuICAgICAgICAgICAgICAgIHZhciBlbmRCYXNlID0gbGFbbG8gKyAzXTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tPZmZzZXQgPSAobGFbbG8gKyA0XTw8MzIpIHwgKGxhW2xvICsgNV0pO1xuICAgICAgICAgICAgICAgIGlmICgoZGlyIDwgMCAmJiAoKHN0YXJ0Q2hyb20gPCBjaHIgfHwgKHN0YXJ0Q2hyb20gPT0gY2hyICYmIHN0YXJ0QmFzZSA8PSBwb3MpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVuZENocm9tICAgPj0gY2hyKSkpIHx8XG4gICAgICAgICAgICAgICAgICAgICAoZGlyID4gMCAmJiAoKGVuZENocm9tID4gY2hyIHx8IChlbmRDaHJvbSA9PSBjaHIgJiYgZW5kQmFzZSA+PSBwb3MpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdGFydENocm9tIDw9IGNocikpKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZXN0UmVjdXIgPCAwIHx8IGVuZEJhc2UgPiBiZXN0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0UmVjdXIgPSBibG9ja09mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3RQb3MgPSAoZGlyIDwgMCkgPyBlbmRCYXNlIDogc3RhcnRCYXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdENociA9IChkaXIgPCAwKSA/IGVuZENocm9tIDogc3RhcnRDaHJvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gMjQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmVzdFJlY3VyID49IDApIHtcbiAgICAgICAgICAgICAgICBjaXJGb2JSZWN1cihbYmVzdFJlY3VyXSwgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG5cbiAgICBjaXJGb2JSZWN1cihbdGhpc0IuY2lyVHJlZU9mZnNldCArIDQ4XSwgMSk7XG59XG5cbkJpZ1dpZy5wcm90b3R5cGUucmVhZFdpZ0RhdGEgPSBmdW5jdGlvbihjaHJOYW1lLCBtaW4sIG1heCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmdldFVuem9vbWVkVmlldygpLnJlYWRXaWdEYXRhKGNock5hbWUsIG1pbiwgbWF4LCBjYWxsYmFjayk7XG59XG5cbkJpZ1dpZy5wcm90b3R5cGUuZ2V0VW56b29tZWRWaWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnVuem9vbWVkVmlldykge1xuICAgICAgICB2YXIgY2lyTGVuID0gNDAwMDtcbiAgICAgICAgdmFyIG56bCA9IHRoaXMuem9vbUxldmVsc1swXTtcbiAgICAgICAgaWYgKG56bCkge1xuICAgICAgICAgICAgY2lyTGVuID0gdGhpcy56b29tTGV2ZWxzWzBdLmRhdGFPZmZzZXQgLSB0aGlzLnVuem9vbWVkSW5kZXhPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnpvb21lZFZpZXcgPSBuZXcgQmlnV2lnVmlldyh0aGlzLCB0aGlzLnVuem9vbWVkSW5kZXhPZmZzZXQsIGNpckxlbiwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51bnpvb21lZFZpZXc7XG59XG5cbkJpZ1dpZy5wcm90b3R5cGUuZ2V0Wm9vbWVkVmlldyA9IGZ1bmN0aW9uKHopIHtcbiAgICB2YXIgemggPSB0aGlzLnpvb21MZXZlbHNbel07XG4gICAgaWYgKCF6aC52aWV3KSB7XG4gICAgICAgIHpoLnZpZXcgPSBuZXcgQmlnV2lnVmlldyh0aGlzLCB6aC5pbmRleE9mZnNldCwgLyogdGhpcy56b29tTGV2ZWxzW3ogKyAxXS5kYXRhT2Zmc2V0IC0gemguaW5kZXhPZmZzZXQgKi8gNDAwMCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB6aC52aWV3O1xufVxuXG5mdW5jdGlvbiBtYWtlQndnKGRhdGEsIGNhbGxiYWNrLCBuYW1lKSB7XG4gICAgdmFyIGJ3ZyA9IG5ldyBCaWdXaWcoKTtcbiAgICBid2cuZGF0YSA9IGRhdGE7XG4gICAgYndnLm5hbWUgPSBuYW1lO1xuICAgIGJ3Zy5kYXRhLnNsaWNlKDAsIDUxMikuc2FsdGVkKCkuZmV0Y2goZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgXCJDb3VsZG4ndCBmZXRjaCBmaWxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlYWRlciA9IHJlc3VsdDtcbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoaGVhZGVyKTtcbiAgICAgICAgdmFyIHNhID0gbmV3IEludDE2QXJyYXkoaGVhZGVyKTtcbiAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkoaGVhZGVyKTtcbiAgICAgICAgdmFyIG1hZ2ljID0gYmFbMF0gKyAoTTEgKiBiYVsxXSkgKyAoTTIgKiBiYVsyXSkgKyAoTTMgKiBiYVszXSk7XG4gICAgICAgIGlmIChtYWdpYyA9PSBCSUdfV0lHX01BR0lDKSB7XG4gICAgICAgICAgICBid2cudHlwZSA9ICdiaWd3aWcnO1xuICAgICAgICB9IGVsc2UgaWYgKG1hZ2ljID09IEJJR19CRURfTUFHSUMpIHtcbiAgICAgICAgICAgIGJ3Zy50eXBlID0gJ2JpZ2JlZCc7XG4gICAgICAgIH0gZWxzZSBpZiAobWFnaWMgPT0gQklHX1dJR19NQUdJQ19CRSB8fCBtYWdpYyA9PSBCSUdfQkVEX01BR0lDX0JFKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgXCJDdXJyZW50bHkgZG9uJ3Qgc3VwcG9ydCBiaWctZW5kaWFuIEJCSSBmaWxlc1wiKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFwiTm90IGEgc3VwcG9ydGVkIGZvcm1hdCwgbWFnaWM9MHhcIiArIG1hZ2ljLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGJ3Zy52ZXJzaW9uID0gc2FbMl07ICAgICAgICAgICAgIC8vIDRcbiAgICAgICAgYndnLm51bVpvb21MZXZlbHMgPSBzYVszXTsgICAgICAgLy8gNlxuICAgICAgICBid2cuY2hyb21UcmVlT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIDgpO1xuICAgICAgICBid2cudW56b29tZWREYXRhT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIDE2KTtcbiAgICAgICAgYndnLnVuem9vbWVkSW5kZXhPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgMjQpO1xuICAgICAgICBid2cuZmllbGRDb3VudCA9IHNhWzE2XTsgICAgICAgICAvLyAzMlxuICAgICAgICBid2cuZGVmaW5lZEZpZWxkQ291bnQgPSBzYVsxN107ICAvLyAzNFxuICAgICAgICBid2cuYXNPZmZzZXQgPSBid2dfcmVhZE9mZnNldChiYSwgMzYpO1xuICAgICAgICBid2cudG90YWxTdW1tYXJ5T2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIDQ0KTtcbiAgICAgICAgYndnLnVuY29tcHJlc3NCdWZTaXplID0gbGFbMTNdOyAgLy8gNTJcbiAgICAgICAgYndnLmV4dEhlYWRlck9mZnNldCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCA1Nik7XG5cbiAgICAgICAgYndnLnpvb21MZXZlbHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgemwgPSAwOyB6bCA8IGJ3Zy5udW1ab29tTGV2ZWxzOyArK3psKSB7XG4gICAgICAgICAgICB2YXIgemxSZWR1Y3Rpb24gPSBsYVt6bCo2ICsgMTZdXG4gICAgICAgICAgICB2YXIgemxEYXRhID0gYndnX3JlYWRPZmZzZXQoYmEsIHpsKjI0ICsgNzIpO1xuICAgICAgICAgICAgdmFyIHpsSW5kZXggPSBid2dfcmVhZE9mZnNldChiYSwgemwqMjQgKyA4MCk7XG4gICAgICAgICAgICBid2cuem9vbUxldmVscy5wdXNoKHtyZWR1Y3Rpb246IHpsUmVkdWN0aW9uLCBkYXRhT2Zmc2V0OiB6bERhdGEsIGluZGV4T2Zmc2V0OiB6bEluZGV4fSk7XG4gICAgICAgIH1cblxuICAgICAgICBid2cucmVhZENocm9tVHJlZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJ3Zy5nZXRBdXRvU1FMKGZ1bmN0aW9uKGFzKSB7XG4gICAgICAgICAgICAgICAgYndnLnNjaGVtYSA9IGFzO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhid2cpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sIHt0aW1lb3V0OiA1MDAwfSk7ICAgIC8vIFBvdGVudGlhbCB0aW1lb3V0IG9uIGZpcnN0IHJlcXVlc3QgdG8gY2F0Y2ggbWl4ZWQtY29udGVudCBlcnJvcnMgb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaHJvbWl1bS5cbn1cblxuXG5CaWdXaWcucHJvdG90eXBlLl90c0ZldGNoID0gZnVuY3Rpb24oem9vbSwgY2hyLCBtaW4sIG1heCwgY2FsbGJhY2spIHtcbiAgICB2YXIgYndnID0gdGhpcztcbiAgICBpZiAoem9vbSA+PSB0aGlzLnpvb21MZXZlbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAoIXRoaXMudG9wTGV2ZWxSZWR1Y3Rpb25DYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5nZXRab29tZWRWaWV3KHRoaXMuem9vbUxldmVscy5sZW5ndGggLSAxKS5yZWFkV2lnRGF0YUJ5SWQoLTEsIDAsIDMwMDAwMDAwMCwgZnVuY3Rpb24oZmVhdHMpIHtcbiAgICAgICAgICAgICAgICBid2cudG9wTGV2ZWxSZWR1Y3Rpb25DYWNoZSA9IGZlYXRzO1xuICAgICAgICAgICAgICAgIHJldHVybiBid2cuX3RzRmV0Y2goem9vbSwgY2hyLCBtaW4sIG1heCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZiA9IFtdO1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLnRvcExldmVsUmVkdWN0aW9uQ2FjaGU7XG4gICAgICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgYy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY1tmaV0uX2Nocm9tSWQgPT0gY2hyKSB7XG4gICAgICAgICAgICAgICAgICAgIGYucHVzaChjW2ZpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGYpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZpZXc7XG4gICAgICAgIGlmICh6b29tIDwgMCkge1xuICAgICAgICAgICAgdmlldyA9IHRoaXMuZ2V0VW56b29tZWRWaWV3KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWV3ID0gdGhpcy5nZXRab29tZWRWaWV3KHpvb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aWV3LnJlYWRXaWdEYXRhQnlJZChjaHIsIG1pbiwgbWF4LCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG5CaWdXaWcucHJvdG90eXBlLnRocmVzaG9sZFNlYXJjaCA9IGZ1bmN0aW9uKGNock5hbWUsIHJlZmVyZW5jZVBvaW50LCBkaXIsIHRocmVzaG9sZCwgY2FsbGJhY2spIHtcbiAgICBkaXIgPSAoZGlyPDApID8gLTEgOiAxO1xuICAgIHZhciBid2cgPSB0aGlzO1xuICAgIHZhciBpbml0aWFsQ2hyID0gdGhpcy5jaHJvbXNUb0lEc1tjaHJOYW1lXTtcbiAgICB2YXIgY2FuZGlkYXRlcyA9IFt7Y2hyT3JkOiAwLCBjaHI6IGluaXRpYWxDaHIsIHpvb206IGJ3Zy56b29tTGV2ZWxzLmxlbmd0aCAtIDQsIG1pbjogMCwgbWF4OiAzMDAwMDAwMDAsIGZyb21SZWY6IHRydWV9XVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IHRoaXMubWF4SUQgKyAxOyArK2kpIHtcbiAgICAgICAgdmFyIGNocklkID0gKGluaXRpYWxDaHIgKyAoZGlyKmkpKSAlICh0aGlzLm1heElEICsgMSk7XG4gICAgICAgIGlmIChjaHJJZCA8IDApIFxuICAgICAgICAgICAgY2hySWQgKz0gKHRoaXMubWF4SUQgKyAxKTtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtjaHJPcmQ6IGksIGNocjogY2hySWQsIHpvb206IGJ3Zy56b29tTGV2ZWxzLmxlbmd0aCAtIDEsIG1pbjogMCwgbWF4OiAzMDAwMDAwMDB9KVxuICAgIH1cbiAgICAgICBcbiAgICBmdW5jdGlvbiBmYlRocmVzaG9sZFNlYXJjaFJlY3VyKCkge1xuICAgIFx0aWYgKGNhbmRpZGF0ZXMubGVuZ3RoID09IDApIHtcbiAgICBcdCAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgXHR9XG4gICAgXHRjYW5kaWRhdGVzLnNvcnQoZnVuY3Rpb24oYzEsIGMyKSB7XG4gICAgXHQgICAgdmFyIGQgPSBjMS56b29tIC0gYzIuem9vbTtcbiAgICBcdCAgICBpZiAoZCAhPSAwKVxuICAgIFx0XHQgICAgcmV0dXJuIGQ7XG5cbiAgICAgICAgICAgIGQgPSBjMS5jaHJPcmQgLSBjMi5jaHJPcmQ7XG4gICAgICAgICAgICBpZiAoZCAhPSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgIFx0ICAgIGVsc2VcbiAgICBcdFx0ICAgIHJldHVybiBjMS5taW4gLSBjMi5taW4gKiBkaXI7XG4gICAgXHR9KTtcblxuXHQgICAgdmFyIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXMuc3BsaWNlKDAsIDEpWzBdO1xuICAgICAgICBid2cuX3RzRmV0Y2goY2FuZGlkYXRlLnpvb20sIGNhbmRpZGF0ZS5jaHIsIGNhbmRpZGF0ZS5taW4sIGNhbmRpZGF0ZS5tYXgsIGZ1bmN0aW9uKGZlYXRzKSB7XG4gICAgICAgICAgICB2YXIgcnAgPSBkaXIgPiAwID8gMCA6IDMwMDAwMDAwMDtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuZnJvbVJlZilcbiAgICAgICAgICAgICAgICBycCA9IHJlZmVyZW5jZVBvaW50O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZmVhdHMubGVuZ3RoOyArK2ZpKSB7XG4gICAgXHQgICAgICAgIHZhciBmID0gZmVhdHNbZmldO1xuICAgICAgICAgICAgICAgIHZhciBzY29yZTtcbiAgICAgICAgICAgICAgICBpZiAoZi5tYXhTY29yZSAhPSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gZi5tYXhTY29yZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlID0gZi5zY29yZTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgXHQgICAgICAgICAgICBpZiAoc2NvcmUgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgXHRcdCAgICAgICAgaWYgKGNhbmRpZGF0ZS56b29tIDwgMCkge1xuICAgICAgICBcdFx0ICAgICAgICAgICAgaWYgKGYubWluID4gcnApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhmKTtcbiAgICAgICAgXHRcdCAgICAgICAgfSBlbHNlIGlmIChmLm1heCA+IHJwKSB7XG4gICAgICAgIFx0XHQgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe2NocjogY2FuZGlkYXRlLmNociwgY2hyT3JkOiBjYW5kaWRhdGUuY2hyT3JkLCB6b29tOiBjYW5kaWRhdGUuem9vbSAtIDIsIG1pbjogZi5taW4sIG1heDogZi5tYXgsIGZyb21SZWY6IGNhbmRpZGF0ZS5mcm9tUmVmfSk7XG4gICAgICAgIFx0XHQgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgXHRcdCAgICBpZiAoY2FuZGlkYXRlLnpvb20gPCAwKSB7XG4gICAgICAgICAgICAgICAgXHQgICAgICAgIGlmIChmLm1heCA8IHJwKVxuICAgICAgICAgICAgICAgIFx0XHRcdCAgICByZXR1cm4gY2FsbGJhY2soZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGYubWluIDwgcnApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe2NocjogY2FuZGlkYXRlLmNociwgY2hyT3JkOiBjYW5kaWRhdGUuY2hyT3JkLCB6b29tOiBjYW5kaWRhdGUuem9vbSAtIDIsIG1pbjogZi5taW4sIG1heDogZi5tYXgsIGZyb21SZWY6IGNhbmRpZGF0ZS5mcm9tUmVmfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgXHQgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgIFx0ICAgIH1cbiAgICAgICAgICAgIGZiVGhyZXNob2xkU2VhcmNoUmVjdXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGZiVGhyZXNob2xkU2VhcmNoUmVjdXIoKTtcbn1cblxuQmlnV2lnLnByb3RvdHlwZS5nZXRBdXRvU1FMID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIGlmICghdGhpcy5hc09mZnNldClcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuXG5cbiAgICB0aGlzLmRhdGEuc2xpY2UodGhpcy5hc09mZnNldCwgMjA0OCkuZmV0Y2goZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG4gICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChiYVtpXSA9PSAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJhW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLyogXG4gICAgICAgICAqIFF1aWNrJ24nZGlydHkgYXR0ZW1wdCB0byBwYXJzZSBhdXRvU3FsIGZvcm1hdC5cbiAgICAgICAgICogU2VlOiBodHRwOi8vd3d3LmxpbnV4am91cm5hbC5jb20vZmlsZXMvbGludXhqb3VybmFsLmNvbS9saW51eGpvdXJuYWwvYXJ0aWNsZXMvMDU5LzU5NDkvNTk0OWwyLmh0bWxcbiAgICAgICAgICovXG5cbiAgICAgICAgdmFyIGhlYWRlcl9yZSA9IC8oXFx3KylcXHMrKFxcdyspXFxzKyhcIihbXlwiXSspXCIpP1xccytcXChcXHMqLztcbiAgICAgICAgdmFyIGZpZWxkX3JlID0gLyhbXFx3XFxbXFxdXSspXFxzKyhcXHcrKVxccyo7XFxzKihcIihbXlwiXSspXCIpP1xccyovZztcblxuICAgICAgICB2YXIgaGVhZGVyTWF0Y2ggPSBoZWFkZXJfcmUuZXhlYyhzKTtcbiAgICAgICAgaWYgKGhlYWRlck1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgYXMgPSB7XG4gICAgICAgICAgICAgICAgZGVjbFR5cGU6IGhlYWRlck1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIG5hbWU6IGhlYWRlck1hdGNoWzJdLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IGhlYWRlck1hdGNoWzRdLFxuXG4gICAgICAgICAgICAgICAgZmllbGRzOiBbXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGhlYWRlck1hdGNoWzBdKTtcbiAgICAgICAgICAgIGZvciAodmFyIG0gPSBmaWVsZF9yZS5leGVjKHMpOyBtICE9IG51bGw7IG0gPSBmaWVsZF9yZS5leGVjKHMpKSB7XG4gICAgICAgICAgICAgICAgYXMuZmllbGRzLnB1c2goe3R5cGU6IG1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG1bMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQ6IG1bNF19KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGFzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5CaWdXaWcucHJvdG90eXBlLmdldEV4dHJhSW5kaWNlcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICBpZiAodGhpcy52ZXJzaW9uIDwgNCB8fCB0aGlzLmV4dEhlYWRlck9mZnNldCA9PSAwIHx8IHRoaXMudHlwZSAhPSAnYmlnYmVkJykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhLnNsaWNlKHRoaXMuZXh0SGVhZGVyT2Zmc2V0LCA2NCkuZmV0Y2goZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIkNvdWxkbid0IGZldGNoIGV4dGVuc2lvbiBoZWFkZXJcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG4gICAgICAgICAgICB2YXIgc2EgPSBuZXcgSW50MTZBcnJheShyZXN1bHQpO1xuICAgICAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkocmVzdWx0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGV4dEhlYWRlclNpemUgPSBzYVswXTtcbiAgICAgICAgICAgIHZhciBleHRyYUluZGV4Q291bnQgPSBzYVsxXTtcbiAgICAgICAgICAgIHZhciBleHRyYUluZGV4TGlzdE9mZnNldCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCA0KTtcblxuICAgICAgICAgICAgaWYgKGV4dHJhSW5kZXhDb3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGSVhNRSAyMGJ5dGUgcmVjb3JkcyBvbmx5IG1ha2Ugc2Vuc2UgZm9yIHNpbmdsZS1maWVsZCBpbmRpY2VzLlxuICAgICAgICAgICAgLy8gUmlnaHQgbm93LCB0aGVzZSBzZWVtIHRvIGJlIHRoZSBvbmx5IHRoaW5ncyBhcm91bmQsIGJ1dCB0aGUgZm9ybWF0XG4gICAgICAgICAgICAvLyBpcyBhY3R1YWxseSBtb3JlIGdlbmVyYWwuXG4gICAgICAgICAgICB0aGlzQi5kYXRhLnNsaWNlKGV4dHJhSW5kZXhMaXN0T2Zmc2V0LCBleHRyYUluZGV4Q291bnQgKiAyMCkuZmV0Y2goZnVuY3Rpb24oZWlsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlaWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFwiQ291bGRuJ3QgZmV0Y2ggaW5kZXggaW5mb1wiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShlaWwpO1xuICAgICAgICAgICAgICAgIHZhciBzYSA9IG5ldyBJbnQxNkFycmF5KGVpbCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkoZWlsKTtcblxuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IGV4dHJhSW5kZXhDb3VudDsgKytpaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWlUeXBlID0gc2FbaWkqMTBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWlGaWVsZENvdW50ID0gc2FbaWkqMTAgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVpT2Zmc2V0ID0gYndnX3JlYWRPZmZzZXQoYmEsIGlpKjIwICsgNCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlaUZpZWxkID0gc2FbaWkqMTAgKyA4XVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBuZXcgQkJJRXh0cmFJbmRleCh0aGlzQiwgZWlUeXBlLCBlaUZpZWxkQ291bnQsIGVpT2Zmc2V0LCBlaUZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaW5kaWNlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBCQklFeHRyYUluZGV4KGJiaSwgdHlwZSwgZmllbGRDb3VudCwgb2Zmc2V0LCBmaWVsZCkge1xuICAgIHRoaXMuYmJpID0gYmJpO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5maWVsZENvdW50ID0gZmllbGRDb3VudDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLmZpZWxkID0gZmllbGQ7XG59XG5cbkJCSUV4dHJhSW5kZXgucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHRoaXMuYmJpLmRhdGEuc2xpY2UodGhpcy5vZmZzZXQsIDMyKS5mZXRjaChmdW5jdGlvbihicHQpIHtcbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkoYnB0KTtcbiAgICAgICAgdmFyIHNhID0gbmV3IEludDE2QXJyYXkoYnB0KTtcbiAgICAgICAgdmFyIGxhID0gbmV3IEludDMyQXJyYXkoYnB0KTtcbiAgICAgICAgdmFyIGJwdE1hZ2ljID0gbGFbMF07XG4gICAgICAgIHZhciBibG9ja1NpemUgPSBsYVsxXTtcbiAgICAgICAgdmFyIGtleVNpemUgPSBsYVsyXTtcbiAgICAgICAgdmFyIHZhbFNpemUgPSBsYVszXTtcbiAgICAgICAgdmFyIGl0ZW1Db3VudCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCAxNik7XG4gICAgICAgIHZhciByb290Tm9kZU9mZnNldCA9IDMyO1xuXG4gICAgICAgIGZ1bmN0aW9uIGJwdFJlYWROb2RlKG5vZGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXNCLmJiaS5kYXRhLnNsaWNlKG5vZGVPZmZzZXQsIDQgKyAoYmxvY2tTaXplICogKGtleVNpemUgKyB2YWxTaXplKSkpLmZldGNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShub2RlKTtcbiAgICAgICAgICAgICAgICB2YXIgc2EgPSBuZXcgVWludDE2QXJyYXkobm9kZSk7XG4gICAgICAgICAgICAgICAgdmFyIGxhID0gbmV3IFVpbnQzMkFycmF5KG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVUeXBlID0gYmFbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNudCA9IHNhWzFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDQ7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RDaGlsZE9mZnNldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY250OyArK24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtpID0gMDsga2kgPCBrZXlTaXplOyArK2tpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gYmFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZE9mZnNldCA9IGJ3Z19yZWFkT2Zmc2V0KGJhLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLmxvY2FsZUNvbXBhcmUoa2V5KSA8IDAgJiYgbGFzdENoaWxkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnB0UmVhZE5vZGUobGFzdENoaWxkT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGRPZmZzZXQgPSBjaGlsZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicHRSZWFkTm9kZShsYXN0Q2hpbGRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY250OyArK24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtpID0gMDsga2kgPCBrZXlTaXplOyArK2tpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gYmFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNwZWNpZmljIGZvciBFSSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYndnX3JlYWRPZmZzZXQoYmEsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHJlYWRJbnQoYmEsIG9mZnNldCArIDgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNCLmJiaS5nZXRVbnpvb21lZFZpZXcoKS5mZXRjaEZlYXR1cmVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCB0b2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rcyAmJiB0b2tzLmxlbmd0aCA+IHRoaXNCLmZpZWxkIC0gMylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rc1t0aGlzQi5maWVsZCAtIDNdID09IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbe29mZnNldDogc3RhcnQsIHNpemU6IGxlbmd0aH1dLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHZhbFNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJwdFJlYWROb2RlKHRoaXNCLm9mZnNldCArIHJvb3ROb2RlT2Zmc2V0KTtcbiAgICB9KTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBtYWtlQndnOiBtYWtlQndnLFxuICAgICAgICBCSUdfQkVEX01BR0lDOiBCSUdfQkVEX01BR0lDLFxuICAgICAgICBCSUdfV0lHX01BR0lDOiBCSUdfV0lHX01BR0lDXG4gICAgfVxufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMVxuLy9cbi8vIGJpbi5qcyBnZW5lcmFsIGJpbmFyeSBkYXRhIHN1cHBvcnRcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcblxuICAgIHZhciBzaGExID0gcmVxdWlyZSgnLi9zaGExJyk7XG4gICAgdmFyIGI2NF9zaGExID0gc2hhMS5iNjRfc2hhMTtcbn1cblxuZnVuY3Rpb24gQmxvYkZldGNoYWJsZShiKSB7XG4gICAgdGhpcy5ibG9iID0gYjtcbn1cblxuQmxvYkZldGNoYWJsZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgbGVuZ3RoKSB7XG4gICAgdmFyIGI7XG5cbiAgICBpZiAodGhpcy5ibG9iLnNsaWNlKSB7XG4gICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIGIgPSB0aGlzLmJsb2Iuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGIgPSB0aGlzLmJsb2Iuc2xpY2Uoc3RhcnQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgYiA9IHRoaXMuYmxvYi53ZWJraXRTbGljZShzdGFydCwgc3RhcnQgKyBsZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYiA9IHRoaXMuYmxvYi53ZWJraXRTbGljZShzdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iRmV0Y2hhYmxlKGIpO1xufVxuXG5CbG9iRmV0Y2hhYmxlLnByb3RvdHlwZS5zYWx0ZWQgPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpczt9XG5cbmlmICh0eXBlb2YoRmlsZVJlYWRlcikgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RlZmluaW5nIGFzeW5jIEJsb2JGZXRjaGFibGUuZmV0Y2gnKTtcblxuICAgIEJsb2JGZXRjaGFibGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgY2FsbGJhY2soYnN0cmluZ1RvQnVmZmVyKHJlYWRlci5yZXN1bHQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0JpbmFyeVN0cmluZyh0aGlzLmJsb2IpO1xuICAgIH1cblxufSBlbHNlIHtcbiAgICAvLyBpZiAoY29uc29sZSAmJiBjb25zb2xlLmxvZylcbiAgICAvLyAgICBjb25zb2xlLmxvZygnZGVmaW5pbmcgc3luYyBCbG9iRmV0Y2hhYmxlLmZldGNoJyk7XG5cbiAgICBCbG9iRmV0Y2hhYmxlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlclN5bmMoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXMgPSByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIodGhpcy5ibG9iKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBVUkxGZXRjaGFibGUodXJsLCBzdGFydCwgZW5kLCBvcHRzKSB7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRzID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdHMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGlmIChlbmQpIHtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG59XG5cblVSTEZldGNoYWJsZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzLCBsKSB7XG4gICAgaWYgKHMgPCAwKSB7XG4gICAgICAgIHRocm93ICdCYWQgc2xpY2UgJyArIHM7XG4gICAgfVxuXG4gICAgdmFyIG5zID0gdGhpcy5zdGFydCwgbmUgPSB0aGlzLmVuZDtcbiAgICBpZiAobnMgJiYgcykge1xuICAgICAgICBucyA9IG5zICsgcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBucyA9IHMgfHwgbnM7XG4gICAgfVxuICAgIGlmIChsICYmIG5zKSB7XG4gICAgICAgIG5lID0gbnMgKyBsIC0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZSA9IG5lIHx8IGwgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVSTEZldGNoYWJsZSh0aGlzLnVybCwgbnMsIG5lLCB0aGlzLm9wdHMpO1xufVxuXG52YXIgc2VlZD0wO1xudmFyIGlzU2FmYXJpID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSA+PSAwICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPCAwIDtcblxuVVJMRmV0Y2hhYmxlLnByb3RvdHlwZS5mZXRjaEFzVGV4dCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmw7XG4gICAgICAgIGlmICgoaXNTYWZhcmkgfHwgdGhpcy5vcHRzLnNhbHQpICYmIHVybC5pbmRleE9mKCc/JykgPCAwKSB7XG4gICAgICAgICAgICB1cmwgPSB1cmwgKyAnP3NhbHQ9JyArIGI2NF9zaGExKCcnICsgRGF0ZS5ub3coKSArICcsJyArICgrK3NlZWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcblxuICAgICAgICBpZiAodGhpcy5lbmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVuZCAtIHRoaXMuc3RhcnQgPiAxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTW9uc3RlciBmZXRjaCEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyB0aGlzLnN0YXJ0ICsgJy0nICsgdGhpcy5lbmQpO1xuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwIHx8IHJlcS5zdGF0dXMgPT0gMjA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZCgnJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxufVxuXG5VUkxGZXRjaGFibGUucHJvdG90eXBlLnNhbHRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvID0gc2hhbGxvd0NvcHkodGhpcy5vcHRzKTtcbiAgICBvLnNhbHQgPSB0cnVlO1xuICAgIHJldHVybiBuZXcgVVJMRmV0Y2hhYmxlKHRoaXMudXJsLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgbyk7XG59XG5cblVSTEZldGNoYWJsZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjYWxsYmFjaywgb3B0cykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGF0dGVtcHQgPSBvcHRzLmF0dGVtcHQgfHwgMTtcbiAgICB2YXIgdHJ1bmNhdGVkTGVuZ3RoID0gb3B0cy50cnVuY2F0ZWRMZW5ndGg7XG4gICAgaWYgKGF0dGVtcHQgPiAzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICB2YXIgdGltZW91dDtcbiAgICAgICAgaWYgKG9wdHMudGltZW91dCAmJiAhdGhpcy5vcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbWluZyBvdXQgJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ1RpbWVvdXQnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdHMudGltZW91dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgdmFyIGxlbmd0aDtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMudXJsO1xuICAgICAgICBpZiAoKGlzU2FmYXJpIHx8IHRoaXMub3B0cy5zYWx0KSAmJiB1cmwuaW5kZXhPZignPycpIDwgMCkge1xuICAgICAgICAgICAgdXJsID0gdXJsICsgJz9zYWx0PScgKyBiNjRfc2hhMSgnJyArIERhdGUubm93KCkgKyAnLCcgKyAoKytzZWVkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcS5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7XG4gICAgICAgIGlmICh0aGlzLmVuZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5kIC0gdGhpcy5zdGFydCA+IDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgIHRocm93ICdNb25zdGVyIGZldGNoISc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIHRoaXMuc3RhcnQgKyAnLScgKyB0aGlzLmVuZCk7XG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLmVuZCAtIHRoaXMuc3RhcnQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KVxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwIHx8IHJlcS5zdGF0dXMgPT0gMjA2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEucmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibCA9IHJlcS5yZXNwb25zZS5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCAmJiBsZW5ndGggIT0gYmwgJiYgKCF0cnVuY2F0ZWRMZW5ndGggfHwgYmwgIT0gdHJ1bmNhdGVkTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQi5mZXRjaChjYWxsYmFjaywge2F0dGVtcHQ6IGF0dGVtcHQgKyAxLCB0cnVuY2F0ZWRMZW5ndGg6IGJsfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXEucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlcS5tb3pSZXNwb25zZUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVxLm1velJlc3BvbnNlQXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSByZXEucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCAmJiBsZW5ndGggIT0gci5sZW5ndGggJiYgKCF0cnVuY2F0ZWRMZW5ndGggfHwgci5sZW5ndGggIT0gdHJ1bmNhdGVkTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzQi5mZXRjaChjYWxsYmFjaywge2F0dGVtcHQ6IGF0dGVtcHQgKyAxLCB0cnVuY2F0ZWRMZW5ndGg6IHIubGVuZ3RofSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhic3RyaW5nVG9CdWZmZXIocmVxLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNCLmZldGNoKGNhbGxiYWNrLCB7YXR0ZW1wdDogYXR0ZW1wdCArIDF9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdHMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5zZW5kKCcnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJzdHJpbmdUb0J1ZmZlcihyZXN1bHQpIHtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShyZXN1bHQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJhW2ldID0gcmVzdWx0LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBiYS5idWZmZXI7XG59XG5cbi8vIFJlYWQgZnJvbSBVaW50OEFycmF5XG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgICB2YXIgY29udmVydEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShjb252ZXJ0QnVmZmVyKTtcbiAgICB2YXIgZmEgPSBuZXcgRmxvYXQzMkFycmF5KGNvbnZlcnRCdWZmZXIpO1xuXG5cbiAgICBnbG9iYWwucmVhZEZsb2F0ID0gZnVuY3Rpb24oYnVmLCBvZmZzZXQpIHtcbiAgICAgICAgYmFbMF0gPSBidWZbb2Zmc2V0XTtcbiAgICAgICAgYmFbMV0gPSBidWZbb2Zmc2V0KzFdO1xuICAgICAgICBiYVsyXSA9IGJ1ZltvZmZzZXQrMl07XG4gICAgICAgIGJhWzNdID0gYnVmW29mZnNldCszXTtcbiAgICAgICAgcmV0dXJuIGZhWzBdO1xuICAgIH07XG4gfSh0aGlzKSk7XG5cbmZ1bmN0aW9uIHJlYWRJbnQ2NChiYSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChiYVtvZmZzZXQgKyA3XSA8PCAyNCkgfCAoYmFbb2Zmc2V0ICsgNl0gPDwgMTYpIHwgKGJhW29mZnNldCArIDVdIDw8IDgpIHwgKGJhW29mZnNldCArIDRdKTtcbn1cblxuZnVuY3Rpb24gcmVhZEludChiYSwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChiYVtvZmZzZXQgKyAzXSA8PCAyNCkgfCAoYmFbb2Zmc2V0ICsgMl0gPDwgMTYpIHwgKGJhW29mZnNldCArIDFdIDw8IDgpIHwgKGJhW29mZnNldF0pO1xufVxuXG5mdW5jdGlvbiByZWFkU2hvcnQoYmEsIG9mZnNldCkge1xuICAgIHJldHVybiAoYmFbb2Zmc2V0ICsgMV0gPDwgOCkgfCAoYmFbb2Zmc2V0XSk7XG59XG5cbmZ1bmN0aW9uIHJlYWRCeXRlKGJhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gYmFbb2Zmc2V0XTtcbn1cblxuZnVuY3Rpb24gcmVhZEludEJFKGJhLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gKGJhW29mZnNldF0gPDwgMjQpIHwgKGJhW29mZnNldCArIDFdIDw8IDE2KSB8IChiYVtvZmZzZXQgKyAyXSA8PCA4KSB8IChiYVtvZmZzZXQgKyAzXSk7XG59XG5cbi8vIEV4cG9ydHMgaWYgd2UgYXJlIGJlaW5nIHVzZWQgYXMgYSBtb2R1bGVcblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBCbG9iRmV0Y2hhYmxlOiBCbG9iRmV0Y2hhYmxlLFxuICAgICAgICBVUkxGZXRjaGFibGU6IFVSTEZldGNoYWJsZSxcblxuICAgICAgICByZWFkSW50OiByZWFkSW50LFxuICAgICAgICByZWFkSW50QkU6IHJlYWRJbnRCRSxcbiAgICAgICAgcmVhZEludDY0OiByZWFkSW50NjQsXG4gICAgICAgIHJlYWRTaG9ydDogcmVhZFNob3J0LFxuICAgICAgICByZWFkQnl0ZTogcmVhZEJ5dGUsXG4gICAgICAgIHJlYWRGbG9hdDogdGhpcy5yZWFkRmxvYXRcbiAgICB9XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy9cbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyBicm93c2VyLXVzLmpzOiBzdGFuZGFyZCBVSSB3aXJpbmdcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBicm93c2VyID0gcmVxdWlyZSgnLi9jYnJvd3NlcicpO1xuICAgIHZhciBCcm93c2VyID0gYnJvd3Nlci5Ccm93c2VyO1xuXG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBtYWtlRWxlbWVudCA9IHV0aWxzLm1ha2VFbGVtZW50O1xuICAgIHZhciByZW1vdmVDaGlsZHJlbiA9IHV0aWxzLnJlbW92ZUNoaWxkcmVuO1xuXG4gICAgdmFyIG5mID0gcmVxdWlyZSgnLi9udW1mb3JtYXRzJyk7XG4gICAgdmFyIGZvcm1hdExvbmdJbnQgPSBuZi5mb3JtYXRMb25nSW50O1xuXG4gICAgdmFyIG1ha2Vab29tU2xpZGVyID0gcmVxdWlyZSgnLi96b29tc2xpZGVyJyk7XG5cbiAgICAvLyBGb3Igc2lkZSBlZmZlY3RzXG5cbiAgICByZXF1aXJlKCcuL3RpZXItZWRpdCcpO1xuICAgIHJlcXVpcmUoJy4vZXhwb3J0LWNvbmZpZycpO1xuICAgIHJlcXVpcmUoJy4vZXhwb3J0LXVpJyk7XG4gICAgcmVxdWlyZSgnLi9leHBvcnQtaW1hZ2UnKTtcbiAgICByZXF1aXJlKCcuL3N2Zy1leHBvcnQnKTtcbiAgICByZXF1aXJlKCcuL3Nlc3Npb24nKTtcbn1cblxuLypcbiAqIFF1aXRlIGEgYml0IG9mIHRoaXMgb3VnaHQgdG8gYmUgZG9uZSB1c2luZyBhIHRlbXBsYXRpbmcgc3lzdGVtLCBidXRcbiAqIHNpbmNlIHdlYi1jb21wb25lbnRzIGlzbid0IHF1aXRlIHJlYWR5IGZvciBwcmltZSB0aW1lIHlldCB3ZSdsbCBzdGlja1xuICogd2l0aCBjb25zdHJ1Y3RpbmcgaXQgYWxsIGluIEphdmFzY3JpcHQgZm9yIG5vdy4uLlxuICovXG5cbkJyb3dzZXIucHJvdG90eXBlLmluaXRVSSA9IGZ1bmN0aW9uKGhvbGRlciwgZ2Vub21lUGFuZWwpIHtcbiAgICBpZiAoIXRoaXMubm9Tb3VyY2VDU1MpIHtcbiAgICAgIFsnYm9vdHN0cmFwLXNjb3BlZC5jc3MnLCAnZGFsbGlhbmNlLXNjb3BlZC5jc3MnLCAnZm9udC1hd2Vzb21lLm1pbi5jc3MnXS5mb3JFYWNoKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnbGluaycsICcnLCB7XG4gICAgICAgICAgcmVsOiAnc3R5bGVzaGVldCcsXG4gICAgICAgICAgaHJlZjogdGhpcy5yZXNvbHZlVVJMKCckJGNzcy8nICsgcGF0aClcbiAgICAgICAgfSkpO1xuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICB2YXIgYiA9IHRoaXM7XG5cbiAgICBpZiAoIWIuZGlzYWJsZURlZmF1bHRGZWF0dXJlUG9wdXApIHtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlTGlzdGVuZXIoZnVuY3Rpb24oZXYsIGZlYXR1cmUsIGhpdCwgdGllcikge1xuICAgICAgICAgICAgYi5mZWF0dXJlUG9wdXAoZXYsIGZlYXR1cmUsIGhpdCwgdGllcik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGhvbGRlci5jbGFzc0xpc3QuYWRkKCdkYWxsaWFuY2UnKTtcbiAgICB2YXIgdG9vbGJhciA9IGIudG9vbGJhciA9IG1ha2VFbGVtZW50KCdkaXYnLCBudWxsLCB7Y2xhc3NOYW1lOiAnYnRuLXRvb2xiYXIgdG9vbGJhcid9KTtcblxuICAgIHZhciB0aXRsZSA9IGIuY29vcmRTeXN0ZW0uc3BlY2llc05hbWUgKyAnICcgKyBiLm5hbWVGb3JDb29yZFN5c3RlbShiLmNvb3JkU3lzdGVtKTtcbiAgICBpZiAodGhpcy5zZXREb2N1bWVudFRpdGxlKSB7XG4gICAgICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGUgKyAnIDo6IGRhbGxpYW5jZSc7XG4gICAgfVxuXG4gICAgdmFyIGxvY0ZpZWxkID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgJycsIHtjbGFzc05hbWU6ICdsb2MtZmllbGQnfSk7XG4gICAgYi5tYWtlVG9vbHRpcChsb2NGaWVsZCwgJ0VudGVyIGEgZ2Vub21pYyBsb2NhdGlvbiBvciBnZW5lIG5hbWUnKTtcbiAgICB2YXIgbG9jU3RhdHVzRmllbGQgPSBtYWtlRWxlbWVudCgncCcsICcnLCB7Y2xhc3NOYW1lOiAnbG9jLXN0YXR1cyd9KTtcblxuICAgIHZhciB6b29tSW5CdG4gPSBtYWtlRWxlbWVudCgnYScsIFttYWtlRWxlbWVudCgnaScsIG51bGwsIHtjbGFzc05hbWU6ICdmYSBmYS1zZWFyY2gtcGx1cyd9KV0sIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgdmFyIHpvb21TbGlkZXIgPSBuZXcgbWFrZVpvb21TbGlkZXIoKTtcbiAgICBiLm1ha2VUb29sdGlwKHpvb21TbGlkZXIsIFwiSGlnaGxpZ2h0ZWQgYnV0dG9uIHNob3dzIGN1cnJlbnQgem9vbSBsZXZlbCwgZ3JheSBidXR0b24gc2hvd3MgaW5hY3RpdmUgem9vbSBsZXZlbCAoY2xpY2sgb3IgdGFwIFNQQUNFIHRvIHRvZ2dsZSkuXCIpXG5cbiAgICB2YXIgem9vbU91dEJ0biA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXNlYXJjaC1taW51cyd9KV0sIHtjbGFzc05hbWU6ICdidG4nfSk7XG5cbiAgICB2YXIgY2xlYXJIaWdobGlnaHRzQnV0dG9uID0gbWFrZUVsZW1lbnQoJ2EnLCBbbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtZXJhc2VyJ30pXSwge2NsYXNzTmFtZTogJ2J0bid9KTtcblxuICAgIHZhciBhZGRUcmFja0J0biA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXBsdXMnfSldLCB7Y2xhc3NOYW1lOiAnYnRuJ30pO1xuICAgIHZhciBmYXZCdG4gPSBtYWtlRWxlbWVudCgnYScsIFttYWtlRWxlbWVudCgnaScsIG51bGwsIHtjbGFzc05hbWU6ICdmYSBmYS1ib29rbWFyayd9KV0sIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgdmFyIHN2Z0J0biA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXByaW50J30pXSwge2NsYXNzTmFtZTogJ2J0bid9KTtcbiAgICB2YXIgcmVzZXRCdG4gPSBtYWtlRWxlbWVudCgnYScsIFttYWtlRWxlbWVudCgnaScsIG51bGwsIHtjbGFzc05hbWU6ICdmYSBmYS1yZWZyZXNoJ30pXSwge2NsYXNzTmFtZTogJ2J0bid9KTtcbiAgICB2YXIgb3B0c0J1dHRvbiA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLWNvZ3MnfSldLCB7Y2xhc3NOYW1lOiAnYnRuJ30pO1xuICAgIHZhciBoZWxwQnV0dG9uID0gbWFrZUVsZW1lbnQoJ2EnLCBbbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtcXVlc3Rpb24nfSldLCB7Y2xhc3NOYW1lOiAnYnRuJ30pO1xuXG4gICAgdmFyIHRpZXJFZGl0QnV0dG9uID0gbWFrZUVsZW1lbnQoJ2EnLCBbbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtcm9hZCd9KV0sIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgYi5tYWtlVG9vbHRpcCh0aWVyRWRpdEJ1dHRvbiwgJ0NvbmZpZ3VyZSBjdXJyZW50bHkgc2VsZWN0ZWQgdHJhY2socykgKEUpJylcblxuICAgIHZhciBsZWFwTGVmdEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdhJywgW21ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLWFuZ2xlLWxlZnQnfSldLCB7Y2xhc3NOYW1lOiAnYnRuJ30sIHt3aWR0aDogJzVweCd9KTtcbiAgICB2YXIgbGVhcFJpZ2h0QnV0dG9uID0gbWFrZUVsZW1lbnQoJ2EnLCBbbWFrZUVsZW1lbnQoJ2knLCBudWxsLCB7Y2xhc3NOYW1lOiAnZmEgZmEtYW5nbGUtcmlnaHQnfSldLCB7Y2xhc3NOYW1lOiAnYnRuIHB1bGwtcmlnaHQnfSwge3dpZHRoOiAnNXB4J30pO1xuXG4gICAgdmFyIG1vZGVCdXR0b25zID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICdidG4tZ3JvdXAgcHVsbC1yaWdodCd9KTtcbiAgICBpZiAoIXRoaXMubm9UcmFja0FkZGVyKVxuICAgICAgICBtb2RlQnV0dG9ucy5hcHBlbmRDaGlsZChhZGRUcmFja0J0bik7XG4gICAgaWYgKCF0aGlzLm5vVHJhY2tFZGl0b3IpXG4gICAgICAgIG1vZGVCdXR0b25zLmFwcGVuZENoaWxkKHRpZXJFZGl0QnV0dG9uKTtcbiAgICBpZiAoIXRoaXMubm9FeHBvcnQpXG4gICAgICAgIG1vZGVCdXR0b25zLmFwcGVuZENoaWxkKHN2Z0J0bik7XG4gICAgaWYgKCF0aGlzLm5vT3B0aW9ucylcbiAgICAgICAgbW9kZUJ1dHRvbnMuYXBwZW5kQ2hpbGQob3B0c0J1dHRvbik7XG4gICAgaWYgKCF0aGlzLm5vSGVscClcbiAgICAgICAgbW9kZUJ1dHRvbnMuYXBwZW5kQ2hpbGQoaGVscEJ1dHRvbik7XG5cbiAgICB0aGlzLnNldFVpTW9kZSA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgdGhpcy51aU1vZGUgPSBtO1xuICAgICAgICB2YXIgbWIgPSB7aGVscDogaGVscEJ1dHRvbiwgYWRkOiBhZGRUcmFja0J0biwgb3B0czogb3B0c0J1dHRvbiwgJ2V4cG9ydCc6IHN2Z0J0biwgdGllcjogdGllckVkaXRCdXR0b259O1xuICAgICAgICBmb3IgKHZhciB4IGluIG1iKSB7XG4gICAgICAgICAgICBpZiAoeCA9PSBtKVxuICAgICAgICAgICAgICAgIG1iW3hdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1iW3hdLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm5vTGVhcEJ1dHRvbnMpXG4gICAgICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQobGVhcFJpZ2h0QnV0dG9uKTtcblxuICAgIGlmIChtb2RlQnV0dG9ucy5maXJzdENoaWxkKVxuICAgICAgICB0b29sYmFyLmFwcGVuZENoaWxkKG1vZGVCdXR0b25zKTtcbiAgICBcbiAgICBpZiAoIXRoaXMubm9MZWFwQnV0dG9ucylcbiAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZChsZWFwTGVmdEJ1dHRvbik7XG4gICAgaWYgKCF0aGlzLm5vVGl0bGUpIHtcbiAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnZGl2JywgbWFrZUVsZW1lbnQoJ2g0JywgdGl0bGUsIHt9LCB7bWFyZ2luOiAnMHB4J30pLCB7Y2xhc3NOYW1lOiAnYnRuLWdyb3VwIHRpdGxlJ30pKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm5vTG9jYXRpb25GaWVsZClcbiAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnZGl2JywgW2xvY0ZpZWxkLCBsb2NTdGF0dXNGaWVsZF0sIHtjbGFzc05hbWU6ICdidG4tZ3JvdXAgbG9jLWdyb3VwJ30pKTtcbiAgICBpZiAoIXRoaXMubm9DbGVhckhpZ2hsaWdodHNCdXR0b24pXG4gICAgICAgIHRvb2xiYXIuYXBwZW5kQ2hpbGQoY2xlYXJIaWdobGlnaHRzQnV0dG9uKTtcblxuICAgIGlmICghdGhpcy5ub1pvb21TbGlkZXIpIHtcbiAgICAgICAgdG9vbGJhci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnZGl2JywgW3pvb21JbkJ0bixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCdzcGFuJywgem9vbVNsaWRlciwge2NsYXNzTmFtZTogJ2J0bid9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHpvb21PdXRCdG5dLCB7Y2xhc3NOYW1lOiAnYnRuLWdyb3VwJ30pKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMudG9vbGJhckJlbG93KSB7XG4gICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZChnZW5vbWVQYW5lbCk7XG4gICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZCh0b29sYmFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBob2xkZXIuYXBwZW5kQ2hpbGQodG9vbGJhcik7XG4gICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZChnZW5vbWVQYW5lbCk7XG4gICAgfVxuXG5cbiAgICB2YXIgbHQyID0gTWF0aC5sb2coMikgLyBNYXRoLmxvZygxMCk7XG4gICAgdmFyIGx0NSA9IE1hdGgubG9nKDUpIC8gTWF0aC5sb2coMTApO1xuICAgIHZhciByb3VuZFNsaWRlclZhbHVlID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgbHR4ID0gKHggLyBiLnpvb21FeHB0ICsgTWF0aC5sb2coYi56b29tQmFzZSkpIC8gTWF0aC5sb2coMTApO1xuICAgICAgICBcbiAgICAgICAgdmFyIHdob2xlID0gbHR4fDBcbiAgICAgICAgdmFyIGZyYWMgPSBsdHggLSB3aG9sZTtcbiAgICAgICAgdmFyIHJvdW5kZWRcblxuICAgICAgICBpZiAoZnJhYyA8IDAuMDEpXG4gICAgICAgICAgICByb3VuZGVkID0gd2hvbGU7XG4gICAgICAgIGVsc2UgaWYgKGZyYWMgPD0gKGx0MiArIDAuMDEpKVxuICAgICAgICAgICAgcm91bmRlZCA9IHdob2xlICsgbHQyO1xuICAgICAgICBlbHNlIGlmIChmcmFjIDw9IChsdDUgKyAwLjAxKSlcbiAgICAgICAgICAgIHJvdW5kZWQgPSB3aG9sZSArIGx0NTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3VuZGVkID0gd2hvbGUgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChyb3VuZGVkICogTWF0aC5sb2coMTApIC1NYXRoLmxvZyhiLnpvb21CYXNlKSkgKiBiLnpvb21FeHB0O1xuICAgIH1cblxuICAgIHZhciBtYXJrU2xpZGVyID0gZnVuY3Rpb24oeCkge1xuICAgICAgICB6b29tU2xpZGVyLmFkZExhYmVsKHgsIGh1bWFuUmVhZGFibGVTY2FsZShNYXRoLmV4cCh4IC8gYi56b29tRXhwdCkgKiBiLnpvb21CYXNlKSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRWaWV3TGlzdGVuZXIoZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgX29sZFpvb20sIHpvb20pIHtcbiAgICAgICAgbG9jRmllbGQudmFsdWUgPSAoY2hyICsgJzonICsgZm9ybWF0TG9uZ0ludChtaW4pICsgJy4uJyArIGZvcm1hdExvbmdJbnQobWF4KSk7XG4gICAgICAgIHpvb21TbGlkZXIubWluID0gem9vbS5taW58MDtcbiAgICAgICAgem9vbVNsaWRlci5tYXggPSB6b29tLm1heHwwO1xuICAgICAgICBpZiAoem9vbS5pc1NuYXBab29taW5nKSB7XG4gICAgICAgICAgICB6b29tU2xpZGVyLnZhbHVlID0gem9vbS5hbHRlcm5hdGVcbiAgICAgICAgICAgIHpvb21TbGlkZXIudmFsdWUyID0gem9vbS5jdXJyZW50O1xuICAgICAgICAgICAgem9vbVNsaWRlci5hY3RpdmUgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgem9vbVNsaWRlci52YWx1ZSA9IHpvb20uY3VycmVudDtcbiAgICAgICAgICAgIHpvb21TbGlkZXIudmFsdWUyID0gem9vbS5hbHRlcm5hdGU7XG4gICAgICAgICAgICB6b29tU2xpZGVyLmFjdGl2ZSA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoem9vbS5jdXJyZW50ID09IHpvb20ubWluKVxuICAgICAgICAgICAgem9vbUluQnRuLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHpvb21JbkJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdkaXNhYmxlZCcpO1xuXG4gICAgICAgIGlmICh6b29tLmN1cnJlbnQgPT0gem9vbS5tYXgpXG4gICAgICAgICAgICB6b29tT3V0QnRuLmNsYXNzTGlzdC5hZGQoJ2Rpc2FibGVkJyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHpvb21PdXRCdG4uY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZWQnKTtcblxuICAgICAgICB6b29tU2xpZGVyLnJlbW92ZUxhYmVscygpO1xuICAgICAgICB2YXIgem1pbiA9IHpvb20ubWluO1xuICAgICAgICB2YXIgem1heCA9IHpvb20ubWF4O1xuICAgICAgICB2YXIgenJhbmdlID0gem1heCAtIHptaW47XG5cbiAgICAgICAgXG4gICAgICAgIG1hcmtTbGlkZXIocm91bmRTbGlkZXJWYWx1ZSh6bWluKSk7XG4gICAgICAgIG1hcmtTbGlkZXIocm91bmRTbGlkZXJWYWx1ZSh6bWluICsgKDEuMCp6cmFuZ2UvMy4wKSkpO1xuICAgICAgICBtYXJrU2xpZGVyKHJvdW5kU2xpZGVyVmFsdWUoem1pbiArICgyLjAqenJhbmdlLzMuMCkpKTtcbiAgICAgICAgbWFya1NsaWRlcihyb3VuZFNsaWRlclZhbHVlKHptYXgpKTtcblxuICAgICAgICBpZiAoYi5zdG9yZVN0YXR1cykge1xuICAgICAgICAgICAgYi5zdG9yZVZpZXdTdGF0dXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiLmhpZ2hsaWdodHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2xlYXJIaWdobGlnaHRzQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFySGlnaGxpZ2h0c0J1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZFRpZXJMaXN0ZW5lcihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGIuc3RvcmVTdGF0dXMpIHtcbiAgICAgICAgICAgIGIuc3RvcmVUaWVyU3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGxvY0ZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihldikge1xuICAgICAgICBpZiAoZXYua2V5Q29kZSA9PSA0MCkge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBiLnNldFNlbGVjdGVkVGllcigwKTtcbiAgICAgICAgfSBpZiAoZXYua2V5Q29kZSA9PSAxMCB8fCBldi5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG5cbiAgICAgICAgICAgIHZhciBnID0gbG9jRmllbGQudmFsdWU7XG4gICAgICAgICAgICBiLnNlYXJjaChnLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY1N0YXR1c0ZpZWxkLnRleHRDb250ZW50ID0gJycgKyBlcnI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jU3RhdHVzRmllbGQudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbiAgICBcbiAgICB2YXIgdHJhY2tBZGRQb3B1cDtcbiAgICBhZGRUcmFja0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICh0cmFja0FkZFBvcHVwICYmIHRyYWNrQWRkUG9wdXAuZGlzcGxheWVkKSB7XG4gICAgICAgICAgICBiLnJlbW92ZUFsbFBvcHVwcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tBZGRQb3B1cCA9IGIuc2hvd1RyYWNrQWRkZXIoZXYpO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIGIubWFrZVRvb2x0aXAoYWRkVHJhY2tCdG4sICdBZGQgYSBuZXcgdHJhY2sgZnJvbSB0aGUgcmVnaXN0cnkgb3IgYW4gaW5kZXhlZCBmaWxlLiAoQSknKTtcblxuICAgIHpvb21JbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgYi56b29tU3RlcCgtMTApO1xuICAgIH0sIGZhbHNlKTtcbiAgICBiLm1ha2VUb29sdGlwKHpvb21JbkJ0biwgJ1pvb20gaW4gKCspJyk7XG5cbiAgICB6b29tT3V0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBiLnpvb21TdGVwKDEwKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgYi5tYWtlVG9vbHRpcCh6b29tT3V0QnRuLCAnWm9vbSBvdXQgKC0pJyk7XG5cbiAgICB6b29tU2xpZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciB3YW50U25hcCA9IHpvb21TbGlkZXIuYWN0aXZlID09IDI7XG4gICAgICAgIGlmICh3YW50U25hcCAhPSBiLmlzU25hcFpvb21pbmcpIHtcbiAgICAgICAgICAgIGIuc2F2ZWRab29tID0gYi56b29tU2xpZGVyVmFsdWUgIC0gYi56b29tTWluO1xuICAgICAgICAgICAgYi5pc1NuYXBab29taW5nID0gd2FudFNuYXA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2ZVpTViA9IHpvb21TbGlkZXIuYWN0aXZlID09IDEgPyB6b29tU2xpZGVyLnZhbHVlIDogem9vbVNsaWRlci52YWx1ZTI7XG5cbiAgICBcdGIuem9vbVNsaWRlclZhbHVlID0gKDEuMCAqIGFjdGl2ZVpTVik7XG4gICAgXHRiLnpvb20oTWF0aC5leHAoKDEuMCAqIGFjdGl2ZVpTVikgLyBiLnpvb21FeHB0KSk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgZmF2QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgYi5tYWtlVG9vbHRpcChmYXZCdG4sICdGYXZvdXJpdGUgcmVnaW9ucycpO1xuXG4gICAgc3ZnQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYi5vcGVuRXhwb3J0UGFuZWwoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgYi5tYWtlVG9vbHRpcChzdmdCdG4sICdFeHBvcnQgcHVibGljYXRpb24tcXVhbGl0eSBTVkcuIChYKScpO1xuXG4gICAgdmFyIG9wdHNQb3B1cDtcbiAgICBvcHRzQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgYi50b2dnbGVPcHRzUG9wdXAoZXYpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBiLm1ha2VUb29sdGlwKG9wdHNCdXR0b24sICdDb25maWd1cmUgb3B0aW9ucy4nKTtcblxuICAgIGhlbHBCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYi50b2dnbGVIZWxwUG9wdXAoZXYpO1xuICAgIH0pO1xuICAgIGIubWFrZVRvb2x0aXAoaGVscEJ1dHRvbiwgJ0hlbHA7IEtleWJvYXJkIHNob3J0Y3V0cy4gKEgpJyk7XG5cbiAgICB0aWVyRWRpdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoYi5zZWxlY3RlZFRpZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBiLm9wZW5UaWVyUGFuZWwoYi50aWVyc1tiLnNlbGVjdGVkVGllcnNbMF1dKTtcbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTtcblxuICAgIGxlYXBMZWZ0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgYi5sZWFwKGIucmV2ZXJzZUtleVNjcm9sbGluZyA/IC0xIDogMSwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBiLm1ha2VUb29sdGlwKGxlYXBMZWZ0QnV0dG9uLCBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgc3QgPSBiLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICB2YXIgdGllcjtcbiAgICAgICAgaWYgKHN0ID49IDApXG4gICAgICAgICAgICB0aWVyID0gYi50aWVyc1tzdF07XG5cbiAgICAgICAgaWYgKHRpZXIgJiYgdGllci5mZWF0dXJlU291cmNlICYmIGIuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdxdWFudExlYXAnKSAmJiB0eXBlb2YodGllci5xdWFudExlYXBUaHJlc2hvbGQpID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0p1bXAgdG8gdGhlIG5leHQgcmVnaW9uIHdpdGggYSBzY29yZSBhYm92ZSB0aGUgdGhyZXNob2xkIGluIHRoZSBzZWxlY3RlZCB0cmFjayBcIicgKyAodGllci5jb25maWcubmFtZSB8fCB0aWVyLmRhc1NvdXJjZS5uYW1lKSArICdcIlwiIChjdHJsK0xFRlQpJztcbiAgICAgICAgfSBlbHNlIGlmICh0aWVyICYmIHRpZXIuZmVhdHVyZVNvdXJjZSAmJiBiLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGllci5mZWF0dXJlU291cmNlLCAnbGVhcCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0p1bXAgdG8gdGhlIG5leHQgZmVhdHVyZSBpbiB0aGUgc2VsZWN0ZWQgdHJhY2sgXCInICsgKHRpZXIuY29uZmlnLm5hbWUgfHwgdGllci5kYXNTb3VyY2UubmFtZSkgKyAnXCIgKGN0cmwrTEVGVCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdKdW1wIGxlZnQgKHNoaWZ0K0xFRlQpJztcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgbGVhcFJpZ2h0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgYi5sZWFwKGIucmV2ZXJzZUtleVNjcm9sbGluZyA/IDEgOiAtMSwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBiLm1ha2VUb29sdGlwKGxlYXBSaWdodEJ1dHRvbiwgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIHN0ID0gYi5nZXRTZWxlY3RlZFRpZXIoKTtcbiAgICAgICAgdmFyIHRpZXI7XG4gICAgICAgIGlmIChzdCA+PSAwKVxuICAgICAgICAgICAgdGllciA9IGIudGllcnNbc3RdO1xuXG4gICAgICAgIGlmICh0aWVyICYmIHRpZXIuZmVhdHVyZVNvdXJjZSAmJiBiLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGllci5mZWF0dXJlU291cmNlLCAncXVhbnRMZWFwJykgJiYgdHlwZW9mKHRpZXIucXVhbnRMZWFwVGhyZXNob2xkKSA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuICdKdW1wIHRvIHRoZSBuZXh0IHJlZ2lvbiB3aXRoIGEgc2NvcmUgYWJvdmUgdGhlIHRocmVzaG9sZCBpbiB0aGUgc2VsZWN0ZWQgdHJhY2sgXCInICsgKHRpZXIuY29uZmlnLm5hbWUgfHwgdGllci5kYXNTb3VyY2UubmFtZSkgKyAnXCJcIiAoY3RybCtSSUdIVCknO1xuICAgICAgICB9IGVsc2UgaWYgKHRpZXIgJiYgdGllci5mZWF0dXJlU291cmNlICYmIGIuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdsZWFwJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSnVtcCB0byB0aGUgbmV4dCBmZWF0dXJlIGluIHRoZSBzZWxlY3RlZCB0cmFjayBcIicgKyAodGllci5jb25maWcubmFtZSB8fCB0aWVyLmRhc1NvdXJjZS5uYW1lKSArICdcIiAoY3RybCtSSUdIVCknO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICdKdW1wIHJpZ2h0IChzaGlmdCtSSUdIVCknO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgYi5hZGRUaWVyU2VsZWN0aW9uTGlzdGVuZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdCA9IGIuZ2V0U2VsZWN0ZWRUaWVyKCk7XG4gICAgICAgIHZhciB0aWVyO1xuICAgICAgICBpZiAoc3QgPj0gMClcbiAgICAgICAgICAgIHRpZXIgPSBiLnRpZXJzW3N0XTtcblxuICAgICAgICB2YXIgY2FuTGVhcCA9IGZhbHNlO1xuICAgICAgICBpZiAodGllciAmJiB0aWVyLmZlYXR1cmVTb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChiLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGllci5mZWF0dXJlU291cmNlLCAncXVhbnRMZWFwJykgJiYgdHlwZW9mKHRpZXIucXVhbnRMZWFwVGhyZXNob2xkKSA9PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBjYW5MZWFwID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGIuc291cmNlQWRhcHRlcklzQ2FwYWJsZSh0aWVyLmZlYXR1cmVTb3VyY2UsICdsZWFwJykpXG4gICAgICAgICAgICAgICAgY2FuTGVhcCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZWFwTGVmdEJ1dHRvbi5maXJzdENoaWxkLmNsYXNzTmFtZSA9IGNhbkxlYXAgPyAnZmEgZmEtYW5nbGUtZG91YmxlLWxlZnQnIDogJ2ZhIGZhLWFuZ2xlLWxlZnQnO1xuICAgICAgICBsZWFwUmlnaHRCdXR0b24uZmlyc3RDaGlsZC5jbGFzc05hbWUgPSBjYW5MZWFwID8gJ2ZhIGZhLWFuZ2xlLWRvdWJsZS1yaWdodCcgOiAnZmEgZmEtYW5nbGUtcmlnaHQnO1xuICAgIH0pO1xuXG4gICAgY2xlYXJIaWdobGlnaHRzQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgYi5jbGVhckhpZ2hsaWdodHMoKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgYi5tYWtlVG9vbHRpcChjbGVhckhpZ2hsaWdodHNCdXR0b24sICdDbGVhciBoaWdobGlnaHRzIChDKScpO1xuXG4gICAgYi5hZGRUaWVyU2VsZWN0aW9uV3JhcExpc3RlbmVyKGZ1bmN0aW9uKGRpcikge1xuICAgICAgICBpZiAoZGlyIDwgMCkge1xuICAgICAgICAgICAgYi5zZXRTZWxlY3RlZFRpZXIobnVsbCk7XG4gICAgICAgICAgICBsb2NGaWVsZC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBiLmFkZFRpZXJTZWxlY3Rpb25MaXN0ZW5lcihmdW5jdGlvbihzZWwpIHtcbiAgICAgICAgaWYgKGIudWlNb2RlID09PSAndGllcicpIHtcbiAgICAgICAgICAgIGlmIChzZWwubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICBiLmhpZGVUb29sUGFuZWwoKTtcbiAgICAgICAgICAgICAgICBiLm1hbmlwdWxhdGluZ1RpZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGIudWlNb2RlID0gJ25vbmUnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZnQgPSBiLnRpZXJzW3NlbFswXV07XG4gICAgICAgICAgICAgICAgaWYgKGZ0ICE9IGIubWFuaXB1bGF0aW5nVGllcikge1xuICAgICAgICAgICAgICAgICAgICBiLm9wZW5UaWVyUGFuZWwoZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHVpS2V5SGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdidWtoOiAnICsgZXYua2V5Q29kZSk7XG4gICAgICAgIGlmIChldi5rZXlDb2RlID09IDY1IHx8IGV2LmtleUNvZGUgPT0gOTcpIHsgIC8vIGFcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYi5zaG93VHJhY2tBZGRlcigpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gNzIgfHwgZXYua2V5Q29kZSA9PSAxMDQpIHsgLy8gaFxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBiLnRvZ2dsZUhlbHBQb3B1cChldik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSA2OSB8fCBldi5rZXlDb2RlID09IDEwMSkgeyAvL2VcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGIuc2VsZWN0ZWRUaWVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIGIub3BlblRpZXJQYW5lbChiLnRpZXJzW2Iuc2VsZWN0ZWRUaWVyc1swXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gODggfHwgZXYua2V5Q29kZSA9PSAxMjApIHsgLy8geFxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBiLm9wZW5FeHBvcnRQYW5lbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gNjcgfHwgZXYua2V5Q29kZSA9PSA5OSkgeyAvLyBjXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGIuY2xlYXJIaWdobGlnaHRzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB1aUtleUhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgaG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbihldikge1xuICAgICAgICBob2xkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHVpS2V5SGFuZGxlciwgZmFsc2UpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIGhvbGRlci5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGV2LmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICBpZiAoYi51aU1vZGUgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgY29uc3VtZSBldmVudCBpZiB0b29sIHBhbmVsIGlzIG9wZW4uXG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBiLnNldFVpTW9kZSgnbm9uZScpO1xuICAgICAgICAgICAgICAgIGIuaGlkZVRvb2xQYW5lbCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGIuc2VsZWN0ZWRUaWVycyAmJiBiLnNlbGVjdGVkVGllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBiLmJyb3dzZXJIb2xkZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNob3dUb29sUGFuZWwgPSBmdW5jdGlvbihwYW5lbCwgbm93cmFwKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIGlmICh0aGlzLmFjdGl2ZVRvb2xQYW5lbCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVRvb2xQYW5lbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuYWN0aXZlVG9vbFBhbmVsKTtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudDtcbiAgICBpZiAobm93cmFwKVxuICAgICAgICBjb250ZW50ID0gcGFuZWw7XG4gICAgZWxzZVxuICAgICAgICBjb250ZW50ID0gbWFrZUVsZW1lbnQoJ2RpdicsIHBhbmVsLCB7fSwge292ZXJmbG93WTogJ2F1dG8nLCB3aWR0aDogJzEwMCUnfSk7XG5cblxuICAgIHZhciBkaXZpZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLWNhcmV0LXJpZ2h0J30pLCB7Y2xhc3NOYW1lOiAndG9vbC1kaXZpZGVyJ30pO1xuICAgIGRpdmlkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICB0aGlzQi5oaWRlVG9vbFBhbmVsKCk7XG4gICAgICAgIHRoaXNCLnNldFVpTW9kZSgnbm9uZScpO1xuICAgIH0sIGZhbHNlKTtcbiAgICB0aGlzLm1ha2VUb29sdGlwKGRpdmlkZXIsICdDbG9zZSB0b29sIHBhbmVsIChFU0MpJyk7XG4gICAgdGhpcy5hY3RpdmVUb29sUGFuZWwgPSBtYWtlRWxlbWVudCgnZGl2JywgW2RpdmlkZXIsIGNvbnRlbnRdLCB7Y2xhc3NOYW1lOiAndG9vbC1ob2xkZXInfSk7XG4gICAgdGhpcy5zdmdIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5hY3RpdmVUb29sUGFuZWwpO1xuICAgIHRoaXMucmVzaXplVmlld2VyKCk7XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5oaWRlVG9vbFBhbmVsID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlVG9vbFBhbmVsKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlVG9vbFBhbmVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5hY3RpdmVUb29sUGFuZWwpO1xuICAgIH1cbiAgICB0aGlzLnN2Z0hvbGRlci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0aGlzLmFjdGl2ZVRvb2xQYW5lbCA9IG51bGw7XG4gICAgdGhpcy5yZXNpemVWaWV3ZXIoKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUudG9nZ2xlSGVscFBvcHVwID0gZnVuY3Rpb24oZXYpIHtcbiAgICBpZiAodGhpcy51aU1vZGUgPT09ICdoZWxwJykge1xuICAgICAgICB0aGlzLmhpZGVUb29sUGFuZWwoKTtcbiAgICAgICAgdGhpcy5zZXRVaU1vZGUoJ25vbmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaGVscEZyYW1lID0gbWFrZUVsZW1lbnQoJ2lmcmFtZScsIG51bGwsIHtzY3JvbGxpbmc6ICd5ZXMnLCBzZWFtbGVzczogJ3NlYW1sZXNzJywgc3JjOiB0aGlzLnJlc29sdmVVUkwoJyQkaGVscC9pbmRleC5odG1sJyksIGNsYXNzTmFtZTogJ2hlbHAtcGFuZWwnfSk7XG4gICAgICAgIHRoaXMuc2hvd1Rvb2xQYW5lbChoZWxwRnJhbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRVaU1vZGUoJ2hlbHAnKTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnRvZ2dsZU9wdHNQb3B1cCA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgdmFyIGIgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMudWlNb2RlID09PSAnb3B0cycpIHtcbiAgICAgICAgdGhpcy5oaWRlVG9vbFBhbmVsKCk7XG4gICAgICAgIHRoaXMuc2V0VWlNb2RlKCdub25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9wdHNGb3JtID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICdmb3JtLWhvcml6b250YWwnfSwge2JveFNpemluZzogJ2JvcmRlci1ib3gnLCBNb3pCb3hTaXppbmc6ICdib3JkZXItYm94JywgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIHZlcnRpY2FsQWxpZ246ICd0b3AnfSk7XG4gICAgICAgIHZhciBvcHRzVGFibGUgPSBtYWtlRWxlbWVudCgndGFibGUnKTtcbiAgICAgICAgb3B0c1RhYmxlLmNlbGxQYWRkaW5nID0gNTtcblxuICAgICAgICB2YXIgc2Nyb2xsTW9kZUJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7dHlwZTogJ2NoZWNrYm94JywgY2hlY2tlZDogYi5yZXZlcnNlU2Nyb2xsaW5nfSk7XG4gICAgICAgIHNjcm9sbE1vZGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIucmV2ZXJzZVNjcm9sbGluZyA9IHNjcm9sbE1vZGVCdXR0b24uY2hlY2tlZDtcbiAgICAgICAgICAgIGIuc3RvcmVTdGF0dXMoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBvcHRzVGFibGUuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3RyJywgW21ha2VFbGVtZW50KCd0ZCcsICdSZXZlcnNlIHRyYWNrcGFkIHNjcm9sbGluZycsIHthbGlnbjogJ3JpZ2h0J30pLCBtYWtlRWxlbWVudCgndGQnLCBzY3JvbGxNb2RlQnV0dG9uKV0pKTtcblxuICAgICAgICB2YXIgc2Nyb2xsS2V5QnV0dG9uID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgJycsIHt0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiBiLnJldmVyc2VLZXlTY3JvbGxpbmd9KTtcbiAgICAgICAgc2Nyb2xsS2V5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBiLnJldmVyc2VLZXlTY3JvbGxpbmcgPSBzY3JvbGxLZXlCdXR0b24uY2hlY2tlZDtcbiAgICAgICAgICAgIGIuc3RvcmVTdGF0dXMoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBvcHRzVGFibGUuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3RyJywgW21ha2VFbGVtZW50KCd0ZCcsICdSZXZlcnNlIHNjcm9sbGluZyBidXR0b25zIGFuZCBrZXlzJywge2FsaWduOiAncmlnaHQnfSksIG1ha2VFbGVtZW50KCd0ZCcsIHNjcm9sbEtleUJ1dHRvbildKSk7XG5cblxuICAgICAgICB2YXIgcnVsZXJTZWxlY3QgPSBtYWtlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIHJ1bGVyU2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnTGVmdCcsIHt2YWx1ZTogJ2xlZnQnfSkpO1xuICAgICAgICBydWxlclNlbGVjdC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnb3B0aW9uJywgJ0NlbnRlcicsIHt2YWx1ZTogJ2NlbnRlcid9KSk7XG4gICAgICAgIHJ1bGVyU2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnUmlnaHQnLCB7dmFsdWU6ICdyaWdodCd9KSk7XG4gICAgICAgIHJ1bGVyU2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnTm9uZScsIHt2YWx1ZTogJ25vbmUnfSkpO1xuICAgICAgICBydWxlclNlbGVjdC52YWx1ZSA9IGIucnVsZXJMb2NhdGlvbjtcbiAgICAgICAgcnVsZXJTZWxlY3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIucnVsZXJMb2NhdGlvbiA9IHJ1bGVyU2VsZWN0LnZhbHVlO1xuICAgICAgICAgICAgYi5wb3NpdGlvblJ1bGVyKCk7XG4gICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgYi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICBiLnRpZXJzW3RpXS5wYWludFF1YW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiLnN0b3JlU3RhdHVzKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgb3B0c1RhYmxlLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCd0cicsIFttYWtlRWxlbWVudCgndGQnLCAnVmVydGljYWwgZ3VpZGVsaW5lJywge2FsaWduOiAncmlnaHQnfSksIG1ha2VFbGVtZW50KCd0ZCcsIHJ1bGVyU2VsZWN0KV0pKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzaW5nbGVCYXNlSGlnaGxpZ2h0QnV0dG9uID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgJycsIHt0eXBlOiAnY2hlY2tib3gnLCBjaGVja2VkOiBiLnNpbmdsZUJhc2VIaWdobGlnaHR9KTsgXG4gICAgICAgIHNpbmdsZUJhc2VIaWdobGlnaHRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIuc2luZ2xlQmFzZUhpZ2hsaWdodCA9IHNpbmdsZUJhc2VIaWdobGlnaHRCdXR0b24uY2hlY2tlZDtcbiAgICAgICAgICAgIGIucG9zaXRpb25SdWxlcigpO1xuICAgICAgICAgICAgYi5zdG9yZVN0YXR1cygpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIHNpbmdsZUJhc2VIaWdobGlnaHRCdXR0b24uc2V0QXR0cmlidXRlKCdpZCcsJ3NpbmdsZUJhc2VIaWdodGxpZ2h0QnV0dG9uJyk7IC8vIG1ha2luZyB0aGlzIGJlY2F1c2UgYWNjZXNzIGlzIHJlcXVpcmVkIHdoZW4gdGhlIGtleSAndScgaXMgcHJlc3NlZCBhbmQgdGhlIG9wdGlvbnMgYXJlIHZpc2libGVcbiAgICAgICAgb3B0c1RhYmxlLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCd0cicsIFttYWtlRWxlbWVudCgndGQnLCAnRGlzcGxheSBhbmQgaGlnaGxpZ2h0IGN1cnJlbnQgZ2Vub21lIGxvY2F0aW9uJywge2FsaWduOiAncmlnaHQnfSksIG1ha2VFbGVtZW50KCd0ZCcsIHNpbmdsZUJhc2VIaWdobGlnaHRCdXR0b24pXSkpO1xuICAgICAgICBcbiAgICAgICAgb3B0c0Zvcm0uYXBwZW5kQ2hpbGQob3B0c1RhYmxlKTtcblxuICAgICAgICB2YXIgcmVzZXRCdXR0b24gPSBtYWtlRWxlbWVudCgnYnV0dG9uJywgJ1Jlc2V0IGJyb3dzZXInLCB7Y2xhc3NOYW1lOiAnYnRuJ30sIHttYXJnaW5MZWZ0OiAnYXV0bycsIG1hcmdpblJpZ2h0OiAnYXV0bycsIGRpc3BsYXk6ICdibG9jayd9KTtcbiAgICAgICAgcmVzZXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgYi5yZXNldCgpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIG9wdHNGb3JtLmFwcGVuZENoaWxkKHJlc2V0QnV0dG9uKTtcblxuICAgICAgICB0aGlzLnNob3dUb29sUGFuZWwob3B0c0Zvcm0pO1xuICAgICAgICB0aGlzLnNldFVpTW9kZSgnb3B0cycpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaHVtYW5SZWFkYWJsZVNjYWxlKHgpIHtcbiAgICB2YXIgc3VmZml4ID0gJ2JwJztcbiAgICBpZiAoeCA+IDEwMDAwMDAwMDApIHtcbiAgICAgICAgeCAvPSAxMDAwMDAwMDAwO1xuICAgICAgICBzdWZmaXggPSAnR2InO1xuICAgIH0gZWxzZSBpZiAoeCA+IDEwMDAwMDApIHtcbiAgICAgICAgeCAvPSAxMDAwMDAwXG4gICAgICAgIHN1ZmZpeCA9ICdNYic7XG4gICAgfSBlbHNlIGlmICh4ID4gMTAwMCkge1xuICAgICAgICB4IC89IDEwMDA7XG4gICAgICAgIHN1ZmZpeCA9ICdrYic7XG4gICAgfVxuICAgIHJldHVybiAnJyArIE1hdGgucm91bmQoeCkgKyBzdWZmaXg7XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDExXG4vL1xuLy8gY2Jyb3dzZXIuanM6IGNhbnZhcyBicm93c2VyIGNvbnRhaW5lclxuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBPYnNlcnZlZCA9IHV0aWxzLk9ic2VydmVkO1xuICAgIHZhciBBd2FpdGVkID0gdXRpbHMuQXdhaXRlZDtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbiAgICB2YXIgcmVtb3ZlQ2hpbGRyZW4gPSB1dGlscy5yZW1vdmVDaGlsZHJlbjtcbiAgICB2YXIgbWluaUpTT05pZnkgPSB1dGlscy5taW5pSlNPTmlmeTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcbiAgICB2YXIgdGV4dFhIUiA9IHV0aWxzLnRleHRYSFI7XG5cbiAgICB2YXIgdGllciA9IHJlcXVpcmUoJy4vdGllcicpO1xuICAgIHZhciBEYXNUaWVyID0gdGllci5EYXNUaWVyO1xuXG4gICAgdmFyIHNoYTEgPSByZXF1aXJlKCcuL3NoYTEnKTtcbiAgICB2YXIgaGV4X3NoYTEgPSBzaGExLmhleF9zaGExO1xuXG4gICAgdmFyIHRodWIgPSByZXF1aXJlKCcuL3RodWInKTtcbiAgICB2YXIgY29ubmVjdFRyYWNrSHViID0gdGh1Yi5jb25uZWN0VHJhY2tIdWI7XG5cbiAgICB2YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG4gICAgdmFyIG5mID0gcmVxdWlyZSgnLi9udW1mb3JtYXRzJyk7XG4gICAgdmFyIGZvcm1hdFF1YW50TGFiZWwgPSBuZi5mb3JtYXRRdWFudExhYmVsO1xuICAgIHZhciBmb3JtYXRMb25nSW50ID0gbmYuZm9ybWF0TG9uZ0ludDtcblxuICAgIHZhciBDaGFpbnNldCA9IHJlcXVpcmUoJy4vY2hhaW5zZXQnKS5DaGFpbnNldDtcblxuICAgIHZhciBQcm9taXNlID0gcmVxdWlyZSgnZXM2LXByb21pc2UnKS5Qcm9taXNlO1xuXG4gICAgdmFyIHNvdXJjZWNvbXBhcmUgPSByZXF1aXJlKCcuL3NvdXJjZWNvbXBhcmUnKTtcbiAgICB2YXIgc291cmNlc0FyZUVxdWFsID0gc291cmNlY29tcGFyZS5zb3VyY2VzQXJlRXF1YWw7XG4gICAgdmFyIHNvdXJjZXNBcmVFcXVhbE1vZHVsb1N0eWxlID0gc291cmNlY29tcGFyZS5zb3VyY2VzQXJlRXF1YWxNb2R1bG9TdHlsZTtcbiAgICB2YXIgc291cmNlRGF0YVVSSSA9IHNvdXJjZWNvbXBhcmUuc291cmNlRGF0YVVSSTtcbiAgICB2YXIgc291cmNlU3R5bGVVUkkgPSBzb3VyY2Vjb21wYXJlLnNvdXJjZVN0eWxlVVJJO1xufVxuXG5mdW5jdGlvbiBSZWdpb24oY2hyLCBtaW4sIG1heCkge1xuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIHRoaXMuY2hyID0gY2hyO1xufVxuXG5mdW5jdGlvbiBCcm93c2VyKG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMucHJlZml4ID0gJy8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvcmVsZWFzZS0wLjEzLyc7XG5cbiAgICB0aGlzLnNvdXJjZXMgPSBbXTtcbiAgICB0aGlzLnRpZXJzID0gW107XG4gICAgdGhpcy50aWVyR3JvdXBzID0ge307XG5cbiAgICB0aGlzLmZlYXR1cmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmZlYXR1cmVIb3Zlckxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMudmlld0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMucmVnaW9uU2VsZWN0TGlzdGVuZXJzID0gW107XG4gICAgdGhpcy50aWVyTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy50aWVyU2VsZWN0aW9uTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy50aWVyU2VsZWN0aW9uV3JhcExpc3RlbmVycyA9IFtdO1xuXG4gICAgdGhpcy5jb29raWVLZXkgPSAnYnJvd3Nlcic7XG5cbiAgICB0aGlzLmNoYWlucyA9IHt9O1xuXG4gICAgdGhpcy5wYWdlTmFtZSA9ICdzdmdIb2xkZXInXG4gICAgdGhpcy5tYXhFeHRyYSA9IDIuNTtcbiAgICB0aGlzLm1pbkV4dHJhID0gMC41O1xuICAgIHRoaXMuem9vbUZhY3RvciA9IDEuMDtcbiAgICB0aGlzLm1heFBpeGVsc1BlckJhc2UgPSAxMDtcbiAgICB0aGlzLm9yaWdpbiA9IDA7XG4gICAgdGhpcy50YXJnZXRRdWFudFJlcyA9IDEuMDtcbiAgICB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoID0gNzUwO1xuICAgIHRoaXMuem9vbUJhc2UgPSAxMDA7XG4gICAgdGhpcy56b29tRXhwdCA9IDMwLjA7IC8vIEJhY2sgdG8gYmVpbmcgZml4ZWQuLi4uXG4gICAgdGhpcy56b29tU2xpZGVyVmFsdWUgPSAxMDA7XG4gICAgdGhpcy5lbnRyeVBvaW50cyA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50U2VxTWF4ID0gLTE7IC8vIGluaXQgb25jZSBFUHMgYXJlIGZldGNoZWQuXG5cbiAgICB0aGlzLmhpZ2hsaWdodHMgPSBbXTtcbiAgICB0aGlzLnNlbGVjdGVkVGllcnMgPSBbMV07XG5cbiAgICB0aGlzLm1heFZpZXdXaWR0aCA9IDUwMDAwMDtcbiAgICB0aGlzLmRlZmF1bHRTdWJ0aWVyTWF4ID0gMTAwO1xuXG4gICAgLy8gT3B0aW9ucy5cbiAgICBcbiAgICB0aGlzLnJldmVyc2VTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJ1bGVyTG9jYXRpb24gPSAnY2VudGVyJztcbiAgICB0aGlzLmRlZmF1bHRIaWdobGlnaHRGaWxsID0gJ3JlZCc7XG4gICAgdGhpcy5kZWZhdWx0SGlnaGxpZ2h0QWxwaGEgPSAwLjM7XG4gICAgdGhpcy5leHBvcnRIaWdobGlnaHRzID0gdHJ1ZTtcbiAgICB0aGlzLmV4cG9ydFJ1bGVyID0gdHJ1ZTtcbiAgICB0aGlzLnNpbmdsZUJhc2VIaWdobGlnaHQgPSB0cnVlO1xuICAgIFxuICAgIC8vIFZpc3VhbCBjb25maWcuXG5cbiAgICAvLyB0aGlzLnRpZXJCYWNrZ3JvdW5kQ29sb3JzID0gW1wicmdiKDI0NSwyNDUsMjQ1KVwiLCBcInJnYigyMzAsMjMwLDI1MClcIiAvKiAnd2hpdGUnICovXTtcbiAgICB0aGlzLnRpZXJCYWNrZ3JvdW5kQ29sb3JzID0gW1wicmdiKDI0NSwyNDUsMjQ1KVwiLCAnd2hpdGUnXTtcbiAgICB0aGlzLm1pblRpZXJIZWlnaHQgPSAyMDtcbiAgICB0aGlzLm5vRGVmYXVsdExhYmVscyA9IGZhbHNlO1xuXG4gICAgLy8gUmVnaXN0cnlcblxuICAgIHRoaXMuYXZhaWxhYmxlU291cmNlcyA9IG5ldyBPYnNlcnZlZCgpO1xuICAgIHRoaXMuZGVmYXVsdFNvdXJjZXMgPSBbXTtcbiAgICB0aGlzLm1hcHBhYmxlU291cmNlcyA9IHt9O1xuXG4gICAgLy8gQ2VudHJhbCBEQVMgUmVnaXN0cnkgbm8gbG9uZ2VyIGF2YWlsYWJsZSAyMDE1LTA1XG5cbiAgICB0aGlzLnJlZ2lzdHJ5ID0gbnVsbDsgLy8gJy8vd3d3LmRhc3JlZ2lzdHJ5Lm9yZy9kYXMvc291cmNlcyc7XG4gICAgdGhpcy5ub1JlZ2lzdHJ5VGFicyA9IHRydWU7XG5cbiAgICB0aGlzLmh1YnMgPSBbXTtcbiAgICB0aGlzLmh1Yk9iamVjdHMgPSBbXTtcblxuICAgIHRoaXMuc291cmNlQ2FjaGUgPSBuZXcgU291cmNlQ2FjaGUoKTtcbiAgICBcbiAgICB0aGlzLnJldGluYSA9IHRydWU7XG5cbiAgICB0aGlzLnVzZUZldGNoV29ya2VycyA9IHRydWU7XG4gICAgdGhpcy5tYXhXb3JrZXJzID0gMjtcbiAgICB0aGlzLndvcmtlclBhdGggPSAnJCR3b3JrZXItYWxsLmpzJztcblxuICAgIHRoaXMuYXNzZW1ibHlOYW1lUHJpbWFyeSA9IHRydWU7XG4gICAgdGhpcy5hc3NlbWJseU5hbWVVY3NjID0gdHJ1ZTtcblxuICAgIC8vIEhUVFAgd2FybmluZyBzdXBwb3J0XG5cbiAgICB0aGlzLmh0dHBDYW5hcnlVUkwgPSAnaHR0cDovL3d3dy5iaW9kYWxsaWFuY2Uub3JnL2h0dHAtY2FuYXJ5LnR4dCc7XG4gICAgdGhpcy5odHRwV2FybmluZ1VSTCA9ICcvL3d3dy5iaW9kYWxsaWFuY2Uub3JnL2h0dHBzLmh0bWwnO1xuXG4gICAgdGhpcy5pbml0TGlzdGVuZXJzID0gW107XG5cbiAgICBpZiAob3B0cy5iYXNlQ29sb3JzKSB7XG4gICAgICAgIHRoaXMuYmFzZUNvbG9ycyA9IG9wdHMuYmFzZUNvbG9yc1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFzZUNvbG9ycyA9IHtcbiAgICAgICAgICAgIEE6ICdncmVlbicsXG4gICAgICAgICAgICBDOiAnYmx1ZScsXG4gICAgICAgICAgICBHOiAnb3JhbmdlJyxcbiAgICAgICAgICAgIFQ6ICdyZWQnLFxuICAgICAgICAgICAgJy0nIDogJ2hvdHBpbmsnLCAvLyBkZWxldGlvblxuICAgICAgICAgICAgJ0knIDogJ3JlZCcgLy8gaW5zZXJ0aW9uXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKG9wdHMudmlld1N0YXJ0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mKG9wdHMudmlld1N0YXJ0KSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ3ZpZXdTdGFydCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG4gICAgaWYgKG9wdHMudmlld0VuZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZihvcHRzLnZpZXdFbmQpICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBFcnJvcigndmlld0VuZCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrIGluIG9wdHMpIHtcbiAgICAgICAgdGhpc1trXSA9IG9wdHNba107XG4gICAgfVxuICAgIGlmICh0eXBlb2Yob3B0cy51aVByZWZpeCkgPT09ICdzdHJpbmcnICYmIHR5cGVvZihvcHRzLnByZWZpeCkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMucHJlZml4ID0gb3B0cy51aVByZWZpeDtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHByZWZpeCBvbmx5IHN0YXJ0cyB3aXRoIGEgc2luZ2xlICcvJyB0aGlzIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50XG4gICAgLy8gc2l0ZSwgc28gd2UgbmVlZCB0byBwcmVmaXggdGhlIHByZWZpeCB3aXRoIC8ve2hvc3RuYW1lfVxuICAgIGlmICh0aGlzLnByZWZpeC5pbmRleE9mKCcvLycpIDwgMCAmJiB0aGlzLnByZWZpeC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLnBvcnQpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uICs9ICc6JyArIHdpbmRvdy5sb2NhdGlvbi5wb3J0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJlZml4ID0gJy8vJyArIGxvY2F0aW9uICsgdGhpcy5wcmVmaXg7XG4gICAgfVxuICAgIGlmICh0aGlzLnByZWZpeC5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICAgIHZhciBwcm90byA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgaWYgKHByb3RvID09ICdodHRwOicgfHwgcHJvdG8gPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIC8vIFByb3RvY29sLXJlbGF0aXZlIFVSTHMgb2theS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogcHJlZml4IGlzIHNldCB0byBhIHByb3RvY29sLXJlbGF0aXZlIFVSTCAoJyArIHRoaXMucHJlZml4ICsgJyB3aGVuIGxvYWRpbmcgZnJvbSBhIG5vbi1IVFRQIHNvdXJjZScpO1xuICAgICAgICAgICAgdGhpcy5wcmVmaXggPSAnaHR0cDonICsgdGhpcy5wcmVmaXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29vcmRTeXN0ZW0pIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Nvb3JkaW5hdGUgc3lzdGVtIG11c3QgYmUgY29uZmlndXJlZCcpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNociA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudmlld1N0YXJ0ID09PSB1bmRlZmluZWQgfHwgdGhpcy52aWV3RW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1ZpZXdlZCByZWdpb24gKGNocjpzdGFydC4uZW5kKSBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgdGhpc0IucmVhbEluaXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbG9hZExpc3RlbmVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzQi5yZWFsSW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyLCBmYWxzZSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZXNvbHZlVVJMID0gZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIHVybC5yZXBsYWNlKCckJCcsIHRoaXMucHJlZml4KTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZUxpc3RlbmVyLCBmYWxzZSk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlYWxJbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMud2FzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcGluZyB0byBjYWxsIHJlYWxJbml0IG9uIGFuIGFscmVhZHktaW5pdGlhbGl6ZWQgRGFsbGlhbmNlIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLndhc0luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgJ2R1bW15JztcbiAgICBpZiAodWEuaW5kZXhPZignVHJpZGVudCcpID49IDAgJiYgdWEuaW5kZXhPZigncnY6MTEnKSA+PSAwKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdEZXRlY3RlZCBJRTExLCBkaXNhYmxpbmcgdGllciBwaW5uaW5nLicpO1xuICAgICAgICB0aGlzLmRpc2FibGVQaW5uaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmRlZmF1bHRDaHIgPSB0aGlzLmNocjtcbiAgICB0aGlzLmRlZmF1bHRTdGFydCA9IHRoaXMudmlld1N0YXJ0O1xuICAgIHRoaXMuZGVmYXVsdEVuZCA9IHRoaXMudmlld0VuZDtcbiAgICB0aGlzLmRlZmF1bHRTb3VyY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNvdXJjZXNbaV07XG4gICAgICAgIGlmIChzKVxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U291cmNlcy5wdXNoKHMpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlc3RvcmVTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNSZXN0b3JlZCA9IHRoaXMucmVzdG9yZVN0YXR1cygpO1xuICAgIH1cblxuICAgIHZhciBoZWxwUG9wdXA7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmJyb3dzZXJIb2xkZXJIb2xkZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLnBhZ2VOYW1lKTtcbiAgICB0aGlzLmJyb3dzZXJIb2xkZXJIb2xkZXIuY2xhc3NMaXN0LmFkZCgnZGFsbGlhbmNlLWluamVjdGlvbi1wb2ludCcpO1xuICAgIHRoaXMuYnJvd3NlckhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnLCBudWxsLCB7Y2xhc3NOYW1lOiAnZGFsbGlhbmNlIGRhbGxpYW5jZS1yb290JywgdGFiSW5kZXg6IC0xfSk7XG4gICAgaWYgKHRoaXMubWF4SGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuYnJvd3NlckhvbGRlci5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCArICdweCc7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1heEhlaWdodCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5icm93c2VySG9sZGVyLnN0eWxlLm1heEhlaWdodCA9IG51bGw7XG4gICAgfVxuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMuYnJvd3NlckhvbGRlckhvbGRlcik7XG4gICAgdGhpcy5icm93c2VySG9sZGVySG9sZGVyLmFwcGVuZENoaWxkKHRoaXMuYnJvd3NlckhvbGRlcik7XG4gICAgdGhpcy5zdmdIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ21haW4taG9sZGVyJ30pO1xuXG4gICAgdGhpcy5pbml0VUkodGhpcy5icm93c2VySG9sZGVyLCB0aGlzLnN2Z0hvbGRlcik7XG5cbiAgICB0aGlzLnBpbm5lZFRpZXJIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ3RpZXItaG9sZGVyIHRpZXItaG9sZGVyLXBpbm5lZCd9KTtcbiAgICB0aGlzLnRpZXJIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgdGhpcy5tYWtlTG9hZGVyKDI0KSwge2NsYXNzTmFtZTogJ3RpZXItaG9sZGVyIHRpZXItaG9sZGVyLXJlc3QnfSk7XG5cbiAgICB0aGlzLmxvY1NpbmdsZUJhc2UgPSBtYWtlRWxlbWVudCgnc3BhbicsICcnLCB7Y2xhc3NOYW1lOiAnbG9jLXNpbmdsZS1iYXNlJ30pO1xuICAgIHZhciBsb2NTaW5nbGVCYXNlSG9sZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIHRoaXMubG9jU2luZ2xlQmFzZSx7Y2xhc3NOYW1lOiAnbG9jLXNpbmdsZS1iYXNlLWhvbGRlcid9KTsgXG4gICAgLy8gQWRkIGxpc3RlbmVyIHRvIHVwZGF0ZSBzaW5nbGUgYmFzZSBsb2NhdGlvblxuICAgIHRoaXMuYWRkVmlld0xpc3RlbmVyKGZ1bmN0aW9uKGNociwgbWluRmxvb3IsIG1heEZsb29yLCB6b29tU2xpZGVyVmFsdWUsIHpvb21TbGlkZXJEaWN0LCBtaW4sIG1heCkge1xuICAgICAgICAvLyBKdXN0IHNldHRpbmcgdGV4dENvbnRlbnQgY2F1c2VzIGxheW91dCBmbGlja2VyaW5nIGluIEJsaW5rLlxuICAgICAgICAvLyBUaGlzIGFwcHJvYWNoIG1lYW5zIHRoYXQgdGhlIGVsZW1lbnQgaXMgbmV2ZXIgZW1wdHkuXG4gICAgICAgIHZhciBsb2MgPSBNYXRoLnJvdW5kKChtYXggKyBtaW4pIC8gMik7XG4gICAgICAgIHNlbGYubG9jU2luZ2xlQmFzZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaHIgKyAnOicgKyBmb3JtYXRMb25nSW50KGxvYykpKTtcbiAgICAgICAgc2VsZi5sb2NTaW5nbGVCYXNlLnJlbW92ZUNoaWxkKHNlbGYubG9jU2luZ2xlQmFzZS5maXJzdENoaWxkKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmRpc2FibGVQaW5uaW5nKSB7XG4gICAgICAgIHRoaXMudGllckhvbGRlckhvbGRlciA9IHRoaXMudGllckhvbGRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRpZXJIb2xkZXJIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgW2xvY1NpbmdsZUJhc2VIb2xkZXIsIHRoaXMucGlubmVkVGllckhvbGRlciwgdGhpcy50aWVySG9sZGVyXSwge2NsYXNzTmFtZTogJ3RpZXItaG9sZGVyLWhvbGRlcid9KTtcbiAgICAgICAgdGhpcy5zdmdIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy50aWVySG9sZGVySG9sZGVyKTtcbiAgICB9XG4gICAgdGhpcy5zdmdIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy50aWVySG9sZGVySG9sZGVyKTtcblxuICAgIHRoaXMuYmh0bWxSb290ID0gbWFrZUVsZW1lbnQoJ2RpdicpO1xuICAgIGlmICghdGhpcy5kaXNhYmxlUG93ZXJlZEJ5KSB7XG4gICAgICAgIHRoaXMuYmh0bWxSb290LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdzcGFuJywgWydQb3dlcmVkIGJ5ICcsIG1ha2VFbGVtZW50KCdhJywgJ0Jpb2RhbGxpYW5jZScsIHtocmVmOiAnaHR0cDovL3d3dy5iaW9kYWxsaWFuY2Uub3JnLyd9KSwgJyAnICsgVkVSU0lPTl0sIHtjbGFzc05hbWU6ICdwb3dlcmVkLWJ5J30pKTtcbiAgICB9XG4gICAgdGhpcy5icm93c2VySG9sZGVyLmFwcGVuZENoaWxkKHRoaXMuYmh0bWxSb290KTtcbiAgICBcbiAgICB0aGlzLnJlc2l6ZUxpc3RlbmVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdGhpc0IucmVzaXplVmlld2VyKCk7XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemVMaXN0ZW5lciwgZmFsc2UpO1xuICAgIHRoaXMucnVsZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ2d1aWRlbGluZSd9KVxuICAgIHRoaXMucnVsZXIyID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICdzaW5nbGUtYmFzZS1ndWlkZWxpbmUnfSk7XG4gICAgdGhpcy50aWVySG9sZGVySG9sZGVyLmFwcGVuZENoaWxkKHRoaXMucnVsZXIpO1xuICAgIHRoaXMudGllckhvbGRlckhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnJ1bGVyMik7XG4gICAgdGhpcy5jaGFpbkNvbmZpZ3MgPSB0aGlzLmNoYWlucyB8fCB7fTtcbiAgICB0aGlzLmNoYWlucyA9IHt9O1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5jaGFpbkNvbmZpZ3MpIHtcbiAgICAgICAgdmFyIGNjID0gdGhpcy5jaGFpbkNvbmZpZ3Nba107XG4gICAgICAgIGlmIChjYyBpbnN0YW5jZW9mIENoYWluc2V0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnV0FSTklORzogU2hvdWxkIG5vIGxvbmdlciB1c2UgXCJuZXcgQ2hhaW5zZXRcIiBpbiBCaW9kYWxsaWFuY2UgY29uZmlndXJhdGlvbnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFpbnNba10gPSBuZXcgQ2hhaW5zZXQoY2MpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlZFdvcmtlcnM7XG4gICAgaWYgKHRoaXMubWF4V29ya2VycyA+IDApIHtcbiAgICAgICAgdmFyIHB3ID0gW107XG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCB0aGlzLm1heFdvcmtlcnM7ICsrZmkpXG4gICAgICAgICAgICBwdy5wdXNoKG1ha2VGZXRjaFdvcmtlcih0aGlzKSk7XG4gICAgICAgIHByb21pc2VkV29ya2VycyA9IFByb21pc2UuYWxsKHB3KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlZFdvcmtlcnMgPSBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIHRoaXMuZmV0Y2hXb3JrZXJzID0gbnVsbDtcbiAgICB0aGlzLm5leHRXb3JrZXIgPSAwO1xuICAgIHByb21pc2VkV29ya2Vycy50aGVuKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0Jvb3RlZCAnICsgdi5sZW5ndGggKyAnIHdvcmtlcnMnKTtcbiAgICAgICAgdGhpc0IuZmV0Y2hXb3JrZXJzID0gdjsgXG4gICAgfSwgZnVuY3Rpb24odikge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIGJvb3Qgd29ya2VycycsIHYpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzQi5icm93c2VySG9sZGVySG9sZGVyKS5kaXNwbGF5ICE9ICdub25lJyAmJlxuICAgICAgICAgICAgdGhpc0IudGllckhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IDApXG4gICAgICAgIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7dGhpc0IucmVhbEluaXQyKCl9LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwb2xsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpc0IuYnJvd3NlckhvbGRlckhvbGRlcikuZGlzcGxheSAhPSAnbm9uZScgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllckhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA+IDApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHBvbGxJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnJlYWxJbml0MigpO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlYWxJbml0MiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG5cbiAgICAvLyBSZW1vdmUgdGhlIGxvYWRlciBpY29uLCBpZiBuZWVkZWRcbiAgICByZW1vdmVDaGlsZHJlbih0aGlzLnRpZXJIb2xkZXIpO1xuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMucGlubmVkVGllckhvbGRlcik7XG5cbiAgICB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoID0gdGhpcy50aWVySG9sZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHwgMDtcbiAgICB0aGlzLnNjYWxlID0gdGhpcy5mZWF0dXJlUGFuZWxXaWR0aCAvICh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCk7XG4gICAgaWYgKCF0aGlzLnpvb21NYXgpIHtcbiAgICAgICAgdGhpcy56b29tTWF4ID0gdGhpcy56b29tRXhwdCAqIE1hdGgubG9nKHRoaXMubWF4Vmlld1dpZHRoIC8gdGhpcy56b29tQmFzZSk7XG4gICAgICAgIHRoaXMuem9vbU1pbiA9IHRoaXMuem9vbUV4cHQgKiBNYXRoLmxvZyh0aGlzLmZlYXR1cmVQYW5lbFdpZHRoIC8gdGhpcy5tYXhQaXhlbHNQZXJCYXNlIC8gdGhpcy56b29tQmFzZSk7XG4gICAgfVxuICAgIHRoaXMuem9vbVNsaWRlclZhbHVlID0gdGhpcy56b29tRXhwdCAqIE1hdGgubG9nKCh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCArIDEpIC8gdGhpcy56b29tQmFzZSk7XG5cbiAgICAvLyBFdmVudCBoYW5kbGVyc1xuXG4gICAgdGhpcy50aWVySG9sZGVySG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoZXYud2hlZWxEZWx0YVgpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YSA9IGV2LndoZWVsRGVsdGFYLzU7XG4gICAgICAgICAgICBpZiAoIXRoaXNCLnJldmVyc2VTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNCLm1vdmUoZGVsdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2LndoZWVsRGVsdGFZKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBldi53aGVlbERlbHRhWTtcbiAgICAgICAgICAgIGlmICh0aGlzQi5yZXZlcnNlU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzQi50aWVySG9sZGVyLnNjcm9sbFRvcCArPSBkZWx0YTtcbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTsgXG5cbiAgICB0aGlzLnRpZXJIb2xkZXJIb2xkZXIuYWRkRXZlbnRMaXN0ZW5lcignTW96TW91c2VQaXhlbFNjcm9sbCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoZXYuYXhpcyA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoZXYuZGV0YWlsICE9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBldi5kZXRhaWwvNDtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0IucmV2ZXJzZVNjcm9sbGluZykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpc0IubW92ZShkZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBldi5kZXRhaWw7XG4gICAgICAgICAgICBpZiAoIXRoaXNCLnJldmVyc2VTY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXNCLnRpZXJIb2xkZXIuc2Nyb2xsVG9wICs9IGRlbHRhO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpOyBcblxuICAgIHRoaXMudGllckhvbGRlckhvbGRlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZXYpIHtyZXR1cm4gdGhpc0IudG91Y2hTdGFydEhhbmRsZXIoZXYpfSwgZmFsc2UpO1xuICAgIHRoaXMudGllckhvbGRlckhvbGRlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBmdW5jdGlvbihldikge3JldHVybiB0aGlzQi50b3VjaE1vdmVIYW5kbGVyKGV2KX0sIGZhbHNlKTtcbiAgICB0aGlzLnRpZXJIb2xkZXJIb2xkZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBmdW5jdGlvbihldikge3JldHVybiB0aGlzQi50b3VjaEVuZEhhbmRsZXIoZXYpfSwgZmFsc2UpO1xuICAgIHRoaXMudGllckhvbGRlckhvbGRlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uKGV2KSB7cmV0dXJuIHRoaXNCLnRvdWNoQ2FuY2VsSGFuZGxlcihldil9LCBmYWxzZSk7XG5cbiAgICB2YXIga2V5SGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjYmtoOiAnICsgZXYua2V5Q29kZSk7XG4gICAgICAgIGlmIChldi5rZXlDb2RlID09IDEzKSB7IC8vIGVudGVyXG4gICAgICAgICAgICB2YXIgbGF5b3V0c0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzQi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IHRoaXNCLnRpZXJzW3RpXTtcbiAgICAgICAgICAgICAgICBpZiAodC53YW50ZWRMYXlvdXRIZWlnaHQgJiYgdC53YW50ZWRMYXlvdXRIZWlnaHQgIT0gdC5sYXlvdXRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdC5sYXlvdXRIZWlnaHQgPSB0LndhbnRlZExheW91dEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdC5jbGlwVGllcigpO1xuICAgICAgICAgICAgICAgICAgICBsYXlvdXRzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dHNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IuYXJyYW5nZVRpZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSAzMiB8fCBldi5jaGFyQ29kZSA9PSAzMikgeyAvLyBzcGFjZVxuICAgICAgICAgICAgaWYgKCF0aGlzQi5pc1NuYXBab29taW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IuaXNTbmFwWm9vbWluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1pvb20gPSAodGhpc0Iuc2F2ZWRab29tIHx8IDAuMCkgKyB0aGlzQi56b29tTWluO1xuICAgICAgICAgICAgICAgIHRoaXNCLnNhdmVkWm9vbSA9IHRoaXNCLnpvb21TbGlkZXJWYWx1ZSAtIHRoaXNCLnpvb21NaW47XG4gICAgICAgICAgICAgICAgdGhpc0Iuem9vbVNsaWRlclZhbHVlID0gbmV3Wm9vbTtcbiAgICAgICAgICAgICAgICB0aGlzQi56b29tKE1hdGguZXhwKCgxLjAgKiBuZXdab29tKSAvIHRoaXNCLnpvb21FeHB0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNCLmlzU25hcFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Wm9vbSA9ICh0aGlzQi5zYXZlZFpvb20gfHwgMjAuMCkgKyB0aGlzQi56b29tTWluO1xuICAgICAgICAgICAgICAgIHRoaXNCLnNhdmVkWm9vbSA9IHRoaXNCLnpvb21TbGlkZXJWYWx1ZSAtIHRoaXNCLnpvb21NaW47XG4gICAgICAgICAgICAgICAgdGhpc0Iuem9vbVNsaWRlclZhbHVlID0gbmV3Wm9vbTtcbiAgICAgICAgICAgICAgICB0aGlzQi56b29tKE1hdGguZXhwKCgxLjAgKiBuZXdab29tKSAvIHRoaXNCLnpvb21FeHB0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTsgICAgICBcbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDg1KSB7IC8vIHVcbiAgICAgICAgICAgIGlmICh0aGlzQi51aU1vZGUgPT09ICdvcHRzJykgeyAvLyBpZiB0aGUgb3B0aW9ucyBhcmUgdmlzaWJsZSwgdG9nZ2xlIHRoZSBjaGVja2JveCB0b29cbiAgICAgICAgICAgICAgICB2YXIgY2hlY2sgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpbmdsZUJhc2VIaWdodGxpZ2h0QnV0dG9uXCIpLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzaW5nbGVCYXNlSGlnaHRsaWdodEJ1dHRvblwiKS5jaGVja2VkID0gIWNoZWNrO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIHRoaXNCLnNpbmdsZUJhc2VIaWdobGlnaHQgPSAhdGhpc0Iuc2luZ2xlQmFzZUhpZ2hsaWdodDtcbiAgICAgICAgICAgIHRoaXNCLnBvc2l0aW9uUnVsZXIoKTtcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gMzkpIHsgLy8gcmlnaHQgYXJyb3dcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpc0Iuc2Nyb2xsQXJyb3dLZXkoZXYsIC0xKTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDM3KSB7IC8vIGxlZnQgYXJyb3dcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpc0Iuc2Nyb2xsQXJyb3dLZXkoZXYsIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gMzggfHwgZXYua2V5Q29kZSA9PSA4NykgeyAvLyB1cCBhcnJvdyB8IHdcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3QgPSB0aGlzQi5nZXRTZWxlY3RlZFRpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3QgPCAwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIHR0ID0gdGhpc0IudGllcnNbc3RdO1xuICAgICAgICAgICAgICAgIHZhciBjaCA9IHR0LmZvcmNlSGVpZ2h0IHx8IHR0LnN1YnRpZXJzWzBdLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPj0gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHQubWVyZ2VDb25maWcoe2hlaWdodDogY2gtMTB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgICAgIGlmIChzdCA8IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdHQgPSB0aGlzQi50aWVyc1tzdF07XG4gIFxuICAgICAgICAgICAgICAgIGlmICh0dC5xdWFudExlYXBUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoID0gdHQuc3VidGllcnNbMF0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHEgPSB0dC5zdWJ0aWVyc1swXS5xdWFudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgcW1pbiA9IDEuMCAqIHRxLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHFtYXggPSAxLjAgKiB0cS5tYXg7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHFzY2FsZSA9IChxbWF4IC0gcW1pbikgLyB0aDtcbiAgICAgICAgICAgICAgICAgICAgdHQubWVyZ2VDb25maWcoe3F1YW50TGVhcFRocmVzaG9sZDogcW1pbiArICgoTWF0aC5yb3VuZCgodHQucXVhbnRMZWFwVGhyZXNob2xkIC0gcW1pbikvcXNjYWxlKXwwKSsxKSpxc2NhbGV9KTtcblxuICAgICAgICAgICAgICAgICAgICB0dC5ub3RpZnkoJ1RocmVzaG9sZDogJyArIGZvcm1hdFF1YW50TGFiZWwodHQucXVhbnRMZWFwVGhyZXNob2xkKSk7XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXYuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNudCA9IHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjbnQgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpc0Iuc2VsZWN0ZWRUaWVyc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGlndW91cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIG10ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICAgICAgICAgIG10LnB1c2godGhpc0IudGllcnNbdGhpc0Iuc2VsZWN0ZWRUaWVyc1tzaV1dKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpID4gMCAmJiB0aGlzQi5zZWxlY3RlZFRpZXJzW3NpXSAtIHRoaXNCLnNlbGVjdGVkVGllcnNbc2kgLSAxXSAhPSAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGlndW91cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb250aWd1b3VzICYmIHN0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpID0gdGhpc0Iuc2VsZWN0ZWRUaWVycy5sZW5ndGggLSAxOyBzaSA+PSAwOyAtLXNpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzQi50aWVycy5zcGxpY2UodGhpc0Iuc2VsZWN0ZWRUaWVyc1tzaV0sIDEpO1xuXG4gICAgICAgICAgICAgICAgdGhpc0Iuc2VsZWN0ZWRUaWVycy5zcGxpY2UoMCwgY250KTtcblxuICAgICAgICAgICAgICAgIHZhciBpcCA9IGNvbnRpZ3VvdXMgPyBzdCAtIDEgOiBzdDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgbXQubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnRpZXJzLnNwbGljZShpcCtzaSwgMCwgbXRbc2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iuc2VsZWN0ZWRUaWVycy5wdXNoKGlwICsgc2kpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXNCLndpdGhQcmVzZXJ2ZWRTZWxlY3Rpb24odGhpc0IuX2Vuc3VyZVRpZXJzR3JvdXBlZCk7XG4gICAgICAgICAgICAgICAgdGhpc0IubWFya1NlbGVjdGVkVGllcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzQi5ub3RpZnlUaWVyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpc0IucmVvcmRlclRpZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5VGllcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3QgPSB0aGlzQi5nZXRTZWxlY3RlZFRpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3QgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnNldFNlbGVjdGVkVGllcihzdCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnN0ID0gdGhpc0IudGllcnNbdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gbnN0LnJvdy5vZmZzZXRUb3AsIGJvdHRvbSA9IHRvcCArIG5zdC5yb3cub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wIDwgdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgfHwgYm90dG9tID4gdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgKyB0aGlzQi50aWVySG9sZGVyLm9mZnNldEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5ub3RpZnlUaWVyU2VsZWN0aW9uV3JhcCgtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gNDAgfHwgZXYua2V5Q29kZSA9PSA4MykgeyAvLyBkb3duIGFycm93IHwgc1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgICAgIGlmIChzdCA8IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdHQgPSB0aGlzQi50aWVyc1tzdF07XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gdHQuZm9yY2VIZWlnaHQgfHwgdHQuc3VidGllcnNbMF0uaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHR0Lm1lcmdlQ29uZmlnKHtoZWlnaHQ6IGNoKzEwfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2LmN0cmxLZXkgfHwgZXYubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IHRoaXNCLmdldFNlbGVjdGVkVGllcigpO1xuICAgICAgICAgICAgICAgIGlmIChzdCA8IDApIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdHQgPSB0aGlzQi50aWVyc1tzdF07XG5cbiAgICAgICAgICAgICAgICBpZiAodHQucXVhbnRMZWFwVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aCA9IHR0LnN1YnRpZXJzWzBdLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRxID0gdHQuc3VidGllcnNbMF0ucXVhbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHFtaW4gPSAxLjAgKiB0cS5taW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBxbWF4ID0gMS4wICogdHEubWF4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcXNjYWxlID0gKHFtYXggLSBxbWluKSAvIHRoO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdCA9IE1hdGgucm91bmQoKHR0LnF1YW50TGVhcFRocmVzaG9sZCAtIHFtaW4pL3FzY2FsZSl8MDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHQubWVyZ2VDb25maWcoe3F1YW50TGVhcFRocmVzaG9sZDogcW1pbiArIChpdC0xKSpxc2NhbGV9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0Lm5vdGlmeSgnVGhyZXNob2xkOiAnICsgZm9ybWF0UXVhbnRMYWJlbCh0dC5xdWFudExlYXBUaHJlc2hvbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXYuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNudCA9IHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjbnQgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpc0Iuc2VsZWN0ZWRUaWVyc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzY29udGlnID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgdGhpc0Iuc2VsZWN0ZWRUaWVycy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbXQucHVzaCh0aGlzQi50aWVyc1t0aGlzQi5zZWxlY3RlZFRpZXJzW3NpXV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2kgPiAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzY29udGlnICs9ICh0aGlzQi5zZWxlY3RlZFRpZXJzW3NpXSAtIHRoaXNCLnNlbGVjdGVkVGllcnNbc2kgLSAxXSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgY29udGlndW91cyA9IGRpc2NvbnRpZyA9PSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpZ3VvdXMgJiYgc3QgKyBjbnQgPj0gdGhpc0IudGllcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoIC0gMTsgc2kgPj0gMDsgLS1zaSlcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllcnMuc3BsaWNlKHRoaXNCLnNlbGVjdGVkVGllcnNbc2ldLCAxKTtcblxuICAgICAgICAgICAgICAgIHRoaXNCLnNlbGVjdGVkVGllcnMuc3BsaWNlKDAsIGNudCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXAgPSBjb250aWd1b3VzID8gc3QgKyAxIDogc3QgKyBkaXNjb250aWc7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IG10Lmxlbmd0aDsgKytzaSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi50aWVycy5zcGxpY2UoaXArc2ksIDAsIG10W3NpXSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnNlbGVjdGVkVGllcnMucHVzaChpcCArIHNpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzQi53aXRoUHJlc2VydmVkU2VsZWN0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5fZW5zdXJlVGllcnNHcm91cGVkKHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXNCLm1hcmtTZWxlY3RlZFRpZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5VGllclNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXNCLnJlb3JkZXJUaWVycygpO1xuICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeVRpZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0IDwgdGhpc0IudGllcnMubGVuZ3RoIC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnNldFNlbGVjdGVkVGllcihzdCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnN0ID0gdGhpc0IudGllcnNbdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9wID0gbnN0LnJvdy5vZmZzZXRUb3AsIGJvdHRvbSA9IHRvcCArIG5zdC5yb3cub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wIDwgdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgfHwgYm90dG9tID4gdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgKyB0aGlzQi50aWVySG9sZGVyLm9mZnNldEhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllckhvbGRlci5zY3JvbGxUb3AgPSBNYXRoLm1pbih0b3AsIGJvdHRvbSAtIHRoaXNCLnRpZXJIb2xkZXIub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDE4NyB8fCBldi5rZXlDb2RlID09IDYxKSB7IC8vICtcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpc0Iuem9vbVN0ZXAoLTEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDE4OSB8fCBldi5rZXlDb2RlID09IDE3MykgeyAvLyAtXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXNCLnpvb21TdGVwKDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDczIHx8IGV2LmtleUNvZGUgPT0gMTA1KSB7IC8vIGlcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIHN0ID0gdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCk7XG4gICAgICAgICAgICBpZiAoc3QgPCAwKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgdCA9IHRoaXNCLnRpZXJzW3N0XTtcbiAgICAgICAgICAgIGlmICghdC5pbmZvVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHQuaW5mb0VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgdC51cGRhdGVIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0LmluZm9WaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdC5pbmZvRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHQudXBkYXRlSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgdC5pbmZvVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gODQgfHwgZXYua2V5Q29kZSA9PSAxMTYpIHsgLy8gdFxuICAgICAgICAgICAgdmFyIGJ1bXBTdGF0dXM7XG4gICAgICAgICAgICBpZiggZXYuc2hpZnRLZXkgKXtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpc0IudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpc0IudGllcnNbdGldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1bXBTdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1bXBTdGF0dXMgPSAhdC5idW1wZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0Lm1lcmdlQ29uZmlnKHtidW1wZWQ6IGJ1bXBTdGF0dXN9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWV2LmN0cmxLZXkgJiYgIWV2Lm1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3QgPSB0aGlzQi5nZXRTZWxlY3RlZFRpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3QgPCAwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzQi50aWVyc1tzdF07XG5cbiAgICAgICAgICAgICAgICBpZiAodC5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVtcFN0YXR1cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidW1wU3RhdHVzID0gIXQuYnVtcGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHQubWVyZ2VDb25maWcoe2J1bXBlZDogYnVtcFN0YXR1c30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09IDc3IHx8IGV2LmtleUNvZGUgPT0gMTA5KSB7IC8vIG1cbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKChldi5jdHJsS2V5IHx8IGV2Lm1ldGFLZXkpICYmIHRoaXNCLnNlbGVjdGVkVGllcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXNCLm1lcmdlU2VsZWN0ZWRUaWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT0gNjggfHwgZXYua2V5Q29kZSA9PSAxMDApIHsgLy8gZFxuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0IDwgMCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXNCLmFkZFRpZXIodGhpc0IudGllcnNbc3RdLmRhc1NvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PSA4MCB8fCBldi5rZXlDb2RlID09IDExMikgeyAvLyBwXG4gICAgICAgICAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBiZSBjYXJlZnVsIGJlY2F1c2Ugb3JkZXIgb2YgdGllcnMgY291bGQgY2hhbmdlXG4gICAgICAgICAgICAgICAgLy8gb25jZSB3ZSBzdGFydCB1cGRhdGluZyBwaW5uaW5nLlxuICAgICAgICAgICAgICAgIHZhciB0dCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHN0ID0gMDsgc3QgPCB0aGlzQi5zZWxlY3RlZFRpZXJzLmxlbmd0aDsgKytzdCkge1xuICAgICAgICAgICAgICAgICAgICB0dC5wdXNoKHRoaXNCLnRpZXJzW3RoaXNCLnNlbGVjdGVkVGllcnNbc3RdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0dC5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHRbdGldLm1lcmdlQ29uZmlnKHtwaW5uZWQ6ICF0dFt0aV0ucGlubmVkfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2tleTogJyArIGV2LmtleUNvZGUgKyAnOyBjaGFyOiAnICsgZXYuY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuYnJvd3NlckhvbGRlci5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHRoaXNCLmJyb3dzZXJIb2xkZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleUhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LCBmYWxzZSk7XG4gICAgdGhpcy5icm93c2VySG9sZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbihldikge1xuICAgICAgICB0aGlzQi5icm93c2VySG9sZGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgLy8gUG9wdXAgc3VwcG9ydCAoZG9lcyB0aGlzIHJlYWxseSBiZWxvbmcgaGVyZT8gRklYTUUpXG4gICAgdGhpcy5oUG9wdXBIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5oUG9wdXBIb2xkZXIuc3R5bGVbJ2ZvbnQtZmFtaWx5J10gPSAnaGVsdmV0aWNhJztcbiAgICB0aGlzLmhQb3B1cEhvbGRlci5zdHlsZVsnZm9udC1zaXplJ10gPSAnMTJwdCc7XG4gICAgdGhpcy5oUG9wdXBIb2xkZXIuY2xhc3NMaXN0LmFkZCgnZGFsbGlhbmNlJyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmhQb3B1cEhvbGRlcik7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMuc291cmNlcy5sZW5ndGg7ICsrdCkge1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2VzW3RdO1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5yZXN0b3JlZENvbmZpZ3MpIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHRoaXMucmVzdG9yZWRDb25maWdzW3RdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzb3VyY2UuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWFrZVRpZXIoc291cmNlLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpc0IuX2Vuc3VyZVRpZXJzR3JvdXBlZCgpO1xuICAgIHRoaXNCLmFycmFuZ2VUaWVycygpO1xuICAgIHRoaXNCLnJlb3JkZXJUaWVycygpO1xuICAgIHRoaXNCLnJlZnJlc2goKTtcbiAgICB0aGlzQi5zZXRTZWxlY3RlZFRpZXIoMSk7XG5cbiAgICB0aGlzQi5wb3NpdGlvblJ1bGVyKCk7XG5cblxuICAgIHZhciBzcyA9IHRoaXMuZ2V0U2VxdWVuY2VTb3VyY2UoKTtcbiAgICBpZiAoc3MpIHtcbiAgICAgICAgc3MuZ2V0U2VxSW5mbyh0aGlzLmNociwgZnVuY3Rpb24oc2kpIHtcbiAgICAgICAgICAgIGlmIChzaSlcbiAgICAgICAgICAgICAgICB0aGlzQi5jdXJyZW50U2VxTWF4ID0gc2kubGVuZ3RoO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNCLmN1cnJlbnRTZXFNYXggPSAtMTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5xdWVyeVJlZ2lzdHJ5KCk7XG4gICAgZm9yICh2YXIgbSBpbiB0aGlzLmNoYWlucykge1xuICAgICAgICB0aGlzLnF1ZXJ5UmVnaXN0cnkobSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaHVicykge1xuICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpcy5odWJzLmxlbmd0aDsgKytoaSkge1xuICAgICAgICAgICAgdmFyIGhjID0gdGhpcy5odWJzW2hpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBoYyA9IHt1cmw6IGhjfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIChmdW5jdGlvbihoYykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RUcmFja0h1YihoYy51cmwsIGZ1bmN0aW9uKGh1YiwgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGRiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhjLmdlbm9tZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZGIgPSBodWIuZ2Vub21lc1toYy5nZW5vbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZGIgPSBodWIuZ2Vub21lc1t0aGlzQi5jb29yZFN5c3RlbS51Y3NjTmFtZV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGMubWFwcGluZykgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkYi5tYXBwaW5nID0gaGMubWFwcGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGMubGFiZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRkYi5odWIuYWx0TGFiZWwgPSBoYy5sYWJlbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmh1Yk9iamVjdHMucHVzaCh0ZGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgaGMpO1xuICAgICAgICAgICAgfSkoaGMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZnVsbFNjcmVlbikge1xuICAgICAgICB0aGlzLnNldEZ1bGxTY3JlZW5IZWlnaHQoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc3RhdHVzUmVzdG9yZWQgJiYgdGhpcy5zdG9yZVN0YXR1cykge1xuICAgICAgICB0aGlzLnN0b3JlU3RhdHVzKCk7XG4gICAgfVxuXG4gICAgLy8gUGluZyBhbnkgaW5pdCBsaXN0ZW5lcnMuXG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IHRoaXMuaW5pdExpc3RlbmVycy5sZW5ndGg7ICsraWkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdExpc3RlbmVyc1tpaV0uY2FsbCh0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFxuLy8gVG91Y2ggZXZlbnQgc3VwcG9ydFxuLy9cblxuQnJvd3Nlci5wcm90b3R5cGUudG91Y2hTdGFydEhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgIC8vIEV2ZW50cyBub3QgY29uc3VtZWQgc28gdGhleSBjYW4gYmUgaW50ZXJwcmV0dGVkIGFzIGNsaWNrcyBhcyB3ZWxsLlxuXG4gICAgdGhpcy50b3VjaE9yaWdpblggPSBldi50b3VjaGVzWzBdLnBhZ2VYO1xuICAgIHRoaXMudG91Y2hPcmlnaW5ZID0gZXYudG91Y2hlc1swXS5wYWdlWTtcbiAgICBpZiAoZXYudG91Y2hlcy5sZW5ndGggPT0gMikge1xuICAgICAgICB2YXIgc2VwID0gTWF0aC5hYnMoZXYudG91Y2hlc1swXS5wYWdlWCAtIGV2LnRvdWNoZXNbMV0ucGFnZVgpO1xuICAgICAgICB0aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnpvb21MYXN0U2VwID0gdGhpcy56b29tSW5pdGlhbFNlcCA9IHNlcDtcbiAgICAgICAgdGhpcy56b29tSW5pdGlhbFNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnRvdWNoTW92ZUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgIC8vIFRoZXNlIGV2ZW50cyAqYXJlKiBjb25zdW1lZCB0byBlbnN1cmUgd2UgbmV2ZXIgZ2V0IGFueSBkcmFnZ2luZyB0aGF0XG4gICAgLy8gd2UgZG9uJ3QgbWFuYWdlIG91cnNlbHZlcy5cblxuICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIFxuICAgIGlmIChldi50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHZhciB0b3VjaFggPSBldi50b3VjaGVzWzBdLnBhZ2VYO1xuICAgICAgICB2YXIgdG91Y2hZID0gZXYudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgaWYgKHRoaXMudG91Y2hPcmlnaW5YICYmIHRvdWNoWCAhPSB0aGlzLnRvdWNoT3JpZ2luWCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlKHRvdWNoWCAtIHRoaXMudG91Y2hPcmlnaW5YKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50b3VjaE9yaWdpblkgJiYgdG91Y2hZICE9IHRoaXMudG91Y2hPcmlnaW5ZKSB7XG4gICAgICAgICAgICB0aGlzLnRpZXJIb2xkZXIuc2Nyb2xsVG9wIC09ICh0b3VjaFkgLSB0aGlzLnRvdWNoT3JpZ2luWSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaE9yaWdpblggPSB0b3VjaFg7XG4gICAgICAgIHRoaXMudG91Y2hPcmlnaW5ZID0gdG91Y2hZO1xuICAgIH0gZWxzZSBpZiAodGhpcy56b29taW5nICYmIGV2LnRvdWNoZXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgdmFyIHNlcCA9IE1hdGguYWJzKGV2LnRvdWNoZXNbMF0ucGFnZVggLSBldi50b3VjaGVzWzFdLnBhZ2VYKTtcbiAgICAgICAgaWYgKHNlcCAhPSB0aGlzLnpvb21MYXN0U2VwKSB7XG4gICAgICAgICAgICB2YXIgY3AgPSAoZXYudG91Y2hlc1swXS5wYWdlWCArIGV2LnRvdWNoZXNbMV0ucGFnZVgpLzI7XG4gICAgICAgICAgICB2YXIgc2NwID0gdGhpcy52aWV3U3RhcnQgKyAoY3AvdGhpcy5zY2FsZSl8MFxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuem9vbUluaXRpYWxTY2FsZSAqIChzZXAvdGhpcy56b29tSW5pdGlhbFNlcCk7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGFydCA9IHNjcCAtIChjcC90aGlzLnNjYWxlKXwwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aWVyc1tpXS5kcmF3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy56b29tTGFzdFNlcCA9IHNlcDtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnRvdWNoRW5kSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnRvdWNoQ2FuY2VsSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG59XG5cblxuQnJvd3Nlci5wcm90b3R5cGUubWFrZVRpZXIgPSBmdW5jdGlvbihzb3VyY2UsIGNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWxNYWtlVGllcihzb3VyY2UsIGNvbmZpZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnRXJyb3IgaW5pdGlhbGl6aW5nJywgc291cmNlKTtcbiAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayB8fCBlKTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlYWxNYWtlVGllciA9IGZ1bmN0aW9uKHNvdXJjZSwgY29uZmlnKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgYmFja2dyb3VuZCA9IG51bGw7XG4gICAgaWYgKHRoaXMudGllckJhY2tncm91bmRDb2xvcnMpIHtcbiAgICAgICAgYmFja2dyb3VuZCA9IHRoaXMudGllckJhY2tncm91bmRDb2xvcnNbdGhpcy50aWVycy5sZW5ndGggJSB0aGlzLnRpZXJCYWNrZ3JvdW5kQ29sb3JzLmxlbmd0aF07XG4gICAgfVxuXG4gICAgdmFyIHRpZXIgPSBuZXcgRGFzVGllcih0aGlzLCBzb3VyY2UsIGNvbmZpZywgYmFja2dyb3VuZCk7XG4gICAgdGllci5vb3JpZ2luID0gdGhpcy52aWV3U3RhcnRcblxuICAgIHZhciBpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdmFyIGRyYWdPcmlnaW4sIGRyYWdNb3ZlT3JpZ2luO1xuICAgIHZhciBob3ZlclRpbWVvdXQ7XG5cbiAgICB2YXIgZmVhdHVyZUxvb2t1cCA9IGZ1bmN0aW9uKHJ4LCByeSkge1xuICAgICAgICB2YXIgc3QgPSB0aWVyLnN1YnRpZXJzO1xuICAgICAgICBpZiAoIXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RpID0gMDtcbiAgICAgICAgcnkgLT0gdGllci5wYWRkaW5nOztcbiAgICAgICAgd2hpbGUgKHN0aSA8IHN0Lmxlbmd0aCAmJiByeSA+IHN0W3N0aV0uaGVpZ2h0ICYmIHN0aSA8IChzdC5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgcnkgPSByeSAtIHN0W3N0aV0uaGVpZ2h0IC0gdGllci5wYWRkaW5nO1xuICAgICAgICAgICAgKytzdGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0aSA+PSBzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbHlwaHMgPSBzdFtzdGldLmdseXBocztcbiAgICAgICAgdmFyIHZpZXdDZW50ZXIgPSAodGhpc0Iudmlld1N0YXJ0ICsgdGhpc0Iudmlld0VuZCkvMjtcbiAgICAgICAgdmFyIG9mZnNldCA9ICh0aWVyLmdseXBoQ2FjaGVPcmlnaW4gLSB0aGlzQi52aWV3U3RhcnQpKnRoaXNCLnNjYWxlO1xuICAgICAgICByeCAtPSBvZmZzZXQ7XG4gICAgICAgXG4gICAgICAgIHJldHVybiBnbHlwaExvb2t1cChnbHlwaHMsIHJ4LCByeSk7XG4gICAgfVxuXG4gICAgdmFyIGRyYWdNb3ZlSGFuZGxlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgcnggPSBldi5jbGllbnRYO1xuICAgICAgICBpZiAocnggIT0gZHJhZ01vdmVPcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXNCLm1vdmUoKHJ4IC0gZHJhZ01vdmVPcmlnaW4pLCB0cnVlKTtcbiAgICAgICAgICAgIGRyYWdNb3ZlT3JpZ2luID0gcng7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc0IuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGRyYWdVcEhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZHJhZ01vdmVIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBkcmFnVXBIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgdGhpc0IubW92ZSgoZXYuY2xpZW50WCAtIGRyYWdNb3ZlT3JpZ2luKSk7IC8vIFNuYXAgYmFjayAoRklYTUU6IGNvbnNpZGVyIGFuaW1hdGlvbilcbiAgICB9XG4gICAgICAgIFxuXG4gICAgdGllci52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldikge1xuICAgICAgICB0aGlzQi5icm93c2VySG9sZGVyLmZvY3VzKCk7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBiciA9IHRpZXIucm93LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcnggPSBldi5jbGllbnRYLCByeSA9IGV2LmNsaWVudFk7XG5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGRyYWdNb3ZlSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgZHJhZ1VwSGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgIGRyYWdPcmlnaW4gPSBkcmFnTW92ZU9yaWdpbiA9IHJ4O1xuICAgICAgICB0aGlzQi5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIE5vdCBkcmFnZ2luZyB1bnRpbCBhIG1vdmVtZW50IGV2ZW50IGFycml2ZXMuXG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdGllci52aWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgYnIgPSB0aWVyLnJvdy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHJ4ID0gZXYuY2xpZW50WCAtIGJyLmxlZnQsIHJ5ID0gZXYuY2xpZW50WSAtIGJyLnRvcDtcblxuICAgICAgICB2YXIgaGl0ID0gZmVhdHVyZUxvb2t1cChyeCwgcnkpO1xuICAgICAgICBpZiAoaGl0ICYmIGhpdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aWVyLnJvdy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWVyLnJvdy5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG92ZXJUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaG92ZXJUaW1lb3V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAvLyBpZiAodGllci5kYXNTb3VyY2UudGllcl90eXBlICE9PSAnc2VxdWVuY2UnICYmIHJ4ICE9IGRyYWdNb3ZlT3JpZ2luKSB7XG4gICAgICAgICAgICAvLyAgICB0aGlzQi5tb3ZlKChyeCAtIGRyYWdNb3ZlT3JpZ2luKSk7XG4gICAgICAgICAgICAvLyAgICBkcmFnTW92ZU9yaWdpbiA9IHJ4O1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGl0ID0gZmVhdHVyZUxvb2t1cChyeCwgcnkpO1xuICAgICAgICAgICAgICAgIGlmIChoaXQgJiYgaGl0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5RmVhdHVyZUhvdmVyKGV2LCBoaXRbaGl0Lmxlbmd0aCAtIDFdLCBoaXQsIHRpZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgZG91YmxlQ2xpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICB0aWVyLnZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgYnIgPSB0aWVyLnJvdy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHJ4ID0gZXYuY2xpZW50WCAtIGJyLmxlZnQsIHJ5ID0gZXYuY2xpZW50WSAtIGJyLnRvcDtcblxuICAgICAgICB2YXIgaGl0ID0gZmVhdHVyZUxvb2t1cChyeCwgcnkpO1xuICAgICAgICBpZiAoaGl0ICYmIGhpdC5sZW5ndGggPiAwICYmICF0aGlzQi5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZiAoZG91YmxlQ2xpY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRvdWJsZUNsaWNrVGltZW91dCk7XG4gICAgICAgICAgICAgICAgZG91YmxlQ2xpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzQi5mZWF0dXJlRG91YmxlQ2xpY2soaGl0LCByeCwgcnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb3VibGVDbGlja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkb3VibGVDbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5ub3RpZnlGZWF0dXJlKGV2LCBoaXRbaGl0Lmxlbmd0aC0xXSwgaGl0LCB0aWVyKTtcbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXNCLmlzRHJhZ2dpbmcgJiYgcnggIT0gZHJhZ09yaWdpbiAmJiB0aWVyLnNlcXVlbmNlU291cmNlKSB7XG4gICAgICAgICAgICB2YXIgYSA9IHRoaXNCLnZpZXdTdGFydCArIChyeC90aGlzQi5zY2FsZSk7XG4gICAgICAgICAgICB2YXIgYiA9IHRoaXNCLnZpZXdTdGFydCArIChkcmFnT3JpZ2luL3RoaXNCLnNjYWxlKTtcblxuICAgICAgICAgICAgdmFyIG1pbiwgbWF4O1xuICAgICAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICAgICAgbWluID0gYXwwOyBtYXggPSBifDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbiA9IGJ8MDsgbWF4ID0gYXwwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlSZWdpb25TZWxlY3QodGhpc0IuY2hyLCBtaW4sIG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc0IuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIHRpZXIudmlld3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBmdW5jdGlvbihldikge1xuICAgICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICB0aWVyLnJlbW92ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpc0IudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICBpZiAodGhpc0IudGllcnNbdGldID09PSB0aWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IucmVtb3ZlVGllcih7aW5kZXg6IHRpfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG4gICAgdGllci5uYW1lQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICB2YXIgaGl0VGllciA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXNCLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzQi50aWVyc1t0aV0gPT09IHRpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0VGllciA9IHRpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGl0VGllciA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzQi5zZWxlY3RlZFRpZXJzLmluZGV4T2YoaGl0VGllcik7XG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5zZWxlY3RlZFRpZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5zZWxlY3RlZFRpZXJzLnB1c2goaGl0VGllcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLnNlbGVjdGVkVGllcnMuc29ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzQi5tYXJrU2VsZWN0ZWRUaWVycygpO1xuICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeVRpZXJTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzQi5zZWxlY3RlZFRpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IuYnJvd3NlckhvbGRlci5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeVRpZXJTZWxlY3Rpb25XcmFwKC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpc0IudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLnRpZXJzW3RpXSA9PT0gdGllcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5icm93c2VySG9sZGVyLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzQi5zZWxlY3RlZFRpZXJzLmxlbmd0aCAhPSAxIHx8IHRoaXNCLnNlbGVjdGVkVGllcnNbMF0gIT0gdGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnNldFNlbGVjdGVkVGllcih0aSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGllci5pbmZvVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRpZXIuaW5mb0VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgdGllci51cGRhdGVIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0aWVyLmluZm9WaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGllci5pbmZvRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHRpZXIudXBkYXRlSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgdGllci5pbmZvVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIHRpZXIuYnVtcEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgYnVtcFN0YXR1cztcbiAgICAgICAgdmFyIHQgPSB0aWVyO1xuICAgICAgICBpZiAodC5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3Vwcykge1xuICAgICAgICAgICAgaWYgKGJ1bXBTdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJ1bXBTdGF0dXMgPSAhdC5idW1wZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0Lm1lcmdlQ29uZmlnKHtidW1wZWQ6IGJ1bXBTdGF0dXN9KTtcbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTtcblxuICAgIFxuICAgIHZhciBkcmFnTGFiZWw7XG4gICAgdmFyIGRyYWdUaWVySG9sZGVyO1xuICAgIHZhciBkcmFnVGllckhvbGRlclNjcm9sbExpbWl0O1xuICAgIHZhciB0aWVyT3JkaW5hbDtcbiAgICB2YXIgeUF0TGFzdFJlb3JkZXI7XG4gICAgdmFyIHRpZXJzV2VyZVJlb3JkZXJlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGxhYmVsRHJhZ0hhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgbGFiZWwgPSB0aWVyLmxhYmVsO1xuXG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoIWRyYWdMYWJlbCkge1xuICAgICAgICAgICAgaWYgKHRpZXIucGlubmVkKSB7XG4gICAgICAgICAgICAgICAgZHJhZ1RpZXJIb2xkZXIgPSB0aGlzQi5waW5uZWRUaWVySG9sZGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkcmFnVGllckhvbGRlciA9IHRoaXNCLnRpZXJIb2xkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcmFnVGllckhvbGRlclNjcm9sbExpbWl0ID0gZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsSGVpZ2h0IC0gZHJhZ1RpZXJIb2xkZXIub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICBkcmFnTGFiZWwgPSBsYWJlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBkcmFnTGFiZWwuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgZHJhZ1RpZXJIb2xkZXIuYXBwZW5kQ2hpbGQoZHJhZ0xhYmVsKTtcbiAgICAgICAgICAgIGxhYmVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgICAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXNCLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzQi50aWVyc1t0aV0gPT09IHRpZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGllck9yZGluYWwgPSB0aTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB5QXRMYXN0UmVvcmRlciA9IGV2LmNsaWVudFk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBob2xkZXJCQ1IgPSBkcmFnVGllckhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgZHJhZ0xhYmVsLnN0eWxlLmxlZnQgPSAobGFiZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIGhvbGRlckJDUi5sZWZ0KSArICdweCc7IFxuICAgICAgICBkcmFnTGFiZWwuc3R5bGUudG9wID0gKGV2LmNsaWVudFkgLSBob2xkZXJCQ1IudG9wICsgZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wIC0gMTApICsgJ3B4JztcblxuICAgICAgICB2YXIgcHR5ID0gZXYuY2xpZW50WSAtIGhvbGRlckJDUi50b3AgKyBkcmFnVGllckhvbGRlci5zY3JvbGxUb3A7XG4gICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzQi50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgICAgIHZhciB0dCA9IHRoaXNCLnRpZXJzW3RpXTtcbiAgICAgICAgICAgIGlmICh0dC5waW5uZWQgXiB0aWVyLnBpbm5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgXG5cbiAgICAgICAgICAgIHZhciB0dHIgPSB0dC5yb3cuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBwdHkgLT0gKHR0ci5ib3R0b20gLSB0dHIudG9wKTtcbiAgICAgICAgICAgIGlmIChwdHkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpIDwgdGllck9yZGluYWwgJiYgZXYuY2xpZW50WSA8IHlBdExhc3RSZW9yZGVyIHx8IHRpID4gdGllck9yZGluYWwgJiYgZXYuY2xpZW50WSA+IHlBdExhc3RSZW9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLndpdGhQcmVzZXJ2ZWRTZWxlY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi50aWVycy5zcGxpY2UodGllck9yZGluYWwsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IudGllcnMuc3BsaWNlKHRpLCAwLCB0aWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLl9lbnN1cmVUaWVyc0dyb3VwZWQodGkgPiB0aWVyT3JkaW5hbCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRpeCA9IDA7IHRpeCA8IHRoaXNCLnRpZXJzLmxlbmd0aDsgKyt0aXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0IudGllcnNbdGl4XSA9PSB0aWVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpZXJPcmRpbmFsID0gdGl4O1xuXG4gICAgICAgICAgICAgICAgICAgIHlBdExhc3RSZW9yZGVyID0gZXYuY2xpZW50WTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IucmVvcmRlclRpZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdUaWVySG9sZGVyLmFwcGVuZENoaWxkKGRyYWdMYWJlbCk7IC8vIEJlY2F1c2UgcmVvcmRlclRpZXJzIHJlbW92ZXMgYWxsIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgICAgICB0aWVyc1dlcmVSZW9yZGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnTGFiZWwub2Zmc2V0VG9wIDwgZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBkcmFnVGllckhvbGRlci5zY3JvbGxUb3AgLT0gKGRyYWdUaWVySG9sZGVyLnNjcm9sbFRvcCAtIGRyYWdMYWJlbC5vZmZzZXRUb3ApO1xuICAgICAgICB9IGVsc2UgaWYgKChkcmFnTGFiZWwub2Zmc2V0VG9wICsgZHJhZ0xhYmVsLm9mZnNldEhlaWdodCkgPiAoZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wICsgZHJhZ1RpZXJIb2xkZXIub2Zmc2V0SGVpZ2h0KSkge1xuICAgICAgICAgICAgZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wID0gTWF0aC5taW4oZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wICsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ0xhYmVsLm9mZnNldFRvcCArIGRyYWdMYWJlbC5vZmZzZXRIZWlnaHQpIC0gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJhZ1RpZXJIb2xkZXIuc2Nyb2xsVG9wICsgZHJhZ1RpZXJIb2xkZXIub2Zmc2V0SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdUaWVySG9sZGVyU2Nyb2xsTGltaXQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBsYWJlbFJlbGVhc2VIYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIGxhYmVsID0gdGllci5sYWJlbDtcblxuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGRyYWdMYWJlbCkge1xuICAgICAgICAgICAgZHJhZ0xhYmVsLnN0eWxlLmN1cnNvciA9ICdhdXRvJztcbiAgICAgICAgICAgIGRyYWdUaWVySG9sZGVyLnJlbW92ZUNoaWxkKGRyYWdMYWJlbCk7XG4gICAgICAgICAgICBkcmFnTGFiZWwgPSBudWxsO1xuICAgICAgICAgICAgbGFiZWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBsYWJlbERyYWdIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBsYWJlbFJlbGVhc2VIYW5kbGVyLCBmYWxzZSk7XG5cbiAgICAgICAgaWYgKHRpZXJzV2VyZVJlb3JkZXJlZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXNCLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzQi50aWVyc1t0aV0gPT0gdGllcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5zZXRTZWxlY3RlZFRpZXIodGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlUaWVyKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGllci5sYWJlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTsgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGllcnNXZXJlUmVvcmRlcmVkID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGxhYmVsRHJhZ0hhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGxhYmVsUmVsZWFzZUhhbmRsZXIsIGZhbHNlKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB0aGlzLnRpZXJzLnB1c2godGllcik7ICAvLyBOQiB0aGlzIGN1cnJlbnRseSB0ZWxscyBhbnkgZXh0YW50IGtub3duU3BhY2UgYWJvdXQgdGhlIG5ldyB0aWVyLlxuICAgIFxuICAgIHRpZXIuaW5pdCgpOyAvLyBmZXRjaGVzIHN0eWxlc2hlZXRcbiAgICB0aWVyLmN1cnJlbnRseUhlaWdodCA9IDUwO1xuICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XG4gICAgdGllci51cGRhdGVMYWJlbCgpO1xuXG5cblxuICAgIHRoaXMud2l0aFByZXNlcnZlZFNlbGVjdGlvbih0aGlzQi5fZW5zdXJlVGllcnNHcm91cGVkKTtcbiAgICB0aWVyLl91cGRhdGVGcm9tQ29uZmlnKCk7XG4gICAgdGhpcy5yZW9yZGVyVGllcnMoKTtcblxuICAgIHJldHVybiB0aWVyO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZW9yZGVyVGllcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZW1vdmVDaGlsZHJlbih0aGlzLnRpZXJIb2xkZXIpO1xuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMucGlubmVkVGllckhvbGRlcik7XG4gICAgaWYgKHRoaXMuZGlzYWJsZVBpbm5pbmcpIHtcbiAgICAgICAgdGhpcy50aWVySG9sZGVyLmFwcGVuZENoaWxkKHRoaXMucnVsZXIpO1xuICAgICAgICB0aGlzLnRpZXJIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy5ydWxlcjIpO1xuICAgIH1cbiAgICB2YXIgaGFzUGlubmVkID0gZmFsc2U7XG4gICAgdmFyIHBpbm5lZFRpZXJzID0gW10sIHVucGlubmVkVGllcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzLnRpZXJzW2ldO1xuICAgICAgICBpZiAodC5waW5uZWQgJiYgIXRoaXMuZGlzYWJsZVBpbm5pbmcpIHtcbiAgICAgICAgICAgIHBpbm5lZFRpZXJzLnB1c2godCk7XG4gICAgICAgICAgICB0aGlzLnBpbm5lZFRpZXJIb2xkZXIuYXBwZW5kQ2hpbGQodGhpcy50aWVyc1tpXS5yb3cpO1xuICAgICAgICAgICAgaGFzUGlubmVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVucGlubmVkVGllcnMucHVzaCh0KTtcbiAgICAgICAgICAgIHRoaXMudGllckhvbGRlci5hcHBlbmRDaGlsZCh0aGlzLnRpZXJzW2ldLnJvdyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLndpdGhQcmVzZXJ2ZWRTZWxlY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGllcnMuc3BsaWNlKDAsIHRoaXMudGllcnMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwaW5uZWRUaWVycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXMudGllcnMucHVzaChwaW5uZWRUaWVyc1tpXSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5waW5uZWRUaWVycy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHRoaXMudGllcnMucHVzaCh1bnBpbm5lZFRpZXJzW2ldKTtcbiAgICB9KTtcblxuICAgIGlmIChoYXNQaW5uZWQpXG4gICAgICAgIHRoaXMucGlubmVkVGllckhvbGRlci5jbGFzc0xpc3QuYWRkKCd0aWVyLWhvbGRlci1waW5uZWQtZnVsbCcpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5waW5uZWRUaWVySG9sZGVyLmNsYXNzTGlzdC5yZW1vdmUoJ3RpZXItaG9sZGVyLXBpbm5lZC1mdWxsJyk7XG5cbiAgICB0aGlzLmFycmFuZ2VUaWVycygpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS53aXRoUHJlc2VydmVkU2VsZWN0aW9uID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBzdCA9IFtdO1xuICAgIGZvciAodmFyIHhpID0gMDsgeGkgPCB0aGlzLnNlbGVjdGVkVGllcnMubGVuZ3RoOyArK3hpKSB7XG4gICAgICAgIHN0LnB1c2godGhpcy50aWVyc1t0aGlzLnNlbGVjdGVkVGllcnNbeGldXSk7XG4gICAgfVxuXG4gICAgZi5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5zZWxlY3RlZFRpZXJzID0gW107XG4gICAgZm9yICh2YXIgc3RpID0gMDsgc3RpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrc3RpKSB7XG4gICAgICAgIGlmIChzdC5pbmRleE9mKHRoaXMudGllcnNbc3RpXSkgPj0gMClcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRUaWVycy5wdXNoKHN0aSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZWZyZXNoVGllciA9IGZ1bmN0aW9uKHRpZXIpIHtcbiAgICBpZiAodGhpcy5rbm93blNwYWNlKSB7XG4gICAgICAgIHRoaXMua25vd25TcGFjZS5pbnZhbGlkYXRlKHRpZXIpO1xuICAgIH1cbn1cblxuLyogSW50ZXJuYWwgdXNlIG9ubHksIGFzc3VtZXMgc2VsZWN0aW9uIGlzIGJlaW5nIG1hbmFnZWQgZWxzZXdoZXJlLi4uICovXG5cbkJyb3dzZXIucHJvdG90eXBlLl9lbnN1cmVUaWVyc0dyb3VwZWQgPSBmdW5jdGlvbihkb3duKSB7XG4gICAgdmFyIGdyb3VwZWRUaWVycyA9IHt9O1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMudGllcnNbdGldO1xuICAgICAgICBpZiAodC5kYXNTb3VyY2UudGllckdyb3VwKSB7XG4gICAgICAgICAgICBwdXNobyhncm91cGVkVGllcnMsIHQuZGFzU291cmNlLnRpZXJHcm91cCwgdCk7XG4gICAgICAgIH0gICBcbiAgICB9XG5cbiAgICB2YXIgbmV3VGllcnMgPSBbXTtcbiAgICBpZiAoZG93bilcbiAgICAgICAgdGhpcy50aWVycy5yZXZlcnNlKCk7XG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgIHZhciB0ID0gdGhpcy50aWVyc1t0aV07XG4gICAgICAgIGlmICh0LmRhc1NvdXJjZS50aWVyR3JvdXApIHtcbiAgICAgICAgICAgIHZhciBudCA9IGdyb3VwZWRUaWVyc1t0LmRhc1NvdXJjZS50aWVyR3JvdXBdO1xuICAgICAgICAgICAgaWYgKG50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvd24pXG4gICAgICAgICAgICAgICAgICAgIG50LnJldmVyc2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBudGkgPSAwOyBudGkgPCBudC5sZW5ndGg7ICsrbnRpKVxuICAgICAgICAgICAgICAgICAgICBuZXdUaWVycy5wdXNoKG50W250aV0pO1xuICAgICAgICAgICAgICAgIGdyb3VwZWRUaWVyc1t0LmRhc1NvdXJjZS50aWVyR3JvdXBdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1RpZXJzLnB1c2godCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRvd24pXG4gICAgICAgIG5ld1RpZXJzLnJldmVyc2UoKTtcbiAgICB0aGlzLnRpZXJzLnNwbGljZSgwLCB0aGlzLnRpZXJzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgbnRpID0gMDsgbnRpIDwgbmV3VGllcnMubGVuZ3RoOyArK250aSlcbiAgICAgICAgdGhpcy50aWVycy5wdXNoKG5ld1RpZXJzW250aV0pO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5hcnJhbmdlVGllcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJyYW5nZWRUaWVycyA9IFtdO1xuICAgIHZhciBncm91cGVkVGllcnMgPSB7fTtcblxuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMudGllcnNbdGldO1xuICAgICAgICBpZiAodC5waW5uZWQpIHtcbiAgICAgICAgICAgIGFycmFuZ2VkVGllcnMucHVzaCh0KTtcbiAgICAgICAgICAgIGlmICh0LmRhc1NvdXJjZS50aWVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBwdXNobyhncm91cGVkVGllcnMsIHQuZGFzU291cmNlLnRpZXJHcm91cCwgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgdCA9IHRoaXMudGllcnNbdGldO1xuICAgICAgICBpZiAoIXQucGlubmVkKSB7XG4gICAgICAgICAgICBhcnJhbmdlZFRpZXJzLnB1c2godCk7XG4gICAgICAgICAgICBpZiAodC5kYXNTb3VyY2UudGllckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcHVzaG8oZ3JvdXBlZFRpZXJzLCB0LmRhc1NvdXJjZS50aWVyR3JvdXAsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgZyBpbiBncm91cGVkVGllcnMpIHtcbiAgICAgICAgdmFyIHRpZXJzID0gZ3JvdXBlZFRpZXJzW2ddO1xuICAgICAgICB2YXIgdGllckdyb3VwID0gdGhpcy50aWVyR3JvdXBzW2ddO1xuICAgICAgICBpZiAoIXRpZXJHcm91cCkge1xuICAgICAgICAgICAgdGllckdyb3VwID0ge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG1ha2VFbGVtZW50KFxuICAgICAgICAgICAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3NwYW4nLCBnLCB7Y2xhc3NOYW1lOiAndGllci1ncm91cC1sYWJlbCd9KSxcbiAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXCJ0aWVyLWdyb3VwXCJ9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudGllckdyb3Vwc1tnXSA9IHRpZXJHcm91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aWVyR3JvdXAuZWxlbWVudC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgdGllckdyb3VwLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aWVyR3JvdXAuZWxlbWVudCk7XG5cbiAgICAgICAgdmFyIGhvbGRlciA9IHRpZXJzWzBdLnBpbm5lZCA/IHRoaXMucGlubmVkVGllckhvbGRlciA6IHRoaXMudGllckhvbGRlcjtcbiAgICAgICAgdmFyIG1pbiA9IDEwMDAwMDAwLCBtYXggPSAwO1xuICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gdGllcnNbdGldLnJvdztcbiAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcm93Lm9mZnNldFRvcCk7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJvdy5vZmZzZXRUb3AgKyByb3cub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aWVyR3JvdXAuZWxlbWVudC5zdHlsZS50b3AgPSBtaW4gKyAncHgnO1xuICAgICAgICB0aWVyR3JvdXAuZWxlbWVudC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgICAgIHRpZXJHcm91cC5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChtYXgtbWluKSArICdweCc7XG4gICAgICAgIGhvbGRlci5hcHBlbmRDaGlsZCh0aWVyR3JvdXAuZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGllckJhY2tncm91bmRDb2xvcnMpIHtcbiAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IGFycmFuZ2VkVGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICB2YXIgdCA9IGFycmFuZ2VkVGllcnNbdGldO1xuICAgICAgICAgICAgdC5zZXRCYWNrZ3JvdW5kKHRoaXMudGllckJhY2tncm91bmRDb2xvcnNbdGkgJSB0aGlzLnRpZXJCYWNrZ3JvdW5kQ29sb3JzLmxlbmd0aF0pO1xuICAgICAgICAgICAgaWYgKHQuZGFzU291cmNlLnRpZXJHcm91cCkgXG4gICAgICAgICAgICAgICAgdC5sYWJlbC5zdHlsZS5sZWZ0ID0gJzE4cHgnO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHQubGFiZWwuc3R5bGUubGVmdCA9ICcycHgnO1xuICAgICAgICAgICAgdC5iYWNrZ3JvdW5kID0gdGhpcy50aWVyQmFja2dyb3VuZENvbG9yc1t0aSAlIHRoaXMudGllckJhY2tncm91bmRDb2xvcnMubGVuZ3RoXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubm90aWZ5TG9jYXRpb24oKTtcbiAgICB2YXIgd2lkdGggPSAodGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQpICsgMTtcbiAgICB2YXIgbWluRXh0cmFXID0gKDEwMC4wL3RoaXMuc2NhbGUpfDA7XG4gICAgdmFyIG1heEV4dHJhVyA9ICgxMDAwLjAvdGhpcy5zY2FsZSl8MDtcblxuICAgIHZhciBuZXdPcmlnaW4gPSAodGhpcy52aWV3U3RhcnQgKyB0aGlzLnZpZXdFbmQpIC8gMjtcbiAgICB2YXIgb2ggPSBuZXdPcmlnaW4gLSB0aGlzLm9yaWdpbjtcbiAgICB0aGlzLm9yaWdpbiA9IG5ld09yaWdpbjtcbiAgICB0aGlzLnNjYWxlQXRMYXN0UmVkcmF3ID0gdGhpcy5zY2FsZTtcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMudGllcnMubGVuZ3RoOyArK3QpIHtcbiAgICAgICAgdmFyIG9kID0gb2g7XG4gICAgICAgIGlmICh0aGlzLnRpZXJzW3RdLm9yaWdpbkhheHgpIHtcbiAgICAgICAgICAgIG9kICs9IHRoaXMudGllcnNbdF0ub3JpZ2luSGF4eDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpZXJzW3RdLm9yaWdpbkhheHggPSBvZDtcbiAgICB9XG5cbiAgICB2YXIgc2NhbGVkUXVhbnRSZXMgPSB0aGlzLnRhcmdldFF1YW50UmVzIC8gdGhpcy5zY2FsZTtcblxuICAgIHZhciBpbm5lckRyYXduU3RhcnQgPSBNYXRoLm1heCgxLCAodGhpcy52aWV3U3RhcnR8MCkgLSBtaW5FeHRyYVcpO1xuICAgIHZhciBpbm5lckRyYXduRW5kID0gTWF0aC5taW4oKHRoaXMudmlld0VuZHwwKSArIG1pbkV4dHJhVywgKCh0aGlzLmN1cnJlbnRTZXFNYXh8MCkgPiAwID8gKHRoaXMuY3VycmVudFNlcU1heHwwKSA6IDEwMDAwMDAwMDApKVxuICAgIHZhciBvdXRlckRyYXduU3RhcnQgPSBNYXRoLm1heCgxLCAodGhpcy52aWV3U3RhcnR8MCkgLSBtYXhFeHRyYVcpO1xuICAgIHZhciBvdXRlckRyYXduRW5kID0gTWF0aC5taW4oKHRoaXMudmlld0VuZHwwKSArIG1heEV4dHJhVywgKCh0aGlzLmN1cnJlbnRTZXFNYXh8MCkgPiAwID8gKHRoaXMuY3VycmVudFNlcU1heHwwKSA6IDEwMDAwMDAwMDApKTtcblxuICAgIGlmICghdGhpcy5rbm93blNwYWNlIHx8IHRoaXMua25vd25TcGFjZS5jaHIgIT09IHRoaXMuY2hyKSB7XG4gICAgICAgIHZhciBzcyA9IHRoaXMuZ2V0U2VxdWVuY2VTb3VyY2UoKTtcbiAgICAgICAgaWYgKHRoaXMua25vd25TcGFjZSlcbiAgICAgICAgICAgIHRoaXMua25vd25TcGFjZS5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5rbm93blNwYWNlID0gbmV3IEtub3duU3BhY2UodGhpcy50aWVycywgdGhpcy5jaHIsIG91dGVyRHJhd25TdGFydCwgb3V0ZXJEcmF3bkVuZCwgc2NhbGVkUXVhbnRSZXMsIHNzKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHNlZyA9IHRoaXMua25vd25TcGFjZS5iZXN0Q2FjaGVPdmVybGFwcGluZyh0aGlzLmNociwgaW5uZXJEcmF3blN0YXJ0LCBpbm5lckRyYXduRW5kKTtcbiAgICBpZiAoc2VnICYmIHNlZy5taW4gPD0gaW5uZXJEcmF3blN0YXJ0ICYmIHNlZy5tYXggPj0gaW5uZXJEcmF3bkVuZCkge1xuICAgICAgICB0aGlzLmRyYXduU3RhcnQgPSBNYXRoLm1heChzZWcubWluLCBvdXRlckRyYXduU3RhcnQpO1xuICAgICAgICB0aGlzLmRyYXduRW5kID0gTWF0aC5taW4oc2VnLm1heCwgb3V0ZXJEcmF3bkVuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kcmF3blN0YXJ0ID0gb3V0ZXJEcmF3blN0YXJ0O1xuICAgICAgICB0aGlzLmRyYXduRW5kID0gb3V0ZXJEcmF3bkVuZDtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5rbm93blNwYWNlLnZpZXdGZWF0dXJlcyh0aGlzLmNociwgdGhpcy5kcmF3blN0YXJ0LCB0aGlzLmRyYXduRW5kLCBzY2FsZWRRdWFudFJlcyk7XG4gICAgdGhpcy5kcmF3T3ZlcmxheXMoKTtcbiAgICB0aGlzLnBvc2l0aW9uUnVsZXIoKTtcbn1cblxuZnVuY3Rpb24gc2V0U291cmNlcyhtc2gsIGF2YWlsYWJsZVNvdXJjZXMsIG1heWJlTWFwcGluZykge1xuICAgIGlmIChtYXliZU1hcHBpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBhdmFpbGFibGVTb3VyY2VzLmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICBhdmFpbGFibGVTb3VyY2VzW3NdLm1hcHBpbmcgPSBtYXliZU1hcHBpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbXNoLnNldChhdmFpbGFibGVTb3VyY2VzKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucXVlcnlSZWdpc3RyeSA9IGZ1bmN0aW9uKG1heWJlTWFwcGluZywgdHJ5Q2FjaGUpIHtcbiAgICBpZiAoIXRoaXMucmVnaXN0cnkpXG4gICAgICAgIHJldHVybjtcblxuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkcywgbXNoO1xuICAgIGlmIChtYXliZU1hcHBpbmcpIHtcbiAgICAgICAgY29vcmRzID0gdGhpcy5jaGFpbnNbbWF5YmVNYXBwaW5nXS5jb29yZHM7XG4gICAgICAgIGlmICghdGhpc0IubWFwcGFibGVTb3VyY2VzW21heWJlTWFwcGluZ10pIHtcbiAgICAgICAgICAgIHRoaXNCLm1hcHBhYmxlU291cmNlc1ttYXliZU1hcHBpbmddID0gbmV3IE9ic2VydmVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgbXNoID0gdGhpc0IubWFwcGFibGVTb3VyY2VzW21heWJlTWFwcGluZ107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29vcmRzID0gdGhpcy5jb29yZFN5c3RlbTtcbiAgICAgICAgbXNoID0gdGhpcy5hdmFpbGFibGVTb3VyY2VzO1xuICAgIH1cbiAgICB2YXIgY2FjaGVIYXNoID0gaGV4X3NoYTEobWluaUpTT05pZnkoY29vcmRzKSk7XG4gICAgaWYgKHRyeUNhY2hlKSB7XG4gICAgICAgIHZhciBjYWNoZVRpbWUgPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS5yZWdpc3RyeS4nICsgY2FjaGVIYXNoICsgJy5sYXN0X3F1ZXJpZWQnXTtcbiAgICAgICAgaWYgKGNhY2hlVGltZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzZXRTb3VyY2VzKG1zaCwgSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS5yZWdpc3RyeS4nICsgY2FjaGVIYXNoICsgJy5zb3VyY2VzJ10pLCBtYXliZU1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZUFnZSA9IChEYXRlLm5vdygpfDApIC0gKGNhY2hlVGltZXwwKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVBZ2UgPCAoMTIgKiA2MCAqIDYwICogMTAwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHJleCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdCYWQgcmVnaXN0cnkgY2FjaGU6ICcgKyByZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJ1cmwgPSB0aGlzLnJlZ2lzdHJ5O1xuICAgIGlmIChydXJsLmluZGV4T2YoJy8vJykgPT0gMCkge1xuICAgICAgICB2YXIgcHJvdG8gPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgIGlmIChwcm90byAhPSAnaHR0cHM6JyAmJiBwcm90byAhPSAnaHR0cDonKVxuICAgICAgICAgICAgcnVybCA9ICdodHRwOicgKyBydXJsO1xuICAgIH1cbiAgICBuZXcgREFTUmVnaXN0cnkocnVybCkuc291cmNlcyhmdW5jdGlvbihzb3VyY2VzKSB7XG4gICAgICAgIHZhciBhdmFpbGFibGVTb3VyY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgc291cmNlcy5sZW5ndGg7ICsrcykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbc107XG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5jb29yZHMgfHwgc291cmNlLmNvb3Jkcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNjb29yZHMgPSBzb3VyY2UuY29vcmRzWzBdO1xuICAgICAgICAgICAgaWYgKHNjb29yZHMudGF4b24gIT0gY29vcmRzLnRheG9uIHx8IHNjb29yZHMuYXV0aCAhPSBjb29yZHMuYXV0aCB8fCBzY29vcmRzLnZlcnNpb24gIT0gY29vcmRzLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgIGF2YWlsYWJsZVNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UucmVnaXN0cnkuJyArIGNhY2hlSGFzaCArICcuc291cmNlcyddID0gSlNPTi5zdHJpbmdpZnkoYXZhaWxhYmxlU291cmNlcyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLnJlZ2lzdHJ5LicgKyBjYWNoZUhhc2ggKyAnLmxhc3RfcXVlcmllZCddID0gJycgKyBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgc2V0U291cmNlcyhtc2gsIGF2YWlsYWJsZVNvdXJjZXMsIG1heWJlTWFwcGluZyk7XG4gICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgLy8gbXNoLnNldChudWxsKTtcbiAgICB9LCBjb29yZHMpO1xufVxuXG4vL1xuLy8gTmF2aWdhdGlvblxuLy9cblxuQnJvd3Nlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHBvcywgc29mdClcbntcbiAgICB2YXIgd2lkID0gdGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQ7XG4gICAgdmFyIG5TdGFydCA9IHRoaXMudmlld1N0YXJ0IC0gKCgxLjAgKiBwb3MpIC8gdGhpcy5zY2FsZSk7XG4gICAgdmFyIG5FbmQgPSBuU3RhcnQgKyB3aWQ7XG5cbiAgICBpZiAoIXNvZnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlcU1heCA+IDAgJiYgbkVuZCA+IHRoaXMuY3VycmVudFNlcU1heCkge1xuICAgICAgICAgICAgbkVuZCA9IHRoaXMuY3VycmVudFNlcU1heDtcbiAgICAgICAgICAgIG5TdGFydCA9IHRoaXMudmlld0VuZCAtIHdpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoblN0YXJ0IDwgMSkge1xuICAgICAgICAgICAgblN0YXJ0ID0gMTtcbiAgICAgICAgICAgIG5FbmQgPSBuU3RhcnQgKyB3aWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldExvY2F0aW9uKG51bGwsIG5TdGFydCwgbkVuZCwgbnVsbCwgc29mdCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnpvb21TdGVwID0gZnVuY3Rpb24oZGVsdGEpIHtcbiAgICB2YXIgb3ogPSAxLjAgKiB0aGlzLnpvb21TbGlkZXJWYWx1ZTtcbiAgICB2YXIgbnogPSBveiArIGRlbHRhO1xuICAgIGlmIChueiA8IHRoaXMuem9vbU1pbikge1xuICAgICAgICBuej0gdGhpcy56b29tTWluO1xuICAgIH1cbiAgICBpZiAobnogPiB0aGlzLnpvb21NYXgpIHtcbiAgICAgICAgbnogPSB0aGlzLnpvb21NYXg7XG4gICAgfVxuXG4gICAgaWYgKG56ICE9IG96KSB7XG4gICAgICAgIHRoaXMuem9vbVNsaWRlclZhbHVlID0gbno7IC8vIEZJWE1FIG1heWJlIG91Z2h0IHRvIHNldCBpbnNpZGUgem9vbSFcbiAgICAgICAgdGhpcy56b29tKE1hdGguZXhwKCgxLjAgKiBueikgLyB0aGlzLnpvb21FeHB0KSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS56b29tID0gZnVuY3Rpb24oZmFjdG9yKSB7XG4gICAgdGhpcy56b29tRmFjdG9yID0gZmFjdG9yO1xuICAgIHZhciB2aWV3Q2VudGVyID0gTWF0aC5yb3VuZCgodGhpcy52aWV3U3RhcnQgKyB0aGlzLnZpZXdFbmQpIC8gMi4wKXwwO1xuICAgIHRoaXMudmlld1N0YXJ0ID0gdmlld0NlbnRlciAtIHRoaXMuem9vbUJhc2UgKiB0aGlzLnpvb21GYWN0b3IgLyAyO1xuICAgIHRoaXMudmlld0VuZCA9IHZpZXdDZW50ZXIgKyB0aGlzLnpvb21CYXNlICogdGhpcy56b29tRmFjdG9yIC8gMjtcbiAgICBpZiAodGhpcy5jdXJyZW50U2VxTWF4ID4gMCAmJiAodGhpcy52aWV3RW5kID4gdGhpcy5jdXJyZW50U2VxTWF4ICsgNSkpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcbiAgICAgICAgdGhpcy52aWV3RW5kID0gdGhpcy5jdXJyZW50U2VxTWF4O1xuICAgICAgICB0aGlzLnZpZXdTdGFydCA9IHRoaXMudmlld0VuZCAtIGxlbiArIDE7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpZXdTdGFydCA8IDEpIHtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcbiAgICAgICAgdGhpcy52aWV3U3RhcnQgPSAxO1xuICAgICAgICB0aGlzLnZpZXdFbmQgPSB0aGlzLnZpZXdTdGFydCArIGxlbiAtIDE7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUgPSB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoIC8gKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0KVxuICAgIHZhciB3aWR0aCA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcbiAgICBcbiAgICB2YXIgc2NhbGVSYXQgPSAodGhpcy5zY2FsZSAvIHRoaXMuc2NhbGVBdExhc3RSZWRyYXcpO1xuXG4gICAgdGhpcy5ub3RpZnlMb2NhdGlvbigpO1xuICAgIHRoaXMucmVmcmVzaCgpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5zcGFjZUNoZWNrID0gZnVuY3Rpb24oZG9udFJlZnJlc2gpIHtcbiAgICBpZiAoIXRoaXMua25vd25TcGFjZSB8fCB0aGlzLmtub3duU3BhY2UuY2hyICE9PSB0aGlzLmNocikge1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gXG5cbiAgICB2YXIgd2lkdGggPSAoKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0KXwwKSArIDE7XG4gICAgdmFyIG1pbkV4dHJhVyA9ICgxMDAuMC90aGlzLnNjYWxlKXwwO1xuICAgIHZhciBtYXhFeHRyYVcgPSAoMTAwMC4wL3RoaXMuc2NhbGUpfDA7XG5cbiAgICBpZiAoKHRoaXMuZHJhd25TdGFydHwwKSA+IE1hdGgubWF4KDEsICgodGhpcy52aWV3U3RhcnR8MCkgLSBtaW5FeHRyYVcpfDApICB8fCAodGhpcy5kcmF3bkVuZHwwKSA8IE1hdGgubWluKCh0aGlzLnZpZXdFbmR8MCkgKyBtaW5FeHRyYVcsICgodGhpcy5jdXJyZW50U2VxTWF4fDApID4gMCA/ICh0aGlzLmN1cnJlbnRTZXFNYXh8MCkgOiAxMDAwMDAwMDAwKSkpICB7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVzaXplVmlld2VyID0gZnVuY3Rpb24oc2tpcFJlZnJlc2gpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLnRpZXJIb2xkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggfCAwO1xuICAgIGlmICh3aWR0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgb2xkRlBXID0gTWF0aC5tYXgodGhpcy5mZWF0dXJlUGFuZWxXaWR0aCwgMzAwKTsgLy8gQ2FuIGdldCBzaWxseSB2YWx1ZXMgc3RvcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdGhlIGJyb3dzZXIgaXMgaGlkZGVuLlxuICAgIHRoaXMuZmVhdHVyZVBhbmVsV2lkdGggPSB3aWR0aHwwO1xuXG4gICAgaWYgKG9sZEZQVyAhPSB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoKSB7XG4gICAgICAgIHRoaXMuem9vbU1heCA9IHRoaXMuem9vbUV4cHQgKiBNYXRoLmxvZyh0aGlzLm1heFZpZXdXaWR0aCAvIHRoaXMuem9vbUJhc2UpO1xuICAgICAgICB0aGlzLnpvb21NaW4gPSB0aGlzLnpvb21FeHB0ICogTWF0aC5sb2codGhpcy5mZWF0dXJlUGFuZWxXaWR0aCAvIHRoaXMubWF4UGl4ZWxzUGVyQmFzZSAvIHRoaXMuem9vbUJhc2UpOyAgIC8vIEZJWE1FIGhhcmQtY29kZWQgbWluaW11bS5cbiAgICAgICAgdGhpcy56b29tU2xpZGVyVmFsdWUgPSB0aGlzLnpvb21FeHB0ICogTWF0aC5sb2coKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMSkgLyB0aGlzLnpvb21CYXNlKTtcblxuICAgICAgICB2YXIgdmlld1dpZHRoID0gdGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQ7XG4gICAgICAgIHZhciBudmUgPSB0aGlzLnZpZXdTdGFydCArICh2aWV3V2lkdGggKiB0aGlzLmZlYXR1cmVQYW5lbFdpZHRoKSAvIG9sZEZQVztcblxuICAgICAgICB0aGlzLnZpZXdFbmQgPSBudmU7XG5cbiAgICAgICAgdmFyIHdpZCA9IHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNlcU1heCA+IDAgJiYgdGhpcy52aWV3RW5kID4gdGhpcy5jdXJyZW50U2VxTWF4KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdFbmQgPSB0aGlzLmN1cnJlbnRTZXFNYXg7XG4gICAgICAgICAgICB0aGlzLnZpZXdTdGFydCA9IHRoaXMudmlld0VuZCAtIHdpZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmlld1N0YXJ0IDwgMSkge1xuICAgICAgICAgICAgdGhpcy52aWV3U3RhcnQgPSAxO1xuICAgICAgICAgICAgdGhpcy52aWV3RW5kID0gdGhpcy52aWV3U3RhcnQgKyB3aWQgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wb3NpdGlvblJ1bGVyKCk7XG5cbiAgICAgICAgaWYgKCFza2lwUmVmcmVzaCkge1xuICAgICAgICAgICAgdGhpcy5zcGFjZUNoZWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlMb2NhdGlvbigpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZ1bGxTY3JlZW4pIHtcbiAgICAgICAgdGhpcy5zZXRGdWxsU2NyZWVuSGVpZ2h0KCk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5zZXRGdWxsU2NyZWVuSGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3QgPSBkb2N1bWVudC5ib2R5Lm9mZnNldEhlaWdodCAtIHRoaXMuYnJvd3NlckhvbGRlci5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5icm93c2VySG9sZGVyLnN0eWxlLm1heEhlaWdodCA9IE1hdGgubWF4KDMwMCwgd2luZG93LmlubmVySGVpZ2h0IC0gcmVzdCAtIDIwKSArICdweCdcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuYWRkVGllciA9IGZ1bmN0aW9uKGNvbmYpIHtcbiAgICBjb25mID0gc2hhbGxvd0NvcHkoY29uZik7XG4gICAgY29uZi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIFxuICAgIHZhciB0aWVyID0gdGhpcy5tYWtlVGllcihjb25mKTtcbiAgICB0aGlzLm1hcmtTZWxlY3RlZFRpZXJzKCk7XG4gICAgdGhpcy5wb3NpdGlvblJ1bGVyKCk7XG4gICAgdGhpcy5ub3RpZnlUaWVyKCk7XG4gICAgcmV0dXJuIHRpZXI7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlbW92ZVRpZXIgPSBmdW5jdGlvbihjb25mLCBmb3JjZSkge1xuICAgIHZhciB0YXJnZXQgPSAtMTtcblxuICAgIGlmICh0eXBlb2YgY29uZi5pbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uZi5pbmRleCA+PTAgJiYgY29uZi5pbmRleCA8IHRoaXMudGllcnMubGVuZ3RoKSB7XG4gICAgICAgIHRhcmdldCA9IGNvbmYuaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICB2YXIgdHMgPSB0aGlzLnRpZXJzW3RpXS5kYXNTb3VyY2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzb3VyY2VzQXJlRXF1YWwoY29uZiwgdHMpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGk7IGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCA8IDApIHtcbiAgICAgICAgdGhyb3cgXCJDb3VsZG4ndCBmaW5kIHJlcXVlc3RlZCB0aWVyXCI7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFRpZXIgPSB0aGlzLnRpZXJzW3RhcmdldF07XG4gICAgdGhpcy50aWVycy5zcGxpY2UodGFyZ2V0LCAxKTtcblxuICAgIHZhciBuc3QgPSBbXTtcbiAgICBmb3IgKHZhciBzdGkgPSAwOyBzdGkgPCB0aGlzLnNlbGVjdGVkVGllcnMubGVuZ3RoOyArK3N0aSkge1xuICAgICAgICB2YXIgc3QgPSB0aGlzLnNlbGVjdGVkVGllcnNbc3RpXTtcbiAgICAgICAgaWYgKHN0IDwgdGFyZ2V0KSB7XG4gICAgICAgICAgICBuc3QucHVzaChzdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3QgPiB0YXJnZXQpIHtcbiAgICAgICAgICAgIG5zdC5wdXNoKHN0IC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZWxlY3RlZFRpZXJzID0gbnN0O1xuICAgIHRoaXMubWFya1NlbGVjdGVkVGllcnMoKTtcblxuICAgIHRhcmdldFRpZXIuZGVzdHJveSgpO1xuICAgIGlmICh0aGlzLmtub3duU3BhY2UpIHtcbiAgICAgICAgdGhpcy5rbm93blNwYWNlLmZlYXR1cmVDYWNoZVt0YXJnZXRUaWVyXSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5yZW9yZGVyVGllcnMoKTtcbiAgICB0aGlzLm5vdGlmeVRpZXIoKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlQWxsVGllcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXNCID0gdGhpcztcbiAgdGhpcy5zZWxlY3RlZFRpZXJzID0gW107XG4gIHRoaXMubWFya1NlbGVjdGVkVGllcnMoKTtcbiAgdGhpcy50aWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXRUaWVyKSB7XG5cdCAgdGFyZ2V0VGllci5kZXN0cm95KCk7XG5cdCAgaWYgKHRoaXNCLmtub3duU3BhY2UpIHtcblx0ICAgICAgdGhpc0Iua25vd25TcGFjZS5mZWF0dXJlQ2FjaGVbdGFyZ2V0VGllcl0gPSBudWxsO1xuXHQgIH1cbiAgfSk7XG4gIHRoaXMudGllcnMubGVuZ3RoID0gMDtcbiAgdGhpcy5yZW9yZGVyVGllcnMoKTtcbiAgdGhpcy5ub3RpZnlUaWVyKCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmdldFNlcXVlbmNlU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3NlcXVlbmNlU291cmNlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRoaXMuX3NlcXVlbmNlU291cmNlID0gdGhpcy5fZ2V0U2VxdWVuY2VTb3VyY2UoKTtcbiAgICByZXR1cm4gdGhpcy5fc2VxdWVuY2VTb3VyY2U7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLl9nZXRTZXF1ZW5jZVNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICBpZiAodGhpcy50aWVyc1t0aV0uc2VxdWVuY2VTb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpZXJzW3RpXS5zZXF1ZW5jZVNvdXJjZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aGlzLmRlZmF1bHRTb3VyY2VzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuZGVmYXVsdFNvdXJjZXNbc2ldO1xuICAgICAgICBpZiAocy5wcm92aWRlc19lbnRyeXBvaW50cyB8fCBzLnRpZXJfdHlwZSA9PSAnc2VxdWVuY2UnIHx8IHMudHdvQml0VVJJIHx8IHMudHdvQml0QmxvYikge1xuICAgICAgICAgICAgaWYgKHMudHdvQml0VVJJIHx8IHMudHdvQml0QmxvYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHdvQml0U2VxdWVuY2VTb3VyY2Uocyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgREFTU2VxdWVuY2VTb3VyY2Uocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24obmV3Q2hyLCBuZXdNaW4sIG5ld01heCwgY2FsbGJhY2ssIHNvZnQpIHtcbiAgICBpZiAodHlwZW9mKG5ld01pbikgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdtaW5pbXVtIG11c3QgYmUgYSBudW1iZXIgKGdvdCAnICsgSlNPTi5zdHJpbmdpZnkobmV3TWluKSArICcpJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YobmV3TWF4KSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ21heGltdW0gbXVzdCBiZSBhIG51bWJlciAoZ290ICcgKyBKU09OLnN0cmluZ2lmeShuZXdNYXgpICsgJyknKTtcbiAgICB9XG5cbiAgICBpZiAobmV3TWluID4gbmV3TWF4KSB7XG4gICAgICAgIHZhciBvbGROZXdNaW4gPSBuZXdNaW47XG4gICAgICAgIG5ld01pbiA9IG5ld01heDtcbiAgICAgICAgbmV3TWF4ID0gb2xkTmV3TWluO1xuICAgIH0gZWxzZSBpZiAobmV3TWluID09PSBuZXdNYXgpIHtcbiAgICAgICAgbmV3TWF4ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgaWYgKCghbmV3Q2hyIHx8IG5ld0NociA9PSB0aGlzLmNocikgJiYgdGhpcy5jdXJyZW50U2VxTWF4ID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0TG9jYXRpb24obnVsbCwgbmV3TWluLCBuZXdNYXgsIG51bGwsIGNhbGxiYWNrLCBzb2Z0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3MgPSB0aGlzLmdldFNlcXVlbmNlU291cmNlKCk7XG4gICAgICAgIGlmICghc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygnTmVlZCBhIHNlcXVlbmNlIHNvdXJjZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZpbmRDaHIgPSBuZXdDaHIgfHwgdGhpcy5jaHI7XG4gICAgICAgIHNzLmdldFNlcUluZm8oZmluZENociwgZnVuY3Rpb24oc2kpIHtcbiAgICAgICAgICAgIGlmICghc2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWx0Q2hyO1xuICAgICAgICAgICAgICAgIGlmIChmaW5kQ2hyLmluZGV4T2YoJ2NocicpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0Q2hyID0gZmluZENoci5zdWJzdHIoMyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0Q2hyID0gJ2NocicgKyBmaW5kQ2hyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcy5nZXRTZXFJbmZvKGFsdENociwgZnVuY3Rpb24oc2kyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2kyICYmIG5ld0Nocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFwiQ291bGRuJ3QgZmluZCBzZXF1ZW5jZSAnXCIgKyBuZXdDaHIgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNpMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNCLl9zZXRMb2NhdGlvbihudWxsLCBuZXdNaW4sIG5ld01heCwgbnVsbCwgY2FsbGJhY2ssIHNvZnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNCLl9zZXRMb2NhdGlvbihhbHRDaHIsIG5ld01pbiwgbmV3TWF4LCBzaTIsIGNhbGxiYWNrLCBzb2Z0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0IuX3NldExvY2F0aW9uKG5ld0NociwgbmV3TWluLCBuZXdNYXgsIHNpLCBjYWxsYmFjaywgc29mdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuX3NldExvY2F0aW9uID0gZnVuY3Rpb24obmV3Q2hyLCBuZXdNaW4sIG5ld01heCwgbmV3Q2hySW5mbywgY2FsbGJhY2ssIHNvZnQpIHtcbiAgICB2YXIgY2hyQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGlmIChuZXdDaHIpIHtcbiAgICAgICAgaWYgKG5ld0Noci5pbmRleE9mKCdjaHInKSA9PSAwKVxuICAgICAgICAgICAgbmV3Q2hyID0gbmV3Q2hyLnN1YnN0cmluZygzKTtcblxuICAgICAgICBpZiAodGhpcy5jaHIgIT0gbmV3Q2hyKVxuICAgICAgICAgICAgY2hyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hyID0gbmV3Q2hyO1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXFNYXggPSBuZXdDaHJJbmZvLmxlbmd0aDtcbiAgICB9XG5cbiAgICBuZXdNaW4gPSBwYXJzZUZsb2F0KG5ld01pbik7IG5ld01heD1wYXJzZUZsb2F0KG5ld01heCk7XG5cbiAgICB2YXIgbmV3V2lkdGggPSBNYXRoLm1heCgxMCwgbmV3TWF4LW5ld01pbisxKTtcblxuICAgIGlmICghc29mdCkge1xuICAgICAgICB2YXIgY3NtID0gdGhpcy5jdXJyZW50U2VxTWF4O1xuICAgICAgICBpZiAoY3NtIDw9IDApXG4gICAgICAgICAgICBjc20gPSAxMDAwMDAwMDAwMDAwO1xuICAgICAgICBpZiAobmV3TWluIDwgMSkge1xuICAgICAgICAgICAgbmV3TWluID0gMTsgbmV3TWF4ID0gbmV3TWluICsgbmV3V2lkdGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdNYXggPiBjc20pIHtcbiAgICAgICAgICAgIG5ld01heCA9IGNzbTtcbiAgICAgICAgICAgIG5ld01pbiA9IE1hdGgubWF4KDEsIG5ld01heCAtIG5ld1dpZHRoICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnZpZXdTdGFydCA9IG5ld01pbjtcbiAgICB0aGlzLnZpZXdFbmQgPSBuZXdNYXg7XG4gICAgdmFyIG5ld1NjYWxlID0gTWF0aC5tYXgodGhpcy5mZWF0dXJlUGFuZWxXaWR0aCwgNTApIC8gKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0KTtcbiAgICB2YXIgb2xkU2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIHZhciBzY2FsZUNoYW5nZWQgPSAoTWF0aC5hYnMobmV3U2NhbGUgLSBvbGRTY2FsZSkpID4gMC4wMDAwMDE7XG4gICAgdGhpcy5zY2FsZSA9IG5ld1NjYWxlO1xuXG4gICAgdmFyIG5ld1pTLCBvbGRaUztcbiAgICBvbGRaUyA9IHRoaXMuem9vbVNsaWRlclZhbHVlO1xuICAgIHRoaXMuem9vbVNsaWRlclZhbHVlID0gbmV3WlMgPSB0aGlzLnpvb21FeHB0ICogTWF0aC5sb2coKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0ICsgMSkgLyB0aGlzLnpvb21CYXNlKTtcbiAgICBcbiAgICBpZiAoc2NhbGVDaGFuZ2VkIHx8IGNockNoYW5nZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnRpZXJzW2ldLnZpZXdwb3J0SG9sZGVyLnN0eWxlLmxlZnQgPSAnNTAwMHB4JztcbiAgICAgICAgICAgIHRoaXMudGllcnNbaV0ub3ZlcmxheS5zdHlsZS5sZWZ0ID0gJzUwMDBweCc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZnJlc2goKTtcblxuICAgICAgICBpZiAodGhpcy5zYXZlZFpvb20pIHtcbiAgICAgICAgICAgIG5ld1pTIC09IHRoaXMuem9vbU1pbjtcbiAgICAgICAgICAgIG9sZFpTIC09IHRoaXMuem9vbU1pbjtcbiAgICAgICAgICAgIHZhciBkaWZUb0FjdGl2ZSA9IG5ld1pTIC0gb2xkWlM7XG4gICAgICAgICAgICB2YXIgZGlmVG9TYXZlZCA9IG5ld1pTIC0gdGhpcy5zYXZlZFpvb207XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGlmVG9BY3RpdmUpID4gTWF0aC5hYnMoZGlmVG9TYXZlZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU25hcFpvb21pbmcgPSAhdGhpcy5pc1NuYXBab29taW5nO1xuICAgICAgICAgICAgICAgIHRoaXMuc2F2ZWRab29tID0gb2xkWlM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzU25hcFpvb21pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2F2ZWRab29tID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2aWV3Q2VudGVyID0gKHRoaXMudmlld1N0YXJ0ICsgdGhpcy52aWV3RW5kKS8yO1xuICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAodGhpcy52aWV3U3RhcnQgLSB0aGlzLnRpZXJzW2ldLm5vcmlnaW4pKnRoaXMuc2NhbGU7XG4gICAgICAgICAgICB0aGlzLnRpZXJzW2ldLnZpZXdwb3J0SG9sZGVyLnN0eWxlLmxlZnQgPSAnJyArICgoLW9mZnNldHwwKSAtIDEwMDApICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXMudGllcnNbaV0uZHJhd092ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubm90aWZ5TG9jYXRpb24oKTtcblxuICAgIHRoaXMuc3BhY2VDaGVjaygpO1xuICAgIGlmICh0aGlzLmluc3RydW1lbnRBY3Rpdml0eSlcbiAgICAgICAgdGhpcy5hY3Rpdml0eVN0YXJ0VGltZSA9IERhdGUubm93KCl8MDtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuc2V0Q2VudGVyTG9jYXRpb24gPSBmdW5jdGlvbihuZXdDaHIsIG5ld0NlbnRlckxvYykge1xuICAgIHZhciBoYWxmV2lkdGggPSAodGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQpLzIsXG4gICAgbmV3TWluID0gbmV3Q2VudGVyTG9jIC0gaGFsZldpZHRoLFxuICAgIG5ld01heCA9IG5ld0NlbnRlckxvYyArIGhhbGZXaWR0aDtcbiAgICB0aGlzLnNldExvY2F0aW9uKG5ld0NociwgbmV3TWluLCBuZXdNYXgpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5waW5nQWN0aXZpdHkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaW5zdHJ1bWVudEFjdGl2aXR5IHx8ICF0aGlzLmFjdGl2aXR5U3RhcnRUaW1lKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgYWN0aXZpdHkgPSAwO1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICBpZiAodGhpcy50aWVyc1t0aV0ubG9hZGVyQnV0dG9uLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJylcbiAgICAgICAgICAgICsrYWN0aXZpdHk7XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2aXR5ID09IDApIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCl8MDtcbiAgICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgdG9vayAnICsgKG5vdy10aGlzLmFjdGl2aXR5U3RhcnRUaW1lKSArICdtcycpO1xuICAgICAgICB0aGlzLmFjdGl2aXR5U3RhcnRUaW1lID0gbnVsbDtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmFkZEluaXRMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB0aGlzLmluaXRMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuYWRkRmVhdHVyZUxpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlciwgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMuZmVhdHVyZUxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlTGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyLCBvcHRzKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLmZlYXR1cmVMaXN0ZW5lcnMsIGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLmZlYXR1cmVMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5ub3RpZnlGZWF0dXJlID0gZnVuY3Rpb24oZXYsIGZlYXR1cmUsIGhpdCwgdGllcikge1xuICBmb3IgKHZhciBmbGkgPSAwOyBmbGkgPCB0aGlzLmZlYXR1cmVMaXN0ZW5lcnMubGVuZ3RoOyArK2ZsaSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlTGlzdGVuZXJzW2ZsaV0oZXYsIGZlYXR1cmUsIGhpdCwgdGllcikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGV4LnN0YWNrKTtcbiAgICAgIH1cbiAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5hZGRGZWF0dXJlSG92ZXJMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLmZlYXR1cmVIb3Zlckxpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZW1vdmVGZWF0dXJlSG92ZXJMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIsIG9wdHMpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMuZmVhdHVyZUhvdmVyTGlzdGVuZXJzLCBoYW5kbGVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlSG92ZXJMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5ub3RpZnlGZWF0dXJlSG92ZXIgPSBmdW5jdGlvbihldiwgZmVhdHVyZSwgaGl0LCB0aWVyKSB7XG4gICAgZm9yICh2YXIgZmxpID0gMDsgZmxpIDwgdGhpcy5mZWF0dXJlSG92ZXJMaXN0ZW5lcnMubGVuZ3RoOyArK2ZsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlSG92ZXJMaXN0ZW5lcnNbZmxpXShldiwgZmVhdHVyZSwgaGl0LCB0aWVyKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4LnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuYWRkVmlld0xpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlciwgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMudmlld0xpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZW1vdmVWaWV3TGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyLCBvcHRzKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLnZpZXdMaXN0ZW5lcnMsIGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLnZpZXdMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5ub3RpZnlMb2NhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBudnMgPSBNYXRoLm1heCgxLCB0aGlzLnZpZXdTdGFydHwwKTtcbiAgICB2YXIgbnZlID0gdGhpcy52aWV3RW5kfDA7XG4gICAgaWYgKHRoaXMuY3VycmVudFNlcU1heCA+IDAgJiYgbnZlID4gdGhpcy5jdXJyZW50U2VxTWF4KVxuICAgICAgICBudmUgPSB0aGlzLmN1cnJlbnRTZXFNYXg7XG5cbiAgICBmb3IgKHZhciBsbGkgPSAwOyBsbGkgPCB0aGlzLnZpZXdMaXN0ZW5lcnMubGVuZ3RoOyArK2xsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52aWV3TGlzdGVuZXJzW2xsaV0oXG4gICAgICAgICAgICAgICAgdGhpcy5jaHIsIFxuICAgICAgICAgICAgICAgIG52cywgXG4gICAgICAgICAgICAgICAgbnZlLCBcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21TbGlkZXJWYWx1ZSwgXG4gICAgICAgICAgICAgICAge2N1cnJlbnQ6IHRoaXMuem9vbVNsaWRlclZhbHVlLFxuICAgICAgICAgICAgICAgICBhbHRlcm5hdGU6ICh0aGlzLnNhdmVkWm9vbSt0aGlzLnpvb21NaW4pIHx8IHRoaXMuem9vbU1pbixcbiAgICAgICAgICAgICAgICAgaXNTbmFwWm9vbWluZzogdGhpcy5pc1NuYXBab29taW5nLFxuICAgICAgICAgICAgICAgICBtaW46IHRoaXMuem9vbU1pbiwgXG4gICAgICAgICAgICAgICAgIG1heDogdGhpcy56b29tTWF4fSxcbiAgICAgICAgICAgICAgICAgdGhpcy52aWV3U3RhcnQsXG4gICAgICAgICAgICAgICAgIHRoaXMudmlld0VuZCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhleC5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmFkZFRpZXJMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB0aGlzLnRpZXJMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlVGllckxpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIHZhciBpZHggPSBhcnJheUluZGV4T2YodGhpcy50aWVyTGlzdGVuZXJzLCBoYW5kbGVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy50aWVyTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubm90aWZ5VGllciA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHRsaSA9IDA7IHRsaSA8IHRoaXMudGllckxpc3RlbmVycy5sZW5ndGg7ICsrdGxpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRpZXJMaXN0ZW5lcnNbdGxpXSgpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXguc3RhY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5hZGRSZWdpb25TZWxlY3RMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB0aGlzLnJlZ2lvblNlbGVjdExpc3RlbmVycy5wdXNoKGhhbmRsZXIpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5yZW1vdmVSZWdpb25TZWxlY3RMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMucmVnaW9uU2VsZWN0TGlzdGVuZXJzLCBoYW5kbGVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5yZWdpb25TZWxlY3RMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5ub3RpZnlSZWdpb25TZWxlY3QgPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4KSB7XG4gICAgZm9yICh2YXIgcmxpID0gMDsgcmxpIDwgdGhpcy5yZWdpb25TZWxlY3RMaXN0ZW5lcnMubGVuZ3RoOyArK3JsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZWdpb25TZWxlY3RMaXN0ZW5lcnNbcmxpXShjaHIsIG1pbiwgbWF4KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4LnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5Ccm93c2VyLnByb3RvdHlwZS5oaWdobGlnaHRSZWdpb24gPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4KSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICBcbiAgICBpZiAoY2hyID09IHRoaXMuY2hyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWdobGlnaHRSZWdpb24oY2hyLCBtaW4sIG1heCk7XG4gICAgfVxuXG4gICAgdmFyIHNzID0gdGhpcy5nZXRTZXF1ZW5jZVNvdXJjZSgpO1xuICAgIGlmICghc3MpIHtcbiAgICAgICAgdGhyb3cgJ05lZWQgYSBzZXF1ZW5jZSBzb3VyY2UnO1xuICAgIH1cblxuICAgIHNzLmdldFNlcUluZm8oY2hyLCBmdW5jdGlvbihzaSkge1xuICAgICAgICBpZiAoIXNpKSB7XG4gICAgICAgICAgICB2YXIgYWx0Q2hyO1xuICAgICAgICAgICAgaWYgKGNoci5pbmRleE9mKCdjaHInKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgYWx0Q2hyID0gY2hyLnN1YnN0cigzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWx0Q2hyID0gJ2NocicgKyBjaHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcy5nZXRTZXFJbmZvKGFsdENociwgZnVuY3Rpb24oc2kyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFpbCBzaWxlbnRseS5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc0IuX2hpZ2hsaWdodFJlZ2lvbihhbHRDaHIsIG1pbiwgbWF4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzQi5faGlnaGxpZ2h0UmVnaW9uKGNociwgbWluLCBtYXgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLl9oaWdobGlnaHRSZWdpb24gPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4KSB7XG4gICAgZm9yICh2YXIgaGkgPSAwOyBoaSA8IHRoaXMuaGlnaGxpZ2h0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLmhpZ2hsaWdodHNbaGldO1xuICAgICAgICBpZiAoaC5jaHIgPT0gY2hyICYmIGgubWluID09IG1pbiAmJiBoLm1heCA9PSBtYXgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5oaWdobGlnaHRzLnB1c2gobmV3IFJlZ2lvbihjaHIsIG1pbiwgbWF4KSk7XG4gICAgdmFyIHZpc1N0YXJ0ID0gdGhpcy52aWV3U3RhcnQgLSAoMTAwMC90aGlzLnNjYWxlKTtcbiAgICB2YXIgdmlzRW5kID0gdGhpcy52aWV3RW5kICsgKDEwMDAvdGhpcy5zY2FsZSk7XG4gICAgaWYgKChjaHIgPT0gdGhpcy5jaHIgfHwgY2hyID09ICgnY2hyJyt0aGlzLmNocikpICYmIG1pbiA8IHZpc0VuZCAmJiBtYXggPiB2aXNTdGFydCkge1xuICAgICAgICB0aGlzLmRyYXdPdmVybGF5cygpO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZ5TG9jYXRpb24oKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuY2xlYXJIaWdobGlnaHRzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oaWdobGlnaHRzID0gW107XG4gICAgdGhpcy5kcmF3T3ZlcmxheXMoKTtcbiAgICB0aGlzLm5vdGlmeUxvY2F0aW9uKCk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmRyYXdPdmVybGF5cyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB0aGlzLnRpZXJzW3RpXS5kcmF3T3ZlcmxheSgpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuZmVhdHVyZXNJblJlZ2lvbiA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICBpZiAoY2hyICE9PSB0aGlzLmNocikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgIHZhciBmbCA9IHRoaXMudGllcnNbdGldLmN1cnJlbnRGZWF0dXJlcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZsLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbFtmaV07XG4gICAgICAgICAgICBpZiAoZi5taW4gPD0gbWF4ICYmIGYubWF4ID49IG1pbikge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuXG5cbkJyb3dzZXIucHJvdG90eXBlLmdldFNlbGVjdGVkVGllciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkVGllcnMubGVuZ3RoID4gMCkgXG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkVGllcnNbMF07XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gLTE7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNldFNlbGVjdGVkVGllciA9IGZ1bmN0aW9uKHQpIHtcbiAgICBpZiAodCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUaWVycyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUaWVycyA9IFt0XTtcbiAgICB9XG4gICAgdGhpcy5tYXJrU2VsZWN0ZWRUaWVycygpO1xuICAgIHRoaXMubm90aWZ5VGllclNlbGVjdGlvbigpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYXJrU2VsZWN0ZWRUaWVycyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gdGhpcy50aWVyc1t0aV0ubmFtZUJ1dHRvbjtcblxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZFRpZXJzLmluZGV4T2YodGkpID49IDApIHtcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5zZWxlY3RlZFRpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGJyb3dzZXJNaWQgPSB0aGlzLmJyb3dzZXJIb2xkZXIub2Zmc2V0VG9wICsgdGhpcy5icm93c2VySG9sZGVyLm9mZnNldEhlaWdodC8yO1xuICAgICAgICBpZiAoYnJvd3Nlck1pZCA+IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wICYmIChicm93c2VyTWlkICsgMTAwKSA8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wICsgd2luZG93LmlubmVySGVpZ2h0KVxuICAgICAgICAgICAgdGhpcy5icm93c2VySG9sZGVyLmZvY3VzKCk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5hZGRUaWVyU2VsZWN0aW9uTGlzdGVuZXIgPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgdGhpcy50aWVyU2VsZWN0aW9uTGlzdGVuZXJzLnB1c2goaGFuZGxlcik7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnJlbW92ZVRpZXJTZWxlY3Rpb25MaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMudGllclNlbGVjdGlvbkxpc3RlbmVycywgaGFuZGxlcik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMudGllclNlbGVjdGlvbkxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLm5vdGlmeVRpZXJTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBmbGkgPSAwOyBmbGkgPCB0aGlzLnRpZXJTZWxlY3Rpb25MaXN0ZW5lcnMubGVuZ3RoOyArK2ZsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy50aWVyU2VsZWN0aW9uTGlzdGVuZXJzW2ZsaV0odGhpcy5zZWxlY3RlZFRpZXJzKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4LnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5hZGRUaWVyU2VsZWN0aW9uV3JhcExpc3RlbmVyID0gZnVuY3Rpb24oZikge1xuICAgIHRoaXMudGllclNlbGVjdGlvbldyYXBMaXN0ZW5lcnMucHVzaChmKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlVGllclNlbGVjdGlvbldyYXBMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMudGllclNlbGVjdGlvbldyYXBMaXN0ZW5lcnMsIGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLnRpZXJTZWxlY3Rpb25XcmFwTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubm90aWZ5VGllclNlbGVjdGlvbldyYXAgPSBmdW5jdGlvbihpKSB7XG4gICAgZm9yICh2YXIgZmxpID0gMDsgZmxpIDwgdGhpcy50aWVyU2VsZWN0aW9uV3JhcExpc3RlbmVycy5sZW5ndGg7ICsrZmxpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnRpZXJTZWxlY3Rpb25XcmFwTGlzdGVuZXJzW2ZsaV0oaSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhleC5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuQnJvd3Nlci5wcm90b3R5cGUucG9zaXRpb25SdWxlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkaXNwbGF5ID0gJ25vbmUnO1xuICAgIHZhciBsZWZ0ID0gJyc7XG4gICAgdmFyIHJpZ2h0ID0gJyc7XG5cbiAgICBpZiAodGhpcy5ydWxlckxvY2F0aW9uID09ICdjZW50ZXInKSB7XG4gICAgICAgIGRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICBsZWZ0ID0gJycgKyAoKHRoaXMuZmVhdHVyZVBhbmVsV2lkdGgvMil8MCkgKyAncHgnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ydWxlckxvY2F0aW9uID09ICdsZWZ0Jykge1xuICAgICAgICBkaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgbGVmdCA9ICcwcHgnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5ydWxlckxvY2F0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHJpZ2h0ID0gJzBweCdcbiAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXIuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXk7XG4gICAgdGhpcy5ydWxlci5zdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJ1bGVyLnN0eWxlLnJpZ2h0ID0gcmlnaHQ7XG5cbiAgICBpZih0aGlzLnNpbmdsZUJhc2VIaWdobGlnaHQpIHtcbiAgICAgICAgdGhpcy5ydWxlcjIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLmJvcmRlcldpZHRoID0gJzFweCc7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5ydWxlcjIuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgICAgICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSAnMHB4JyBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLndpZHRoID0gdGhpcy5zY2FsZSArICdweCc7XG4gICAgICAgICAgICB0aGlzLnJ1bGVyMi5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gJzFweCcgXG4gICAgICAgIH0gXG4gICAgICAgIC8vIFBvc2l0aW9uIGFjY29tcGFueWluZyBzaW5nbGUgYmFzZSBsb2NhdGlvbiB0ZXh0XG4gICAgICAgIHRoaXMubG9jU2luZ2xlQmFzZS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB2YXIgY2VudHJlT2Zmc2V0ID0gdGhpcy5mZWF0dXJlUGFuZWxXaWR0aC8yIC0gdGhpcy5sb2NTaW5nbGVCYXNlLm9mZnNldFdpZHRoLzIgKyB0aGlzLnJ1bGVyMi5vZmZzZXRXaWR0aC8yOyBcbiAgICAgICAgdGhpcy5sb2NTaW5nbGVCYXNlLnN0eWxlLmxlZnQgPSAnJyArIChjZW50cmVPZmZzZXR8MCkgKyAncHgnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9jU2luZ2xlQmFzZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLndpZHRoID0gJzFweCc7XG4gICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLmJvcmRlcldpZHRoID0gJzBweCc7XG4gICAgICAgIHRoaXMucnVsZXIyLnN0eWxlLmRpc3BsYXkgPSB0aGlzLnJ1bGVyTG9jYXRpb24gPT0gJ2NlbnRlcicgPyAnbm9uZScgOiAnYmxvY2snO1xuICAgIH1cbiAgIFxuICAgIHRoaXMucnVsZXIyLnN0eWxlLmxlZnQgPSAnJyArICgodGhpcy5mZWF0dXJlUGFuZWxXaWR0aC8yKXwwKSArICdweCc7XG4gICAgXG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgIHZhciB0aWVyID0gdGhpcy50aWVyc1t0aV07XG4gICAgICAgIHZhciBxID0gdGllci5xdWFudE92ZXJsYXk7XG5cbiAgICAgICAgdmFyIHF1YW50O1xuICAgICAgICBpZiAodGllci5zdWJ0aWVycyAmJiB0aWVyLnN1YnRpZXJzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICBxdWFudCA9IHRpZXIuc3VidGllcnNbMF0ucXVhbnQ7XG5cbiAgICAgICAgaWYgKHEpIHtcbiAgICAgICAgICAgIHEuc3R5bGUuZGlzcGxheSA9IHF1YW50ID8gZGlzcGxheSA6ICdub25lJztcbiAgICAgICAgICAgIHEuc3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgICAgICBxLnN0eWxlLnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmZlYXR1cmVEb3VibGVDbGljayA9IGZ1bmN0aW9uKGhpdCwgcngsIHJ5KSB7XG4gICAgaWYgKCFoaXQgfHwgaGl0Lmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgZiA9IGhpdFtoaXQubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoIWYubWluIHx8ICFmLm1heCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZzdGFydCA9ICgoKGYubWlufDApIC0gKHRoaXMudmlld1N0YXJ0fDApKSAqIHRoaXMuc2NhbGUpO1xuICAgIHZhciBmd2lkdGggPSAoKChmLm1heCAtIGYubWluKSArIDEpICogdGhpcy5zY2FsZSk7XG4gICAgXG4gICAgdmFyIG5ld01pZCA9ICgoKGYubWlufDApICsgKGYubWF4fDApKSkvMjtcbiAgICBpZiAoZndpZHRoID4gMTApIHtcbiAgICAgICAgdmFyIGZyYWMgPSAoMS4wICogKHJ4IC0gZnN0YXJ0KSkgLyBmd2lkdGg7XG4gICAgICAgIGlmIChmcmFjIDwgMC4zKSB7XG4gICAgICAgICAgICBuZXdNaWQgPSAoZi5taW58MCk7XG4gICAgICAgIH0gZWxzZSAgaWYgKGZyYWMgPiAwLjcpIHtcbiAgICAgICAgICAgIG5ld01pZCA9IChmLm1heHwwKSArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSB0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydDtcbiAgICB0aGlzLnNldExvY2F0aW9uKG51bGwsIG5ld01pZCAtICh3aWR0aC8yKSwgbmV3TWlkICsgKHdpZHRoLzIpKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuem9vbUZvclNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcbiAgICB2YXIgc3NTY2FsZTtcbiAgICBpZiAoc2NhbGUgPiAwLjIpIHtcbiAgICAgICAgc3NTY2FsZSA9ICdoaWdoJztcbiAgICB9IGVsc2UgaWYgKHNjYWxlID4gMC4wMSkge1xuICAgICAgICBzc1NjYWxlID0gJ21lZGl1bSc7XG4gICAgfSBlbHNlICB7XG4gICAgICAgIHNzU2NhbGUgPSAnbG93JztcbiAgICB9XG4gICAgcmV0dXJuIHNzU2NhbGU7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnpvb21Gb3JDdXJyZW50U2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy56b29tRm9yU2NhbGUodGhpcy5zY2FsZSk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aWVyVG90YWwgPSAwO1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkgXG4gICAgICAgIHRpZXJUb3RhbCArPSAodGhpcy50aWVyc1t0aV0uY3VycmVudEhlaWdodCB8fCAzMCk7XG4gICAgdGhpcy5ydWxlci5zdHlsZS5oZWlnaHQgPSAnJyArIHRpZXJUb3RhbCArICdweCc7XG4gICAgdGhpcy5ydWxlcjIuc3R5bGUuaGVpZ2h0ID0gJycgKyB0aWVyVG90YWwgKyAncHgnO1xuICAgIHRoaXMuYnJvd3NlckhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICB0aGlzLmJyb3dzZXJIb2xkZXIuc3R5bGUuZGlzcGxheSA9ICctd2Via2l0LWZsZXgnO1xuICAgIHRoaXMuYnJvd3NlckhvbGRlci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIC8vIHRoaXMuc3ZnSG9sZGVyLnN0eWxlLm1heEhlaWdodCA9ICcnICsgTWF0aC5tYXgodGllclRvdGFsLCA1MDApICsgJ3B4Jztcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuc2Nyb2xsQXJyb3dLZXkgPSBmdW5jdGlvbihldiwgZGlyKSB7XG4gICAgaWYgKHRoaXMucmV2ZXJzZUtleVNjcm9sbGluZylcbiAgICAgICAgZGlyID0gLWRpcjtcbiAgICBcbiAgICBpZiAoZXYuY3RybEtleSB8fCBldi5tZXRhS2V5KSB7XG4gICAgICAgIHZhciBmZWRnZSA9IGZhbHNlO1xuICAgICAgICBpZihldi5zaGlmdEtleSl7XG4gICAgICAgICAgICBmZWRnZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxlYXAoZGlyLCBmZWRnZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjYWxlID4gMSkge1xuICAgICAgICAvLyBwZXItYmFzZSBzY3JvbGxpbmcgbW9kZSwgdHJpZXMgdG8gcGVyZmVjdGx5IGNlbnRlci5cbiAgICAgICAgdmFyIG1pZCA9ICh0aGlzLnZpZXdTdGFydCArIHRoaXMudmlld0VuZCkvMlxuICAgICAgICB2YXIgZXJyID0gbWlkIC0gTWF0aC5yb3VuZChtaWQpO1xuICAgICAgICB2YXIgbiA9IDE7XG4gICAgICAgIGlmIChldi5zaGlmdEtleSlcbiAgICAgICAgICAgIG4gKj0gMTA7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBuID0gLW47XG4gICAgICAgICAgICBuIC09IGVycjtcbiAgICAgICAgICAgIGlmIChlcnIgPiAwKVxuICAgICAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4gLT0gZXJyO1xuICAgICAgICAgICAgaWYgKGVyciA8IDApXG4gICAgICAgICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TG9jYXRpb24obnVsbCwgdGhpcy52aWV3U3RhcnQgKyBuLCB0aGlzLnZpZXdFbmQgKyBuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vdmUoZXYuc2hpZnRLZXkgPyAxMDAqZGlyIDogMjUqZGlyKTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmxlYXAgPSBmdW5jdGlvbihkaXIsIGZlZGdlKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgcG9zPSgodGhpc0Iudmlld1N0YXJ0ICsgdGhpc0Iudmlld0VuZCArIDEpLzIpfDA7XG4gICAgaWYgKGRpciA+IDAgJiYgdGhpc0Iudmlld1N0YXJ0IDw9IDEpIHtcbiAgICAgICAgcG9zIC09IDEwMDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKGRpciA8IDAgJiYgdGhpc0Iudmlld0VuZCA+PSB0aGlzQi5jdXJyZW50U2VxTWF4KSB7XG4gICAgICAgIHBvcyArPSAxMDAwMDAwMDA7XG4gICAgfVxuXG4gICAgdmFyIHN0ID0gdGhpc0IuZ2V0U2VsZWN0ZWRUaWVyKCk7XG4gICAgaWYgKHN0IDwgMCkgcmV0dXJuO1xuICAgIHZhciB0aWVyID0gdGhpc0IudGllcnNbc3RdO1xuXG4gICAgaWYgKHRpZXIgJiYgKCh0aWVyLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5zb3VyY2VBZGFwdGVySXNDYXBhYmxlKHRpZXIuZmVhdHVyZVNvdXJjZSwgJ3F1YW50TGVhcCcpICYmIHR5cGVvZih0aWVyLnF1YW50TGVhcFRocmVzaG9sZCkgPT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgIHx8ICh0aWVyLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5zb3VyY2VBZGFwdGVySXNDYXBhYmxlKHRpZXIuZmVhdHVyZVNvdXJjZSwgJ2xlYXAnKSkpKSB7XG4gICAgICAgIHRpZXIuZmluZE5leHRGZWF0dXJlKFxuICAgICAgICAgICAgICB0aGlzQi5jaHIsXG4gICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgLWRpcixcbiAgICAgICAgICAgICAgZmVkZ2UsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKG54dCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG54dCkge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBubWluID0gbnh0Lm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbm1heCA9IG54dC5tYXg7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGZlZGdlKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5taW4+cG9zKzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tYXg9bm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tYXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5taW49bm1heFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChubWF4PHBvcy0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tYXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm1pbj1ubWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5tYXg9bm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkID0gdGhpc0Iudmlld0VuZCAtIHRoaXNCLnZpZXdTdGFydCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgaWYocGFyc2VGbG9hdCh3aWQvMikgPT0gcGFyc2VJbnQod2lkLzIpKXt3aWQtLTt9XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gKG5taW4gKyBubWF4IC0gd2lkKS8yICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3RW5kID0gbmV3U3RhcnQgKyB3aWQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MyPXBvcztcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5zZXRMb2NhdGlvbihueHQuc2VnbWVudCwgbmV3U3RhcnQsIG5ld0VuZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdubyBuZXh0IGZlYXR1cmUnKTsgLy8gRklYTUUgYmV0dGVyIHJlcG9ydGluZyB3b3VsZCBiZSBuaWNlIVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vdmUoMTAwKmRpcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnbHlwaExvb2t1cChnbHlwaHMsIHJ4LCByeSwgbWF0Y2hlcykge1xuICAgIG1hdGNoZXMgPSBtYXRjaGVzIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgZ2kgPSBnbHlwaHMubGVuZ3RoIC0gMTsgZ2kgPj0gMDsgLS1naSkge1xuICAgICAgICB2YXIgZyA9IGdseXBoc1tnaV07XG4gICAgICAgIGlmICghZy5ub3RTZWxlY3RhYmxlICYmIGcubWluKCkgPD0gcnggJiYgZy5tYXgoKSA+PSByeCkge1xuICAgICAgICAgICAgaWYgKGcubWluWSkge1xuICAgICAgICAgICAgICAgIGlmIChyeSA8IGcubWluWSgpIHx8IHJ5ID4gZy5tYXhZKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZy5mZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGcuZmVhdHVyZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGcuZ3JvdXApIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goZy5ncm91cCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoZy5nbHlwaHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2x5cGhMb29rdXAoZy5nbHlwaHMsIHJ4LCByeSwgbWF0Y2hlcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGcuZ2x5cGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2x5cGhMb29rdXAoW2cuZ2x5cGhdLCByeCwgcnksIG1hdGNoZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcztcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubmFtZUZvckNvb3JkU3lzdGVtID0gZnVuY3Rpb24oY3MpIHtcbiAgICB2YXIgcHJpbWFyeSA9IG51bGwsIHVjc2MgPSBudWxsO1xuICAgIGlmICh0aGlzLmFzc2VtYmx5TmFtZVByaW1hcnkpIHtcbiAgICAgICAgcHJpbWFyeSA9ICcnICsgY3MuYXV0aDtcbiAgICAgICAgaWYgKHR5cGVvZihjcy52ZXJzaW9uKSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICBwcmltYXJ5ICs9IGNzLnZlcnNpb247XG4gICAgfVxuICAgIGlmICh0aGlzLmFzc2VtYmx5TmFtZVVjc2MpIHtcbiAgICAgICAgdWNzYyA9IGNzLnVjc2NOYW1lO1xuICAgIH1cbiAgICBpZiAocHJpbWFyeSAhPSBudWxsICYmIHVjc2MgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHByaW1hcnkgKyAnLycgKyB1Y3NjO1xuICAgIGVsc2UgXG4gICAgICAgIHJldHVybiBwcmltYXJ5IHx8IHVjc2MgfHwgJ3Vua25vd24nO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYWtlTG9hZGVyID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHNpemUgPSBzaXplIHx8IDE2O1xuICAgIHZhciByZXRpbmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG4gICAgaWYgKHNpemUgPCAyMCkge1xuICAgICAgICByZXR1cm4gbWFrZUVsZW1lbnQoJ2ltZycsIG51bGwsIHtzcmM6IHRoaXMucmVzb2x2ZVVSTCgnJCRpbWcvc3Bpbm5lcl8nICsgKHJldGluYSA/IDE2IDogMzIpICsgJy5naWYnKSwgd2lkdGg6ICcxNicsIGhlaWdodDogJzE2J30pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlRWxlbWVudCgnaW1nJywgbnVsbCwge3NyYzogdGhpcy5yZXNvbHZlVVJMKCckJGltZy9zcGlubmVyXycgKyAocmV0aW5hID8gMjQgOiA0OCkgKyAnLmdpZicpLCB3aWR0aDogJzI0JywgaGVpZ2h0OiAnMjQnfSk7XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5jYW5GZXRjaFBsYWluSFRUUCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIXRoaXMuX3BsYWluSFRUUFByb21pc2UpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHRoaXMuZ2V0V29ya2VyKCk7XG4gICAgICAgIGlmICh3b3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYWluSFRUUFByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdENvbW1hbmQoXG4gICAgICAgICAgICAgICAgICAgIHtjb21tYW5kOiAndGV4dHhocicsXG4gICAgICAgICAgICAgICAgICAgICB1cmk6IHNlbGYuaHR0cENhbmFyeVVSTH0sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3VsdCwgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICB0aGlzLl9wbGFpbkhUVFBQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGV4dFhIUihcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5odHRwQ2FuYXJ5VVJMLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihyZXN1bHQsIGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7dGltZW91dDogMjAwMH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BsYWluSFRUUFByb21pc2U7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmdldFdvcmtlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy51c2VGZXRjaFdvcmtlcnMgfHwgIXRoaXMuZmV0Y2hXb3JrZXJzIHx8IHRoaXMuZmV0Y2hXb3JrZXJzLmxlbmd0aD09MClcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAodGhpcy5uZXh0V29ya2VyID49IHRoaXMuZmV0Y2hXb3JrZXJzLmxlbmd0aClcbiAgICAgICAgdGhpcy5uZXh0V29ya2VyID0gMDtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFdvcmtlcnNbdGhpcy5uZXh0V29ya2VyKytdO1xufVxuXG5mdW5jdGlvbiBGZXRjaFdvcmtlcihicm93c2VyLCB3b3JrZXIpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMudGFnU2VlZCA9IDA7XG4gICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLmJyb3dzZXIgPSBicm93c2VyO1xuICAgIHRoaXMud29ya2VyID0gd29ya2VyO1xuXG4gICAgdGhpcy53b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgdmFyIGNiID0gdGhpc0IuY2FsbGJhY2tzW2V2LmRhdGEudGFnXTtcbiAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICBjYihldi5kYXRhLnJlc3VsdCwgZXYuZGF0YS5lcnJvcik7XG4gICAgICAgICAgICBkZWxldGUgdGhpc0IuY2FsbGJhY2tzW2V2LmRhdGEudGFnXTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIG1ha2VGZXRjaFdvcmtlcihicm93c2VyKSB7XG4gICAgdmFyIHd1cmwgPSBicm93c2VyLnJlc29sdmVVUkwoYnJvd3Nlci53b3JrZXJQYXRoKTtcbiAgICBpZiAod3VybC5pbmRleE9mKCcvLycpID09IDApIHtcbiAgICAgICAgdmFyIHByb3RvID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAocHJvdG8gPT0gJ2h0dHBzOicpXG4gICAgICAgICAgICB3dXJsID0gJ2h0dHBzOicgKyB3dXJsO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB3dXJsID0gJ2h0dHA6JyArIHd1cmw7XG4gICAgfVxuXG4gICAgdmFyIHdzY3JpcHQgPSAnaW1wb3J0U2NyaXB0cyhcIicgKyB3dXJsICsgJz92ZXJzaW9uPScgKyBWRVJTSU9OICsgJ1wiKTsnO1xuICAgIHZhciB3YmxvYiA9IG5ldyBCbG9iKFt3c2NyaXB0XSwge3R5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0J30pO1xuXG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwod2Jsb2IpKTtcblxuICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5kYXRhLnRhZyA9PT0gJ2luaXQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1dvcmtlciBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEZldGNoV29ya2VyKGJyb3dzZXIsIHdvcmtlcikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHdvcmtlci5vbmVycm9yID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHJlamVjdChldi5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0pOyAgICBcbn1cblxuRmV0Y2hXb3JrZXIucHJvdG90eXBlLnBvc3RDb21tYW5kID0gZnVuY3Rpb24oY21kLCBjYWxsYmFjaywgdHJhbnNmZXIpIHtcbiAgICB2YXIgdGFnID0gJ3gnICsgKCsrdGhpcy50YWdTZWVkKTtcbiAgICBjbWQudGFnID0gdGFnO1xuICAgIHRoaXMuY2FsbGJhY2tzW3RhZ10gPSBjYWxsYmFjaztcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShjbWQsIHRyYW5zZmVyKTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBCcm93c2VyOiBCcm93c2VyXG4gICAgfTtcblxuICAgIC8vIFJlcXVpcmVkIGJlY2F1c2UgdGhleSBhZGQgc3R1ZmYgdG8gQnJvd3Nlci5wcm90b3R5cGVcbiAgICByZXF1aXJlKCcuL2Jyb3dzZXItdWknKTtcbiAgICByZXF1aXJlKCcuL3RyYWNrLWFkZGVyJyk7XG4gICAgcmVxdWlyZSgnLi9mZWF0dXJlLXBvcHVwJyk7XG4gICAgcmVxdWlyZSgnLi90aWVyLWFjdGlvbnMnKTtcbiAgICByZXF1aXJlKCcuL2RvbXVpJyk7XG4gICAgcmVxdWlyZSgnLi9zZWFyY2gnKTtcblxuICAgIHZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbiAgICB2YXIgVHdvQml0U2VxdWVuY2VTb3VyY2UgPSBzYS5Ud29CaXRTZXF1ZW5jZVNvdXJjZTtcbiAgICB2YXIgREFTU2VxdWVuY2VTb3VyY2UgPSBzYS5EQVNTZXF1ZW5jZVNvdXJjZTtcblxuICAgIHZhciBLbm93blNwYWNlID0gcmVxdWlyZSgnLi9rc3BhY2UnKS5Lbm93blNwYWNlO1xuXG4gICAgdmFyIERBU1JlZ2lzdHJ5ID0gcmVxdWlyZSgnLi9kYXMnKS5EQVNSZWdpc3RyeTtcbn1cblxuZnVuY3Rpb24gU291cmNlQ2FjaGUoKSB7XG4gICAgdGhpcy5zb3VyY2VzQnlVUkkgPSB7fVxufVxuXG5Tb3VyY2VDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oY29uZikge1xuICAgIHZhciBzY2IgPSB0aGlzLnNvdXJjZXNCeVVSSVtzb3VyY2VEYXRhVVJJKGNvbmYpXTtcbiAgICBpZiAoc2NiKSB7XG4gICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzY2IuY29uZmlncy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VzQXJlRXF1YWxNb2R1bG9TdHlsZShzY2IuY29uZmlnc1tzaV0sIGNvbmYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjYi5zb3VyY2VzW3NpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuU291cmNlQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKGNvbmYsIHNvdXJjZSkge1xuICAgIHZhciB1cmkgPSBzb3VyY2VEYXRhVVJJKGNvbmYpO1xuICAgIHZhciBzY2IgPSB0aGlzLnNvdXJjZXNCeVVSSVt1cmldO1xuICAgIGlmICghc2NiKSB7XG4gICAgICAgIHNjYiA9IHtjb25maWdzOiBbXSwgc291cmNlczogW119O1xuICAgICAgICB0aGlzLnNvdXJjZXNCeVVSSVt1cmldID0gc2NiO1xuICAgIH1cbiAgICBzY2IuY29uZmlncy5wdXNoKGNvbmYpO1xuICAgIHNjYi5zb3VyY2VzLnB1c2goc291cmNlKTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBjaGFpbnNldC5qczogbGlmdG92ZXIgc3VwcG9ydFxuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIERBU1NvdXJjZSA9IGRhcy5EQVNTb3VyY2U7XG4gICAgdmFyIERBU1NlZ21lbnQgPSBkYXMuREFTU2VnbWVudDtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgcHVzaG8gPSB1dGlscy5wdXNobztcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcblxuICAgIHZhciBwYXJzZUNpZ2FyID0gcmVxdWlyZSgnLi9jaWdhcicpLnBhcnNlQ2lnYXI7XG5cbiAgICB2YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbiAgICB2YXIgVVJMRmV0Y2hhYmxlID0gYmluLlVSTEZldGNoYWJsZTtcblxuICAgIHZhciBiYmkgPSByZXF1aXJlKCcuL2JpZ3dpZycpO1xuICAgIHZhciBtYWtlQndnID0gYmJpLm1ha2VCd2c7XG5cbiAgICB2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gQ2hhaW5zZXQoY29uZiwgc3JjVGFnLCBkZXN0VGFnLCBjb29yZHMpIHtcbiAgICBpZiAodHlwZW9mKGNvbmYpID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudXJpID0gY29uZjtcbiAgICAgICAgdGhpcy5zcmNUYWcgPSBzcmNUYWc7XG4gICAgICAgIHRoaXMuZGVzdFRhZyA9IGRlc3RUYWc7XG4gICAgICAgIHRoaXMuY29vcmRzID0gY29vcmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXJpID0gY29uZi51cmk7XG4gICAgICAgIHRoaXMuc3JjVGFnID0gY29uZi5zcmNUYWc7XG4gICAgICAgIHRoaXMuZGVzdFRhZyA9IGNvbmYuZGVzdFRhZztcbiAgICAgICAgdGhpcy5jb29yZHMgPSBzaGFsbG93Q29weShjb25mLmNvb3Jkcyk7XG4gICAgICAgIHRoaXMudHlwZSA9IGNvbmYudHlwZTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNvbmYuY3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgdGhpcy5jaGFpbnNCeVNyYyA9IHt9O1xuICAgIHRoaXMuY2hhaW5zQnlEZXN0ID0ge307XG4gICAgdGhpcy5wb3N0RmV0Y2hRdWV1ZXMgPSB7fTtcbiAgICB0aGlzLmZldGNoZWRUaWxlcyA9IHt9O1xuICAgIHRoaXMuZ3JhbnVsYXJpdHkgPSAxMDAwMDAwOyAgLy8gc2l6ZSBpbiBiYXNlcyBvZiB0aWxlIHRvIGZldGNoXG5cbiAgICBpZiAodGhpcy50eXBlID09ICdiaWdiZWQnKSB7XG4gICAgICAgIHRoaXMuY2hhaW5GZXRjaGVyID0gbmV3IEJCSUNoYWluRmV0Y2hlcih0aGlzLnVyaSwgdGhpcy5jcmVkZW50aWFscyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnR5cGUgPT0gJ2FsaWFzJykge1xuICAgICAgICB0aGlzLmNoYWluRmV0Y2hlciA9IG5ldyBBbGlhc0NoYWluRmV0Y2hlcihjb25mKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNoYWluRmV0Y2hlciA9IG5ldyBEQVNDaGFpbkZldGNoZXIodGhpcy51cmksIHRoaXMuc3JjVGFnLCB0aGlzLmRlc3RUYWcpO1xuICAgIH1cbn07XG5cbkNoYWluc2V0LnByb3RvdHlwZS5leHBvcnRDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmk6IHRoaXMudXJpLFxuICAgICAgICBzcmNUYWc6IHRoaXMuc3JjVGFnLFxuICAgICAgICBkZXN0VGFnOiB0aGlzLmRlc3RUYWcsXG4gICAgICAgIGNvb3JkczogdGhpcy5jb29yZHMsXG4gICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHNcbiAgICB9O1xufVxuXG5DaGFpbnNldC5wcm90b3R5cGUubWFwUG9pbnQgPSBmdW5jdGlvbihjaHIsIHBvcykge1xuICAgIHZhciBjaGFpbnMgPSB0aGlzLmNoYWluc0J5U3JjW2Nocl0gfHwgW107XG4gICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoYWlucy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFpbnNbY2ldO1xuICAgICAgICBpZiAocG9zID49IGMuc3JjTWluICYmIHBvcyA8PSBjLnNyY01heCkge1xuICAgICAgICAgICAgdmFyIGNwb3M7XG4gICAgICAgICAgICBpZiAoYy5zcmNPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgY3BvcyA9IGMuc3JjTWF4IC0gcG9zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcG9zID0gcG9zIC0gYy5zcmNNaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmxvY2tzID0gYy5ibG9ja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYmxvY2tzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gYmxvY2tzW2JpXTtcbiAgICAgICAgICAgICAgICB2YXIgYlNyYyA9IGJbMF07XG4gICAgICAgICAgICAgICAgdmFyIGJEZXN0ID0gYlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYlNpemUgPSBiWzJdO1xuICAgICAgICAgICAgICAgIGlmIChjcG9zID49IGJTcmMgJiYgY3BvcyA8PSAoYlNyYyArIGJTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXBvcyA9IGNwb3MgLSBiU3JjO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5kZXN0T3JpID09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHBvcyA9IGMuZGVzdE1heCAtIGJEZXN0IC0gYXBvcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwb3MgPSBhcG9zICsgYkRlc3QgKyBjLmRlc3RNaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtzZXE6IGMuZGVzdENociwgcG9zOiBkcG9zLCBmbGlwcGVkOiAoYy5zcmNPcmkgIT0gYy5kZXN0T3JpKX1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbkNoYWluc2V0LnByb3RvdHlwZS5tYXBTZWdtZW50ID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCkge1xuICAgIHZhciBjaGFpbnMgPSB0aGlzLmNoYWluc0J5U3JjW2Nocl0gfHwgW107XG4gICAgdmFyIG1hcHBpbmdzID0gW107XG4gICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoYWlucy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFpbnNbY2ldO1xuICAgICAgICBpZiAobWF4ID49IGMuc3JjTWluICYmIG1pbiA8PSBjLnNyY01heCkge1xuICAgICAgICAgICAgdmFyIGNtaW4sIGNtYXg7XG4gICAgICAgICAgICBpZiAoYy5zcmNPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgY21pbiA9IGMuc3JjTWF4IC0gbWF4O1xuICAgICAgICAgICAgICAgIGNtYXggPSBjLnNyY01heCAtIG1pbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY21pbiA9IG1pbiAtIGMuc3JjTWluO1xuICAgICAgICAgICAgICAgIGNtYXggPSBtYXggLSBjLnNyY01pbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBibG9ja3MgPSBjLmJsb2NrcztcbiAgICAgICAgICAgIGZvciAodmFyIGJpID0gMDsgYmkgPCBibG9ja3MubGVuZ3RoOyArK2JpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBibG9ja3NbYmldO1xuICAgICAgICAgICAgICAgIHZhciBiU3JjID0gYlswXTtcbiAgICAgICAgICAgICAgICB2YXIgYkRlc3QgPSBiWzFdO1xuICAgICAgICAgICAgICAgIHZhciBiU2l6ZSA9IGJbMl07XG4gICAgICAgICAgICAgICAgaWYgKGNtYXggPj0gYlNyYyAmJiBjbWluIDw9IChiU3JjICsgYlNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudDogYy5kZXN0Q2hyLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmxpcHBlZDogKGMuc3JjT3JpID09ICctJykgXiAoYy5kZXN0T3JpID09ICctJyl9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjLmRlc3RPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY21pbiA+PSBiU3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5tYXggPSBjLmRlc3RNYXggLSBiRGVzdCAtIGNtaW4gKyBiU3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm1heCA9IGMuZGVzdE1heCAtIGJEZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucGFydGlhbE1heCA9IGJTcmMgLSBjbWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtYXggPD0gKGJTcmMgKyBiU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm1pbiA9IGMuZGVzdE1heCAtIGJEZXN0IC0gY21heCArIGJTcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ubWluID0gYy5kZXN0TWF4IC0gYkRlc3QgLSBiU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnBhcnRpYWxNaW4gPSBjbWF4IC0gYlNyYyAtIGJTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNtaW4gPj0gYlNyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ubWluID0gYy5kZXN0TWluICsgYkRlc3QgKyBjbWluIC0gYlNyYztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5taW4gPSBjLmRlc3RNaW4gKyBiRGVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLnBhcnRpYWxNaW4gPSBiU3JjIC0gY21pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbWF4IDw9IChiU3JjICsgYlNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5tYXggPSBjLmRlc3RNaW4gKyBiRGVzdCArIGNtYXggLSBiU3JjO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtLm1heCA9IGMuZGVzdE1pbiArIGJEZXN0ICsgYlNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5wYXJ0aWFsTWF4ID0gY21heCAtIGJTcmMgLSBiU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXBwaW5ncy5wdXNoKG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwcGluZ3M7XG59XG5cbkNoYWluc2V0LnByb3RvdHlwZS51bm1hcFBvaW50ID0gZnVuY3Rpb24oY2hyLCBwb3MpIHtcbiAgICB2YXIgY2hhaW5zID0gdGhpcy5jaGFpbnNCeURlc3RbY2hyXSB8fCBbXTtcbiAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY2hhaW5zLmxlbmd0aDsgKytjaSkge1xuICAgICAgICB2YXIgYyA9IGNoYWluc1tjaV07XG4gICAgICAgIGlmIChwb3MgPj0gYy5kZXN0TWluICYmIHBvcyA8PSBjLmRlc3RNYXgpIHtcbiAgICAgICAgICAgIHZhciBjcG9zO1xuICAgICAgICAgICAgaWYgKGMuc3JjT3JpID09ICctJykge1xuICAgICAgICAgICAgICAgIGNwb3MgPSBjLmRlc3RNYXggLSBwb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNwb3MgPSBwb3MgLSBjLmRlc3RNaW47XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYmxvY2tzID0gYy5ibG9ja3M7XG4gICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYmxvY2tzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gYmxvY2tzW2JpXTtcbiAgICAgICAgICAgICAgICB2YXIgYlNyYyA9IGJbMF07XG4gICAgICAgICAgICAgICAgdmFyIGJEZXN0ID0gYlsxXTtcbiAgICAgICAgICAgICAgICB2YXIgYlNpemUgPSBiWzJdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNwb3MgPj0gYkRlc3QgJiYgY3BvcyA8PSAoYkRlc3QgKyBiU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwb3MgPSBjcG9zIC0gYkRlc3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRwb3MgPSBhcG9zICsgYlNyYyArIGMuc3JjTWluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHBvcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuZGVzdE9yaSA9PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRwb3MgPSBjLnNyY01heCAtIGJTcmMgLSBhcG9zO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHBvcyA9IGFwb3MgKyBiU3JjICsgYy5zcmNNaW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtzZXE6IGMuc3JjQ2hyLCBwb3M6IGRwb3MsIGZsaXBwZWQ6IChjLnNyY09yaSAhPSBjLmRlc3RPcmkpfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5DaGFpbnNldC5wcm90b3R5cGUuc291cmNlQmxvY2tzRm9yUmFuZ2UgPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBjYWxsYmFjaykge1xuICAgIHZhciBTVEFURV9QRU5ESU5HID0gMTtcbiAgICB2YXIgU1RBVEVfRkVUQ0hFRCA9IDI7XG5cbiAgICB2YXIgdGhpc0NTID0gdGhpcztcbiAgICB2YXIgbWluVGlsZSA9IChtaW4vdGhpcy5ncmFudWxhcml0eSl8MDtcbiAgICB2YXIgbWF4VGlsZSA9IChtYXgvdGhpcy5ncmFudWxhcml0eSl8MDtcblxuICAgIHZhciBuZWVkc05ld09yUGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBuZWVkc05ld0ZldGNoID0gZmFsc2U7XG4gICAgZm9yICh2YXIgdCA9IG1pblRpbGU7IHQgPD0gbWF4VGlsZTsgKyt0KSB7XG4gICAgICAgIHZhciB0biA9IGNociArICdfJyArIHQ7XG4gICAgICAgIGlmICh0aGlzLmZldGNoZWRUaWxlc1t0bl0gIT0gU1RBVEVfRkVUQ0hFRCkge1xuICAgICAgICAgICAgbmVlZHNOZXdPclBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmV0Y2hlZFRpbGVzW3RuXSAhPSBTVEFURV9QRU5ESU5HKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZXRjaGVkVGlsZXNbdG5dID0gU1RBVEVfUEVORElORztcbiAgICAgICAgICAgICAgICBuZWVkc05ld0ZldGNoID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc05ld09yUGVuZGluZykge1xuICAgICAgICBpZiAoIXRoaXMucG9zdEZldGNoUXVldWVzW2Nocl0pIHtcbiAgICAgICAgICAgIHRoaXMuY2hhaW5GZXRjaGVyLmZldGNoQ2hhaW5zKFxuICAgICAgICAgICAgICAgIGNociwgXG4gICAgICAgICAgICAgICAgbWluVGlsZSAqIHRoaXMuZ3JhbnVsYXJpdHksIFxuICAgICAgICAgICAgICAgIChtYXhUaWxlKzEpICogdGhpcy5ncmFudWxhcml0eSAtIDEpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGNoYWlucykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpc0NTLmNoYWluc0J5RGVzdClcbiAgICAgICAgICAgICAgICAgICAgdGhpc0NTLmNoYWluc0J5RGVzdFtjaHJdID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoYWlucy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYWluID0gY2hhaW5zW2NpXTtcblxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2JzID0gdGhpc0NTLmNoYWluc0J5U3JjW2NoYWluLnNyY0Nocl07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNicykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNDUy5jaGFpbnNCeVNyY1tjaGFpbi5zcmNDaHJdID0gW2NoYWluXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvY2kgPSAwOyBvY2kgPCBjYnMubGVuZ3RoOyArK29jaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2MgPSBjYnNbb2NpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9jLnNyY01pbiA9PSBjaGFpbi5zcmNNaW4gJiYgb2Muc3JjTWF4ID09IGNoYWluLnNyY01heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXNlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNicy5wdXNoKGNoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYmQgPSB0aGlzQ1MuY2hhaW5zQnlEZXN0W2NoYWluLmRlc3RDaHJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQ1MuY2hhaW5zQnlEZXN0W2NoYWluLmRlc3RDaHJdID0gW2NoYWluXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBvY2kgPSAwOyBvY2kgPCBjYmQubGVuZ3RoOyArK29jaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2MgPSBjYmRbb2NpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9jLmRlc3RNaW4gPT0gY2hhaW4uZGVzdE1pbiAmJiBvYy5kZXN0TWF4ID09IGNoYWluLmRlc3RNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVzZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYmQucHVzaChjaGFpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IG1pblRpbGU7IHQgPD0gbWF4VGlsZTsgKyt0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0biA9IGNociArICdfJyArIHQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNDUy5mZXRjaGVkVGlsZXNbdG5dID0gU1RBVEVfRkVUQ0hFRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNDUy5wb3N0RmV0Y2hRdWV1ZXNbY2hyXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGZxID0gdGhpc0NTLnBvc3RGZXRjaFF1ZXVlc1tjaHJdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBmcS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGZxW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc0NTLnBvc3RGZXRjaFF1ZXVlc1tjaHJdID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgICB9KTsgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2hvKHRoaXMucG9zdEZldGNoUXVldWVzLCBjaHIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gV2lsbCBlaXRoZXIgc3VjY2VlZCBpZiB0aGUgdGlsZXMgdGhhdCBhcmUgbmVlZGVkIGhhdmUgYWxyZWFkeSBiZWVuIGZldGNoZWQsXG4gICAgICAgICAgICAvLyBvciBxdWV1ZSB1cCBhIG5ldyBmZXRjaC5cblxuICAgICAgICAgICAgdGhpc0NTLnNvdXJjZUJsb2Nrc0ZvclJhbmdlKGNociwgbWluLCBtYXgsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNyY0Jsb2NrcyA9IFtdO1xuICAgICAgICB2YXIgY2hhaW5zID0gdGhpcy5jaGFpbnNCeURlc3RbY2hyXSB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoYWlucy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hhaW5zW2NpXTtcbiAgICAgICAgICAgIGlmIChtaW4gPD0gYy5kZXN0TWF4ICYmIG1heCA+PSBjLmRlc3RNaW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgY21pbiwgY21heDtcbiAgICAgICAgICAgICAgICBpZiAoYy5zcmNPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNtaW4gPSBjLmRlc3RNYXggLSBtYXg7XG4gICAgICAgICAgICAgICAgICAgIGNtYXggPSBjLmRlc3RNYXggLSBtaW47XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY21pbiA9IG1pbiAtIGMuZGVzdE1pbjtcbiAgICAgICAgICAgICAgICAgICAgY21heCA9IG1heCAtIGMuZGVzdE1pbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tzID0gYy5ibG9ja3M7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYmkgPSAwOyBiaSA8IGJsb2Nrcy5sZW5ndGg7ICsrYmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBibG9ja3NbYmldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYlNyYyA9IGJbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiRGVzdCA9IGJbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBiU2l6ZSA9IGJbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtYXggPj0gYkRlc3QgJiYgY21pbiA8PSAoYkRlc3QgKyBiU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbWluID0gTWF0aC5tYXgoY21pbiwgYkRlc3QpIC0gYkRlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW1heCA9IE1hdGgubWluKGNtYXgsIGJEZXN0ICsgYlNpemUpIC0gYkRlc3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLmRlc3RPcmkgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjQmxvY2tzLnB1c2gobmV3IERBU1NlZ21lbnQoYy5zcmNDaHIsIGMuc3JjTWF4IC0gYlNyYyAtIGFtYXgsIGMuc3JjTWF4IC0gYlNyYyAtIGFtaW4pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjQmxvY2tzLnB1c2gobmV3IERBU1NlZ21lbnQoYy5zcmNDaHIsIGMuc3JjTWluICsgYW1pbiArIGJTcmMsIGMuc3JjTWluICsgYW1heCArIGJTcmMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhzcmNCbG9ja3MpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gREFTQ2hhaW5GZXRjaGVyKHVyaSwgc3JjVGFnLCBkZXN0VGFnKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBuZXcgREFTU291cmNlKHVyaSk7XG4gICAgdGhpcy5zcmNUYWcgPSBzcmNUYWc7XG4gICAgdGhpcy5kZXN0VGFnID1kZXN0VGFnO1xufVxuXG5EQVNDaGFpbkZldGNoZXIucHJvdG90eXBlLmZldGNoQ2hhaW5zID0gZnVuY3Rpb24oY2hyLCBfbWluLCBfbWF4KSB7XG4gICAgdmFyIHRoaXNDUyA9IHRoaXM7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRoaXNDUy5zb3VyY2UuYWxpZ25tZW50cyhjaHIsIHt9LCBmdW5jdGlvbihhbGlnbnMpIHtcbiAgICAgICAgICAgIHZhciBjaGFpbnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYWkgPSAwOyBhaSA8IGFsaWducy5sZW5ndGg7ICsrYWkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxuID0gYWxpZ25zW2FpXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYWxuLmJsb2Nrcy5sZW5ndGg7ICsrYmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrID0gYWxuLmJsb2Nrc1tiaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcmNTZWcsIGRlc3RTZWc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBibG9jay5zZWdtZW50cy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWcgPSBibG9jay5zZWdtZW50c1tzaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gYWxuLm9iamVjdHNbc2VnLm9iamVjdF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmRiU291cmNlID09PSB0aGlzQ1Muc3JjVGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjU2VnID0gc2VnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvYmouZGJTb3VyY2UgPT09IHRoaXNDUy5kZXN0VGFnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFNlZyA9IHNlZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3JjU2VnICYmIGRlc3RTZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFpbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNDaHI6ICAgICBhbG4ub2JqZWN0c1tzcmNTZWcub2JqZWN0XS5hY2Nlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjTWluOiAgICAgc3JjU2VnLm1pbnwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY01heDogICAgIHNyY1NlZy5tYXh8MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNPcmk6ICAgICBzcmNTZWcuc3RyYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RDaHI6ICAgIGFsbi5vYmplY3RzW2Rlc3RTZWcub2JqZWN0XS5hY2Nlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdE1pbjogICAgZGVzdFNlZy5taW58MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0TWF4OiAgICBkZXN0U2VnLm1heHwwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RPcmk6ICAgIGRlc3RTZWcuc3RyYW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrczogICAgIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmNvcHMgPSBwYXJzZUNpZ2FyKHNyY1NlZy5jaWdhciksIGRlc3RvcHMgPSBwYXJzZUNpZ2FyKGRlc3RTZWcuY2lnYXIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjT2Zmc2V0ID0gMCwgZGVzdE9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjaSA9IDAsIGRlc3RpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzcmNpIDwgc3Jjb3BzLmxlbmd0aCAmJiBkZXN0aSA8IGRlc3RvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNyY29wc1tzcmNpXS5vcCA9PSAnTScgJiYgZGVzdG9wc1tkZXN0aV0ub3AgPT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0xlbiA9IE1hdGgubWluKHNyY29wc1tzcmNpXS5jbnQsIGRlc3RvcHNbZGVzdGldLmNudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluLmJsb2Nrcy5wdXNoKFtzcmNPZmZzZXQsIGRlc3RPZmZzZXQsIGJsb2NrTGVuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcmNvcHNbc3JjaV0uY250ID09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArK3NyY2k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNvcHNbc3JjaV0uY250IC09IGJsb2NrTGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0b3BzW2Rlc3RpXS5jbnQgPT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrZGVzdGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0b3BzW2Rlc3RpXSAtPSBibG9ja0xlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNPZmZzZXQgKz0gYmxvY2tMZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RPZmZzZXQgKz0gYmxvY2tMZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzcmNvcHNbc3JjaV0ub3AgPT0gJ0knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RPZmZzZXQgKz0gc3Jjb3BzW3NyY2krK10uY250O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVzdG9wc1tkZXN0aV0ub3AgPT0gJ0knKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY09mZnNldCArPSBkZXN0b3BzW2Rlc3RpKytdLmNudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlucy5wdXNoKGNoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoY2hhaW5zKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIEJCSUNoYWluRmV0Y2hlcih1cmksIGNyZWRlbnRpYWxzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcblxuICAgIHRoaXMuYndnID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIG1ha2VCd2cobmV3IFVSTEZldGNoYWJsZShzZWxmLnVyaSwge2NyZWRlbnRpYWxzOiBzZWxmLmNyZWRlbnRpYWxzfSksIGZ1bmN0aW9uKGJ3ZywgZXJyKSB7XG4gICAgICAgICAgICBpZiAoYndnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShid2cpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmJ3Zy50aGVuKGZ1bmN0aW9uKGJ3ZywgZXJyKSB7XG4gICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwaSh4KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHgpO1xufVxuXG5mdW5jdGlvbiBjbGVhbkNocihjKSB7XG4gICAgaWYgKGMuaW5kZXhPZignY2hyJykgPT0gMClcbiAgICAgICAgcmV0dXJuIGMuc3Vic3RyKDMpO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGJiaUZlYXR1cmVUb0NoYWluKGZlYXR1cmUpIHtcbiAgICB2YXIgY2hhaW4gPSB7XG4gICAgICAgIHNyY0NocjogICAgIGNsZWFuQ2hyKGZlYXR1cmUuc3JjQ2hyb20pLFxuICAgICAgICBzcmNNaW46ICAgICBwYXJzZUludChmZWF0dXJlLnNyY1N0YXJ0KSxcbiAgICAgICAgc3JjTWF4OiAgICAgcGFyc2VJbnQoZmVhdHVyZS5zcmNFbmQpLFxuICAgICAgICBzcmNPcmk6ICAgICBmZWF0dXJlLnNyY09yaSxcbiAgICAgICAgZGVzdENocjogICAgY2xlYW5DaHIoZmVhdHVyZS5zZWdtZW50KSxcbiAgICAgICAgZGVzdE1pbjogICAgZmVhdHVyZS5taW4gLSAxLCAgICAgLy8gQ29udmVydCBiYWNrIGZyb20gYmlnYmVkIHBhcnNlclxuICAgICAgICBkZXN0TWF4OiAgICBmZWF0dXJlLm1heCxcbiAgICAgICAgZGVzdE9yaTogICAgZmVhdHVyZS5vcmksXG4gICAgICAgIGJsb2NrczogICAgIFtdXG4gICAgfTtcbiAgICB2YXIgc3JjU3RhcnRzID0gZmVhdHVyZS5zcmNTdGFydHMuc3BsaXQoJywnKS5tYXAocGkpO1xuICAgIHZhciBkZXN0U3RhcnRzID0gZmVhdHVyZS5kZXN0U3RhcnRzLnNwbGl0KCcsJykubWFwKHBpKTtcbiAgICB2YXIgYmxvY2tMZW5ndGhzID0gZmVhdHVyZS5ibG9ja0xlbnMuc3BsaXQoJywnKS5tYXAocGkpO1xuICAgIGZvciAodmFyIGJpID0gMDsgYmkgPCBzcmNTdGFydHMubGVuZ3RoOyArK2JpKSB7XG4gICAgICAgIGNoYWluLmJsb2Nrcy5wdXNoKFtzcmNTdGFydHNbYmldLCBkZXN0U3RhcnRzW2JpXSwgYmxvY2tMZW5ndGhzW2JpXV0pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFpbjtcbn1cblxuQkJJQ2hhaW5GZXRjaGVyLnByb3RvdHlwZS5mZXRjaENoYWlucyA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gdGhpcy5id2cudGhlbihmdW5jdGlvbihid2csIGVycikge1xuICAgICAgICBpZiAoIWJ3ZylcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiTm8gQldHXCIpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGJ3Zy5nZXRVbnpvb21lZFZpZXcoKS5yZWFkV2lnRGF0YShjaHIsIG1pbiwgbWF4LCBmdW5jdGlvbihmZWF0cykge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZmVhdHMubWFwKGJiaUZlYXR1cmVUb0NoYWluKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5mdW5jdGlvbiBBbGlhc0NoYWluRmV0Y2hlcihjb25mKSB7XG4gICAgdGhpcy5jb25mID0gY29uZjtcbiAgICB0aGlzLmZvcndhcmRBbGlhc2VzID0ge307XG4gICAgdmFyIHNhID0gY29uZi5zZXF1ZW5jZUFsaWFzZXMgfHwgW107XG4gICAgZm9yICh2YXIgYWkgPSAwOyBhaSA8IHNhLmxlbmd0aDsgKythaSkge1xuICAgICAgICB2YXIgYWwgPSBzYVthaV07XG4gICAgICAgIGlmIChhbC5sZW5ndGggPCAyKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGZhID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWwubGVuZ3RoIC0gMTsgKytpKVxuICAgICAgICAgICAgZmEucHVzaChhbFtpXSk7XG4gICAgICAgIHRoaXMuZm9yd2FyZEFsaWFzZXNbYWxbYWwubGVuZ3RoIC0gMV1dID0gZmE7XG4gICAgfVxufVxuXG5BbGlhc0NoYWluRmV0Y2hlci5wcm90b3R5cGUuZmV0Y2hDaGFpbnMgPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4KSB7XG4gICAgdmFyIHJlc3AgPSBbXTtcbiAgICB2YXIgZmEgPSB0aGlzLmZvcndhcmRBbGlhc2VzW2Nocl0gfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmYS5sZW5ndGg7ICsraSkge1xuICAgICAgICByZXNwLnB1c2goXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3JjQ2hyOiAgICAgICAgIGZhW2ldLFxuICAgICAgICAgICAgICAgIHNyY01pbjogICAgICAgICAxLFxuICAgICAgICAgICAgICAgIHNyY01heDogICAgICAgICAxMDAwMDAwMDAwLFxuICAgICAgICAgICAgICAgIHNyY09yaTogICAgICAgICAnKycsXG4gICAgICAgICAgICAgICAgZGVzdENocjogICAgICAgIGNocixcbiAgICAgICAgICAgICAgICBkZXN0TWluOiAgICAgICAgMSxcbiAgICAgICAgICAgICAgICBkZXN0TWF4OiAgICAgICAgMTAwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBkZXN0T3JpOiAgICAgICAgJysnLFxuICAgICAgICAgICAgICAgIGJsb2NrczogW1sxLCAxLCAxMDAwMDAwMDAwXV1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcCk7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgQ2hhaW5zZXQ6IENoYWluc2V0XG4gICAgfTtcbn0iLCJcbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIGNoYWluc2V0LmpzOiBsaWZ0b3ZlciBzdXBwb3J0XG4vL1xuXG52YXIgQ0lHQVJfUkVHRVhQID0gbmV3IFJlZ0V4cCgnKFswLTldKikoW01JRFNdKScsICdnJyk7XG5cbmZ1bmN0aW9uIHBhcnNlQ2lnYXIoY2lnYXIpXG57XG4gICAgdmFyIGNpZ29wcyA9IFtdO1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gQ0lHQVJfUkVHRVhQLmV4ZWMoY2lnYXIpKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBjb3VudCA9IG1hdGNoWzFdO1xuICAgICAgICBpZiAoY291bnQubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGNvdW50ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjaWdvcHMucHVzaCh7Y250OiBjb3VudHwwLCBvcDogbWF0Y2hbMl19KTtcbiAgICB9XG4gICAgcmV0dXJuIGNpZ29wcztcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBwYXJzZUNpZ2FyOiBwYXJzZUNpZ2FyXG4gICAgfTtcbn0iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEwXG4vL1xuLy8gY29sb3IuanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBEQ29sb3VyKHJlZCwgZ3JlZW4sIGJsdWUsIG5hbWUpIHtcbiAgICB0aGlzLnJlZCA9IHJlZHwwO1xuICAgIHRoaXMuZ3JlZW4gPSBncmVlbnwwO1xuICAgIHRoaXMuYmx1ZSA9IGJsdWV8MDtcbiAgICBpZiAobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbn1cblxuRENvbG91ci5wcm90b3R5cGUudG9TdmdTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMubmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBcInJnYihcIiArIHRoaXMucmVkICsgXCIsXCIgKyB0aGlzLmdyZWVuICsgXCIsXCIgKyB0aGlzLmJsdWUgKyBcIilcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5uYW1lO1xufVxuXG5mdW5jdGlvbiBoZXgyKHgpIHtcbiAgICB2YXIgeSA9ICcwMCcgKyB4LnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4geS5zdWJzdHJpbmcoeS5sZW5ndGggLSAyKTtcbn1cblxuRENvbG91ci5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJyMnICsgaGV4Mih0aGlzLnJlZCkgKyBoZXgyKHRoaXMuZ3JlZW4pICsgaGV4Mih0aGlzLmJsdWUpO1xufVxuXG52YXIgcGFsZXR0ZSA9IHtcbiAgICByZWQ6IG5ldyBEQ29sb3VyKDI1NSwgMCwgMCwgJ3JlZCcpLFxuICAgIGdyZWVuOiBuZXcgRENvbG91cigwLCAyNTUsIDAsICdncmVlbicpLFxuICAgIGJsdWU6IG5ldyBEQ29sb3VyKDAsIDAsIDI1NSwgJ2JsdWUnKSxcbiAgICB5ZWxsb3c6IG5ldyBEQ29sb3VyKDI1NSwgMjU1LCAwLCAneWVsbG93JyksXG4gICAgd2hpdGU6IG5ldyBEQ29sb3VyKDI1NSwgMjU1LCAyNTUsICd3aGl0ZScpLFxuICAgIGJsYWNrOiBuZXcgRENvbG91cigwLCAwLCAwLCAnYmxhY2snKSxcbiAgICBncmF5OiBuZXcgRENvbG91cigxODAsIDE4MCwgMTgwLCAnZ3JheScpLFxuICAgIGdyZXk6IG5ldyBEQ29sb3VyKDE4MCwgMTgwLCAxODAsICdncmV5JyksXG4gICAgbGlnaHRza3libHVlOiBuZXcgRENvbG91cigxMzUsIDIwNiwgMjUwLCAnbGlnaHRza3libHVlJyksXG4gICAgbGlnaHRzYWxtb246IG5ldyBEQ29sb3VyKDI1NSwgMTYwLCAxMjIsICdsaWdodHNhbG1vbicpLFxuICAgIGhvdHBpbms6IG5ldyBEQ29sb3VyKDI1NSwgMTA1LCAxODAsICdob3RwaW5rJylcbn07XG5cbnZhciBDT0xPUl9SRSA9IG5ldyBSZWdFeHAoJ14jKFswLTlBLUZhLWZdezJ9KShbMC05QS1GYS1mXXsyfSkoWzAtOUEtRmEtZl17Mn0pJCcpO1xudmFyIENTU19DT0xPUl9SRSA9IC9yZ2JcXCgoWzAtOV0rKSwoWzAtOV0rKSwoWzAtOV0rKVxcKS9cblxuZnVuY3Rpb24gZGFzQ29sb3VyRm9yTmFtZShuYW1lKSB7XG4gICAgdmFyIGMgPSBwYWxldHRlW25hbWVdO1xuICAgIGlmICghYykge1xuICAgICAgICB2YXIgbWF0Y2ggPSBDT0xPUl9SRS5leGVjKG5hbWUpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGMgPSBuZXcgRENvbG91cigoJzB4JyArIG1hdGNoWzFdKXwwLCAoJzB4JyArIG1hdGNoWzJdKXwwLCAoJzB4JyArIG1hdGNoWzNdKXwwLCBuYW1lKTtcbiAgICAgICAgICAgIHBhbGV0dGVbbmFtZV0gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgIFx0ICAgIG1hdGNoID0gQ1NTX0NPTE9SX1JFLmV4ZWMobmFtZSk7XG4gICAgXHQgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIFx0XHRjID0gbmV3IERDb2xvdXIobWF0Y2hbMV18MCwgbWF0Y2hbMl18MCwgbWF0Y2hbM118MCwgbmFtZSk7XG4gICAgICAgIFx0XHRwYWxldHRlW25hbWVdID0gYztcblx0ICAgICAgIH0gZWxzZSB7XG5cdFx0ICAgICAgY29uc29sZS5sb2coXCJjb3VsZG4ndCBoYW5kbGUgY29sb3I6IFwiICsgbmFtZSk7XG5cdFx0ICAgICAgYyA9IHBhbGV0dGUuYmxhY2s7XG5cdFx0ICAgICAgcGFsZXR0ZVtuYW1lXSA9IGM7XG5cdCAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIG1ha2VDb2xvdXJTdGVwcyhzdGVwcywgc3RvcHMsIGNvbG91cnMpIHtcbiAgICB2YXIgZGNvbG91cnMgPSBbXTtcbiAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY29sb3Vycy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgZGNvbG91cnMucHVzaChkYXNDb2xvdXJGb3JOYW1lKGNvbG91cnNbY2ldKSk7XG4gICAgfVxuXG4gICAgdmFyIGdyYWQgPSBbXTtcbiAgU1RFUF9MT09QOlxuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzdGVwczsgKytzaSkge1xuICAgICAgICB2YXIgcnMgPSAoMS4wICogc2kpIC8gKHN0ZXBzLTEpO1xuICAgICAgICB2YXIgc2NvcmUgPSBzdG9wc1swXSArIChzdG9wc1tzdG9wcy5sZW5ndGggLTFdIC0gc3RvcHNbMF0pICogcnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcHMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmUgPj0gc3RvcHNbaV0gJiYgc2NvcmUgPD0gc3RvcHNbaSsxXSkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFjID0gKHNjb3JlIC0gc3RvcHNbaV0pIC8gKHN0b3BzW2krMV0gLSBzdG9wc1tpXSk7XG4gICAgICAgICAgICAgICAgdmFyIGNhID0gZGNvbG91cnNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGNiID0gZGNvbG91cnNbaSsxXTtcblxuICAgICAgICAgICAgICAgIHZhciBmaWxsID0gbmV3IERDb2xvdXIoXG4gICAgICAgICAgICAgICAgICAgICgoY2EucmVkICogKDEuMCAtIGZyYWMpKSArIChjYi5yZWQgKiBmcmFjKSl8MCxcbiAgICAgICAgICAgICAgICAgICAgKChjYS5ncmVlbiAqICgxLjAgLSBmcmFjKSkgKyAoY2IuZ3JlZW4gKiBmcmFjKSl8MCxcbiAgICAgICAgICAgICAgICAgICAgKChjYS5ibHVlICogKDEuMCAtIGZyYWMpKSArIChjYi5ibHVlICogZnJhYykpfDBcbiAgICAgICAgICAgICAgICApLnRvU3ZnU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgZ3JhZC5wdXNoKGZpbGwpO1xuXG4gICAgICAgICAgICAgICAgY29udGludWUgU1RFUF9MT09QO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93ICdCYWQgc3RlcCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYWQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VHcmFkaWVudChzdGVwcywgY29sb3IxLCBjb2xvcjIsIGNvbG9yMykge1xuICAgIGlmIChjb2xvcjMpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDb2xvdXJTdGVwcyhzdGVwcywgWzAsIDAuNSwgMV0sIFtjb2xvcjEsIGNvbG9yMiwgY29sb3IzXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1ha2VDb2xvdXJTdGVwcyhzdGVwcywgWzAsIDFdLCBbY29sb3IxLCBjb2xvcjJdKTtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbWFrZUNvbG91clN0ZXBzOiBtYWtlQ29sb3VyU3RlcHMsXG4gICAgICAgIG1ha2VHcmFkaWVudDogbWFrZUdyYWRpZW50LFxuICAgICAgICBkYXNDb2xvdXJGb3JOYW1lOiBkYXNDb2xvdXJGb3JOYW1lXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBkYXMuanM6IHF1ZXJpZXMgYW5kIGxvdy1sZXZlbCBkYXRhIG1vZGVsLlxuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xuICAgIHZhciBwdXNobyA9IHV0aWxzLnB1c2hvO1xuXG4gICAgdmFyIGNvbG9yID0gcmVxdWlyZSgnLi9jb2xvcicpO1xuICAgIHZhciBtYWtlQ29sb3VyU3RlcHMgPSBjb2xvci5tYWtlQ29sb3VyU3RlcHM7XG59XG5cbnZhciBkYXNMaWJFcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJNc2cpIHtcbiAgICBhbGVydChlcnJNc2cpO1xufVxudmFyIGRhc0xpYlJlcXVlc3RRdWV1ZSA9IG5ldyBBcnJheSgpO1xuXG5mdW5jdGlvbiBEQVNTZWdtZW50KG5hbWUsIHN0YXJ0LCBlbmQsIGRlc2NyaXB0aW9uKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xufVxuREFTU2VnbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lICsgJzonICsgdGhpcy5zdGFydCArICcuLicgKyB0aGlzLmVuZDtcbn07XG5EQVNTZWdtZW50LnByb3RvdHlwZS5pc0JvdW5kZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydCAmJiB0aGlzLmVuZDtcbn1cbkRBU1NlZ21lbnQucHJvdG90eXBlLnRvREFTUXVlcnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcSA9ICdzZWdtZW50PScgKyB0aGlzLm5hbWU7XG4gICAgaWYgKHRoaXMuc3RhcnQgJiYgdGhpcy5lbmQpIHtcbiAgICAgICAgcSArPSAoJzonICsgdGhpcy5zdGFydCArICcsJyArIHRoaXMuZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHE7XG59XG5cblxuZnVuY3Rpb24gREFTU291cmNlKGExLCBhMikge1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgYTEgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy51cmkgPSBhMTtcbiAgICAgICAgb3B0aW9ucyA9IGEyIHx8IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBhMSB8fCB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgayBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Yob3B0aW9uc1trXSkgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpc1trXSA9IG9wdGlvbnNba107XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGlmICghdGhpcy5jb29yZHMpIHtcbiAgICAgICAgdGhpcy5jb29yZHMgPSBbXTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLmRhc0Jhc2VVUkkgPSB0aGlzLnVyaTtcbiAgICBpZiAodGhpcy5kYXNCYXNlVVJJICYmIHRoaXMuZGFzQmFzZVVSSS5zdWJzdHIodGhpcy51cmkubGVuZ3RoIC0gMSkgIT0gJy8nKSB7XG4gICAgICAgIHRoaXMuZGFzQmFzZVVSSSA9IHRoaXMuZGFzQmFzZVVSSSArICcvJztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIERBU0Nvb3JkcygpIHtcbn1cblxuZnVuY3Rpb24gY29vcmRzTWF0Y2goYzEsIGMyKSB7XG4gICAgcmV0dXJuIGMxLnRheG9uID09IGMyLnRheG9uICYmIGMxLmF1dGggPT0gYzIuYXV0aCAmJiBjMS52ZXJzaW9uID09IGMyLnZlcnNpb247XG59XG5cbi8vXG4vLyBEQVMgMS42IGVudHJ5X3BvaW50cyBjb21tYW5kXG4vL1xuXG5EQVNTb3VyY2UucHJvdG90eXBlLmVudHJ5UG9pbnRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgZGFzVVJJID0gdGhpcy5kYXNCYXNlVVJJICsgJ2VudHJ5X3BvaW50cyc7XG4gICAgdGhpcy5kb0Nyb3NzRG9tYWluUmVxdWVzdChkYXNVUkksIGZ1bmN0aW9uKHJlc3BvbnNlWE1MKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlWE1MKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFtdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBlbnRyeVBvaW50cyA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBzZWdzID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1NFR01FTlQnKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdJZCA9IHNlZy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnU2l6ZSA9IHNlZy5nZXRBdHRyaWJ1dGUoJ3NpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ01pbiwgc2VnTWF4O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTWluID0gMTsgc2VnTWF4ID0gc2VnU2l6ZXwwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnTWluID0gc2VnLmdldEF0dHJpYnV0ZSgnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdNaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdNaW4gfD0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01heCA9IHNlZy5nZXRBdHRyaWJ1dGUoJ3N0b3AnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWdNYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdNYXggfD0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnRGVzYyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWcuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VnRGVzYyA9IHNlZy5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbnRyeVBvaW50cy5wdXNoKG5ldyBEQVNTZWdtZW50KHNlZ0lkLCBzZWdNaW4sIHNlZ01heCwgc2VnRGVzYykpO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgXG4gICAgICAgICAgICAgICBjYWxsYmFjayhlbnRyeVBvaW50cyk7XG4gICAgfSk7ICAgICAgICAgXG59XG5cbi8vXG4vLyBEQVMgMS42IHNlcXVlbmNlIGNvbW1hbmRcbi8vIERvIHdlIG5lZWQgYW4gb3B0aW9uIHRvIGZhbGwgYmFjayB0byB0aGUgZG5hIGNvbW1hbmQ/XG4vL1xuXG5mdW5jdGlvbiBEQVNTZXF1ZW5jZShuYW1lLCBzdGFydCwgZW5kLCBhbHBoYSwgc2VxKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5hbHBoYWJldCA9IGFscGhhO1xuICAgIHRoaXMuc2VxID0gc2VxO1xufVxuXG5EQVNTb3VyY2UucHJvdG90eXBlLnNlcXVlbmNlID0gZnVuY3Rpb24oc2VnbWVudCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGFzVVJJID0gdGhpcy5kYXNCYXNlVVJJICsgJ3NlcXVlbmNlPycgKyBzZWdtZW50LnRvREFTUXVlcnkoKTtcbiAgICB0aGlzLmRvQ3Jvc3NEb21haW5SZXF1ZXN0KGRhc1VSSSwgZnVuY3Rpb24ocmVzcG9uc2VYTUwpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZVhNTCkge1xuICAgICAgICAgICAgY2FsbGJhY2soW10pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzZXFzID0gbmV3IEFycmF5KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHNlZ3MgPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnU0VRVUVOQ0UnKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdJZCA9IHNlZy5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWdNaW4gPSBzZWcuZ2V0QXR0cmlidXRlKCdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnTWF4ID0gc2VnLmdldEF0dHJpYnV0ZSgnc3RvcCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnQWxwaGEgPSAnRE5BJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ1NlcSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWcuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd1NlcSA9IHNlZy5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ1NlcSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGFjZSA9IHJhd1NlcS5pbmRleE9mKCdcXG4nLCBpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGFjZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ1NlcSArPSByYXdTZXEuc3Vic3RyaW5nKGlkeCwgc3BhY2UpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IHNwYWNlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdTZXEgKz0gcmF3U2VxLnN1YnN0cmluZyhpZHgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXFzLnB1c2gobmV3IERBU1NlcXVlbmNlKHNlZ0lkLCBzZWdNaW4sIHNlZ01heCwgc2VnQWxwaGEsIHNlZ1NlcSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzZXFzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vL1xuLy8gREFTIDEuNiBmZWF0dXJlcyBjb21tYW5kXG4vL1xuXG5mdW5jdGlvbiBEQVNGZWF0dXJlKCkge1xufVxuXG5mdW5jdGlvbiBEQVNHcm91cChpZCkge1xuICAgIGlmIChpZClcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xufVxuXG5mdW5jdGlvbiBEQVNMaW5rKGRlc2MsIHVyaSkge1xuICAgIHRoaXMuZGVzYyA9IGRlc2M7XG4gICAgdGhpcy51cmkgPSB1cmk7XG59XG5cbkRBU1NvdXJjZS5wcm90b3R5cGUuZmVhdHVyZXMgPSBmdW5jdGlvbihzZWdtZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG5cbiAgICB2YXIgZGFzVVJJO1xuICAgIGlmICh0aGlzLmZlYXR1cmVzX3VyaSkge1xuICAgICAgICBkYXNVUkkgPSB0aGlzLmZlYXR1cmVzX3VyaTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmlsdGVycyA9IFtdO1xuXG4gICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICBmaWx0ZXJzLnB1c2goc2VnbWVudC50b0RBU1F1ZXJ5KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgICAgIHZhciBnID0gb3B0aW9ucy5ncm91cDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCgnZ3JvdXBfaWQ9JyArIGcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBnaSA9IDA7IGdpIDwgZy5sZW5ndGg7ICsrZ2kpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVycy5wdXNoKCdncm91cF9pZD0nICsgZ1tnaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmFkamFjZW50KSB7XG4gICAgICAgICAgICB2YXIgYWRqID0gb3B0aW9ucy5hZGphY2VudDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWRqID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgYWRqID0gW2Fkal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBhaSA9IDA7IGFpIDwgYWRqLmxlbmd0aDsgKythaSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCgnYWRqYWNlbnQ9JyArIGFkalthaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudHlwZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJzLnB1c2goJ3R5cGU9JyArIG9wdGlvbnMudHlwZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCBvcHRpb25zLnR5cGUubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnMucHVzaCgndHlwZT0nICsgb3B0aW9ucy50eXBlW3RpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAob3B0aW9ucy5tYXhiaW5zKSB7XG4gICAgICAgICAgICBmaWx0ZXJzLnB1c2goJ21heGJpbnM9JyArIG9wdGlvbnMubWF4Ymlucyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRhc1VSSSA9IHRoaXMuZGFzQmFzZVVSSSArICdmZWF0dXJlcz8nICsgZmlsdGVycy5qb2luKCc7Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhbXSwgJ05vIGZpbHRlcnMgc3BlY2lmaWVkJyk7XG4gICAgICAgIH1cbiAgICB9IFxuICAgXG5cbiAgICB0aGlzLmRvQ3Jvc3NEb21haW5SZXF1ZXN0KGRhc1VSSSwgZnVuY3Rpb24ocmVzcG9uc2VYTUwsIHJlcSkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlWE1MKSB7XG4gICAgICAgICAgICB2YXIgbXNnO1xuICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMCkge1xuICAgICAgICAgICAgICAgIG1zZyA9ICdzZXJ2ZXIgbWF5IG5vdCBzdXBwb3J0IENPUlMnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtc2cgPSAnc3RhdHVzPScgKyByZXEuc3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soW10sICdGYWlsZWQgcmVxdWVzdDogJyArIG1zZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbi8qICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgdmFyIGNhcHMgPSByZXEuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtREFTLUNhcGFiaWx0aWVzJyk7XG4gICAgICAgICAgICBpZiAoY2Fwcykge1xuICAgICAgICAgICAgICAgIGFsZXJ0KGNhcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9ICovXG5cbiAgICAgICAgdmFyIGZlYXR1cmVzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHZhciBzZWdtZW50TWFwID0ge307XG5cbiAgICAgICAgdmFyIHNlZ3MgPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnU0VHTUVOVCcpO1xuICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc2Vncy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50WE1MID0gc2Vnc1tzaV07XG4gICAgICAgICAgICB2YXIgc2VnbWVudElEID0gc2VnbWVudFhNTC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICBzZWdtZW50TWFwW3NlZ21lbnRJRF0gPSB7XG4gICAgICAgICAgICAgICAgbWluOiBzZWdtZW50WE1MLmdldEF0dHJpYnV0ZSgnc3RhcnQnKSxcbiAgICAgICAgICAgICAgICBtYXg6IHNlZ21lbnRYTUwuZ2V0QXR0cmlidXRlKCdzdG9wJylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBmZWF0dXJlWE1McyA9IHNlZ21lbnRYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0ZFQVRVUkUnKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZVhNTHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVYTUxzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBkYXNGZWF0dXJlID0gbmV3IERBU0ZlYXR1cmUoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLnNlZ21lbnQgPSBzZWdtZW50SUQ7XG4gICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5pZCA9IGZlYXR1cmUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUubGFiZWwgPSBmZWF0dXJlLmdldEF0dHJpYnV0ZSgnbGFiZWwnKTtcblxuXG4vKlxuICAgICAgICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gZmVhdHVyZS5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2hpbGROb2Rlcy5sZW5ndGg7ICsrYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY24gPSBjaGlsZE5vZGVzW2NdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY24ubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBjbi50YWdOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy92YXIgdmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgKGNuLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgdmFsID0gY24uZmlyc3RDaGlsZC5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmVba2V5XSA9ICd4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gKi9cblxuXG4gICAgICAgICAgICAgICAgdmFyIHNwb3MgPSBlbGVtZW50VmFsdWUoZmVhdHVyZSwgXCJTVEFSVFwiKTtcbiAgICAgICAgICAgICAgICB2YXIgZXBvcyA9IGVsZW1lbnRWYWx1ZShmZWF0dXJlLCBcIkVORFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoKHNwb3N8MCkgPiAoZXBvc3wwKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLm1pbiA9IGVwb3N8MDtcbiAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5tYXggPSBzcG9zfDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5taW4gPSBzcG9zfDA7XG4gICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUubWF4ID0gZXBvc3wwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZWMgPSBmZWF0dXJlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdUWVBFJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZWMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlID0gdGVjWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLnR5cGUgPSB0ZS5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUudHlwZUlkID0gdGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS50eXBlQ3YgPSB0ZS5nZXRBdHRyaWJ1dGUoJ2N2SWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLnR5cGUgPSBlbGVtZW50VmFsdWUoZmVhdHVyZSwgXCJUWVBFXCIpO1xuICAgICAgICAgICAgICAgIGlmICghZGFzRmVhdHVyZS50eXBlICYmIGRhc0ZlYXR1cmUudHlwZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUudHlwZSA9IGRhc0ZlYXR1cmUudHlwZUlkOyAvLyBGSVhNRT9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5tZXRob2QgPSBlbGVtZW50VmFsdWUoZmVhdHVyZSwgXCJNRVRIT0RcIik7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpID0gZWxlbWVudFZhbHVlKGZlYXR1cmUsIFwiT1JJRU5UQVRJT05cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb3JpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmkgPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5vcmllbnRhdGlvbiA9IG9yaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5zY29yZSA9IGVsZW1lbnRWYWx1ZShmZWF0dXJlLCBcIlNDT1JFXCIpO1xuICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUubGlua3MgPSBkYXNMaW5rc09mKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUubm90ZXMgPSBkYXNOb3Rlc09mKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBncm91cHMgPSBmZWF0dXJlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiR1JPVVBcIik7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZ2kgID0gMDsgZ2kgPCBncm91cHMubGVuZ3RoOyArK2dpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91cFhNTCA9IGdyb3Vwc1tnaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXNHcm91cCA9IG5ldyBEQVNHcm91cCgpO1xuICAgICAgICAgICAgICAgICAgICBkYXNHcm91cC50eXBlID0gZ3JvdXBYTUwuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgIGRhc0dyb3VwLmlkID0gZ3JvdXBYTUwuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICBkYXNHcm91cC5saW5rcyA9IGRhc0xpbmtzT2YoZ3JvdXBYTUwpO1xuICAgICAgICAgICAgICAgICAgICBkYXNHcm91cC5ub3RlcyA9IGRhc05vdGVzT2YoZ3JvdXBYTUwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhc0ZlYXR1cmUuZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLmdyb3VwcyA9IG5ldyBBcnJheShkYXNHcm91cCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLmdyb3Vwcy5wdXNoKGRhc0dyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1hZ2ljIG5vdGVzLiAgQ2hlY2sgd2l0aCBUQUQgYmVmb3JlIGNoYW5naW5nIHRoaXMuXG4gICAgICAgICAgICAgICAgaWYgKGRhc0ZlYXR1cmUubm90ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmkgPSAwOyBuaSA8IGRhc0ZlYXR1cmUubm90ZXMubGVuZ3RoOyArK25pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IGRhc0ZlYXR1cmUubm90ZXNbbmldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4uaW5kZXhPZignR2VuZW5hbWU9JykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBnZyA9IG5ldyBEQVNHcm91cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdnLnR5cGU9J2dlbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdnLmlkID0gbi5zdWJzdHJpbmcoOSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXNGZWF0dXJlLmdyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLmdyb3VwcyA9IG5ldyBBcnJheShnZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFzRmVhdHVyZS5ncm91cHMucHVzaChnZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlYyA9IGZlYXR1cmUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1BBUlQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlYy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBpID0gMDsgcGkgPCBwZWMubGVuZ3RoOyArK3BpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChwZWNbcGldLmdldEF0dHJpYnV0ZSgnaWQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXNGZWF0dXJlLnBhcnRzID0gcGFydHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVjID0gZmVhdHVyZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnUEFSRU5UJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZWMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHBpID0gMDsgcGkgPCBwZWMubGVuZ3RoOyArK3BpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50cy5wdXNoKHBlY1twaV0uZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhc0ZlYXR1cmUucGFyZW50cyA9IHBhcmVudHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZmVhdHVyZXMucHVzaChkYXNGZWF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICBjYWxsYmFjayhmZWF0dXJlcywgdW5kZWZpbmVkLCBzZWdtZW50TWFwKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soW10sIGVycik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIERBU0FsaWdubWVudCh0eXBlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLm9iamVjdHMgPSB7fTtcbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xufVxuXG5EQVNTb3VyY2UucHJvdG90eXBlLmFsaWdubWVudHMgPSBmdW5jdGlvbihzZWdtZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXNVUkkgPSB0aGlzLmRhc0Jhc2VVUkkgKyAnYWxpZ25tZW50P3F1ZXJ5PScgKyBzZWdtZW50O1xuICAgIHRoaXMuZG9Dcm9zc0RvbWFpblJlcXVlc3QoZGFzVVJJLCBmdW5jdGlvbihyZXNwb25zZVhNTCkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlWE1MKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhbXSwgJ0ZhaWxlZCByZXF1ZXN0ICcgKyBkYXNVUkkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFsaWdubWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGFsaVhNTHMgPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYWxpZ25tZW50Jyk7XG4gICAgICAgIGZvciAodmFyIGFpID0gMDsgYWkgPCBhbGlYTUxzLmxlbmd0aDsgKythaSkge1xuICAgICAgICAgICAgdmFyIGFsaVhNTCA9IGFsaVhNTHNbYWldO1xuICAgICAgICAgICAgdmFyIGFsaSA9IG5ldyBEQVNBbGlnbm1lbnQoYWxpWE1MLmdldEF0dHJpYnV0ZSgnYWxpZ25UeXBlJykpO1xuICAgICAgICAgICAgdmFyIG9ialhNTHMgPSBhbGlYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2FsaWduT2JqZWN0Jyk7XG4gICAgICAgICAgICBmb3IgKHZhciBvaSA9IDA7IG9pIDwgb2JqWE1Mcy5sZW5ndGg7ICsrb2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqWE1MID0gb2JqWE1Mc1tvaV07XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6ICAgICAgICAgIG9ialhNTC5nZXRBdHRyaWJ1dGUoJ2ludE9iamVjdElkJyksXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc2lvbjogICBvYmpYTUwuZ2V0QXR0cmlidXRlKCdkYkFjY2Vzc2lvbklkJyksXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICAgICBvYmpYTUwuZ2V0QXR0cmlidXRlKCdvYmplY3RWZXJzaW9uJyksXG4gICAgICAgICAgICAgICAgICAgIGRiU291cmNlOiAgICBvYmpYTUwuZ2V0QXR0cmlidXRlKCdkYlNvdXJjZScpLFxuICAgICAgICAgICAgICAgICAgICBkYlZlcnNpb246ICAgb2JqWE1MLmdldEF0dHJpYnV0ZSgnZGJWZXJzaW9uJylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFsaS5vYmplY3RzW29iai5pZF0gPSBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBibG9ja1hNTHMgPSBhbGlYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jsb2NrJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYmxvY2tYTUxzLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgICAgICAgIHZhciBibG9ja1hNTCA9IGJsb2NrWE1Mc1tiaV07XG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcjogICAgICBibG9ja1hNTC5nZXRBdHRyaWJ1dGUoJ2Jsb2NrT3JkZXInKSxcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudHM6ICAgW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBzZWdYTUxzID0gYmxvY2tYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NlZ21lbnQnKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc2VnWE1Mcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ1hNTCA9IHNlZ1hNTHNbc2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VnID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiAgICAgIHNlZ1hNTC5nZXRBdHRyaWJ1dGUoJ2ludE9iamVjdElkJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW46ICAgICAgICAgc2VnWE1MLmdldEF0dHJpYnV0ZSgnc3RhcnQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDogICAgICAgICBzZWdYTUwuZ2V0QXR0cmlidXRlKCdlbmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmFuZDogICAgICBzZWdYTUwuZ2V0QXR0cmlidXRlKCdzdHJhbmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpZ2FyOiAgICAgICBlbGVtZW50VmFsdWUoc2VnWE1MLCAnY2lnYXInKVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBibG9jay5zZWdtZW50cy5wdXNoKHNlZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFsaS5ibG9ja3MucHVzaChibG9jayk7XG4gICAgICAgICAgICB9ICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGFsaWdubWVudHMucHVzaChhbGkpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGFsaWdubWVudHMpO1xuICAgIH0pO1xufVxuXG5cbmZ1bmN0aW9uIERBU1N0eWxlc2hlZXQoKSB7XG4vKlxuICAgIHRoaXMuaGlnaFpvb21TdHlsZXMgPSBuZXcgT2JqZWN0KCk7XG4gICAgdGhpcy5tZWRpdW1ab29tU3R5bGVzID0gbmV3IE9iamVjdCgpO1xuICAgIHRoaXMubG93Wm9vbVN0eWxlcyA9IG5ldyBPYmplY3QoKTtcbiovXG5cbiAgICB0aGlzLnN0eWxlcyA9IFtdO1xufVxuXG5EQVNTdHlsZXNoZWV0LnByb3RvdHlwZS5wdXNoU3R5bGUgPSBmdW5jdGlvbihmaWx0ZXJzLCB6b29tLCBzdHlsZSkge1xuICAgIC8qXG5cbiAgICBpZiAoIXpvb20pIHtcbiAgICAgICAgdGhpcy5oaWdoWm9vbVN0eWxlc1t0eXBlXSA9IHN0eWxlO1xuICAgICAgICB0aGlzLm1lZGl1bVpvb21TdHlsZXNbdHlwZV0gPSBzdHlsZTtcbiAgICAgICAgdGhpcy5sb3dab29tU3R5bGVzW3R5cGVdID0gc3R5bGU7XG4gICAgfSBlbHNlIGlmICh6b29tID09ICdoaWdoJykge1xuICAgICAgICB0aGlzLmhpZ2hab29tU3R5bGVzW3R5cGVdID0gc3R5bGU7XG4gICAgfSBlbHNlIGlmICh6b29tID09ICdtZWRpdW0nKSB7XG4gICAgICAgIHRoaXMubWVkaXVtWm9vbVN0eWxlc1t0eXBlXSA9IHN0eWxlO1xuICAgIH0gZWxzZSBpZiAoem9vbSA9PSAnbG93Jykge1xuICAgICAgICB0aGlzLmxvd1pvb21TdHlsZXNbdHlwZV0gPSBzdHlsZTtcbiAgICB9XG5cbiAgICAqL1xuXG4gICAgaWYgKCFmaWx0ZXJzKSB7XG4gICAgICAgIGZpbHRlcnMgPSB7dHlwZTogJ2RlZmF1bHQnfTtcbiAgICB9XG4gICAgdmFyIHN0eWxlSG9sZGVyID0gc2hhbGxvd0NvcHkoZmlsdGVycyk7XG4gICAgaWYgKHpvb20pIHtcbiAgICAgICAgc3R5bGVIb2xkZXIuem9vbSA9IHpvb207XG4gICAgfVxuICAgIHN0eWxlSG9sZGVyLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5zdHlsZXMucHVzaChzdHlsZUhvbGRlcik7XG59XG5cbmZ1bmN0aW9uIERBU1N0eWxlKCkge1xufVxuXG5mdW5jdGlvbiBwYXJzZUdyYWRpZW50KGdyYWQpIHtcbiAgICB2YXIgc3RlcHMgPSBncmFkLmdldEF0dHJpYnV0ZSgnc3RlcHMnKTtcbiAgICBpZiAoc3RlcHMpIHtcbiAgICAgICAgc3RlcHMgPSBzdGVwc3wwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ZXBzID0gNTA7XG4gICAgfVxuXG5cbiAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICB2YXIgY29sb3JzID0gW107XG4gICAgdmFyIHNlID0gZ3JhZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnU1RPUCcpO1xuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzZS5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgdmFyIHN0b3AgPSBzZVtzaV07XG4gICAgICAgIHN0b3BzLnB1c2goMS4wICogc3RvcC5nZXRBdHRyaWJ1dGUoJ3Njb3JlJykpO1xuICAgICAgICBjb2xvcnMucHVzaChzdG9wLmZpcnN0Q2hpbGQubm9kZVZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZUNvbG91clN0ZXBzKHN0ZXBzLCBzdG9wcywgY29sb3JzKTtcbn1cblxuREFTU291cmNlLnByb3RvdHlwZS5zdHlsZXNoZWV0ID0gZnVuY3Rpb24oc3VjY2Vzc0NCLCBmYWlsdXJlQ0IpIHtcbiAgICB2YXIgZGFzVVJJLCBjcmVkcyA9IHRoaXMuY3JlZGVudGlhbHM7XG4gICAgaWYgKHRoaXMuc3R5bGVzaGVldF91cmkpIHtcbiAgICAgICAgZGFzVVJJID0gdGhpcy5zdHlsZXNoZWV0X3VyaTtcbiAgICAgICAgY3JlZHMgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYXNVUkkgPSB0aGlzLmRhc0Jhc2VVUkkgKyAnc3R5bGVzaGVldCc7XG4gICAgfVxuXG4gICAgZG9Dcm9zc0RvbWFpblJlcXVlc3QoZGFzVVJJLCBmdW5jdGlvbihyZXNwb25zZVhNTCkge1xuICAgICAgICBpZiAoIXJlc3BvbnNlWE1MKSB7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZUNCKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZUNCKCk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcbiAgICAgICAgdmFyIHR5cGVYTUxzID0gcmVzcG9uc2VYTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ1RZUEUnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlWE1Mcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHR5cGVTdHlsZSA9IHR5cGVYTUxzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0ge307XG4gICAgICAgICAgICBmaWx0ZXIudHlwZSA9IHR5cGVTdHlsZS5nZXRBdHRyaWJ1dGUoJ2lkJyk7IC8vIEFtIEkgcmlnaHQgaW4gdGhpbmtpbmcgdGhhdCB0aGlzIG1ha2VzIERBU1NUWUxFIFhNTCBpbnZhbGlkPyAgVWdoLlxuICAgICAgICAgICAgZmlsdGVyLmxhYmVsID0gdHlwZVN0eWxlLmdldEF0dHJpYnV0ZSgnbGFiZWwnKTtcbiAgICAgICAgICAgIGZpbHRlci5tZXRob2QgPSB0eXBlU3R5bGUuZ2V0QXR0cmlidXRlKCdtZXRob2QnKTtcbiAgICAgICAgICAgIHZhciBnbHlwaFhNTHMgPSB0eXBlU3R5bGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0dMWVBIJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBnaSA9IDA7IGdpIDwgZ2x5cGhYTUxzLmxlbmd0aDsgKytnaSkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaFhNTCA9IGdseXBoWE1Mc1tnaV07XG4gICAgICAgICAgICAgICAgdmFyIHpvb20gPSBnbHlwaFhNTC5nZXRBdHRyaWJ1dGUoJ3pvb20nKTtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBjaGlsZEVsZW1lbnRPZihnbHlwaFhNTCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICAgICAgc3R5bGUuZ2x5cGggPSBnbHlwaC5sb2NhbE5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gZ2x5cGguZmlyc3RDaGlsZDtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxlcnQoY2hpbGQubG9jYWxOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5sb2NhbE5hbWUgPT0gJ0JHR1JBRCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVtjaGlsZC5sb2NhbE5hbWVdID0gcGFyc2VHcmFkaWVudChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlW2NoaWxkLmxvY2FsTmFtZV0gPSBjaGlsZC5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZShmaWx0ZXIsIHpvb20sIHN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWNjZXNzQ0Ioc3R5bGVzaGVldCk7XG4gICAgfSwgY3JlZHMpO1xufVxuXG4vL1xuLy8gc291cmNlcyBjb21tYW5kXG4vLyBcblxuZnVuY3Rpb24gREFTUmVnaXN0cnkodXJpLCBvcHRzKVxue1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMudXJpID0gdXJpO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7ICAgXG59XG5cbkRBU1JlZ2lzdHJ5LnByb3RvdHlwZS5zb3VyY2VzID0gZnVuY3Rpb24oY2FsbGJhY2ssIGZhaWx1cmUsIG9wdHMpXG57XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgZmlsdGVycyA9IFtdO1xuICAgIGlmIChvcHRzLnRheG9uKSB7XG4gICAgICAgIGZpbHRlcnMucHVzaCgnb3JnYW5pc209JyArIG9wdHMudGF4b24pO1xuICAgIH1cbiAgICBpZiAob3B0cy5hdXRoKSB7XG4gICAgICAgIGZpbHRlcnMucHVzaCgnYXV0aG9yaXR5PScgKyBvcHRzLmF1dGgpO1xuICAgIH1cbiAgICBpZiAob3B0cy52ZXJzaW9uKSB7XG4gICAgICAgIGZpbHRlcnMucHVzaCgndmVyc2lvbj0nICsgb3B0cy52ZXJzaW9uKTtcbiAgICB9XG4gICAgdmFyIHF1cmkgPSB0aGlzLnVyaTtcbiAgICBpZiAoZmlsdGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHF1cmkgPSBxdXJpICsgJz8nICsgZmlsdGVycy5qb2luKCcmJyk7ICAgLy8gJyYnIGFzIGEgc2VwYXJhdG9yIHRvIGhhY2sgYXJvdW5kIGRhc3JlZ2lzdHJ5Lm9yZyBidWcuXG4gICAgfVxuXG4gICAgZG9Dcm9zc0RvbWFpblJlcXVlc3QocXVyaSwgZnVuY3Rpb24ocmVzcG9uc2VYTUwpIHtcbiAgICAgICAgaWYgKCFyZXNwb25zZVhNTCAmJiBmYWlsdXJlKSB7XG4gICAgICAgICAgICBmYWlsdXJlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc291cmNlcyA9IFtdOyAgICAgICBcbiAgICAgICAgdmFyIHNvdXJjZVhNTHMgPSByZXNwb25zZVhNTC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnU09VUkNFJyk7XG4gICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzb3VyY2VYTUxzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZVhNTCA9IHNvdXJjZVhNTHNbc2ldO1xuICAgICAgICAgICAgdmFyIHZlcnNpb25YTUxzID0gc291cmNlWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdWRVJTSU9OJyk7XG4gICAgICAgICAgICBpZiAodmVyc2lvblhNTHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZlcnNpb25YTUwgPSB2ZXJzaW9uWE1Mc1swXTtcblxuICAgICAgICAgICAgdmFyIGNvb3JkWE1McyA9IHZlcnNpb25YTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NPT1JESU5BVEVTJyk7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY29vcmRYTUxzLmxlbmd0aDsgKytjaSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZFhNTCA9IGNvb3JkWE1Mc1tjaV07XG4gICAgICAgICAgICAgICAgdmFyIGNvb3JkID0gbmV3IERBU0Nvb3JkcygpO1xuICAgICAgICAgICAgICAgIGNvb3JkLmF1dGggPSBjb29yZFhNTC5nZXRBdHRyaWJ1dGUoJ2F1dGhvcml0eScpO1xuICAgICAgICAgICAgICAgIGNvb3JkLnRheG9uID0gY29vcmRYTUwuZ2V0QXR0cmlidXRlKCd0YXhpZCcpO1xuICAgICAgICAgICAgICAgIGNvb3JkLnZlcnNpb24gPSBjb29yZFhNTC5nZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nKTtcbiAgICAgICAgICAgICAgICBjb29yZHMucHVzaChjb29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjYXBzID0gW107XG4gICAgICAgICAgICB2YXIgY2FwWE1McyA9IHZlcnNpb25YTUwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ0NBUEFCSUxJVFknKTtcbiAgICAgICAgICAgIHZhciB1cmk7XG4gICAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgY2FwWE1Mcy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FwWE1MID0gY2FwWE1Mc1tjaV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2Fwcy5wdXNoKGNhcFhNTC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FwWE1MLmdldEF0dHJpYnV0ZSgndHlwZScpID09ICdkYXMxOmZlYXR1cmVzJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmVwID0gY2FwWE1MLmdldEF0dHJpYnV0ZSgncXVlcnlfdXJpJyk7XG4gICAgICAgICAgICAgICAgICAgIHVyaSA9IGZlcC5zdWJzdHJpbmcoMCwgZmVwLmxlbmd0aCAtICgnZmVhdHVyZXMnLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICB2YXIgcHJvcFhNTHMgPSB2ZXJzaW9uWE1MLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdQUk9QJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBwaSA9IDA7IHBpIDwgcHJvcFhNTHMubGVuZ3RoOyArK3BpKSB7XG4gICAgICAgICAgICAgICAgcHVzaG8ocHJvcHMsIHByb3BYTUxzW3BpXS5nZXRBdHRyaWJ1dGUoJ25hbWUnKSwgcHJvcFhNTHNbcGldLmdldEF0dHJpYnV0ZSgndmFsdWUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlID0gbmV3IERBU1NvdXJjZSh1cmksIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlX3VyaTogc291cmNlWE1MLmdldEF0dHJpYnV0ZSgndXJpJyksXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICBzb3VyY2VYTUwuZ2V0QXR0cmlidXRlKCd0aXRsZScpLFxuICAgICAgICAgICAgICAgICAgICBkZXNjOiAgc291cmNlWE1MLmdldEF0dHJpYnV0ZSgnZGVzY3JpcHRpb24nKSxcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzOiBjb29yZHMsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiBjYXBzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNhbGxiYWNrKHNvdXJjZXMpO1xuICAgIH0pO1xufVxuXG5cbi8vXG4vLyBVdGlsaXR5IGZ1bmN0aW9uc1xuLy9cblxuZnVuY3Rpb24gZWxlbWVudFZhbHVlKGVsZW1lbnQsIHRhZylcbntcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZyk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDAgJiYgY2hpbGRyZW5bMF0uZmlyc3RDaGlsZCkge1xuICAgICAgICB2YXIgYyA9IGNoaWxkcmVuWzBdO1xuICAgICAgICBpZiAoYy5jaGlsZE5vZGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gYy5maXJzdENoaWxkLm5vZGVWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKHZhciBuaSA9IDA7IG5pIDwgYy5jaGlsZE5vZGVzLmxlbmd0aDsgKytuaSkge1xuICAgICAgICAgICAgICAgIHMgKz0gYy5jaGlsZE5vZGVzW25pXS5ub2RlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjaGlsZEVsZW1lbnRPZihlbGVtZW50KVxue1xuICAgIGlmIChlbGVtZW50Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9IHdoaWxlIChjaGlsZCAhPSBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cblxuZnVuY3Rpb24gZGFzTGlua3NPZihlbGVtZW50KVxue1xuICAgIHZhciBsaW5rcyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBtYXliZUxpbmtDaGlsZGVuID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnTElOSycpO1xuICAgIGZvciAodmFyIGNpID0gMDsgY2kgPCBtYXliZUxpbmtDaGlsZGVuLmxlbmd0aDsgKytjaSkge1xuICAgICAgICB2YXIgbGlua1hNTCA9IG1heWJlTGlua0NoaWxkZW5bY2ldO1xuICAgICAgICBpZiAobGlua1hNTC5wYXJlbnROb2RlID09IGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxpbmtzLnB1c2gobmV3IERBU0xpbmsobGlua1hNTC5maXJzdENoaWxkID8gbGlua1hNTC5maXJzdENoaWxkLm5vZGVWYWx1ZSA6ICdVbmtub3duJywgbGlua1hNTC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBsaW5rcztcbn1cblxuZnVuY3Rpb24gZGFzTm90ZXNPZihlbGVtZW50KVxue1xuICAgIHZhciBub3RlcyA9IFtdO1xuICAgIHZhciBtYXliZU5vdGVzID0gZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnTk9URScpO1xuICAgIGZvciAodmFyIG5pID0gMDsgbmkgPCBtYXliZU5vdGVzLmxlbmd0aDsgKytuaSkge1xuICAgICAgICBpZiAobWF5YmVOb3Rlc1tuaV0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgbm90ZXMucHVzaChtYXliZU5vdGVzW25pXS5maXJzdENoaWxkLm5vZGVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vdGVzO1xufVxuXG5mdW5jdGlvbiBkb0Nyb3NzRG9tYWluUmVxdWVzdCh1cmwsIGhhbmRsZXIsIGNyZWRlbnRpYWxzLCBjdXN0QXV0aCkge1xuICAgIC8vIFRPRE86IGV4cGxpY2l0IGVycm9yIGhhbmRsZXJzP1xuXG4gICAgaWYgKHdpbmRvdy5YRG9tYWluUmVxdWVzdCkge1xuICAgICAgICB2YXIgcmVxID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgICAgIHJlcS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkb20gPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgICAgICBkb20uYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvbS5sb2FkWE1MKHJlcS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgaGFuZGxlcihkb20pO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5vcGVuKFwiZ2V0XCIsIHVybCk7XG4gICAgICAgIHJlcS5zZW5kKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndGltaW5nIG91dCAnICArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKG51bGwsIHJlcSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICA1MDAwXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXEudGltZW91dCA9IDUwMDA7XG4gICAgICAgICAgICByZXEub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbWVvdXQgb24gJyArIHVybCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA+PSAyMDAgfHwgcmVxLnN0YXR1cyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKHJlcS5yZXNwb25zZVhNTCwgcmVxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEub3BlbihcImdldFwiLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgcmVxLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VzdEF1dGgpIHtcbiAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcignWC1EQVMtQXV0aG9yaXNhdGlvbicsIGN1c3RBdXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi94bWwsKi8qJyk7XG4gICAgICAgICAgICByZXEuc2VuZCgnJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXIobnVsbCwgcmVxLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuREFTU291cmNlLnByb3RvdHlwZS5kb0Nyb3NzRG9tYWluUmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgaGFuZGxlciwgZXJySGFuZGxlcikge1xuICAgIHZhciBjdXN0QXV0aDtcbiAgICBpZiAodGhpcy54VXNlcikge1xuICAgICAgICBjdXN0QXV0aCA9ICdCYXNpYyAnICsgYnRvYSh0aGlzLnhVc2VyICsgJzonICsgdGhpcy54UGFzcyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvQ3Jvc3NEb21haW5SZXF1ZXN0KHVybCwgaGFuZGxlciwgdGhpcy5jcmVkZW50aWFscywgY3VzdEF1dGgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJySGFuZGxlcikge1xuICAgICAgICAgICAgZXJySGFuZGxlcihlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0Rhc0Jvb2xlYW5UcnVlKHMpIHtcbiAgICBzID0gKCcnICsgcykudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gcz09PSd5ZXMnIHx8IHM9PT0ndHJ1ZSc7XG59XG5cbmZ1bmN0aW9uIGlzRGFzQm9vbGVhbk5vdEZhbHNlKHMpIHtcbiAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHMgPSAoJycgKyBzKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBzIT09J25vJyB8fCBzIT09J2ZhbHNlJztcbn1cblxuZnVuY3Rpb24gY29weVN0eWxlc2hlZXQoc3MpIHtcbiAgICB2YXIgbnNzID0gc2hhbGxvd0NvcHkoc3MpO1xuICAgIG5zcy5zdHlsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc3Muc3R5bGVzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgc2ggPSBuc3Muc3R5bGVzW3NpXSA9IHNoYWxsb3dDb3B5KHNzLnN0eWxlc1tzaV0pO1xuICAgICAgICBzaC5fbWV0aG9kUkUgPSBzaC5fbGFiZWxSRSA9IHNoLl90eXBlUkUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNoLnN0eWxlID0gc2hhbGxvd0NvcHkoc2guc3R5bGUpO1xuICAgICAgICBzaC5zdHlsZS5pZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgc2guc3R5bGUuX2dyYWRpZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbnNzO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIERBU0dyb3VwOiBEQVNHcm91cCxcbiAgICAgICAgREFTRmVhdHVyZTogREFTRmVhdHVyZSxcbiAgICAgICAgREFTU3R5bGVzaGVldDogREFTU3R5bGVzaGVldCxcbiAgICAgICAgREFTU3R5bGU6IERBU1N0eWxlLFxuICAgICAgICBEQVNTb3VyY2U6IERBU1NvdXJjZSxcbiAgICAgICAgREFTU2VnbWVudDogREFTU2VnbWVudCxcbiAgICAgICAgREFTUmVnaXN0cnk6IERBU1JlZ2lzdHJ5LFxuICAgICAgICBEQVNTZXF1ZW5jZTogREFTU2VxdWVuY2UsXG4gICAgICAgIERBU0xpbms6IERBU0xpbmssXG5cbiAgICAgICAgaXNEYXNCb29sZWFuVHJ1ZTogaXNEYXNCb29sZWFuVHJ1ZSxcbiAgICAgICAgaXNEYXNCb29sZWFuTm90RmFsc2U6IGlzRGFzQm9vbGVhbk5vdEZhbHNlLFxuICAgICAgICBjb3B5U3R5bGVzaGVldDogY29weVN0eWxlc2hlZXQsXG4gICAgICAgIGNvb3Jkc01hdGNoOiBjb29yZHNNYXRjaFxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEwXG4vL1xuLy8gZG9tdWkuanM6IFNWRyBVSSBjb21wb25lbnRzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbiAgICB2YXIgcmVtb3ZlQ2hpbGRyZW4gPSB1dGlscy5yZW1vdmVDaGlsZHJlbjtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVtb3ZlQWxsUG9wdXBzID0gZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlQ2hpbGRyZW4odGhpcy5oUG9wdXBIb2xkZXIpO1xuICAgIHJlbW92ZUNoaWxkcmVuKHRoaXMucG9wdXBIb2xkZXIpO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYWtlVG9vbHRpcCA9IGZ1bmN0aW9uKGVsZSwgdGV4dClcbntcbiAgICB2YXIgaXNpbiA9IGZhbHNlO1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdmFyIHRpbWVyID0gbnVsbDtcbiAgICB2YXIgb3V0bGlzdGVuZXI7XG4gICAgb3V0bGlzdGVuZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICBpc2luID0gZmFsc2U7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCBvdXRsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dXAgPSBmdW5jdGlvbihldikge1xuICAgICAgICB2YXIgbXggPSBldi5jbGllbnRYICsgd2luZG93LnNjcm9sbFgsIG15ID0gZXYuY2xpZW50WSArIHdpbmRvdy5zY3JvbGxZO1xuICAgICAgICBpZiAoIXRpbWVyKSB7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR0dDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mKHRleHQpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHR0dCA9IHRleHQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0dHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwb3B1cCA9IG1ha2VFbGVtZW50KCdkaXYnLFxuICAgICAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICd0b29sdGlwLWFycm93J30pLFxuICAgICAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ2RpdicsIHR0dCwge2NsYXNzTmFtZTogJ3Rvb2x0aXAtaW5uZXInfSldLCBcbiAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogJ3Rvb2x0aXAgYm90dG9tIGluJ30sIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAnJyArIChteSArIDIwKSArICdweCcsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICcnICsgTWF0aC5tYXgobXggLSAzMCwgMjApICsgJ3B4J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXNCLmhQb3B1cEhvbGRlci5hcHBlbmRDaGlsZChwb3B1cCk7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVIYW5kbGVyO1xuICAgICAgICAgICAgICAgIG1vdmVIYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmhQb3B1cEhvbGRlci5yZW1vdmVDaGlsZChwb3B1cCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1heSBoYXZlIGJlZW4gcmVtb3ZlZCBieSBvdGhlciBjb2RlIHdoaWNoIGNsZWFycyB0aGUgcG9wdXAgbGF5ZXIuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxlLm9mZnNldFBhcmVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBlbGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaXNpbiA9IHRydWVcbiAgICAgICAgZWxlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jywgb3V0bGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgc2V0dXAoZXYpO1xuICAgIH0sIGZhbHNlKTtcbiAgICBlbGUuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWRGcm9tRG9jdW1lbnQnLCBmdW5jdGlvbihldikge1xuICAgICAgICBpc2luID0gZmFsc2U7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIGZhbHNlKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucG9waXQgPSBmdW5jdGlvbihldiwgbmFtZSwgZWxlLCBvcHRzKVxue1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgaWYgKCFvcHRzKSBcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIGlmICghZXYpIFxuICAgICAgICBldiA9IHt9O1xuXG4gICAgdmFyIHdpZHRoID0gb3B0cy53aWR0aCB8fCAyMDA7XG5cbiAgICB2YXIgbXgsIG15O1xuXG4gICAgaWYgKGV2LmNsaWVudFgpIHtcbiAgICAgICAgdmFyIG14ID0gIGV2LmNsaWVudFgsIG15ID0gZXYuY2xpZW50WTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBteCA9IDUwMDsgbXk9IDUwO1xuICAgIH1cbiAgICBteCArPSAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xuICAgIG15ICs9ICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgIHZhciB3aW5XaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuXG4gICAgdmFyIHRvcCA9IG15O1xuICAgIHZhciBsZWZ0ID0gTWF0aC5taW4obXggLSAod2lkdGgvMikgLSA0LCAod2luV2lkdGggLSB3aWR0aCAtIDMwKSk7XG5cbiAgICB2YXIgcG9wdXAgPSBtYWtlRWxlbWVudCgnZGl2Jyk7XG4gICAgcG9wdXAuY2xhc3NOYW1lID0gJ3BvcG92ZXIgZmFkZSAnICsgKGV2LmNsaWVudFggPyAnYm90dG9tICcgOiAnJykgKyAnaW4nO1xuICAgIHBvcHVwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIHBvcHVwLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBwb3B1cC5zdHlsZS50b3AgPSAnJyArIHRvcCArICdweCc7XG4gICAgcG9wdXAuc3R5bGUubGVmdCA9ICcnICsgbGVmdCArICdweCc7XG4gICAgcG9wdXAuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgaWYgKHdpZHRoID4gMjc2KSB7XG4gICAgICAgIC8vIEhBQ0sgQm9vdHN0cmFwcGlmaWNhdGlvbi4uLlxuICAgICAgICBwb3B1cC5zdHlsZS5tYXhXaWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB9XG5cbiAgICBwb3B1cC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ2Fycm93J30pKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhciBjbG9zZUJ1dHRvbiA9IG1ha2VFbGVtZW50KCdidXR0b24nLCAnJywge2NsYXNzTmFtZTogJ2Nsb3NlJ30pO1xuICAgICAgICBjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJnRpbWVzOydcblxuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgY2xvc2VCdXR0b24uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBjbG9zZUJ1dHRvbi5zdHlsZS5jb2xvciA9ICdibGFjayc7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB0aGlzQi5yZW1vdmVBbGxQb3B1cHMoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB2YXIgdGJhciA9IG1ha2VFbGVtZW50KCdoNCcsIFttYWtlRWxlbWVudCgnc3BhbicsIG5hbWUsIG51bGwsIHttYXhXaWR0aDogJzIwMHB4J30pLCBjbG9zZUJ1dHRvbl0sIHsvKmNsYXNzTmFtZTogJ3BvcG92ZXItdGl0bGUnICovfSwge3BhZGRpbmdMZWZ0OiAnMTBweCcsIHBhZGRpbmdSaWdodDogJzEwcHgnfSk7XG5cbiAgICAgICAgdmFyIGRyYWdPWCwgZHJhZ09ZO1xuICAgICAgICB2YXIgbW92ZUhhbmRsZXIsIHVwSGFuZGxlcjtcbiAgICAgICAgbW92ZUhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsZWZ0ID0gbGVmdCArIChldi5jbGllbnRYIC0gZHJhZ09YKTtcbiAgICAgICAgICAgIGlmIChsZWZ0IDwgOCkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSA4O1xuICAgICAgICAgICAgfSBpZiAobGVmdCA+ICh3aW5XaWR0aCAtIHdpZHRoIC0gMzIpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICh3aW5XaWR0aCAtIHdpZHRoIC0gMjYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wID0gdG9wICsgKGV2LmNsaWVudFkgLSBkcmFnT1kpO1xuICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgoMTAsIHRvcCk7XG4gICAgICAgICAgICBwb3B1cC5zdHlsZS50b3AgPSAnJyArIHRvcCArICdweCc7XG4gICAgICAgICAgICBwb3B1cC5zdHlsZS5sZWZ0ID0gJycgKyBNYXRoLm1pbihsZWZ0LCAod2luV2lkdGggLSB3aWR0aCAtIDEwKSkgKyAncHgnO1xuICAgICAgICAgICAgZHJhZ09YID0gZXYuY2xpZW50WDsgZHJhZ09ZID0gZXYuY2xpZW50WTtcbiAgICAgICAgfVxuICAgICAgICB1cEhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdXBIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGJhci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBkcmFnT1ggPSBldi5jbGllbnRYOyBkcmFnT1kgPSBldi5jbGllbnRZO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICBwb3B1cC5hcHBlbmRDaGlsZCh0YmFyKTtcbiAgICB9XG5cbiAgICBwb3B1cC5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnZGl2JywgZWxlLCB7Y2xhc3NOYW1lOiAncG9wb3Zlci1jb250ZW50J30sIHtcbiAgICAgICAgcGFkZGluZzogJzBweCdcbiAgICB9KSk7XG4gICAgdGhpcy5oUG9wdXBIb2xkZXIuYXBwZW5kQ2hpbGQocG9wdXApO1xuXG4gICAgdmFyIHBvcHVwSGFuZGxlID0ge1xuICAgICAgICBub2RlOiBwb3B1cCxcbiAgICAgICAgZGlzcGxheWVkOiB0cnVlXG4gICAgfTtcbiAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKCdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmIChldi50YXJnZXQgPT0gcG9wdXApIHtcbiAgICAgICAgICAgIHBvcHVwSGFuZGxlLmRpc3BsYXllZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuICAgIHJldHVybiBwb3B1cEhhbmRsZTtcbn1cblxuZnVuY3Rpb24gbWFrZVRyZWVUYWJsZVNlY3Rpb24odGl0bGUsIGNvbnRlbnQsIHZpc2libGUpIHtcbiAgICB2YXIgdHRCdXR0b24gPSBtYWtlRWxlbWVudCgnaScpO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgIHR0QnV0dG9uLmNsYXNzTmFtZSA9ICdmYSBmYS1jYXJldC1kb3duJztcbiAgICAgICAgICAgIGNvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICd0YWJsZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0dEJ1dHRvbi5jbGFzc05hbWUgPSAnZmEgZmEtY2FyZXQtcmlnaHQnO1xuICAgICAgICAgICAgY29udGVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSgpO1xuXG4gICAgdHRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdmlzaWJsZSA9ICF2aXNpYmxlO1xuICAgICAgICB1cGRhdGUoKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgaGVhZGluZyA9IG1ha2VFbGVtZW50KCdoNicsIFt0dEJ1dHRvbiwgJyAnLCB0aXRsZV0sIHt9LCB7ZGlzcGxheTogJ2Jsb2NrJywgYmFja2dyb3VuZDogJ2dyYXknLCBjb2xvcjogJ3doaXRlJywgd2lkdGg6ICcxMDAlJywgcGFkZGluZzogJzVweCAycHgnLCBtYXJnaW46ICcwcHgnfSk7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50KCdkaXYnLCBbaGVhZGluZywgY29udGVudF0sIHt9KTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBtYWtlVHJlZVRhYmxlU2VjdGlvbjogbWFrZVRyZWVUYWJsZVNlY3Rpb25cbiAgICB9O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIGVuY29kZS5qczogaW50ZXJmYWNlIGZvciBFTkNPREUgRENDIHNlcnZpY2VzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbG9va3VwRW5jb2RlVVJJKHVyaSwganNvbikge1xuICAgIGlmICh1cmkuaW5kZXhPZignPycpIDwgMClcbiAgICAgICAgdXJpID0gdXJpICsgJz9zb2Z0PXRydWUnO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGFjY2VwdCwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCdFcnJvciBjb2RlICcgKyByZXEuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcCA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXB0KGpzb24gPyByZXNwIDogcmVzcC5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICByZXEub3BlbignR0VUJywgdXJpLCB0cnVlKTtcbiAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgIHJlcS5zZW5kKCcnKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gRW5jb2RlVVJMSG9sZGVyKHVybCkge1xuICAgIHRoaXMucmF3dXJsID0gdXJsO1xufVxuXG5FbmNvZGVVUkxIb2xkZXIucHJvdG90eXBlLmdldFVSTFByb21pc2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy51cmxQcm9taXNlICYmIHRoaXMudXJsUHJvbWlzZVZhbGlkaXR5ID4gRGF0ZS5ub3coKSkge1xuICAgICAgICByZXR1cm4gdGhpcy51cmxQcm9taXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXJsUHJvbWlzZSA9IGxvb2t1cEVuY29kZVVSSSh0aGlzLnJhd3VybCwgdHJ1ZSkudGhlbihmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcC5sb2NhdGlvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXJsUHJvbWlzZVZhbGlkaXR5ID0gRGF0ZS5ub3coKSArICgxMiAqIDM2MDAgKiAxMDAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsUHJvbWlzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEVuY29kZUZldGNoYWJsZSh1cmwsIHN0YXJ0LCBlbmQsIG9wdHMpIHtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIG9wdHMgPSBzdGFydDtcbiAgICAgICAgICAgIHN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy51cmwgPSAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycgPyBuZXcgRW5jb2RlVVJMSG9sZGVyKHVybCkgOiB1cmwpO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIGlmIChlbmQpIHtcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIHRoaXMub3B0cyA9IG9wdHM7XG59XG5cblxuXG5FbmNvZGVGZXRjaGFibGUucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24ocywgbCkge1xuICAgIGlmIChzIDwgMCkge1xuICAgICAgICB0aHJvdyAnQmFkIHNsaWNlICcgKyBzO1xuICAgIH1cblxuICAgIHZhciBucyA9IHRoaXMuc3RhcnQsIG5lID0gdGhpcy5lbmQ7XG4gICAgaWYgKG5zICYmIHMpIHtcbiAgICAgICAgbnMgPSBucyArIHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbnMgPSBzIHx8IG5zO1xuICAgIH1cbiAgICBpZiAobCAmJiBucykge1xuICAgICAgICBuZSA9IG5zICsgbCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmUgPSBuZSB8fCBsIC0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFbmNvZGVGZXRjaGFibGUodGhpcy51cmwsIG5zLCBuZSwgdGhpcy5vcHRzKTtcbn1cblxuRW5jb2RlRmV0Y2hhYmxlLnByb3RvdHlwZS5mZXRjaEFzVGV4dCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbGVuZ3RoO1xuICAgIHNlbGYudXJsLmdldFVSTFByb21pc2UoKS50aGVuKGZ1bmN0aW9uKHVybCkge1xuICAgICAgICByZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcblxuICAgICAgICBpZiAoc2VsZi5lbmQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmVuZCAtIHNlbGYuc3RhcnQgPiAxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTW9uc3RlciBmZXRjaCEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBzZWxmLnN0YXJ0ICsgJy0nICsgc2VsZi5lbmQpO1xuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5lbmQgLSBzZWxmLnN0YXJ0ICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwIHx8IHJlcS5zdGF0dXMgPT0gMjA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2VsZi5vcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZCgnJyk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9KTtcbn1cblxuRW5jb2RlRmV0Y2hhYmxlLnByb3RvdHlwZS5zYWx0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbn1cblxuRW5jb2RlRmV0Y2hhYmxlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhdHRlbXB0LCB0cnVuY2F0ZWRMZW5ndGgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBhdHRlbXB0ID0gYXR0ZW1wdCB8fCAxO1xuICAgIGlmIChhdHRlbXB0ID4gMykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuXG4gICAgc2VsZi51cmwuZ2V0VVJMUHJvbWlzZSgpLnRoZW4oZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHZhciBsZW5ndGg7XG4gICAgICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICByZXEub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpO1xuICAgICAgICBpZiAoc2VsZi5lbmQpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmVuZCAtIHNlbGYuc3RhcnQgPiAxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTW9uc3RlciBmZXRjaCEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNldFJlcXVlc3RIZWFkZXIoJ1JhbmdlJywgJ2J5dGVzPScgKyBzZWxmLnN0YXJ0ICsgJy0nICsgc2VsZi5lbmQpO1xuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5lbmQgLSBzZWxmLnN0YXJ0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXEucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnN0YXR1cyA9PSAyMDAgfHwgcmVxLnN0YXR1cyA9PSAyMDYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5yZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsID0gcmVxLnJlc3BvbnNlLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoICYmIGxlbmd0aCAhPSBibCAmJiAoIXRydW5jYXRlZExlbmd0aCB8fCBibCAhPSB0cnVuY2F0ZWRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZmV0Y2goY2FsbGJhY2ssIGF0dGVtcHQgKyAxLCBibCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXEucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlcS5tb3pSZXNwb25zZUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2socmVxLm1velJlc3BvbnNlQXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSByZXEucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCAmJiBsZW5ndGggIT0gci5sZW5ndGggJiYgKCF0cnVuY2F0ZWRMZW5ndGggfHwgci5sZW5ndGggIT0gdHJ1bmNhdGVkTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZldGNoKGNhbGxiYWNrLCBhdHRlbXB0ICsgMSwgci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYnN0cmluZ1RvQnVmZmVyKHJlcS5yZXNwb25zZVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmZldGNoKGNhbGxiYWNrLCBhdHRlbXB0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2VsZi5vcHRzLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXEud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXEuc2VuZCgnJyk7XG4gICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGJzdHJpbmdUb0J1ZmZlcihyZXN1bHQpIHtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShyZXN1bHQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJhW2ldID0gcmVzdWx0LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBiYS5idWZmZXI7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgbG9va3VwRW5jb2RlVVJJOiBsb29rdXBFbmNvZGVVUkksXG4gICAgICAgIEVuY29kZUZldGNoYWJsZTogRW5jb2RlRmV0Y2hhYmxlXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyBlbnNlbWJsanNvbi5qcyAtLSBxdWVyeSB0aGUgRW5zZW1ibCBSRVNUIEFQSS5cbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbiAgICB2YXIgZGFsbGlhbmNlX3JlZ2lzdGVyU291cmNlQWRhcHRlckZhY3RvcnkgPSBzYS5yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5O1xuICAgIHZhciBGZWF0dXJlU291cmNlQmFzZSA9IHNhLkZlYXR1cmVTb3VyY2VCYXNlO1xuXG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIERBU1N0eWxlc2hlZXQgPSBkYXMuREFTU3R5bGVzaGVldDtcbiAgICB2YXIgREFTU3R5bGUgPSBkYXMuREFTU3R5bGU7XG4gICAgdmFyIERBU0ZlYXR1cmUgPSBkYXMuREFTRmVhdHVyZTtcbiAgICB2YXIgREFTR3JvdXAgPSBkYXMuREFTR3JvdXA7XG59XG5cblxuXG5mdW5jdGlvbiBFbnNlbWJsRmVhdHVyZVNvdXJjZShzb3VyY2UpIHtcbiAgICBGZWF0dXJlU291cmNlQmFzZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuYmFzZSA9IHNvdXJjZS51cmkgfHwgJy8vcmVzdC5lbnNlbWJsLm9yZyc7XG4gICAgaWYgKHRoaXMuYmFzZS5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICAgIHZhciBwcm90byA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgICAgaWYgKHByb3RvID09ICdodHRwOicgfHwgcHJvdG8gPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgIC8vIFByb3RvY29sLXJlbGF0aXZlIFVSTHMgb2theS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9ICdodHRwOicgKyB0aGlzLmJhc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zcGVjaWVzID0gc291cmNlLnNwZWNpZXMgfHwgJ2h1bWFuJztcblxuICAgIGlmICh0eXBlb2Ygc291cmNlLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFtzb3VyY2UudHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50eXBlID0gc291cmNlLnR5cGUgfHwgWydyZWd1bGF0b3J5J107XG4gICAgfVxufVxuXG5FbnNlbWJsRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZSk7XG5FbnNlbWJsRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbnNlbWJsRmVhdHVyZVNvdXJjZTtcblxuRW5zZW1ibEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFN0eWxlU2hlZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcblxuICAgIHZhciB0c1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgdHNTdHlsZS5nbHlwaCA9ICdfX05PTkUnO1xuICAgIGlmICh0aGlzLnR5cGUuaW5kZXhPZignZXhvbicpID49IDApXG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNjcmlwdCd9LCBudWxsLCB0c1N0eWxlKTtcbiAgICBpZiAodGhpcy50eXBlLmluZGV4T2YoJ2V4b24nKSA+PSAwIHx8IHRoaXMudHlwZS5pbmRleE9mKCd0cmFuc2NyaXB0JykgPj0gMClcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdnZW5lJ30sIG51bGwsIHRzU3R5bGUpO1xuXG4gICAgdmFyIGNkc1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgY2RzU3R5bGUuZ2x5cGggPSAnQk9YJztcbiAgICBjZHNTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICBjZHNTdHlsZS5CR0NPTE9SID0gJ3JlZCdcbiAgICBjZHNTdHlsZS5IRUlHSFQgPSA4O1xuICAgIGNkc1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgIGNkc1N0eWxlLkxBQkVMID0gdHJ1ZTtcbiAgICBjZHNTdHlsZS5aSU5ERVggPSAxMDtcbiAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2Nkcyd9LCBudWxsLCBjZHNTdHlsZSk7XG5cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdTUVVBUkUnO1xuICAgICAgICB2YXJTdHlsZS5CVU1QID0gJ3llcyc7XG4gICAgICAgIHZhclN0eWxlLkxBQkVMID0gJ25vJztcbiAgICAgICAgLy8gdmFyU3R5bGUuQkdDT0xPUiA9ICcjODg4ODg4JztcbiAgICAgICAgdmFyU3R5bGUuRkdDT0xPUiA9ICdibHVlJztcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICd2YXJpYXRpb24nLCBtZXRob2Q6ICcuK19VVFJfdmFyaWFudCd9LCBudWxsLCB2YXJTdHlsZSk7XG4gICAgfVxuICAgIHtcbiAgICAgICAgdmFyIHZhclN0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHZhclN0eWxlLmdseXBoID0gJ1RSSUFOR0xFJztcbiAgICAgICAgdmFyU3R5bGUuRElSRUNUSU9OID0gJ1MnO1xuICAgICAgICB2YXJTdHlsZS5CVU1QID0gJ3llcyc7XG4gICAgICAgIHZhclN0eWxlLkxBQkVMID0gJ25vJztcbiAgICAgICAgLy8gdmFyU3R5bGUuQkdDT0xPUiA9ICcjODg4ODg4JztcbiAgICAgICAgdmFyU3R5bGUuRkdDT0xPUiA9ICdibHVlJztcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICd2YXJpYXRpb24nLCBtZXRob2Q6ICdtaXNzZW5zZV92YXJpYW50J30sIG51bGwsIHZhclN0eWxlKTtcbiAgICB9XG4gICAge1xuICAgICAgICB2YXIgdmFyU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgdmFyU3R5bGUuZ2x5cGggPSAnVFJJQU5HTEUnO1xuICAgICAgICB2YXJTdHlsZS5ESVJFQ1RJT04gPSAnTic7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICAvLyB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ2JsdWUnO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3ZhcmlhdGlvbicsIG1ldGhvZDogJ3NwbGljZV8uK192YXJpYW50J30sIG51bGwsIHZhclN0eWxlKTtcbiAgICB9XG4gICAge1xuICAgICAgICB2YXIgdmFyU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgdmFyU3R5bGUuZ2x5cGggPSAnU1RBUic7XG4gICAgICAgIHZhclN0eWxlLlBPSU5UUyA9IDY7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICAvLyB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ2JsdWUnO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3ZhcmlhdGlvbicsIG1ldGhvZDogJ3JlZ3VsYXRvcnlfcmVnaW9uX3ZhcmlhbnQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdQTElNU09MTCc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICAvLyB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ3JnYig1MCw4MCwyNTUpJztcbiAgICAgICAgdmFyU3R5bGUuU1RST0tFQ09MT1IgPSAnYmxhY2snO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3ZhcmlhdGlvbid9LCBudWxsLCB2YXJTdHlsZSk7XG4gICAgfVxuICAgICAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdTUVVBUkUnO1xuICAgICAgICB2YXJTdHlsZS5CVU1QID0gJ3llcyc7XG4gICAgICAgIHZhclN0eWxlLkxBQkVMID0gJ25vJztcbiAgICAgICAgdmFyU3R5bGUuQkdDT0xPUiA9ICcjODg4ODg4JztcbiAgICAgICAgdmFyU3R5bGUuRkdDT0xPUiA9ICdyZWQnO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2luZGVsJywgbWV0aG9kOiAnLitfVVRSX3ZhcmlhbnQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdUUklBTkdMRSc7XG4gICAgICAgIHZhclN0eWxlLkRJUkVDVElPTiA9ICdTJztcbiAgICAgICAgdmFyU3R5bGUuQlVNUCA9ICd5ZXMnO1xuICAgICAgICB2YXJTdHlsZS5MQUJFTCA9ICdubyc7XG4gICAgICAgIHZhclN0eWxlLkJHQ09MT1IgPSAnIzg4ODg4OCc7XG4gICAgICAgIHZhclN0eWxlLkZHQ09MT1IgPSAncmVkJztcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdpbmRlbCcsIG1ldGhvZDogJ21pc3NlbnNlX3ZhcmlhbnQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdUUklBTkdMRSc7XG4gICAgICAgIHZhclN0eWxlLkRJUkVDVElPTiA9ICdOJztcbiAgICAgICAgdmFyU3R5bGUuQlVNUCA9ICd5ZXMnO1xuICAgICAgICB2YXJTdHlsZS5MQUJFTCA9ICdubyc7XG4gICAgICAgIHZhclN0eWxlLkJHQ09MT1IgPSAnIzg4ODg4OCc7XG4gICAgICAgIHZhclN0eWxlLkZHQ09MT1IgPSAncmVkJztcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdpbmRlbCcsIG1ldGhvZDogJ3NwbGljZV8uK192YXJpYW50J30sIG51bGwsIHZhclN0eWxlKTtcbiAgICB9XG4gICAge1xuICAgICAgICB2YXIgdmFyU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgdmFyU3R5bGUuZ2x5cGggPSAnU1RBUic7XG4gICAgICAgIHZhclN0eWxlLlBPSU5UUyA9IDY7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ3JlZCc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnaW5kZWwnLCBtZXRob2Q6ICdyZWd1bGF0b3J5X3JlZ2lvbl92YXJpYW50J30sIG51bGwsIHZhclN0eWxlKTtcbiAgICB9XG4gICAge1xuICAgICAgICB2YXIgdmFyU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgdmFyU3R5bGUuZ2x5cGggPSAnUExJTVNPTEwnO1xuICAgICAgICB2YXJTdHlsZS5CVU1QID0gJ3llcyc7XG4gICAgICAgIHZhclN0eWxlLkxBQkVMID0gJ25vJztcbiAgICAgICAgdmFyU3R5bGUuQkdDT0xPUiA9ICcjODg4ODg4JztcbiAgICAgICAgdmFyU3R5bGUuRkdDT0xPUiA9ICdyZWQnO1xuICAgICAgICB2YXJTdHlsZS5TVFJPS0VDT0xPUiA9ICdibGFjayc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnaW5kZWwnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cblxuICAgIHZhciB3aWdTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgIHdpZ1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgd2lnU3R5bGUuQkdDT0xPUiA9ICdvcmFuZ2UnXG4gICAgd2lnU3R5bGUuSEVJR0hUID0gODtcbiAgICB3aWdTdHlsZS5CVU1QID0gdHJ1ZTtcbiAgICB3aWdTdHlsZS5MQUJFTCA9IHRydWU7XG4gICAgd2lnU3R5bGUuWklOREVYID0gMjA7XG4gICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZWZhdWx0J30sIG51bGwsIHdpZ1N0eWxlKTtcbiAgICByZXR1cm4gY2FsbGJhY2soc3R5bGVzaGVldCk7XG59XG5cblxuRW5zZW1ibEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFNjYWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbXTtcbn1cblxuRW5zZW1ibEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdmFyIHVybCA9IHRoaXMuYmFzZSArICcvb3ZlcmxhcC9yZWdpb24vJyArIHRoaXMuc3BlY2llcyArICcvJyArIGNociArICc6JyArIG1pbiArICctJyArIG1heDtcblxuICAgIHZhciBmaWx0ZXJzID0gW107XG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudHlwZS5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgZmlsdGVycy5wdXNoKCdmZWF0dXJlPScgKyB0aGlzLnR5cGVbdGldKTtcbiAgICB9XG4gICAgZmlsdGVycy5wdXNoKCdjb250ZW50LXR5cGU9YXBwbGljYXRpb24vanNvbicpO1xuICAgIHVybCA9IHVybCArICc/JyArIGZpbHRlcnMuam9pbignOycpO1xuXG4gICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBcdGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgXHQgICAgaWYgKHJlcS5zdGF0dXMgPj0gMzAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9ICdFcnJvciBjb2RlICcgKyByZXEuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBqciA9IEpTT04ucGFyc2UocmVxLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpyLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBqci5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7fTtcblxuICAgIFx0XHQgICAgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICBcdCAgICB9IGVsc2Uge1xuICAgICAgICBcdFx0dmFyIGpmID0gSlNPTi5wYXJzZShyZXEucmVzcG9uc2UpO1xuICAgICAgICBcdFx0dmFyIGZlYXR1cmVzID0gW107XG4gICAgICAgIFx0XHRmb3IgKHZhciBmaSA9IDA7IGZpIDwgamYubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIFx0XHQgICAgdmFyIGogPSBqZltmaV07XG5cbiAgICAgICAgXHRcdCAgICB2YXIgbm90ZXMgPSBbXTtcbiAgICAgICAgXHRcdCAgICB2YXIgZiA9IG5ldyBEQVNGZWF0dXJlKCk7XG4gICAgICAgIFx0XHQgICAgZi5zZWdtZW50ID0gY2hyO1xuICAgICAgICBcdFx0ICAgIGYubWluID0galsnc3RhcnQnXSB8IDA7XG4gICAgICAgIFx0XHQgICAgZi5tYXggPSBqWydlbmQnXSB8IDA7XG4gICAgICAgIFx0XHQgICAgZi50eXBlID0gai5mZWF0dXJlX3R5cGUgfHwgJ3Vua25vd24nO1xuICAgICAgICBcdFx0ICAgIGYuaWQgPSBqLklEO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqLlBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdycCA9IG5ldyBEQVNHcm91cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JwLmlkID0gai5QYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmdyb3VwcyA9IFtncnBdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGouc3RyYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoai5zdHJhbmQgPCAwKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLm9yaWVudGF0aW9uID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoai5zdHJhbmQgPiAwKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLm9yaWVudGF0aW9uID0gJysnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGouY29uc2VxdWVuY2VfdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGYubWV0aG9kID0gai5jb25zZXF1ZW5jZV90eXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChqLmFsdF9hbGxlbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3Rlcy5wdXNoKCdBbGxlbGVzPScgKyBqLmFsdF9hbGxlbGVzLmpvaW4oJy8nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoai5hbHRfYWxsZWxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGouYWx0X2FsbGVsZXNbMV0ubGVuZ3RoICE9IGouYWx0X2FsbGVsZXNbMF0ubGVuZ3RoIHx8IGouYWx0X2FsbGVsZXNbMV0gPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYudHlwZSA9ICdpbmRlbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFx0XHQgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChub3Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLm5vdGVzID0gbm90ZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXHRcdCAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICBcdFx0fVxuICAgICAgICBcdFx0Y2FsbGJhY2sobnVsbCwgZmVhdHVyZXMpO1xuICAgIFx0ICAgIH1cbiAgICBcdH1cblx0XG4gICAgfTtcbiAgICBcbiAgICB0aGlzQi5idXN5Kys7XG4gICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcblxuICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHJlcS5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgcmVxLnNlbmQoJycpO1xufVxuXG5kYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSgnZW5zZW1ibCcsIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHJldHVybiB7ZmVhdHVyZXM6IG5ldyBFbnNlbWJsRmVhdHVyZVNvdXJjZShzb3VyY2UpfTtcbn0pO1xuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIGV4cG9ydC1jb25maWcuanNcbi8vXG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Nicm93c2VyJyk7XG4gICAgdmFyIEJyb3dzZXIgPSBicm93c2VyLkJyb3dzZXI7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIHNoYWxsb3dDb3B5ID0gdXRpbHMuc2hhbGxvd0NvcHk7XG5cbiAgICB2YXIgc2hhMSA9IHJlcXVpcmUoJy4vc2hhMScpO1xuICAgIHZhciBoZXhfc2hhMSA9IHNoYTEuaGV4X3NoYTE7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgY29weVN0eWxlc2hlZXQgPSBkYXMuY29weVN0eWxlc2hlZXQ7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmV4cG9ydEZ1bGxDb25maWcgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICBjaHI6IHRoaXMuY2hyLFxuICAgICAgICB2aWV3U3RhcnQ6IHRoaXMudmlld1N0YXJ0fDAsXG4gICAgICAgIHZpZXdFbmQ6IHRoaXMudmlld0VuZHwwLFxuICAgICAgICBjb29raWVLZXk6ICdkYWxsaWFuY2VfJyArIGhleF9zaGExKERhdGUubm93KCkpLFxuXG4gICAgICAgIGNvb3JkU3lzdGVtOiB0aGlzLmNvb3JkU3lzdGVtLFxuXG4gICAgICAgIHNvdXJjZXM6IHRoaXMuZXhwb3J0U291cmNlQ29uZmlnKCksXG5cbiAgICAgICAgY2hhaW5zOiB0aGlzLmV4cG9ydENoYWlucygpXG4gICAgfTtcblxuICAgIGlmICh0aGlzLnByZWZpeClcbiAgICAgICAgY29uZmlnLnByZWZpeCA9IHRoaXMucHJlZml4O1xuXG4gICAgcmV0dXJuIGNvbmZpZztcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuZXhwb3J0Q2hhaW5zID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNjID0ge307XG4gICAgdmFyIGNzID0gdGhpcy5jaGFpbnMgfHwge307XG4gICAgZm9yICh2YXIgayBpbiBjcykge1xuICAgICAgICBjY1trXSA9IGNzW2tdLmV4cG9ydENvbmZpZygpO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmV4cG9ydFNvdXJjZUNvbmZpZyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciBzb3VyY2VDb25maWcgPSBbXTtcbiAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdGkpIHtcbiAgICAgICAgdmFyIHRpZXIgPSB0aGlzLnRpZXJzW3RpXTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNoYWxsb3dDb3B5KHRpZXIuZGFzU291cmNlKTtcblxuICAgICAgICBpZiAoc291cmNlLm5vUGVyc2lzdClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHNvdXJjZS5jb29yZHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNvdXJjZS5wcm9wcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFzb3VyY2UuZGlzYWJsZWQpXG4gICAgICAgICAgICBzb3VyY2UuZGlzYWJsZWQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHRpZXIuY29uZmlnLnN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgIHNvdXJjZS5zdHlsZSA9IGNvcHlTdHlsZXNoZWV0KHRpZXIuY29uZmlnLnN0eWxlc2hlZXQpLnN0eWxlcztcbiAgICAgICAgICAgIHNvdXJjZS5zdHlsZXNoZWV0X3VyaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc3R5bGUpIHtcbiAgICAgICAgICAgIHNvdXJjZS5zdHlsZSA9IGNvcHlTdHlsZXNoZWV0KHtzdHlsZXM6IHNvdXJjZS5zdHlsZX0pLnN0eWxlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YodGllci5jb25maWcubmFtZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzb3VyY2UubmFtZSA9IHRpZXIuY29uZmlnLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGllci5jb25maWcuaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNvdXJjZS5mb3JjZUhlaWdodCA9IHRpZXIuY29uZmlnLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGllci5jb25maWcuZm9yY2VNaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc291cmNlLmZvcmNlTWluID0gdGllci5jb25maWcuZm9yY2VNaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpZXIuY29uZmlnLmZvcmNlTWluRHluYW1pYylcbiAgICAgICAgICAgIHNvdXJjZS5mb3JjZU1pbkR5bmFtaWMgPSB0aWVyLmNvbmZpZy5mb3JjZU1pbkR5bmFtaWM7XG4gICAgICAgIGlmICh0aWVyLmNvbmZpZy5mb3JjZU1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzb3VyY2UuZm9yY2VNYXggPSB0aWVyLmNvbmZpZy5mb3JjZU1heDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGllci5jb25maWcuYnVtcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNvdXJjZS5idW1wZWQgPSB0aWVyLmNvbmZpZy5idW1wZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpZXIuY29uZmlnLmZvcmNlTWF4RHluYW1pYylcbiAgICAgICAgICAgIHNvdXJjZS5mb3JjZU1heER5bmFtaWMgPSB0aWVyLmNvbmZpZy5mb3JjZU1heER5bmFtaWM7XG5cbiAgICAgICAgc291cmNlQ29uZmlnLnB1c2goc291cmNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc291cmNlQ29uZmlnO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5leHBvcnRQYWdlVGVtcGxhdGUgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHRlbXBsYXRlID0gJzxodG1sPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgIDxoZWFkPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgICAgPHNjcmlwdCBsYW5ndWFnZT1cImphdmFzY3JpcHRcIiBzcmM9XCInICsgdGhpcy5yZXNvbHZlVVJMKCckJGRhbGxpYW5jZS1jb21waWxlZC5qcycpICsgJ1wiPjwvc2NyaXB0PlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgICAgPHNjcmlwdCBsYW5ndWFnZT1cImphdmFzY3JpcHRcIj5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAnICAgICAgdmFyIGRhbGxpYW5jZV9icm93c2VyID0gbmV3IEJyb3dzZXIoJyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwb3J0RnVsbENvbmZpZyhvcHRzKSwgbnVsbCwgMikgKyAnKTtcXG4nICtcbiAgICAgICAgICAgICAgICAgICAnICAgIDwvc2NyaXB0PlxcbicgKyAgXG4gICAgICAgICAgICAgICAgICAgJyAgPC9oZWFkPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgIDxib2R5PlxcbicgK1xuICAgICAgICAgICAgICAgICAgICcgICAgPGRpdiBpZD1cInN2Z0hvbGRlclwiPkRhbGxpYW5jZSBnb2VzIGhlcmU8L2Rpdj5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAnICA8L2JvZHk+XFxuJyArXG4gICAgICAgICAgICAgICAgICAgJzxodG1sPlxcbic7XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG59IiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIGV4cG9ydC1pbWFnZS5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Nicm93c2VyJyk7XG4gICAgdmFyIEJyb3dzZXIgPSBicm93c2VyLkJyb3dzZXI7XG5cbiAgICB2YXIgZyA9IHJlcXVpcmUoJy4vZ2x5cGhzJyk7XG4gICAgdmFyIE92ZXJsYXlMYWJlbENhbnZhcyA9IGcuT3ZlcmxheUxhYmVsQ2FudmFzO1xuXG4gICAgdmFyIG5mID0gcmVxdWlyZSgnLi9udW1mb3JtYXRzJyk7XG4gICAgdmFyIGZvcm1hdFF1YW50TGFiZWwgPSBuZi5mb3JtYXRRdWFudExhYmVsO1xuXG4gICAgdmFyIGRyYXdTZXFUaWVyR0MgPSByZXF1aXJlKCcuL3NlcXVlbmNlLWRyYXcnKS5kcmF3U2VxVGllckdDO1xufVxuXG5mdW5jdGlvbiBmaWxsVGV4dFJpZ2h0SnVzdGlmaWVkKGcsIHRleHQsIHgsIHkpIHtcbiAgICBnLmZpbGxUZXh0KHRleHQsIHggLSBnLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoLCB5KTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuZXhwb3J0SW1hZ2UgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICB2YXIgZnB3ID0gdGhpcy5mZWF0dXJlUGFuZWxXaWR0aDtcbiAgICB2YXIgcGFkZGluZyA9IDM7XG4gICAgdmFyIHRvdEhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgIGlmICh0aSA+IDApXG4gICAgICAgICAgICB0b3RIZWlnaHQgKz0gcGFkZGluZztcbiAgICAgICAgdmFyIHRpZXIgPSB0aGlzLnRpZXJzW3RpXTtcbiAgICAgICAgaWYgKHRpZXIubGF5b3V0SGVpZ2h0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0b3RIZWlnaHQgKz0gdGllci5sYXlvdXRIZWlnaHQ7XG4gICAgfVxuICAgIHZhciBtdWx0ID0gb3B0cy5yZXNvbHV0aW9uTXVsdGlwbGllciB8fCAxLjA7XG4gICAgdmFyIG1hcmdpbiA9IDIwMDtcblxuXG4gICAgdmFyIGN3ID0gKChmcHcgKyBtYXJnaW4pICogbXVsdCl8MDtcbiAgICB2YXIgY2ggPSAodG90SGVpZ2h0ICogbXVsdCl8MDtcbiAgICB2YXIgYyA9IG1ha2VFbGVtZW50KCdjYW52YXMnLCBudWxsLCB7d2lkdGg6IGN3LCBoZWlnaHQ6IGNofSk7XG4gICAgdmFyIGcgPSBjLmdldENvbnRleHQoJzJkJyk7XG4gICAgZy5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGcuZmlsbFJlY3QoMCwgMCwgY3csIGNoKTtcblxuICAgIGcuc2NhbGUobXVsdCwgbXVsdCk7XG4gICAgXG4gICAgdmFyIHlwb3MgPSAwO1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgdGllciA9IHRoaXMudGllcnNbdGldO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gKCh0aWVyLmdseXBoQ2FjaGVPcmlnaW4gLSB0aGlzLnZpZXdTdGFydCkqdGhpcy5zY2FsZSk7XG5cbiAgICAgICAgdmFyIG9jID0gbmV3IE92ZXJsYXlMYWJlbENhbnZhcygpO1xuICAgICAgICBnLnNhdmUoKTsgICAgICAgLy8gMVxuICAgICAgICBnLnRyYW5zbGF0ZSgwLCB5cG9zKTtcblxuICAgICAgICBnLnNhdmUoKTsgICAgICAgLy8gMlxuICAgICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgICBnLm1vdmVUbyhtYXJnaW4sIDApO1xuICAgICAgICBnLmxpbmVUbyhtYXJnaW4gKyBmcHcsIDApO1xuICAgICAgICBnLmxpbmVUbyhtYXJnaW4gKyBmcHcsIHRpZXIubGF5b3V0SGVpZ2h0KTtcbiAgICAgICAgZy5saW5lVG8obWFyZ2luLCB0aWVyLmxheW91dEhlaWdodCk7XG4gICAgICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgICAgIGcuY2xpcCgpO1xuICAgICAgICBnLnRyYW5zbGF0ZShtYXJnaW4sIDApO1xuXG4gICAgICAgIGcuc2F2ZSgpOyAgICAgIC8vIDNcbiAgICAgICAgZy50cmFuc2xhdGUob2Zmc2V0LCAwKTtcbiAgICAgICAgaWYgKHRpZXIuc3VidGllcnMpIHtcbiAgICAgICAgICAgIHRpZXIucGFpbnRUb0NvbnRleHQoZywgb2MsIG9mZnNldCArIDEwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd1NlcVRpZXJHQyh0aWVyLCB0aWVyLmN1cnJlbnRTZXF1ZW5jZSwgZyk7XG4gICAgICAgIH1cbiAgICAgICAgZy5yZXN0b3JlKCk7ICAgLy8gMlxuICAgICAgICBcbiAgICAgICAgZy5zYXZlKCkgICAgICAgLy8gM1xuICAgICAgICBnLnRyYW5zbGF0ZShvZmZzZXQsIDApO1xuICAgICAgICBvYy5kcmF3KGcsIC1vZmZzZXQsIGZwdyAtIG9mZnNldCk7XG4gICAgICAgIGcucmVzdG9yZSgpOyAgIC8vIDJcbiAgICAgICAgZy5yZXN0b3JlKCk7ICAgLy8gMVxuXG4gICAgICAgIHZhciBoYXNRdWFudCA9IGZhbHNlO1xuICAgICAgICB2YXIgcG9zID0gMDtcbiAgICAgICAgdmFyIHN1YnRpZXJzID0gdGllci5zdWJ0aWVycyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgc3RpID0gMDsgc3RpIDwgc3VidGllcnMubGVuZ3RoOyArK3N0aSkge1xuICAgICAgICAgICAgdmFyIHN1YnRpZXIgPSBzdWJ0aWVyc1tzdGldO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzdWJ0aWVyLnF1YW50KSB7XG4gICAgICAgICAgICAgICAgaGFzUXVhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBxID0gc3VidGllci5xdWFudDtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHN1YnRpZXIuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgdmFyIG51bVRpY3MgPSAyO1xuICAgICAgICAgICAgICAgIGlmIChoID4gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgbnVtVGljcyA9IDEgKyAoKGgvMjApIHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0aWNTcGFjaW5nID0gaCAvIChudW1UaWNzIC0gMSk7XG4gICAgICAgICAgICAgICAgdmFyIHRpY0ludGVydmFsID0gKHEubWF4IC0gcS5taW4pIC8gKG51bVRpY3MgLSAxKTtcblxuICAgICAgICAgICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICAgICAgZy5tb3ZlVG8obWFyZ2luICsgNSwgcG9zKTtcbiAgICAgICAgICAgICAgICBnLmxpbmVUbyhtYXJnaW4sIHBvcyk7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8obWFyZ2luLCBwb3MgKyBzdWJ0aWVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8obWFyZ2luICsgNSwgcG9zICsgc3VidGllci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5ID0gdCp0aWNTcGFjaW5nO1xuICAgICAgICAgICAgICAgICAgICBnLm1vdmVUbyhtYXJnaW4sIHBvcyArIHR5KTtcbiAgICAgICAgICAgICAgICAgICAgZy5saW5lVG8obWFyZ2luKzMsIHBvcyArIHR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZy5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgICAgICAgZy5zdHJva2VXaWR0aCA9IDI7XG4gICAgICAgICAgICAgICAgZy5zdHJva2UoKTtcblxuICAgICAgICAgICAgICAgIGcuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgICAgICAgICBmaWxsVGV4dFJpZ2h0SnVzdGlmaWVkKGcsIGZvcm1hdFF1YW50TGFiZWwocS5tYXgpLCBtYXJnaW4gLSAzLCBwb3MgKyA3KTtcbiAgICAgICAgICAgICAgICBmaWxsVGV4dFJpZ2h0SnVzdGlmaWVkKGcsIGZvcm1hdFF1YW50TGFiZWwocS5taW4pLCBtYXJnaW4gLSAzLCBwb3MgKyBzdWJ0aWVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDE7IHQgPCBudW1UaWNzLTE7ICsrdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxUZXh0UmlnaHRKdXN0aWZpZWQoZywgZm9ybWF0UXVhbnRMYWJlbCgoMS4wKnEubWF4KSAtICh0KnRpY0ludGVydmFsKSksIG1hcmdpbiAtIDMsIHBvcyArIHR5ICsgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwb3MgKz0gc3VidGllci5oZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhYmVsTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aWVyLmNvbmZpZy5uYW1lID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIGxhYmVsTmFtZSA9IHRpZXIuY29uZmlnLm5hbWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxhYmVsTmFtZSA9IHRpZXIuZGFzU291cmNlLm5hbWU7XG4gICAgICAgIHZhciBsYWJlbFdpZHRoID0gZy5tZWFzdXJlVGV4dChsYWJlbE5hbWUpLndpZHRoO1xuICAgICAgICBnLmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICAgIGcuZmlsbFRleHQobGFiZWxOYW1lLCBtYXJnaW4gLSAoaGFzUXVhbnQgPyAyMiA6IDEyKSAtIGxhYmVsV2lkdGgsICh0aWVyLmxheW91dEhlaWdodCArIDYpIC8gMik7XG5cbiAgICAgICAgZy5yZXN0b3JlKCk7IC8vIDBcblxuICAgICAgICB5cG9zICs9IHRpZXIubGF5b3V0SGVpZ2h0ICsgcGFkZGluZztcbiAgICB9XG5cbiAgICBpZiAob3B0cy5oaWdobGlnaHRzKSB7XG4gICAgICAgIGcuc2F2ZSgpO1xuXG4gICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgIGcubW92ZVRvKG1hcmdpbiwgMCk7XG4gICAgICAgIGcubGluZVRvKG1hcmdpbiArIGZwdywgMCk7XG4gICAgICAgIGcubGluZVRvKG1hcmdpbiArIGZwdywgeXBvcyk7XG4gICAgICAgIGcubGluZVRvKG1hcmdpbiwgeXBvcyk7XG4gICAgICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgICAgIGcuY2xpcCgpO1xuXG4gICAgICAgIGcudHJhbnNsYXRlKG1hcmdpbiArIG9mZnNldCwgMCk7XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLnZpZXdTdGFydDtcbiAgICAgICAgdmFyIHZpc1N0YXJ0ID0gdGhpcy52aWV3U3RhcnQ7XG4gICAgICAgIHZhciB2aXNFbmQgPSB0aGlzLnZpZXdFbmQ7XG5cbiAgICAgICAgZm9yICh2YXIgaGkgPSAwOyBoaSA8IHRoaXMuaGlnaGxpZ2h0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgIHZhciBoID0gdGhpcy5oaWdobGlnaHRzW2hpXTtcbiAgICAgICAgICAgIGlmICgoKGguY2hyID09PSB0aGlzLmNocikgfHwgKGguY2hyID09PSAoJ2NocicgKyB0aGlzLmNocikpKSAmJiBoLm1pbiA8IHZpc0VuZCAmJiBoLm1heCA+IHZpc1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZy5nbG9iYWxBbHBoYSA9IHRoaXMuZGVmYXVsdEhpZ2hsaWdodEFscGhhO1xuICAgICAgICAgICAgICAgIGcuZmlsbFN0eWxlID0gdGhpcy5kZWZhdWx0SGlnaGxpZ2h0RmlsbDtcbiAgICAgICAgICAgICAgICBnLmZpbGxSZWN0KChoLm1pbiAtIG9yaWdpbikgKiB0aGlzLnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChoLm1heCAtIGgubWluKSAqIHRoaXMuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB5cG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgZy5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGVyUG9zID0gLTE7IFxuICAgIGlmIChvcHRzLnJ1bGVyID09ICdjZW50ZXInKSB7XG4gICAgICAgIHJ1bGVyUG9zID0gbWFyZ2luICsgKCh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCArIDEpKnRoaXMuc2NhbGUpIC8gMjtcbiAgICB9IGVsc2UgaWYgKG9wdHMucnVsZXIgPT0gJ2xlZnQnKSB7XG4gICAgICAgIHJ1bGVyUG9zID0gbWFyZ2luO1xuICAgIH0gZWxzZSBpZiAob3B0cy5ydWxlciA9PSAncmlnaHQnKSB7XG4gICAgICAgIHJ1bGVyUG9zID0gbWFyZ2luICsgKCh0aGlzLnZpZXdFbmQgLSB0aGlzLnZpZXdTdGFydCArIDEpKnRoaXMuc2NhbGUpO1xuICAgIH1cbiAgICBpZiAocnVsZXJQb3MgPj0gMCkge1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgICBnLm1vdmVUbyhydWxlclBvcywgMCk7XG4gICAgICAgIGcubGluZVRvKHJ1bGVyUG9zLCB5cG9zKTtcbiAgICAgICAgZy5zdHJva2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xufSIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTRcbi8vXG4vLyBleHBvcnQtdWkuanNcbi8vXG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Nicm93c2VyJyk7XG4gICAgdmFyIEJyb3dzZXIgPSBicm93c2VyLkJyb3dzZXI7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIG1ha2VFbGVtZW50ID0gdXRpbHMubWFrZUVsZW1lbnQ7XG4gICAgdmFyIHJlbW92ZUNoaWxkcmVuID0gdXRpbHMucmVtb3ZlQ2hpbGRyZW47XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLm9wZW5FeHBvcnRQYW5lbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiID0gdGhpcztcbiAgICBpZiAodGhpcy51aU1vZGUgPT09ICdleHBvcnQnKSB7XG4gICAgICAgIHRoaXMuaGlkZVRvb2xQYW5lbCgpO1xuICAgICAgICB0aGlzLnNldFVpTW9kZSgnbm9uZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBvcnRGb3JtID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHtjbGFzc05hbWU6ICdleHBvcnQtZm9ybSd9KTtcbiAgICAgICAgdmFyIGV4cG9ydFNlbGVjdCA9IG1ha2VFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnU1ZHJywge3ZhbHVlOiAnc3ZnJ30pKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnSW1hZ2UnLCB7dmFsdWU6ICdwbmcnfSkpO1xuICAgICAgICBleHBvcnRTZWxlY3QuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsICdEYWxsaWFuY2UgY29uZmlnJywge3ZhbHVlOiAnY29uZmlnJ30pKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnRGFsbGlhbmNlIHNvdXJjZXMnLCB7dmFsdWU6ICdzb3VyY2VzJ30pKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnRGFsbGlhbmNlIHBhZ2UnLCB7dmFsdWU6ICdwYWdlJ30pKTtcbiAgICAgICAgZXhwb3J0U2VsZWN0LnZhbHVlID0gJ3N2Zyc7XG5cbiAgICAgICAgZXhwb3J0U2VsZWN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihleHBvcnRDb250ZW50KTtcbiAgICAgICAgICAgIHNldHVwRU9UKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgZXhwb3J0Rm9ybS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFsnRXhwb3J0IGFzOiAnLCBleHBvcnRTZWxlY3RdKSk7XG5cbiAgICAgICAgdmFyIGV4cG9ydEhpZ2hsaWdodHNUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94JywgY2hlY2tlZDogdGhpcy5leHBvcnRIaWdobGlnaHRzfSk7XG4gICAgICAgIGV4cG9ydEhpZ2hsaWdodHNUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGIuZXhwb3J0SGlnaGxpZ2h0cyA9IGV4cG9ydEhpZ2hsaWdodHNUb2dnbGUuY2hlY2tlZDtcbiAgICAgICAgICAgIGIuc3RvcmVTdGF0dXMoKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB2YXIgZXhwb3J0UnVsZXJUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94JywgY2hlY2tlZDogdGhpcy5leHBvcnRSdWxlcn0pO1xuICAgICAgICBleHBvcnRSdWxlclRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgYi5leHBvcnRSdWxlciA9IGV4cG9ydFJ1bGVyVG9nZ2xlLmNoZWNrZWQ7XG4gICAgICAgICAgICBiLnN0b3JlU3RhdHVzKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgdmFyIGV4cG9ydFNjYWxlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcxLjAnfSk7XG5cbiAgICAgICAgdmFyIGV4cG9ydEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdidXR0b24nLCAnRXhwb3J0Jywge2NsYXNzTmFtZTogJ2J0biBidG4tcHJpbWFyeSd9KTtcbiAgICAgICAgZXhwb3J0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGV4cG9ydENvbnRlbnQpO1xuXG4gICAgICAgICAgICB2YXIgYmxvYlVSTDtcbiAgICAgICAgICAgIHZhciBub3RlLCB0eXBlLCBuYW1lO1xuICAgICAgICAgICAgaWYgKGV4cG9ydFNlbGVjdC52YWx1ZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICBibG9iVVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChiLm1ha2VTVkcoe2hpZ2hsaWdodHM6IGV4cG9ydEhpZ2hsaWdodHNUb2dnbGUuY2hlY2tlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVyOiBleHBvcnRSdWxlclRvZ2dsZS5jaGVja2VkID8gYi5ydWxlckxvY2F0aW9uIDogJ25vbmUnfSkpO1xuICAgICAgICAgICAgICAgIG5vdGUgPSAnU1ZHJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2ltYWdlL3N2Zyc7XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdkYWxsaWFuY2Utdmlldy5zdmcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHBvcnRTZWxlY3QudmFsdWUgPT09ICdwbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIG11bHQgPSBwYXJzZUZsb2F0KGV4cG9ydFNjYWxlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAobXVsdCA8IDAuMSB8fCBtdWx0ID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ2JhZCBzY2FsZSAnICsgbXVsdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBibG9iVVJMID0gYi5leHBvcnRJbWFnZSh7aGlnaGxpZ2h0czogZXhwb3J0SGlnaGxpZ2h0c1RvZ2dsZS5jaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcjogZXhwb3J0UnVsZXJUb2dnbGUuY2hlY2tlZCA/IGIucnVsZXJMb2NhdGlvbiA6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x1dGlvbk11bHRpcGxpZXI6IG11bHR9KTtcbiAgICAgICAgICAgICAgICBub3RlID0gJ0ltYWdlJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2ltYWdlL3BuZyc7XG4gICAgICAgICAgICAgICAgbmFtZSA9ICdkYWxsaWFuY2Utdmlldy5wbmcnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChleHBvcnRTZWxlY3QudmFsdWUgPT09ICdjb25maWcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbmZpZyA9IEpTT04uc3RyaW5naWZ5KGIuZXhwb3J0RnVsbENvbmZpZygpLCBudWxsLCAyKTtcbiAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtjb25maWddLCB7dHlwZTogJ3RleHQvcGxhaW4nfSk7XG4gICAgICAgICAgICAgICAgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgbm90ZSA9ICdDb25maWd1cmF0aW9uJztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnZGFsbGlhbmNlLWNvbmZpZy5qc29uJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXhwb3J0U2VsZWN0LnZhbHVlID09PSAnc291cmNlcycpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gSlNPTi5zdHJpbmdpZnkoYi5leHBvcnRTb3VyY2VDb25maWcoKSwgbnVsbCwgMik7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbY29uZmlnXSwge3R5cGU6ICd0ZXh0L3BsYWluJ30pO1xuICAgICAgICAgICAgICAgIGJsb2JVUkwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgIG5vdGUgPSAnU291cmNlIGFycmF5JztcbiAgICAgICAgICAgICAgICB0eXBlID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgIG5hbWUgPSAnZGFsbGlhbmNlLXNvdXJjZXMuanNvbic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV4cG9ydFNlbGVjdC52YWx1ZSA9PT0gJ3BhZ2UnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhZ2UgPSBiLmV4cG9ydFBhZ2VUZW1wbGF0ZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gJ3RleHQvaHRtbCc7XG4gICAgICAgICAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbcGFnZV0sIHt0eXBlOiB0eXBlfSk7XG4gICAgICAgICAgICAgICAgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgICAgICAgbm90ZSA9ICdQYWdlIHRlbXBsYXRlJztcbiAgICAgICAgICAgICAgICBuYW1lID0gJ2RhbGxpYW5jZS12aWV3Lmh0bWwnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYmxvYlVSTCkge1xuICAgICAgICAgICAgICAgIHZhciBkb3dubG9hZExpbmsgPSBtYWtlRWxlbWVudCgnYScsICdbRG93bmxvYWRdJywge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBibG9iVVJMLFxuICAgICAgICAgICAgICAgICAgICBkb3dubG9hZDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIHByZXZpZXdMaW5rID0gbWFrZUVsZW1lbnQoJ2EnLCAnW1ByZXZpZXcgaW4gYnJvd3Nlcl0nLCB7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6IGJsb2JVUkwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ19uZXcnXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBleHBvcnRDb250ZW50LmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgWycnICsgbm90ZSArICcgY3JlYXRlZDogJywgZG93bmxvYWRMaW5rLCBwcmV2aWV3TGlua10pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIGIuYWRkVmlld0xpc3RlbmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oZXhwb3J0Q29udGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBiLmFkZFRpZXJMaXN0ZW5lcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGV4cG9ydENvbnRlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZXhwb3J0Q29udGVudCA9IG1ha2VFbGVtZW50KCdwJywgJycpO1xuXG4gICAgICAgIHZhciBlb3RIaWdobGlnaHRzID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ0luY2x1ZGUgaGlnaGxpZ2h0cycsIHt9LCB7d2lkdGg6ICcyMDBweCcsIHRleHRBbGlnbjogJ3JpZ2h0J30pLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBleHBvcnRIaWdobGlnaHRzVG9nZ2xlKV0pO1xuICAgICAgICB2YXIgZW90R3VpZGVsaW5lID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ0luY2x1ZGUgdmVydGljYWwgZ3VpZGVsaW5lJyksXG4gICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIGV4cG9ydFJ1bGVyVG9nZ2xlKV0pO1xuICAgICAgICB2YXIgZW90U2NhbGUgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdTY2FsZSBtdWx0aXBsaWVyJyksXG4gICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgZXhwb3J0U2NhbGUpXSk7XG5cbiAgICAgICAgdmFyIGV4cG9ydE9wdHNUYWJsZSA9IG1ha2VFbGVtZW50KCd0YWJsZScsXG4gICAgICAgICAgICBbZW90SGlnaGxpZ2h0cyxcbiAgICAgICAgICAgICBlb3RHdWlkZWxpbmUsXG4gICAgICAgICAgICAgZW90U2NhbGVdKTtcbiAgICAgICAgdmFyIHNldHVwRU9UID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZXMgPSBleHBvcnRTZWxlY3QudmFsdWU7XG4gICAgICAgICAgICBlb3RIaWdobGlnaHRzLnN0eWxlLmRpc3BsYXkgPSAoZXMgPT0gJ3N2ZycgfHwgZXMgPT0gJ3BuZycpID8gJ3RhYmxlLXJvdycgOiAnbm9uZSc7XG4gICAgICAgICAgICBlb3RHdWlkZWxpbmUuc3R5bGUuZGlzcGxheSA9IChlcyA9PSAnc3ZnJyB8fCBlcyA9PSAncG5nJykgPyAndGFibGUtcm93JyA6ICdub25lJztcbiAgICAgICAgICAgIGVvdFNjYWxlLnN0eWxlLmRpc3BsYXkgPSAoZXMgPT0gJ3BuZycpID8gJ3RhYmxlLXJvdycgOiAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dXBFT1QoKTtcblxuICAgICAgICBleHBvcnRGb3JtLmFwcGVuZENoaWxkKGV4cG9ydE9wdHNUYWJsZSk7XG4gICAgICAgIGV4cG9ydEZvcm0uYXBwZW5kQ2hpbGQoZXhwb3J0QnV0dG9uKTtcbiAgICAgICAgZXhwb3J0Rm9ybS5hcHBlbmRDaGlsZChleHBvcnRDb250ZW50KTtcblxuICAgICAgICBpZiAodGhpcy51aU1vZGUgIT09ICdub25lJylcbiAgICAgICAgICAgIHRoaXMuaGlkZVRvb2xQYW5lbCgpO1xuICAgICAgICB0aGlzLmJyb3dzZXJIb2xkZXIuaW5zZXJ0QmVmb3JlKGV4cG9ydEZvcm0sIHRoaXMuc3ZnSG9sZGVyKTtcbiAgICAgICAgdGhpcy5hY3RpdmVUb29sUGFuZWwgPSBleHBvcnRGb3JtO1xuXG4gICAgICAgIHRoaXMuc2V0VWlNb2RlKCdleHBvcnQnKTtcbiAgICB9XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE0XG4vL1xuLy8gZXhwb3J0cy5qczogc2hpbSB0byBleHBvcnQgc3ltYm9scyBpbnRvIGdsb2JhbCBuYW1lc3BhY2UgZm9yIGVhc2Ugb2YgZW1iZWRkaW5nXG4vL1xuXG52YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbnZhciBjaGFpbnNldCA9IHJlcXVpcmUoJy4vY2hhaW5zZXQnKTtcbnZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xudmFyIHNjID0gcmVxdWlyZSgnLi9zb3VyY2Vjb21wYXJlJyk7XG5cbndpbmRvdy5Ccm93c2VyID0gYnJvd3Nlci5Ccm93c2VyO1xud2luZG93LnNvdXJjZXNBcmVFcXVhbCA9IHNjLnNvdXJjZXNBcmVFcXVhbDtcbndpbmRvdy5DaGFpbnNldCA9IGNoYWluc2V0LkNoYWluc2V0OyAgICAvLyBQcmUtMC4xMiBjb25maWd1cmF0aW9ucyBuZWVkIHRoaXMuXG5cbi8vIFVzZWZ1bCBmb3IgaW5mbyBwbHVnaW5zLiAgU2hvdWxkIGJlIHJlY29uc2lkZXJlZCBpbiB0aGUgZnV0dXJlLlxud2luZG93Lm1ha2VFbGVtZW50ID0gdXRpbHMubWFrZUVsZW1lbnQ7XG5cbi8vIEFsbG93IHNvdXJjZSBwbHVnaW5zIHRvIGJlIGxvYWRlZCBzZXBhcmF0ZWx5Llxud2luZG93LmRhbGxpYW5jZV9yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5ID0gc2EucmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeTtcbndpbmRvdy5kYWxsaWFuY2VfcmVnaXN0ZXJQYXJzZXJGYWN0b3J5ID0gc2EucmVnaXN0ZXJQYXJzZXJGYWN0b3J5O1xud2luZG93LmRhbGxpYW5jZV9tYWtlUGFyc2VyID0gc2EubWFrZVBhcnNlcjtcblxuLy8gREFTKiBvYmplY3RzIGZvciBzb21lIHBsdWdpbnMgLS0gcmVtb3ZlIHdoZW4gcGx1Z2luIEFQSSBjaGFuZ2VzLi4uXG5cbndpbmRvdy5EQVNTZXF1ZW5jZSA9IGRhcy5EQVNTZXF1ZW5jZTtcbndpbmRvdy5EQVNGZWF0dXJlID0gZGFzLkRBU0ZlYXR1cmU7XG53aW5kb3cuREFTR3JvdXAgPSBkYXMuREFTR3JvdXA7XG53aW5kb3cuREFTU3R5bGVzaGVldCA9IGRhcy5EQVNTdHlsZXNoZWV0O1xud2luZG93LkRBU1N0eWxlID0gZGFzLkRBU1N0eWxlO1xud2luZG93LkRBU1NvdXJjZSA9IGRhcy5EQVNTb3VyY2U7ICAgIC8vIFByZS0wLjggY29uZmlndXJhdGlvbnMgdXNlZCB0aGlzLiAgU3RpbGwgc29tZSBhcm91bmQuLi5cbiIsIi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIGZlYXR1cmUtZHJhdy5qczogbmV3IGZlYXR1cmUtdGllciByZW5kZXJlclxuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xuICAgIHZhciBwdXNobyA9IHV0aWxzLnB1c2hvO1xuXG4gICAgdmFyIHRpZXIgPSByZXF1aXJlKCcuL3RpZXInKTtcbiAgICB2YXIgRGFzVGllciA9IHRpZXIuRGFzVGllcjtcblxuICAgIHZhciBzb3J0RmVhdHVyZXMgPSByZXF1aXJlKCcuL2ZlYXR1cmVzJykuc29ydEZlYXR1cmVzO1xuXG4gICAgdmFyIGcgPSByZXF1aXJlKCcuL2dseXBocycpO1xuICAgIHZhciBCb3hHbHlwaCA9IGcuQm94R2x5cGg7XG4gICAgdmFyIEdyb3VwR2x5cGggPSBnLkdyb3VwR2x5cGg7XG4gICAgdmFyIExpbmVHcmFwaEdseXBoID0gZy5MaW5lR3JhcGhHbHlwaDtcbiAgICB2YXIgTGFiZWxsZWRHbHlwaCA9IGcuTGFiZWxsZWRHbHlwaDtcbiAgICB2YXIgQ3Jvc3NHbHlwaCA9IGcuQ3Jvc3NHbHlwaDtcbiAgICB2YXIgRXhHbHlwaCA9IGcuRXhHbHlwaDtcbiAgICB2YXIgVHJpYW5nbGVHbHlwaCA9IGcuVHJpYW5nbGVHbHlwaDtcbiAgICB2YXIgRG90R2x5cGggPSBnLkRvdEdseXBoO1xuICAgIHZhciBQYWRkZWRHbHlwaCA9IGcuUGFkZGVkR2x5cGg7XG4gICAgdmFyIEFBcnJvd0dseXBoID0gZy5BQXJyb3dHbHlwaDtcbiAgICB2YXIgU3BhbkdseXBoID0gZy5TcGFuR2x5cGg7XG4gICAgdmFyIExpbmVHbHlwaCA9IGcuTGluZUdseXBoO1xuICAgIHZhciBQcmltZXJzR2x5cGggPSBnLlByaW1lcnNHbHlwaDtcbiAgICB2YXIgQXJyb3dHbHlwaCA9IGcuQXJyb3dHbHlwaDtcbiAgICB2YXIgVG9vTWFueUdseXBoID0gZy5Ub29NYW55R2x5cGg7XG4gICAgdmFyIFRleHRHbHlwaCA9IGcuVGV4dEdseXBoO1xuICAgIHZhciBTZXF1ZW5jZUdseXBoID0gZy5TZXF1ZW5jZUdseXBoO1xuICAgIHZhciBBbWlub0FjaWRHbHlwaCA9IGcuQW1pbm9BY2lkR2x5cGg7XG4gICAgdmFyIFRyYW5zbGF0ZWRHbHlwaCA9IGcuVHJhbnNsYXRlZEdseXBoO1xuICAgIHZhciBQb2ludEdseXBoID0gZy5Qb2ludEdseXBoO1xuICAgIHZhciBHcmlkR2x5cGggPSBnLkdyaWRHbHlwaDtcbiAgICB2YXIgU3RhckdseXBoID0gZy5TdGFyR2x5cGg7XG4gICAgdmFyIFBsaW1zb2xsR2x5cGggPSBnLlBsaW1zb2xsR2x5cGg7XG4gICAgdmFyIE92ZXJsYXlMYWJlbENhbnZhcyA9IGcuT3ZlcmxheUxhYmVsQ2FudmFzO1xuXG4gICAgdmFyIGNvbG9yID0gcmVxdWlyZSgnLi9jb2xvcicpO1xuICAgIHZhciBtYWtlR3JhZGllbnQgPSBjb2xvci5tYWtlR3JhZGllbnQ7XG5cbiAgICB2YXIgc3BhbnMgPSByZXF1aXJlKCcuL3NwYW5zJyk7XG4gICAgdmFyIFJhbmdlID0gc3BhbnMuUmFuZ2U7XG4gICAgdmFyIHVuaW9uID0gc3BhbnMudW5pb247XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTRmVhdHVyZSA9IGRhcy5EQVNGZWF0dXJlO1xuICAgIHZhciBpc0Rhc0Jvb2xlYW5UcnVlID0gZGFzLmlzRGFzQm9vbGVhblRydWU7XG4gICAgdmFyIGlzRGFzQm9vbGVhbk5vdEZhbHNlID0gZGFzLmlzRGFzQm9vbGVhbk5vdEZhbHNlO1xuXG4gICAgdmFyIHBhcnNlQ2lnYXIgPSByZXF1aXJlKCcuL2NpZ2FyJykucGFyc2VDaWdhcjtcblxuICAgIHZhciBuZiA9IHJlcXVpcmUoJy4vbnVtZm9ybWF0cycpO1xuICAgIHZhciBmb3JtYXRRdWFudExhYmVsID0gbmYuZm9ybWF0UXVhbnRMYWJlbDtcbn1cblxudmFyIE1JTl9QQURESU5HID0gMztcblxuZnVuY3Rpb24gU3ViVGllcigpIHtcbiAgICB0aGlzLmdseXBocyA9IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLnF1YW50ID0gbnVsbDtcbn1cblxuU3ViVGllci5wcm90b3R5cGUuaW5kZXhGb3IgPSBmdW5jdGlvbihnbHlwaCkge1xuICAgIHZhciBnbWluID0gZ2x5cGgubWluKCk7XG4gICAgdmFyIGxiID0gMCwgdWIgPSB0aGlzLmdseXBocy5sZW5ndGg7XG4gICAgd2hpbGUgKHViID4gbGIpIHtcbiAgICAgICAgdmFyIG1pZCA9ICgobGIgKyB1YikvMil8MDtcbiAgICAgICAgaWYgKG1pZCA+PSB0aGlzLmdseXBocy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nbHlwaHMubGVuZ3RoO1xuICAgICAgICB2YXIgbWcgPSB0aGlzLmdseXBoc1ttaWRdO1xuICAgICAgICBpZiAoZ21pbiA8IG1nLm1pbigpKSB7XG4gICAgICAgICAgICB1YiA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxiID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdWI7XG59XG5cblN1YlRpZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGdseXBoKSB7XG4gICAgdmFyIGluZCA9IHRoaXMuaW5kZXhGb3IoZ2x5cGgpO1xuICAgIHRoaXMuZ2x5cGhzLnNwbGljZShpbmQsIDAsIGdseXBoKTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaGVpZ2h0LCBnbHlwaC5oZWlnaHQoKSk7XG4gICAgaWYgKGdseXBoLnF1YW50ICYmIHRoaXMucXVhbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnF1YW50ID0gZ2x5cGgucXVhbnQ7XG4gICAgfVxufVxuXG5TdWJUaWVyLnByb3RvdHlwZS5oYXNTcGFjZUZvciA9IGZ1bmN0aW9uKGdseXBoKSB7XG4gICAgdmFyIGluZCA9IHRoaXMuaW5kZXhGb3IoZ2x5cGgpO1xuICAgIGlmIChpbmQgPiAwICYmIHRoaXMuZ2x5cGhzW2luZC0xXS5tYXgoKSA+PSBnbHlwaC5taW4oKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChpbmQgPCB0aGlzLmdseXBocy5sZW5ndGggJiYgdGhpcy5nbHlwaHNbaW5kXS5taW4oKSA8PSBnbHlwaC5tYXgoKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBHTE9CQUxfR0M7XG5cbmZ1bmN0aW9uIGRyYXdGZWF0dXJlVGllcih0aWVyKVxue1xuICAgIHZhciBzdGFydCA9IERhdGUubm93KCl8MDtcbiAgICBHTE9CQUxfR0MgPSB0aWVyLnZpZXdwb3J0LmdldENvbnRleHQoJzJkJyk7IC8vIFNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIG1ldHJpY3MuXG4gICAgc29ydEZlYXR1cmVzKHRpZXIpO1xuICAgIGlmICh0eXBlb2YodGllci5kYXNTb3VyY2UucGFkZGluZykgPT09ICdudW1iZXInKVxuICAgICAgICB0aWVyLnBhZGRpbmcgPSB0aWVyLmRhc1NvdXJjZS5wYWRkaW5nO1xuICAgIGVsc2VcbiAgICAgICAgdGllci5wYWRkaW5nID0gTUlOX1BBRERJTkc7XG5cbiAgICB2YXIgZ2x5cGhzID0gW107XG4gICAgdmFyIHNwZWNpYWxzID0gZmFsc2U7XG5cbiAgICAvLyBncm91cCBieSBzdHlsZVxuICAgIHZhciBnYnNGZWF0dXJlcyA9IHt9O1xuICAgIHZhciBnYnNTdHlsZXMgPSB7fTtcblxuICAgIGZvciAodmFyIHVmdCBpbiB0aWVyLnVuZ3JvdXBlZEZlYXR1cmVzKSB7XG4gICAgICAgIHZhciB1ZmwgPSB0aWVyLnVuZ3JvdXBlZEZlYXR1cmVzW3VmdF07XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBwZ2lkID0gMDsgcGdpZCA8IHVmbC5sZW5ndGg7ICsrcGdpZCkge1xuICAgICAgICAgICAgdmFyIGYgPSB1ZmxbcGdpZF07XG4gICAgICAgICAgICBpZiAoZi5wYXJ0cykgeyAgLy8gRklYTUUgc2hvdWxkbid0IHJlYWxseSBiZSBuZWVkZWRcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGllci5zdHlsZUZvckZlYXR1cmUoZik7XG4gICAgICAgICAgICBpZiAoIXN0eWxlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuZ2x5cGggPT0gJ0xJTkVQTE9UJykge1xuICAgICAgICAgICAgICAgIHB1c2hvKGdic0ZlYXR1cmVzLCBzdHlsZS5pZCwgZik7XG4gICAgICAgICAgICAgICAgZ2JzU3R5bGVzW3N0eWxlLmlkXSA9IHN0eWxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IGdseXBoRm9yRmVhdHVyZShmLCAwLCBzdHlsZSwgdGllcik7XG4gICAgICAgICAgICAgICAgaWYgKGcpXG4gICAgICAgICAgICAgICAgICAgIGdseXBocy5wdXNoKGcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgZ2JzIGluIGdic0ZlYXR1cmVzKSB7XG4gICAgICAgIHZhciBnZiA9IGdic0ZlYXR1cmVzW2dic107XG4gICAgICAgIHZhciBzdHlsZSA9IGdic1N0eWxlc1tnYnNdO1xuICAgICAgICBpZiAoc3R5bGUuZ2x5cGggPT0gJ0xJTkVQTE9UJykge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2gobWFrZUxpbmVHbHlwaChnZiwgc3R5bGUsIHRpZXIpKTtcbiAgICAgICAgICAgIHNwZWNpYWxzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1lcmdlIHN1cGVyZ3JvdXBzICAgIFxuXG4gICAgaWYgKHRpZXIuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMgJiYgIXRpZXIuYnVtcGVkKSB7XG4gICAgICAgIGZvciAodmFyIHNnIGluIHRpZXIuc3VwZXJHcm91cHMpIHtcbiAgICAgICAgICAgIHZhciBzZ2cgPSB0aWVyLnN1cGVyR3JvdXBzW3NnXTtcbiAgICAgICAgICAgIHRpZXIuZ3JvdXBzW3NnXSA9IHNoYWxsb3dDb3B5KHRpZXIuZ3JvdXBzW3NnXSk7XG4gICAgICAgICAgICB0aWVyLmdyb3Vwc1tzZ10uaXNTdXBlckdyb3VwID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBmZWF0c0J5VHlwZSA9IHt9O1xuXG4gICAgICAgICAgICB2YXIgc2dNaW4gPSAxMDAwMDAwMDAwMCwgc2dNYXggPSAtMTAwMDAwMDAwMDA7XG4gICAgICAgICAgICB2YXIgc2dTZWcgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBzZ2cubGVuZ3RoOyArK2cpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2YgPSB0aWVyLmdyb3VwZWRGZWF0dXJlc1tzZ2dbZ11dO1xuICAgICAgICAgICAgICAgIGlmICghZ2YpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGdmLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGdmW2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgcHVzaG8oZmVhdHNCeVR5cGUsIGYudHlwZSwgZik7XG4gICAgICAgICAgICAgICAgICAgIHNnTWluID0gTWF0aC5taW4oZi5taW4sIHNnTWluKTtcbiAgICAgICAgICAgICAgICAgICAgc2dNYXggPSBNYXRoLm1heChmLm1heCwgc2dNYXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZi5zZWdtZW50ICYmICFzZ1NlZylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNnU2VnID0gZi5zZWdtZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aWVyLmdyb3Vwc1tzZ10gJiYgIXRpZXIuZ3JvdXBzW3NnXS5saW5rcyB8fCB0aWVyLmdyb3Vwc1tzZ10ubGlua3MubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICB0aWVyLmdyb3Vwc1tzZ10ubGlua3MgPSB0aWVyLmdyb3Vwc1tzZ2dbMF1dLmxpbmtzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aWVyLmdyb3VwZWRGZWF0dXJlc1tzZ2dbZ11dOyAgLy8gJ2NvcyB3ZSBkb24ndCB3YW50IHRvIHJlbmRlciB0aGUgdW5tZXJnZWQgdmVyc2lvbi5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGllci5ncm91cHNbc2ddLm1heCA9IHNnTWF4O1xuICAgICAgICAgICAgdGllci5ncm91cHNbc2ddLm1pbiA9IHNnTWluO1xuICAgICAgICAgICAgdGllci5ncm91cHNbc2ddLnNlZ21lbnQgPSBzZ1NlZztcblxuICAgICAgICAgICAgZm9yICh2YXIgdCBpbiBmZWF0c0J5VHlwZSkge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0cyA9IGZlYXRzQnlUeXBlW3RdO1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGZlYXRzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBsb2MgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmZWF0cy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmZWF0c1tmaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbCA9IG5ldyBSYW5nZShmLm1pbiwgZi5tYXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jID0gZmw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2MgPSB1bmlvbihsb2MsIGZsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWVyZ2VkUmFuZ2VzID0gbG9jLnJhbmdlcygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBtZXJnZWRSYW5nZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gbWVyZ2VkUmFuZ2VzW3NpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbiBjb3ZlcmFnZS1jb3VudGluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zQ292ZXJhZ2UgPSAoKHIubWF4KCl8MCkgLSAoci5taW4oKXwwKSArIDEpICogc2dnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdENvdmVyYWdlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZlYXRzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmZWF0c1tmaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGYubWlufDApIDw9IHIubWF4KCkgJiYgKGYubWF4fDApID49IHIubWluKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW1pbiA9IE1hdGgubWF4KGYubWlufDAsIHIubWluKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bWF4ID0gTWF0aC5taW4oZi5tYXh8MCwgci5tYXgoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0Q292ZXJhZ2UgKz0gKHVtYXggLSB1bWluICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpc3VhbFdlaWdodCA9ICgoMS4wICogYWN0Q292ZXJhZ2UpIC8gcG9zQ292ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgY292ZXJhZ2UtY291bnRpbmdcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3ZiA9IG5ldyBEQVNGZWF0dXJlKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2Zba10gPSB0ZW1wbGF0ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdmLm1pbiA9IHIubWluKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld2YubWF4ID0gci5tYXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld2YubGFiZWwgJiYgc2dnLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld2YubGFiZWwgKz0gJyAoJyArIHNnZy5sZW5ndGggKyAnIHZhcnMpJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXdmLnZpc3VhbFdlaWdodCA9ICgoMS4wICogYWN0Q292ZXJhZ2UpIC8gcG9zQ292ZXJhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBwdXNobyh0aWVyLmdyb3VwZWRGZWF0dXJlcywgc2csIG5ld2YpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzdXBlcmdyb3VwcyBhcmUgYWxyZWFkeSBpbiB0aWVyLmdyb3Vwcy5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aWVyLnN1cGVyR3JvdXBzW3NnXTsgLy8gRG8gd2Ugd2FudCB0aGlzP1xuICAgICAgICB9ICAgICAgIFxuICAgIH1cblxuICAgIC8vIEdseXBoaWZ5IGdyb3Vwcy5cblxuICAgIHZhciBnbCA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAodmFyIGdpZCBpbiB0aWVyLmdyb3VwZWRGZWF0dXJlcykge1xuICAgICAgICBnbC5wdXNoKGdpZCk7XG4gICAgfVxuICAgIGdsLnNvcnQoZnVuY3Rpb24oZzEsIGcyKSB7XG4gICAgICAgIHZhciBkID0gdGllci5ncm91cGVkRmVhdHVyZXNbZzFdWzBdLnNjb3JlIC0gdGllci5ncm91cGVkRmVhdHVyZXNbZzJdWzBdLnNjb3JlO1xuICAgICAgICBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChkID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHZhciBncm91cEdseXBocyA9IHt9O1xuICAgIGZvciAodmFyIGd4ID0gMDsgZ3ggPCBnbC5sZW5ndGg7ICsrZ3gpIHtcbiAgICAgICAgdmFyIGdpZCA9IGdsW2d4XTtcbiAgICAgICAgdmFyIGcgPSBnbHlwaHNGb3JHcm91cCh0aWVyLmdyb3VwZWRGZWF0dXJlc1tnaWRdLCAwLCB0aWVyLmdyb3Vwc1tnaWRdLCB0aWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aWVyLmRhc1NvdXJjZS5jb2xsYXBzZVN1cGVyR3JvdXBzICYmICF0aWVyLmJ1bXBlZCkgPyAnY29sbGFwc2VkX2dlbmUnIDogJ3RlbnQnKTtcbiAgICAgICAgaWYgKGcpIHtcbiAgICAgICAgICAgIGcuZ3JvdXAgPSB0aWVyLmdyb3Vwc1tnaWRdO1xuICAgICAgICAgICAgZ3JvdXBHbHlwaHNbZ2lkXSA9IGc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBzZyBpbiB0aWVyLnN1cGVyR3JvdXBzKSB7XG4gICAgICAgIHZhciBzZ2cgPSB0aWVyLnN1cGVyR3JvdXBzW3NnXTtcbiAgICAgICAgdmFyIHNnR2x5cGhzID0gW107XG4gICAgICAgIHZhciBzZ01pbiA9IDEwMDAwMDAwMDAwO1xuICAgICAgICB2YXIgc2dNYXggPSAtMTAwMDAwMDAwMDA7XG4gICAgICAgIGZvciAodmFyIHNnaSA9IDA7IHNnaSA8IHNnZy5sZW5ndGg7ICsrc2dpKSB7XG4gICAgICAgICAgICB2YXIgZ2cgPSBncm91cEdseXBoc1tzZ2dbc2dpXV07XG4gICAgICAgICAgICBncm91cEdseXBoc1tzZ2dbc2dpXV0gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGdnKSB7XG4gICAgICAgICAgICAgICAgc2dHbHlwaHMucHVzaChnZyk7XG4gICAgICAgICAgICAgICAgc2dNaW4gPSBNYXRoLm1pbihzZ01pbiwgZ2cubWluKCkpO1xuICAgICAgICAgICAgICAgIHNnTWF4ID0gTWF0aC5tYXgoc2dNYXgsIGdnLm1heCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBzZ2kgPSAwOyBzZ2kgPCBzZ0dseXBocy5sZW5ndGg7ICsrc2dpKSB7XG4gICAgICAgICAgICB2YXIgZ2cgPSBzZ0dseXBoc1tzZ2ldO1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2gobmV3IFBhZGRlZEdseXBoKGdnLCBzZ01pbiwgc2dNYXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBnIGluIGdyb3VwR2x5cGhzKSB7XG4gICAgICAgIHZhciBnZyA9IGdyb3VwR2x5cGhzW2ddO1xuICAgICAgICBpZiAoZ2cpIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGdnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1bXBpbmdcblxuICAgIHZhciB1bmJ1bXBlZFNUID0gbmV3IFN1YlRpZXIoKTtcbiAgICB2YXIgYnVtcGVkU1RzID0gW107XG4gICAgdmFyIGhhc0J1bXBlZEZlYXR1cmVzID0gZmFsc2U7XG4gICAgdmFyIHN1YnRpZXJNYXggPSB0aWVyLnN1YnRpZXJNYXggfHwgdGllci5kYXNTb3VyY2Uuc3VidGllck1heCB8fCB0aWVyLmJyb3dzZXIuZGVmYXVsdFN1YnRpZXJNYXg7XG4gICAgdmFyIHN1YnRpZXJzRXhjZWVkZWQgPSBmYWxzZTtcblxuICBHTFlQSF9MT09QOlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBnID0gZ2x5cGhzW2ldO1xuICAgICAgICBpZiAoZy5idW1wKSB7XG4gICAgICAgICAgICBoYXNCdW1wZWRGZWF0dXJlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGcuYnVtcCAmJiAodGllci5idW1wZWQgfHwgdGllci5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3VwcykpIHsgICAgICAgLy8ga2luZC1vZiBuYXN0eS4gIHN1cGVyZ3JvdXAgY29sbGFwc2luZyBpcyBkaWZmZXJlbnQgZnJvbSBcIm5vcm1hbFwiIHVuYnVtcGluZ1xuICAgICAgICAgICAgZm9yICh2YXIgc3RpID0gMDsgc3RpIDwgYnVtcGVkU1RzLmxlbmd0aDsgICsrc3RpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0ID0gYnVtcGVkU1RzW3N0aV07XG4gICAgICAgICAgICAgICAgaWYgKHN0Lmhhc1NwYWNlRm9yKGcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0LmFkZChnKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgR0xZUEhfTE9PUDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVtcGVkU1RzLmxlbmd0aCA+PSBzdWJ0aWVyTWF4KSB7XG4gICAgICAgICAgICAgICAgc3VidGllcnNFeGNlZWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdCA9IG5ldyBTdWJUaWVyKCk7XG4gICAgICAgICAgICAgICAgc3QuYWRkKGcpO1xuICAgICAgICAgICAgICAgIGJ1bXBlZFNUcy5wdXNoKHN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuYnVtcGVkU1QuYWRkKGcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHVuYnVtcGVkU1QuZ2x5cGhzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYnVtcGVkU1RzID0gW3VuYnVtcGVkU1RdLmNvbmNhdChidW1wZWRTVHMpO1xuICAgIH1cblxuICAgIGZvciAodmFyIHN0aSA9IDA7IHN0aSA8IGJ1bXBlZFNUcy5sZW5ndGg7ICsrc3RpKSB7XG4gICAgICAgIHZhciBzdCA9IGJ1bXBlZFNUc1tzdGldO1xuICAgICAgICBpZiAoc3QucXVhbnQpIHtcbiAgICAgICAgICAgIHN0LmdseXBocy51bnNoaWZ0KG5ldyBHcmlkR2x5cGgoc3QuaGVpZ2h0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdGkgPSAwOyBzdGkgPCBidW1wZWRTVHMubGVuZ3RoOyArK3N0aSkge1xuICAgICAgICB2YXIgc3QgPSBidW1wZWRTVHNbc3RpXTtcbiAgICAgICAgc3QuZ2x5cGhzLnNvcnQoZnVuY3Rpb24gKGcxLCBnMikge1xuICAgICAgICAgICAgdmFyIHoxID0gZzEuemluZGV4IHx8IDA7XG4gICAgICAgICAgICB2YXIgejIgPSBnMi56aW5kZXggfHwgMDtcbiAgICAgICAgICAgIHJldHVybiB6MSAtIHoyO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aWVyLnN1YnRpZXJzID0gYnVtcGVkU1RzO1xuICAgIHRpZXIuZ2x5cGhDYWNoZU9yaWdpbiA9IHRpZXIuYnJvd3Nlci52aWV3U3RhcnQ7XG5cbiAgICBpZiAoc3VidGllcnNFeGNlZWRlZClcbiAgICAgICAgdGllci51cGRhdGVTdGF0dXMoJ0J1bXBpbmcgbGltaXQgZXhjZWVkZWQsIHVzZSB0aGUgdHJhY2sgZWRpdG9yIHRvIHNlZSBtb3JlIGZlYXR1cmVzJyk7XG4gICAgZWxzZVxuICAgICAgICB0aWVyLnVwZGF0ZVN0YXR1cygpO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5wYWludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXRpbmEgPSB0aGlzLmJyb3dzZXIucmV0aW5hICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMTtcblxuICAgIHZhciBzdWJ0aWVycyA9IHRoaXMuc3VidGllcnM7XG4gICAgaWYgKCFzdWJ0aWVycykge1xuXHQgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlc2lyZWRXaWR0aCA9IHRoaXMuYnJvd3Nlci5mZWF0dXJlUGFuZWxXaWR0aCArIDIwMDA7XG4gICAgaWYgKHJldGluYSkge1xuICAgICAgICBkZXNpcmVkV2lkdGggKj0gMjtcbiAgICB9XG4gICAgdmFyIGZwdyA9IHRoaXMudmlld3BvcnQud2lkdGh8MDtcbiAgICBpZiAoZnB3IDwgZGVzaXJlZFdpZHRoIC0gNTApIHtcbiAgICAgICAgdGhpcy52aWV3cG9ydC53aWR0aCA9IGZwdyA9IGRlc2lyZWRXaWR0aDtcbiAgICB9XG5cbiAgICB2YXIgbGggPSB0aGlzLnBhZGRpbmc7XG4gICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdWJ0aWVycy5sZW5ndGg7ICsrcykge1xuICAgICAgICBsaCA9IGxoICsgc3VidGllcnNbc10uaGVpZ2h0ICsgdGhpcy5wYWRkaW5nO1xuICAgIH1cbiAgICBsaCArPSA2XG4gICAgbGggPSBNYXRoLm1heChsaCwgdGhpcy5icm93c2VyLm1pblRpZXJIZWlnaHQpO1xuXG4gICAgdmFyIGNhbnZhc0hlaWdodCA9IGxoO1xuICAgIGlmIChyZXRpbmEpIHtcbiAgICAgICAgY2FudmFzSGVpZ2h0ICo9IDI7XG4gICAgfVxuXG4gICAgaWYgKGNhbnZhc0hlaWdodCAhPSB0aGlzLnZpZXdwb3J0LmhlaWdodCkge1xuICAgICAgICB0aGlzLnZpZXdwb3J0LmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICB9XG4gICAgXG4gICAgdmFyIHRpZXJIZWlnaHQgPSBNYXRoLm1heChsaCwgdGhpcy5icm93c2VyLm1pblRpZXJIZWlnaHQpO1xuICAgIHRoaXMudmlld3BvcnRIb2xkZXIuc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICB0aGlzLnZpZXdwb3J0LnN0eWxlLndpZHRoID0gcmV0aW5hID8gKCcnICsgKGZwdy8yKSArICdweCcpIDogKCcnICsgZnB3ICsgJ3B4Jyk7XG4gICAgdGhpcy52aWV3cG9ydC5zdHlsZS5oZWlnaHQgPSAnJyArIGxoICsgJ3B4JztcbiAgICB0aGlzLmxheW91dEhlaWdodCA9ICBNYXRoLm1heChsaCwgdGhpcy5icm93c2VyLm1pblRpZXJIZWlnaHQpO1xuXG4gICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcbiAgICB0aGlzLm5vcmlnaW4gPSB0aGlzLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgdmFyIGdjID0gdGhpcy52aWV3cG9ydC5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGdjLmNsZWFyUmVjdCgwLCAwLCBmcHcsIGNhbnZhc0hlaWdodCk7XG5cbiAgICBnYy5zYXZlKCk7XG4gICAgaWYgKHJldGluYSkge1xuICAgICAgICBnYy5zY2FsZSgyLCAyKTtcbiAgICB9XG5cbiAgICAvKlxuICAgIGlmICh0aGlzLmJhY2tncm91bmQpIHtcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kO1xuXG4gICAgICAgIGlmICh0aGlzLmtub3duQ292ZXJhZ2UpIHtcbiAgICAgICAgICAgIHZhciBrbm93blJhbmdlcyA9IHRoaXMua25vd25Db3ZlcmFnZS5yYW5nZXMoKTtcbiAgICAgICAgICAgIGZvciAodmFyIHJpID0gMDsgcmkgPCBrbm93blJhbmdlcy5sZW5ndGg7ICsrcmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IGtub3duUmFuZ2VzW3JpXTtcbiAgICAgICAgICAgICAgICB2YXIga25vd25NaW4gPSAoci5taW4oKSAtIHRoaXMuYnJvd3Nlci52aWV3U3RhcnQpICogdGhpcy5icm93c2VyLnNjYWxlICsgMTAwMDtcbiAgICAgICAgICAgICAgICB2YXIga25vd25NYXggPSAoci5tYXgoKSAtIHRoaXMuYnJvd3Nlci52aWV3U3RhcnQpICogdGhpcy5icm93c2VyLnNjYWxlICsgMTAwMDtcbiAgICAgICAgICAgICAgICBnYy5maWxsUmVjdChrbm93bk1pbiwgMCwga25vd25NYXggLSBrbm93bk1pbiwgbGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSovXG5cbiAgICB2YXIgZHJhd1N0YXJ0ID0gIHRoaXMuYnJvd3Nlci52aWV3U3RhcnQgLSAxMDAwLjAvdGhpcy5icm93c2VyLnNjYWxlO1xuICAgIHZhciBkcmF3RW5kID0gdGhpcy5icm93c2VyLnZpZXdFbmQgKyAxMDAwLjAvdGhpcy5icm93c2VyLnNjYWxlO1xuICAgIHZhciB1bm1hcHBlZEJsb2NrcyA9IFtdO1xuICAgIGlmICh0aGlzLmtub3duQ292ZXJhZ2UpIHtcbiAgICAgICAgdmFyIGtub3duUmFuZ2VzID0gdGhpcy5rbm93bkNvdmVyYWdlLnJhbmdlcygpO1xuICAgICAgICBmb3IgKHZhciByaSA9IDA7IHJpIDwga25vd25SYW5nZXMubGVuZ3RoOyArK3JpKSB7XG4gICAgICAgICAgICB2YXIgciA9IGtub3duUmFuZ2VzW3JpXTtcbiAgICAgICAgICAgIGlmIChyaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHIubWluKCkgPiBkcmF3U3RhcnQpIFxuICAgICAgICAgICAgICAgICAgIHVubWFwcGVkQmxvY2tzLnB1c2goe21pbjogZHJhd1N0YXJ0LCBtYXg6IHIubWluKCkgLSAxfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVubWFwcGVkQmxvY2tzLnB1c2goe21pbjoga25vd25SYW5nZXNbcmktMV0ubWF4KCkgKyAxLCBtYXg6IHIubWluKCkgLSAxfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyaSA9PSBrbm93blJhbmdlcy5sZW5ndGggLSAxICYmIHIubWF4KCkgPCBkcmF3RW5kKSB7XG4gICAgICAgICAgICAgICAgdW5tYXBwZWRCbG9ja3MucHVzaCh7bWluOiByLm1heCgpICsgMSwgbWF4OiBkcmF3RW5kfSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1bm1hcHBlZEJsb2Nrcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9ICdncmF5JztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bm1hcHBlZEJsb2Nrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGIgPSB1bm1hcHBlZEJsb2Nrc1tpXTtcbiAgICAgICAgICAgIHZhciBtaW4gPSAoYi5taW4gLSB0aGlzLmJyb3dzZXIudmlld1N0YXJ0KSAqIHRoaXMuYnJvd3Nlci5zY2FsZSArIDEwMDA7XG4gICAgICAgICAgICB2YXIgbWF4ID0gKGIubWF4IC0gdGhpcy5icm93c2VyLnZpZXdTdGFydCkgKiB0aGlzLmJyb3dzZXIuc2NhbGUgKyAxMDAwO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QobWluLCAwLCBtYXggLSBtaW4sIGxoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvYyA9IG5ldyBPdmVybGF5TGFiZWxDYW52YXMoKTtcbiAgICB2YXIgb2Zmc2V0ID0gKCh0aGlzLmdseXBoQ2FjaGVPcmlnaW4gLSB0aGlzLmJyb3dzZXIudmlld1N0YXJ0KSp0aGlzLmJyb3dzZXIuc2NhbGUpKzEwMDA7XG4gICAgZ2MudHJhbnNsYXRlKG9mZnNldCwgdGhpcy5wYWRkaW5nKTtcbiAgICBvYy50cmFuc2xhdGUoMCwgdGhpcy5wYWRkaW5nKTtcblxuICAgIHRoaXMucGFpbnRUb0NvbnRleHQoZ2MsIG9jLCBvZmZzZXQpO1xuXG4gICAgaWYgKG9jLmdseXBocy5sZW5ndGggPiAwKVxuICAgICAgICB0aGlzLm92ZXJsYXlMYWJlbENhbnZhcyA9IG9jO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5vdmVybGF5TGFiZWxDYW52YXMgPSBudWxsO1xuXG4gICAgZ2MucmVzdG9yZSgpO1xuICAgIHRoaXMuZHJhd092ZXJsYXkoKTtcbiAgICB0aGlzLnBhaW50UXVhbnQoKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUucGFpbnRUb0NvbnRleHQgPSBmdW5jdGlvbihnYywgb2MsIG9mZnNldCkge1xuICAgIHZhciBzdWJ0aWVycyA9IHRoaXMuc3VidGllcnM7XG4gICAgdmFyIGZwdyA9IHRoaXMudmlld3BvcnQud2lkdGh8MDtcblxuICAgIGdjLnNhdmUoKTtcbiAgICBmb3IgKHZhciBzID0gMDsgcyA8IHN1YnRpZXJzLmxlbmd0aDsgKytzKSB7XG4gICAgICAgIHZhciBxdWFudCA9IG51bGw7XG4gICAgICAgIHZhciBnbHlwaHMgPSBzdWJ0aWVyc1tzXS5nbHlwaHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgICAgICBpZiAoZ2x5cGgubWluKCkgPCBmcHctb2Zmc2V0ICYmIGdseXBoLm1heCgpID4gLW9mZnNldCkgeyBcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgICAgICAgICAgZ2x5cGguZHJhdyhnYywgb2MpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaC5xdWFudCkge1xuICAgICAgICAgICAgICAgICAgICBxdWFudCA9IGdseXBoLnF1YW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnYy50cmFuc2xhdGUoMCwgc3VidGllcnNbc10uaGVpZ2h0ICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgb2MudHJhbnNsYXRlKDAsIHN1YnRpZXJzW3NdLmhlaWdodCArIHRoaXMucGFkZGluZyk7XG4gICAgfVxuICAgIGdjLnJlc3RvcmUoKTtcblxuICAgIGlmIChxdWFudCAmJiB0aGlzLnF1YW50TGVhcFRocmVzaG9sZCAmJiB0aGlzLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5icm93c2VyLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGhpcy5mZWF0dXJlU291cmNlLCAncXVhbnRMZWFwJykpIHtcbiAgICAgICAgdmFyIHJ5ID0gc3VidGllcnNbMF0uaGVpZ2h0ICogKDEuMCAtICgodGhpcy5xdWFudExlYXBUaHJlc2hvbGQgLSBxdWFudC5taW4pIC8gKHF1YW50Lm1heCAtIHF1YW50Lm1pbikpKTtcblxuICAgICAgICBnYy5zYXZlKCk7XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgICAgIGdjLmxpbmVXaWR0aCA9IDAuMztcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIGdjLm1vdmVUbygtMTAwMCwgcnkpO1xuICAgICAgICBnYy5saW5lVG8oZnB3ICsgMTAwMCwgcnkpO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgIH0gICAgXG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnBhaW50UXVhbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMucXVhbnRPdmVybGF5KVxuICAgICAgICByZXR1cm47XG5cbiAgICB2YXIgcmV0aW5hID0gdGhpcy5icm93c2VyLnJldGluYSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG5cbiAgICB2YXIgcXVhbnQ7XG4gICAgaWYgKHRoaXMuc3VidGllcnMgJiYgdGhpcy5zdWJ0aWVycy5sZW5ndGggPiAwKVxuICAgICAgICBxdWFudCA9IHRoaXMuc3VidGllcnNbMF0ucXVhbnQ7XG5cbiAgICBpZiAocXVhbnQpIHtcbiAgICAgICAgdmFyIGggPSB0aGlzLnN1YnRpZXJzWzBdLmhlaWdodDtcbiAgICAgICAgdmFyIHcgPSA1MDtcbiAgICAgICAgdGhpcy5xdWFudE92ZXJsYXkuaGVpZ2h0ID0gdGhpcy52aWV3cG9ydC5oZWlnaHQ7XG4gICAgICAgIHRoaXMucXVhbnRPdmVybGF5LndpZHRoID0gcmV0aW5hID8gdyoyIDogdztcbiAgICAgICAgdGhpcy5xdWFudE92ZXJsYXkuc3R5bGUuaGVpZ2h0ID0gJycgKyAocmV0aW5hID8gdGhpcy5xdWFudE92ZXJsYXkuaGVpZ2h0LzIgOiB0aGlzLnF1YW50T3ZlcmxheS5oZWlnaHQpICsgJ3B4JztcbiAgICAgICAgdGhpcy5xdWFudE92ZXJsYXkuc3R5bGUud2lkdGggPSAnJyArIHcgKyAncHgnO1xuICAgICAgICB0aGlzLnF1YW50T3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMucXVhbnRPdmVybGF5LmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmIChyZXRpbmEpXG4gICAgICAgICAgICBjdHguc2NhbGUoMiwgMik7XG5cbiAgICAgICAgdmFyIG51bVRpY3MgPSAyO1xuICAgICAgICBpZiAoaCA+IDQwKSB7XG4gICAgICAgICAgICBudW1UaWNzID0gMSArICgoaC8yMCkgfCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGljU3BhY2luZyA9IChoICsgdGhpcy5wYWRkaW5nKjIpIC8gKG51bVRpY3MgLSAxKTtcbiAgICAgICAgdmFyIHRpY0ludGVydmFsID0gKHF1YW50Lm1heCAtIHF1YW50Lm1pbikgLyAobnVtVGljcyAtIDEpO1xuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IDAuNjtcbiAgICAgICAgaWYgKHRoaXMuYnJvd3Nlci5ydWxlckxvY2F0aW9uID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh3LTMwLCAwLCAzMCwgaCArIHRoaXMucGFkZGluZyoyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAzMCwgaCArIHRoaXMucGFkZGluZyoyKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgICAgICBpZiAodGhpcy5icm93c2VyLnJ1bGVyTG9jYXRpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh3IC0gOCwgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8odywgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8odywgaCArIHRoaXMucGFkZGluZyk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHcgLSA4LCBoICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgY3R4Lm1vdmVUbyh3LCB0eSk7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh3IC0gNSwgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyg4LCB0aGlzLnBhZGRpbmcpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCB0aGlzLnBhZGRpbmcpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbygwLCBoICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oOCwgaCArIHRoaXMucGFkZGluZyk7XG4gICAgICAgICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IG51bVRpY3MtMTsgKyt0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5ID0gdCp0aWNTcGFjaW5nO1xuICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8oMCwgdHkpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8oNSwgdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcblxuICAgICAgICBpZiAodGhpcy5icm93c2VyLnJ1bGVyTG9jYXRpb24gPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZm9ybWF0UXVhbnRMYWJlbChxdWFudC5tYXgpLCB3LTksIDgpO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwocXVhbnQubWluKSwgdy05LCBoICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwoKDEuMCpxdWFudC5tYXgpIC0gKHQqdGljSW50ZXJ2YWwpKSwgdyAtIDksIHR5ICsgMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwocXVhbnQubWF4KSwgOSwgOCk7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZm9ybWF0UXVhbnRMYWJlbChxdWFudC5taW4pLCA5LCBoICsgdGhpcy5wYWRkaW5nKTtcbiAgICAgICAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgbnVtVGljcy0xOyArK3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGZvcm1hdFF1YW50TGFiZWwoKDEuMCpxdWFudC5tYXgpIC0gKHQqdGljSW50ZXJ2YWwpKSwgOSwgdHkgKyAzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucXVhbnRPdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnbHlwaHNGb3JHcm91cChmZWF0dXJlcywgeSwgZ3JvdXBFbGVtZW50LCB0aWVyLCBjb25uZWN0b3JUeXBlKSB7XG4gICAgdmFyIGdzdHlsZSA9IHRpZXIuc3R5bGVGb3JGZWF0dXJlKGdyb3VwRWxlbWVudCk7XG4gICAgdmFyIGxhYmVsO1xuICAgIHZhciBsYWJlbFdhbnRlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGdseXBocyA9IFtdO1xuICAgIHZhciBzdHJhbmQgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGYgPSBmZWF0dXJlc1tpXTtcbiAgICAgICAgaWYgKGYub3JpZW50YXRpb24gJiYgc3RyYW5kPT1udWxsKSB7XG4gICAgICAgICAgICBzdHJhbmQgPSBmLm9yaWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgICBpZiAoIWxhYmVsICYmIGYubGFiZWwpIHtcbiAgICAgICAgICAgIGxhYmVsID0gZi5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdHlsZSA9IHRpZXIuc3R5bGVGb3JGZWF0dXJlKGYpO1xuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZi5wYXJ0cykgeyAgLy8gRklYTUUgc2hvdWxkbid0IHJlYWxseSBiZSBuZWVkZWRcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLkxBQkVMKSlcbiAgICAgICAgICAgIGxhYmVsV2FudGVkID0gdHJ1ZTtcblxuICAgICAgICB2YXIgZyA9IGdseXBoRm9yRmVhdHVyZShmLCAwLCBzdHlsZSwgdGllciwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIGlmIChnKSB7XG4gICAgICAgICAgICBnbHlwaHMucHVzaChnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChnbHlwaHMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIFxuICAgIHZhciBjb25uZWN0b3IgPSAnZmxhdCc7XG4gICAgaWYgKGdzdHlsZSAmJiBnc3R5bGUuZ2x5cGggPT09ICdMSU5FJykge1xuICAgICAgICAvLyBTdGljayB3aXRoIGZsYXQuLi5cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGllci5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3VwcyAmJiAhdGllci5idW1wZWQpIHtcbiAgICAgICAgICAgIGlmIChzdHJhbmQgPT09ICcrJykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3RvciA9ICdjb2xsYXBzZWQrJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyYW5kID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSAnY29sbGFwc2VkLSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc3RyYW5kID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0b3IgPSAnaGF0Kyc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmFuZCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdG9yID0gJ2hhdC0nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSAgIFxuXG4gICAgdmFyIGxhYmVsVGV4dCA9IG51bGw7XG4gICAgaWYgKChsYWJlbCAmJiBsYWJlbFdhbnRlZCkgfHwgKGdzdHlsZSAmJiAoaXNEYXNCb29sZWFuVHJ1ZShnc3R5bGUuTEFCRUwpIHx8IGlzRGFzQm9vbGVhblRydWUoZ3N0eWxlLkxBQkVMUykpKSkgeyAgLy8gSEFDSywgTEFCRUxTIHNob3VsZCB3b3JrLlxuICAgICAgICBsYWJlbFRleHQgPSBncm91cEVsZW1lbnQubGFiZWwgfHwgbGFiZWw7XG4gICAgfVxuXG4gICAgdmFyIGdnID0gbmV3IEdyb3VwR2x5cGgoZ2x5cGhzLCBjb25uZWN0b3IpO1xuICAgIGlmIChsYWJlbFRleHQpIHtcbiAgICAgICAgaWYgKHN0cmFuZCA9PT0gJysnKSB7XG4gICAgICAgICAgICBsYWJlbFRleHQgPSAnPicgKyBsYWJlbFRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyYW5kID09PSAnLScpIHtcbiAgICAgICAgICAgIGxhYmVsVGV4dCA9ICc8JyArIGxhYmVsVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBnZyA9IG5ldyBMYWJlbGxlZEdseXBoKEdMT0JBTF9HQywgZ2csIGxhYmVsVGV4dCwgZmFsc2UpO1xuICAgIH1cbiAgICBnZy5idW1wID0gdHJ1ZTtcbiAgICByZXR1cm4gZ2c7XG59XG5cbmZ1bmN0aW9uIGdseXBoRm9yRmVhdHVyZShmZWF0dXJlLCB5LCBzdHlsZSwgdGllciwgZm9yY2VIZWlnaHQsIG5vTGFiZWwpXG57XG4gICAgZnVuY3Rpb24gZ2V0UmVmU2VxKHRpZXIsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciByZWZTZXEgPSBudWxsO1xuICAgICAgICBpZiAodGllci5jdXJyZW50U2VxdWVuY2UpIHtcbiAgICAgICAgICAgIHZhciBjc1N0YXJ0ID0gdGllci5jdXJyZW50U2VxdWVuY2Uuc3RhcnR8MDtcbiAgICAgICAgICAgIHZhciBjc0VuZCA9IHRpZXIuY3VycmVudFNlcXVlbmNlLmVuZHwwO1xuICAgICAgICAgICAgaWYgKGNzU3RhcnQgPD0gbWF4ICYmIGNzRW5kID49IG1pbikge1xuICAgICAgICAgICAgICAgIHZhciBzZk1pbiA9IE1hdGgubWF4KG1pbiwgY3NTdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIHNmTWF4ID0gTWF0aC5taW4obWF4LCBjc0VuZCk7XG5cbiAgICAgICAgICAgICAgICByZWZTZXEgPSB0aWVyLmN1cnJlbnRTZXF1ZW5jZS5zZXEuc3Vic3RyKHNmTWluIC0gY3NTdGFydCwgc2ZNYXggLSBzZk1pbiArIDEpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChtaW4gPCBzZk1pbikge1xuICAgICAgICAgICAgICAgICAgICByZWZTZXEgPSAnTicgKyByZWZTZXE7XG4gICAgICAgICAgICAgICAgICAgIHNmTWluLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChtYXggPiBzZk1heCkge1xuICAgICAgICAgICAgICAgICAgICByZWZTZXEgPSByZWZTZXEgKyAnTic7XG4gICAgICAgICAgICAgICAgICAgIHNmTWF4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWZTZXE7XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlID0gdGllci5icm93c2VyLnNjYWxlLCBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuICAgIHZhciBndHlwZSA9IHN0eWxlLmdseXBoIHx8ICdCT1gnO1xuICAgIHZhciBnbHlwaDtcblxuICAgIHZhciBtaW4gPSBmZWF0dXJlLm1pbjtcbiAgICB2YXIgbWF4ID0gZmVhdHVyZS5tYXg7XG4gICAgdmFyIHR5cGUgPSBmZWF0dXJlLnR5cGU7XG4gICAgdmFyIHN0cmFuZCA9IGZlYXR1cmUub3JpZW50YXRpb247XG4gICAgdmFyIHNjb3JlID0gZmVhdHVyZS5zY29yZTtcbiAgICB2YXIgbGFiZWwgPSBmZWF0dXJlLmxhYmVsIHx8IGZlYXR1cmUuaWQ7XG5cbiAgICB2YXIgbWluUG9zID0gKG1pbiAtIG9yaWdpbikgKiBzY2FsZTtcbiAgICB2YXIgcmF3TWF4UG9zID0gKChtYXggLSBvcmlnaW4gKyAxKSAqIHNjYWxlKTtcbiAgICB2YXIgbWF4UG9zID0gTWF0aC5tYXgocmF3TWF4UG9zLCBtaW5Qb3MgKyAxKTtcblxuICAgIHZhciBoZWlnaHQgPSB0aWVyLmZvcmNlSGVpZ2h0IHx8IHN0eWxlLkhFSUdIVCB8fCBmb3JjZUhlaWdodCB8fCAxMjtcbiAgICB2YXIgcmVxdWlyZWRIZWlnaHQgPSBoZWlnaHQgPSAxLjAgKiBoZWlnaHQ7XG4gICAgdmFyIGJ1bXAgPSBzdHlsZS5CVU1QICYmIGlzRGFzQm9vbGVhblRydWUoc3R5bGUuQlVNUCk7XG5cbiAgICB2YXIgZ2csIHF1YW50O1xuXG4gICAgaWYgKGd0eXBlID09PSAnQ1JPU1MnIHx8IGd0eXBlID09PSAnRVgnIHx8IGd0eXBlID09PSAnVFJJQU5HTEUnIHx8IGd0eXBlID09PSAnRE9UJyB8fCBndHlwZSA9PT0gJ1NRVUFSRScgfHwgZ3R5cGUgPT09ICdTVEFSJyB8fCBndHlwZSA9PT0gJ1BMSU1TT0xMJykge1xuICAgICAgICB2YXIgc3Ryb2tlID0gc3R5bGUuRkdDT0xPUiB8fCAnYmxhY2snO1xuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgJ25vbmUnO1xuICAgICAgICB2YXIgb3V0bGluZSA9IHN0eWxlLlNUUk9LRUNPTE9SO1xuXG4gICAgICAgIGlmIChzdHlsZS5CR0lURU0gJiYgZmVhdHVyZS5pdGVtUmdiKSB7XG4gICAgICAgICAgICBzdHJva2UgPSBmZWF0dXJlLml0ZW1SZ2I7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5DT0xPUl9CWV9TQ09SRTIpKSB7XG4gICAgICAgICAgICB2YXIgZ3JhZCA9IHN0eWxlLkJHR1JBRCB8fCBzdHlsZS5fZ3JhZGllbnQ7XG4gICAgICAgICAgICBpZiAoIWdyYWQpIHtcbiAgICAgICAgICAgICAgICBncmFkID0gbWFrZUdyYWRpZW50KDUwLCBzdHlsZS5DT0xPUjEsIHN0eWxlLkNPTE9SMiwgc3R5bGUuQ09MT1IzKTtcbiAgICAgICAgICAgICAgICBzdHlsZS5fZ3JhZGllbnQgPSBncmFkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2MyID0gZmVhdHVyZS5zY29yZTI7XG4gICAgICAgICAgICBpZiAoc2MyICE9IHVuZGVmaW5lZCB8fCAhc3Ryb2tlKSB7XG4gICAgICAgICAgICAgICAgc2MyID0gc2MyIHx8IDA7XG5cbiAgICAgICAgICAgICAgICB2YXIgc21pbjIgPSBzdHlsZS5NSU4yID8gKDEuMCAqIHN0eWxlLk1JTjIpIDogMC4wO1xuICAgICAgICAgICAgICAgIHZhciBzbWF4MiA9IHN0eWxlLk1BWDIgPyAoMS4wICogc3R5bGUuTUFYMikgOiAxLjA7XG4gICAgICAgICAgICAgICAgdmFyIHJlbFNjb3JlMiA9ICgoMS4wICogc2MyKSAtIHNtaW4yKSAvIChzbWF4Mi1zbWluMik7XG5cbiAgICAgICAgICAgICAgICB2YXIgc3RlcCA9IChyZWxTY29yZTIqZ3JhZC5sZW5ndGgpfDA7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXAgPCAwKSBzdGVwID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCA+PSBncmFkLmxlbmd0aCkgc3RlcCA9IGdyYWQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICBzdHJva2UgPSBncmFkW3N0ZXBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aWVyLmZvcmNlSGVpZ2h0IHx8IHN0eWxlLkhFSUdIVCB8fCBmb3JjZUhlaWdodCB8fCAxMjtcbiAgICAgICAgcmVxdWlyZWRIZWlnaHQgPSBoZWlnaHQgPSAxLjAgKiBoZWlnaHQ7XG5cbiAgICAgICAgdmFyIHNpemUgPSBzdHlsZS5TSVpFIHx8IGhlaWdodDtcbiAgICAgICAgaWYgKHN0eWxlLlJTSVpFKSB7XG4gICAgICAgICAgICBzaXplID0gKDEuMCAqIHN0eWxlLlJTSVpFKSAqIGhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHlsZS5TVFJPS0VUSFJFU0hPTEQpIHtcbiAgICAgICAgICAgIGlmIChzaXplIDwgKDEuMCAqIHN0eWxlLlNUUk9LRVRIUkVTSE9MRCkpXG4gICAgICAgICAgICAgICAgb3V0bGluZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNpemUgPSAxLjAgKiBzaXplO1xuXG4gICAgICAgIHZhciBtaWQgPSAobWluUG9zICsgbWF4UG9zKS8yO1xuICAgICAgICB2YXIgaGggPSBzaXplLzI7XG5cbiAgICAgICAgdmFyIG1hcms7XG4gICAgICAgIHZhciBiTWluUG9zID0gbWluUG9zLCBiTWF4UG9zID0gbWF4UG9zO1xuXG4gICAgICAgIGlmIChndHlwZSA9PT0gJ0VYJykge1xuICAgICAgICAgICAgZ2cgPSBuZXcgRXhHbHlwaChtaWQsIHNpemUsIHN0cm9rZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3R5cGUgPT09ICdUUklBTkdMRScpIHtcbiAgICAgICAgICAgIHZhciBkaXIgPSBzdHlsZS5ESVJFQ1RJT04gfHwgJ04nO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUuTElORVdJRFRIIHx8IHNpemU7XG4gICAgICAgICAgICBnZyA9IG5ldyBUcmlhbmdsZUdseXBoKG1pZCwgc2l6ZSwgZGlyLCB3aWR0aCwgc3Ryb2tlLCBvdXRsaW5lKTtcbiAgICAgICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ0RPVCcpIHtcbiAgICAgICAgICAgIGdnID0gbmV3IERvdEdseXBoKG1pZCwgc2l6ZSwgc3Ryb2tlLCBvdXRsaW5lKTtcbiAgICAgICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ1BMSU1TT0xMJykge1xuICAgICAgICAgICAgZ2cgPSBuZXcgUGxpbXNvbGxHbHlwaChtaWQsIHNpemUsIDAuMiAqIHNpemUsIHN0cm9rZSwgb3V0bGluZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3R5cGUgPT09ICdTUVVBUkUnKSB7XG4gICAgICAgICAgICBnZyA9IG5ldyBCb3hHbHlwaChtaWQgLSBoaCwgMCwgc2l6ZSwgc2l6ZSwgc3Ryb2tlLCBvdXRsaW5lKTtcbiAgICAgICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ1NUQVInKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gNTtcbiAgICAgICAgICAgIGlmIChzdHlsZS5QT0lOVFMpIFxuICAgICAgICAgICAgICAgIHBvaW50cyA9IHN0eWxlLlBPSU5UUyB8IDA7XG4gICAgICAgICAgICBnZyA9IG5ldyBTdGFyR2x5cGgobWlkLCBoaCwgcG9pbnRzLCBzdHJva2UsIG91dGxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2cgPSBuZXcgQ3Jvc3NHbHlwaChtaWQsIHNpemUsIHN0cm9rZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbCAmJiBmaWxsICE9ICdub25lJyAmJiAobWF4UG9zIC0gbWluUG9zKSA+IDUpIHtcbiAgICAgICAgICAgIHZhciBiZ2cgPSBuZXcgQm94R2x5cGgobWluUG9zLCAwLCAobWF4UG9zIC0gbWluUG9zKSwgc2l6ZSwgZmlsbCk7XG4gICAgICAgICAgICBnZyA9IG5ldyBHcm91cEdseXBoKFtiZ2csIGdnXSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5TQ0FUVEVSKSkge1xuICAgICAgICAgICAgdmFyIHNtaW4gPSB0aWVyLnF1YW50TWluKHN0eWxlKTtcbiAgICAgICAgICAgIHZhciBzbWF4ID0gdGllci5xdWFudE1heChzdHlsZSk7XG5cbiAgICAgICAgICAgIGlmICghc21heCkge1xuICAgICAgICAgICAgICAgIGlmIChzbWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzbWF4ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzbWF4ID0gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzbWluKSB7XG4gICAgICAgICAgICAgICAgc21pbiA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWxTY29yZSA9ICgoMS4wICogc2NvcmUpIC0gc21pbikgLyAoc21heC1zbWluKTtcbiAgICAgICAgICAgIHZhciByZWxPcmlnaW4gPSAoLTEuMCAqIHNtaW4pIC8gKHNtYXggLSBzbWluKTtcblxuICAgICAgICAgICAgaWYgKHJlbFNjb3JlIDwgMC4wIHx8IHJlbFNjb3JlID4gMS4wKSB7XG4gICAgICAgICAgICAgICAgLy8gR2x5cGggaXMgb3V0IG9mIGJvdW5kcy5cbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgd2UgYWxsb3cgZm9yIFwicGFydGlhbGx5IHNob3dpbmdcIiBnbHlwaHM/XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbFNjb3JlID49IHJlbE9yaWdpbikge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgxLCAocmVsU2NvcmUgLSByZWxPcmlnaW4pICogcmVxdWlyZWRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB5ID0geSArICgoMS4wIC0gcmVsT3JpZ2luKSAqIHJlcXVpcmVkSGVpZ2h0KSAtIGhlaWdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heCgxLCAocmVsU2NvcmUgLSByZWxPcmlnaW4pICogcmVxdWlyZWRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB5ID0geSArICgoMS4wIC0gcmVsT3JpZ2luKSAqIHJlcXVpcmVkSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcXVhbnQgPSB7bWluOiBzbWluLCBtYXg6IHNtYXh9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGhlaWdodEZ1ZGdlID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZUxhYmVsO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YoZmVhdHVyZS5mb3JjZUxhYmVsKSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMYWJlbCA9IGZlYXR1cmUuZm9yY2VMYWJlbDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVMYWJlbCA9IHN0eWxlLkxBQkVMO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzRGFzQm9vbGVhbk5vdEZhbHNlKGZlYXR1cmVMYWJlbCkgJiYgbGFiZWwgJiYgIW5vTGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2cgPSBuZXcgTGFiZWxsZWRHbHlwaChHTE9CQUxfR0MsIGdnLCBsYWJlbCwgdHJ1ZSwgbnVsbCwgZmVhdHVyZUxhYmVsID09ICdhYm92ZScgPyAnYWJvdmUnIDogJ2JlbG93Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTGFiZWwgPT0gJ2Fib3ZlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0RnVkZ2UgPSBnZy50ZXh0SGVpZ2h0ICsgMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub0xhYmVsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2cgPSBuZXcgVHJhbnNsYXRlZEdseXBoKGdnLCAwLCB5IC0gaGggLSBoZWlnaHRGdWRnZSwgcmVxdWlyZWRIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ0hJU1RPR1JBTScgfHwgZ3R5cGUgPT09ICdHUkFESUVOVCcgJiYgc2NvcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBzbWluID0gdGllci5xdWFudE1pbihzdHlsZSk7XG4gICAgICAgIHZhciBzbWF4ID0gdGllci5xdWFudE1heChzdHlsZSk7XG5cbiAgICAgICAgaWYgKCFzbWF4KSB7XG4gICAgICAgICAgICBpZiAoc21pbiA8IDApIHtcbiAgICAgICAgICAgICAgICBzbWF4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc21heCA9IDEwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc21pbikge1xuICAgICAgICAgICAgc21pbiA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKDEuMCAqIHNjb3JlKSA8ICgxLjAgKnNtaW4pKSB7XG4gICAgICAgICAgICBzY29yZSA9IHNtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgxLjAgKiBzY29yZSkgPiAoMS4wICogc21heCkpIHtcbiAgICAgICAgICAgIHNjb3JlID0gc21heDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVsU2NvcmUgPSAoKDEuMCAqIHNjb3JlKSAtIHNtaW4pIC8gKHNtYXgtc21pbik7XG4gICAgICAgIHZhciByZWxPcmlnaW4gPSAoLTEuMCAqIHNtaW4pIC8gKHNtYXggLSBzbWluKTtcblxuICAgICAgICBpZiAoZ3R5cGUgPT09ICdISVNUT0dSQU0nKSB7XG4gICAgICAgICAgICBpZiAocmVsU2NvcmUgPj0gcmVsT3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gKHJlbFNjb3JlIC0gTWF0aC5tYXgoMCwgcmVsT3JpZ2luKSkgKiByZXF1aXJlZEhlaWdodDtcbiAgICAgICAgICAgICAgICB5ID0geSArICgoMS4wIC0gTWF0aC5tYXgoMCwgcmVsT3JpZ2luKSkgKiByZXF1aXJlZEhlaWdodCkgLSBoZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IChNYXRoLm1heCgwLCByZWxPcmlnaW4pIC0gcmVsU2NvcmUpICogcmVxdWlyZWRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgeSA9IHkgKyAoKDEuMCAtIE1hdGgubWF4KDAsIHJlbE9yaWdpbikpICogcmVxdWlyZWRIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVhbnQgPSB7bWluOiBzbWluLCBtYXg6IHNtYXh9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cm9rZSA9IHN0eWxlLkZHQ09MT1IgfHwgbnVsbDtcbiAgICAgICAgdmFyIGZpbGwgPSBzdHlsZS5CR0NPTE9SIHx8IHN0eWxlLkNPTE9SMSB8fCAnZ3JlZW4nO1xuICAgICAgICBpZiAoc3R5bGUuQkdJVEVNICYmIGZlYXR1cmUuaXRlbVJnYilcbiAgICAgICAgICAgIGZpbGwgPSBmZWF0dXJlLml0ZW1SZ2I7XG4gICAgICAgIHZhciBhbHBoYSA9IHN0eWxlLkFMUEhBID8gKDEuMCAqIHN0eWxlLkFMUEhBKSA6IG51bGw7XG5cbiAgICAgICAgaWYgKHN0eWxlLkJHR1JBRCkge1xuICAgICAgICAgICAgdmFyIGdyYWQgPSBzdHlsZS5CR0dSQUQ7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IChyZWxTY29yZSpncmFkLmxlbmd0aCl8MDtcbiAgICAgICAgICAgIGlmIChzdGVwIDwgMCkgc3RlcCA9IDA7XG4gICAgICAgICAgICBpZiAoc3RlcCA+PSBncmFkLmxlbmd0aCkgc3RlcCA9IGdyYWQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGZpbGwgPSBncmFkW3N0ZXBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZS5DT0xPUjIpIHtcbiAgICAgICAgICAgIHZhciBncmFkID0gc3R5bGUuX2dyYWRpZW50O1xuICAgICAgICAgICAgaWYgKCFncmFkKSB7XG4gICAgICAgICAgICAgICAgZ3JhZCA9IG1ha2VHcmFkaWVudCg1MCwgc3R5bGUuQ09MT1IxLCBzdHlsZS5DT0xPUjIsIHN0eWxlLkNPTE9SMyk7XG4gICAgICAgICAgICAgICAgc3R5bGUuX2dyYWRpZW50ID0gZ3JhZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0ZXAgPSAocmVsU2NvcmUqZ3JhZC5sZW5ndGgpfDA7XG4gICAgICAgICAgICBpZiAoc3RlcCA8IDApIHN0ZXAgPSAwO1xuICAgICAgICAgICAgaWYgKHN0ZXAgPj0gZ3JhZC5sZW5ndGgpIHN0ZXAgPSBncmFkLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBmaWxsID0gZ3JhZFtzdGVwXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdnID0gbmV3IEJveEdseXBoKG1pblBvcywgeSwgKG1heFBvcyAtIG1pblBvcyksIGhlaWdodCwgZmlsbCwgc3Ryb2tlLCBhbHBoYSk7XG4gICAgICAgIGdnID0gbmV3IFRyYW5zbGF0ZWRHbHlwaChnZywgMCwgMCwgcmVxdWlyZWRIZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoZ3R5cGUgPT09ICdISURERU4nKSB7XG4gICAgICAgIGdnID0gbmV3IFBhZGRlZEdseXBoKG51bGwsIG1pblBvcywgbWF4UG9zKTtcbiAgICAgICAgbm9MYWJlbCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ0FSUk9XJykge1xuICAgICAgICB2YXIgY29sb3IgPSBzdHlsZS5GR0NPTE9SIHx8ICdwdXJwbGUnO1xuICAgICAgICB2YXIgcGFyYWxsZWwgPSBpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLlBBUkFMTEVMKTtcbiAgICAgICAgdmFyIHN3ID0gaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5TT1VUSFdFU1QpO1xuICAgICAgICB2YXIgbmUgPSBpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLk5PUlRIRUFTVCk7XG4gICAgICAgIGdnID0gbmV3IEFycm93R2x5cGgobWluUG9zLCBtYXhQb3MsIGhlaWdodCwgY29sb3IsIHBhcmFsbGVsLCBzdywgbmUpO1xuICAgIH0gZWxzZSBpZiAoZ3R5cGUgPT09ICdBTkNIT1JFRF9BUlJPVycpIHtcbiAgICAgICAgdmFyIHN0cm9rZSA9IHN0eWxlLkZHQ09MT1IgfHwgJ25vbmUnO1xuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgJ2dyZWVuJztcbiAgICAgICAgZ2cgPSBuZXcgQUFycm93R2x5cGgobWluUG9zLCBtYXhQb3MsIGhlaWdodCwgZmlsbCwgc3Ryb2tlLCBzdHJhbmQpO1xuICAgICAgICBnZy5idW1wID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGd0eXBlID09PSAnU1BBTicpIHtcbiAgICAgICAgdmFyIHN0cm9rZSA9IHN0eWxlLkZHQ09MT1IgfHwgJ2JsYWNrJztcbiAgICAgICAgZ2cgPSBuZXcgU3BhbkdseXBoKG1pblBvcywgbWF4UG9zLCBoZWlnaHQsIHN0cm9rZSk7XG4gICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ0xJTkUnKSB7XG4gICAgICAgIHZhciBzdHJva2UgPSBzdHlsZS5GR0NPTE9SIHx8ICdibGFjayc7XG4gICAgICAgIHZhciBsaW5lU3R5bGUgPSBzdHlsZS5TVFlMRSB8fCAnc29saWQnO1xuICAgICAgICBnZyA9IG5ldyBMaW5lR2x5cGgobWluUG9zLCBtYXhQb3MsIGhlaWdodCwgbGluZVN0eWxlLCBzdHJhbmQsIHN0cm9rZSk7XG4gICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ1BSSU1FUlMnKSB7XG4gICAgICAgIHZhciBzdHJva2UgPSBzdHlsZS5GR0NPTE9SIHx8ICdibGFjayc7XG4gICAgICAgIHZhciBmaWxsID0gc3R5bGUuQkdDT0xPUiB8fCAncmVkJztcbiAgICAgICAgZ2cgPSBuZXcgUHJpbWVyc0dseXBoKG1pblBvcywgbWF4UG9zLCBoZWlnaHQsIGZpbGwsIHN0cm9rZSk7XG4gICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ1RFWFQnKSB7XG4gICAgICAgIHZhciBzdHJpbmcgPSBzdHlsZS5TVFJJTkcgfHwgJ3RleHQnO1xuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLkZHQ09MT1IgfHwgJ2JsYWNrJztcbiAgICAgICAgZ2cgPSBuZXcgVGV4dEdseXBoKEdMT0JBTF9HQywgbWluUG9zLCBtYXhQb3MsIGhlaWdodCwgZmlsbCwgc3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKGd0eXBlID09PSAnVE9PTUFOWScpIHtcbiAgICAgICAgdmFyIHN0cm9rZSA9IHN0eWxlLkZHQ09MT1IgfHwgJ2dyYXknO1xuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgJ29yYW5nZSc7XG4gICAgICAgIGdnID0gbmV3IFRvb01hbnlHbHlwaChtaW5Qb3MsIG1heFBvcywgaGVpZ2h0LCBmaWxsLCBzdHJva2UpO1xuICAgIH0gZWxzZSBpZiAoZ3R5cGUgPT09ICdQT0lOVCcpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRpZXIuZm9yY2VIZWlnaHQgfHwgc3R5bGUuSEVJR0hUIHx8IDMwO1xuICAgICAgICB2YXIgc21pbiA9IHRpZXIucXVhbnRNaW4oc3R5bGUpO1xuICAgICAgICB2YXIgc21heCA9IHRpZXIucXVhbnRNYXgoc3R5bGUpO1xuICAgICAgICB2YXIgeXNjYWxlID0gKCgxLjAgKiBoZWlnaHQpIC8gKHNtYXggLSBzbWluKSk7XG4gICAgICAgIHZhciByZWxTY29yZSA9ICgoMS4wICogc2NvcmUpIC0gc21pbikgLyAoc21heC1zbWluKTtcbiAgICAgICAgdmFyIHNjID0gKChzY29yZSAtICgxLjAqc21pbikpICogeXNjYWxlKXwwO1xuICAgICAgICBxdWFudCA9IHttaW46IHNtaW4sIG1heDogc21heH07XG5cbiAgICAgICAgdmFyIGZpbGwgPSBzdHlsZS5GR0NPTE9SIHx8IHN0eWxlLkNPTE9SMSB8fCAnYmxhY2snO1xuICAgICAgICBpZiAoc3R5bGUuQ09MT1IyKSB7XG4gICAgICAgICAgICB2YXIgZ3JhZCA9IHN0eWxlLl9ncmFkaWVudDtcbiAgICAgICAgICAgIGlmICghZ3JhZCkge1xuICAgICAgICAgICAgICAgIGdyYWQgPSBtYWtlR3JhZGllbnQoNTAsIHN0eWxlLkNPTE9SMSwgc3R5bGUuQ09MT1IyLCBzdHlsZS5DT0xPUjMpO1xuICAgICAgICAgICAgICAgIHN0eWxlLl9ncmFkaWVudCA9IGdyYWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGVwID0gKHJlbFNjb3JlKmdyYWQubGVuZ3RoKXwwO1xuICAgICAgICAgICAgaWYgKHN0ZXAgPCAwKSBzdGVwID0gMDtcbiAgICAgICAgICAgIGlmIChzdGVwID49IGdyYWQubGVuZ3RoKSBzdGVwID0gZ3JhZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgZmlsbCA9IGdyYWRbc3RlcF07XG4gICAgICAgIH0gXG5cbiAgICAgICAgZ2cgPSBuZXcgUG9pbnRHbHlwaCgobWluUG9zICsgbWF4UG9zKS8yLCBoZWlnaHQtc2MsIGhlaWdodCwgZmlsbCk7XG4gICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ19fU0VRVUVOQ0UnKSB7XG4gICAgICAgIHZhciByYXdzZXEgPSBmZWF0dXJlLnNlcTtcbiAgICAgICAgdmFyIHNlcSA9IHJhd3NlcTtcbiAgICAgICAgdmFyIHJhd3F1YWxzID0gZmVhdHVyZS5xdWFscztcbiAgICAgICAgdmFyIHF1YWxzID0gcmF3cXVhbHM7XG4gICAgICAgIHZhciBpbnNlcnRpb25MYWJlbHMgPSBpc0Rhc0Jvb2xlYW5UcnVlKHN0eWxlLl9fSU5TRVJUSU9OUyk7XG5cbiAgICAgICAgdmFyIGluZGVscyA9IFtdO1xuICAgICAgICBpZiAoZmVhdHVyZS5jaWdhcikge1xuICAgICAgICAgICAgdmFyIG9wcyA9IHBhcnNlQ2lnYXIoZmVhdHVyZS5jaWdhcik7XG4gICAgICAgICAgICBzZXEgPSAnJ1xuICAgICAgICAgICAgcXVhbHMgPSAnJztcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IG9wcy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgY28gPSBvcHNbY2ldO1xuICAgICAgICAgICAgICAgIGlmIChjby5vcCA9PSAnTScpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxICs9IHJhd3NlcS5zdWJzdHIoY3Vyc29yLCBjby5jbnQpO1xuICAgICAgICAgICAgICAgICAgICBxdWFscyArPSByYXdxdWFscy5zdWJzdHIoY3Vyc29yLCBjby5jbnQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgKz0gY28uY250O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY28ub3AgPT0gJ0QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG9pID0gMDsgb2kgPCBjby5jbnQ7ICsrb2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcSArPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWFscyArPSAnWic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvLm9wID09ICdJJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zZXEgPSAgcmF3c2VxLnN1YnN0cihjdXJzb3IsIGNvLmNudCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZyA9IG5ldyBUcmlhbmdsZUdseXBoKG1pblBvcyArIChzZXEubGVuZ3RoKnNjYWxlKSwgNSwgJ1MnLCA1LCB0aWVyLmJyb3dzZXIuYmFzZUNvbG9yc1snSSddKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc2VydGlvbkxhYmVscylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlnID0gbmV3IExhYmVsbGVkR2x5cGgoR0xPQkFMX0dDLCBpZywgaW5zZXEsIGZhbHNlLCAnY2VudGVyJywgJ2Fib3ZlJywgJzdweCBzYW5zLXNlcmlmJyk7XG4gICAgICAgICAgICAgICAgICAgIGlnLmZlYXR1cmUgPSB7bGFiZWw6ICdJbnNlcnRpb246ICcgKyBpbnNlcSwgdHlwZTogJ2luc2VydGlvbicsIG1ldGhvZDogJ2luc2VydGlvbid9O1xuICAgICAgICAgICAgICAgICAgICBpbmRlbHMucHVzaChpZyk7XG5cbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yICs9IGNvLmNudDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvLm9wID09ICdTJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgKz0gY28uY250O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1bmtub3duIGNpZ29wJyArIGNvLm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmU2VxID0gZ2V0UmVmU2VxKHRpZXIsIG1pbiwgbWF4KTtcbiAgICAgICAgaWYgKHNlcSAmJiByZWZTZXEgJiYgKHN0eWxlLl9fU0VRQ09MT1IgPT09ICdtaXNtYXRjaCcgfHwgc3R5bGUuX19TRVFDT0xPUiA9PT0gJ21pc21hdGNoLWFsbCcpKSB7XG4gICAgICAgICAgICB2YXIgbWlzbWF0Y2hTZXEgPSBbXTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGZlYXR1cmUub3JpZW50YXRpb24gPT09ICctJyA/ICcsJyA6ICcuJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIG1pc21hdGNoU2VxLnB1c2goc2VxW2ldID09IHJlZlNlcVtpXSA/IG1hdGNoIDogc2VxW2ldKTtcbiAgICAgICAgICAgIHNlcSA9IG1pc21hdGNoU2VxLmpvaW4oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0cmFuZENvbG9yO1xuICAgICAgICBpZiAoZmVhdHVyZS5vcmllbnRhdGlvbiA9PT0gJy0nKVxuICAgICAgICAgICAgc3RyYW5kQ29sb3IgPSBzdHlsZS5fbWludXNDb2xvciB8fCAnbGlnaHRza3libHVlJztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RyYW5kQ29sb3IgPSBzdHlsZS5fcGx1c0NvbG9yIHx8ICdsaWdodHNhbG1vbic7XG5cbiAgICAgICAgaWYgKHN0eWxlLl9fZGlzYWJsZVF1YWxzKVxuICAgICAgICAgICAgcXVhbHMgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGdnID0gbmV3IFNlcXVlbmNlR2x5cGgoXG4gICAgICAgICAgICB0aWVyLmJyb3dzZXIuYmFzZUNvbG9ycywgXG4gICAgICAgICAgICBzdHJhbmRDb2xvciwgXG4gICAgICAgICAgICBtaW5Qb3MsIFxuICAgICAgICAgICAgbWF4UG9zLCBcbiAgICAgICAgICAgIGhlaWdodCwgXG4gICAgICAgICAgICBzZXEsIFxuICAgICAgICAgICAgcmVmU2VxLCBcbiAgICAgICAgICAgIHN0eWxlLl9fU0VRQ09MT1IsIFxuICAgICAgICAgICAgcXVhbHMsXG4gICAgICAgICAgICAhaXNEYXNCb29sZWFuVHJ1ZShzdHlsZS5fX0NMRUFSQkcpXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbnNlcnRpb25MYWJlbHMpXG4gICAgICAgICAgICBnZyA9IG5ldyBUcmFuc2xhdGVkR2x5cGgoZ2csIDAsIDcpO1xuICAgICAgICBpZiAoaW5kZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGluZGVscy5zcGxpY2UoMCwgMCwgZ2cpO1xuICAgICAgICAgICAgZ2cgPSBuZXcgR3JvdXBHbHlwaChpbmRlbHMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChndHlwZSA9PT0gJ19fSU5TRVJUSU9OJykge1xuICAgICAgICB2YXIgaWcgPSBuZXcgVHJpYW5nbGVHbHlwaChtaW5Qb3MsIDUsICdTJywgNSwgdGllci5icm93c2VyLmJhc2VDb2xvcnNbJ0knXSk7XG4gICAgICAgIGdnID0gbmV3IExhYmVsbGVkR2x5cGgoR0xPQkFMX0dDLCBpZywgZmVhdHVyZS5pbnNlcnRpb24gfHwgZmVhdHVyZS5hbHRBbGxlbGVzWzBdLCBmYWxzZSwgJ2NlbnRlcicsICdhYm92ZScsICc3cHggc2Fucy1zZXJpZicpO1xuICAgICAgICBpZiAoKG1heFBvcyAtIG1pblBvcykgPiAxKSB7XG4gICAgICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgc3R5bGUuQ09MT1IxIHx8ICdncmVlbic7XG4gICAgICAgICAgICB2YXIgYmcgPSBuZXcgQm94R2x5cGgobWluUG9zLCA1LCAobWF4UG9zIC0gbWluUG9zKSwgaGVpZ2h0LCBmaWxsLCBzdHJva2UpO1xuICAgICAgICAgICAgZ2cgPSBuZXcgR3JvdXBHbHlwaChbYmcsIGdnXSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGd0eXBlID09PSAnX19OT05FJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgLyogZGVmYXVsdCB0byBCT1ggKi8ge1xuICAgICAgICB2YXIgc3Ryb2tlID0gc3R5bGUuRkdDT0xPUiB8fCBudWxsO1xuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLkJHQ09MT1IgfHwgc3R5bGUuQ09MT1IxIHx8ICdncmVlbic7XG4gICAgICAgIGlmIChzdHlsZS5CR0lURU0gJiYgZmVhdHVyZS5pdGVtUmdiKVxuICAgICAgICAgICAgZmlsbCA9IGZlYXR1cmUuaXRlbVJnYjtcbiAgICAgICAgdmFyIHNjYWxlID0gKG1heFBvcyAtIG1pblBvcykgLyAobWF4IC0gbWluKTtcbiAgICAgICAgaWYgKGZlYXR1cmUudHlwZSA9PSAndHJhbnNsYXRpb24nICYmXG4gICAgICAgICAgICAoZmVhdHVyZS5tZXRob2QgPT0gJ3Byb3RlaW5fY29kaW5nJyB8fCBmZWF0dXJlLnJlYWRmcmFtZUV4cGxpY2l0KSAmJlxuICAgICAgICAgICAgKCFmZWF0dXJlLnRhZ3MgfHwgZmVhdHVyZS50YWdzLmluZGV4T2YoJ2Nkc19zdGFydF9ORicpIDwgMCB8fCBmZWF0dXJlLnJlYWRmcmFtZUV4cGxpY2l0KSAmJlxuICAgICAgICAgICAgKCF0aWVyLmRhc1NvdXJjZS5jb2xsYXBzZVN1cGVyR3JvdXBzIHx8IHRpZXIuYnVtcGVkKVxuICAgICAgICAgICAgJiYgc2NhbGUgPj0gMC41KSB7XG4gICAgICAgICAgICB2YXIgcmVmU2VxID0gZ2V0UmVmU2VxKHRpZXIsIG1pbiwgbWF4KTtcbiAgICAgICAgICAgIGdnID0gbmV3IEFtaW5vQWNpZEdseXBoKG1pblBvcywgbWF4UG9zLCBoZWlnaHQsIGZpbGwsIHJlZlNlcSwgZmVhdHVyZS5vcmllbnRhdGlvbiwgZmVhdHVyZS5yZWFkZnJhbWUpOyAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdnID0gbmV3IEJveEdseXBoKG1pblBvcywgMCwgKG1heFBvcyAtIG1pblBvcyksIGhlaWdodCwgZmlsbCwgc3Ryb2tlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZy5idW1wID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoKGlzRGFzQm9vbGVhblRydWUoc3R5bGUuTEFCRUwpIHx8IGZlYXR1cmUuZm9yY2VMYWJlbCkgJiYgbGFiZWwgJiYgIW5vTGFiZWwpIHtcbiAgICAgICAgZ2cgPSBuZXcgTGFiZWxsZWRHbHlwaChHTE9CQUxfR0MsIGdnLCBsYWJlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIGlmIChidW1wKSB7XG4gICAgICAgIGdnLmJ1bXAgPSB0cnVlO1xuICAgIH1cblxuICAgIGdnLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgIGlmIChxdWFudCkge1xuICAgICAgICBnZy5xdWFudCA9IHF1YW50O1xuICAgIH1cblxuICAgIGlmIChzdHlsZS5aSU5ERVgpIHtcbiAgICAgICAgZ2cuemluZGV4ID0gc3R5bGUuWklOREVYIHwgMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2c7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnN0eWxlRm9yRmVhdHVyZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgc3NTY2FsZSA9IHRoaXMuYnJvd3Nlci56b29tRm9yQ3VycmVudFNjYWxlKCk7XG5cbiAgICBpZiAoIXRoaXMuc3R5bGVzaGVldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmUgPSBudWxsO1xuICAgIHZhciBzcyA9IHRoaXMuc3R5bGVzaGVldC5zdHlsZXM7XG4gICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgc2ggPSBzc1tzaV07XG4gICAgICAgIGlmIChzaC56b29tICYmIHNoLnpvb20gIT0gc3NTY2FsZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2gub3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIGlmIChzaC5vcmllbnRhdGlvbiAhPSBmLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFiZWxSRSA9IHNoLl9sYWJlbFJFO1xuICAgICAgICBpZiAoIWxhYmVsUkUgfHwgIWxhYmVsUkUudGVzdCkge1xuICAgICAgICAgICAgbGFiZWxSRSA9IG5ldyBSZWdFeHAoJ14nICsgc2gubGFiZWwgKyAnJCcpO1xuICAgICAgICAgICAgc2guX2xhYmVsUkUgPSBsYWJlbFJFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaC5sYWJlbCAmJiAhKGxhYmVsUkUudGVzdChmLmxhYmVsKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtZXRob2RSRSA9IHNoLl9tZXRob2RSRTtcbiAgICAgICAgaWYgKCFtZXRob2RSRSB8fCAhbWV0aG9kUkUudGVzdCkge1xuICAgICAgICAgICAgbWV0aG9kUkUgPSBuZXcgUmVnRXhwKCdeJyArIHNoLm1ldGhvZCArICckJyk7XG4gICAgICAgICAgICBzaC5fbWV0aG9kUkUgPSBtZXRob2RSRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2gubWV0aG9kICYmICEobWV0aG9kUkUudGVzdChmLm1ldGhvZCkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2gudHlwZSkge1xuICAgICAgICAgICAgaWYgKHNoLnR5cGUgPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXliZSkge1xuICAgICAgICAgICAgICAgICAgICBtYXliZSA9IHNoLnN0eWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGVSRSA9IHNoLl90eXBlUkU7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlUkUgfHwgIXR5cGVSRS50ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVSRSA9IG5ldyBSZWdFeHAoJ14nICsgc2gudHlwZSArICckJyk7XG4gICAgICAgICAgICAgICAgICAgIHNoLl90eXBlUkUgPSB0eXBlUkU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdHlwZVJFLnRlc3QoZi50eXBlKSkgXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaC5zdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIG1heWJlO1xufVxuXG5mdW5jdGlvbiBtYWtlTGluZUdseXBoKGZlYXR1cmVzLCBzdHlsZSwgdGllcikge1xuICAgIHZhciBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0LCBzY2FsZSA9IHRpZXIuYnJvd3Nlci5zY2FsZTtcbiAgICB2YXIgaGVpZ2h0ID0gdGllci5mb3JjZUhlaWdodCB8fCBzdHlsZS5IRUlHSFQgfHwgMzA7XG4gICAgdmFyIG1pbiA9IHRpZXIucXVhbnRNaW4oc3R5bGUpO1xuICAgIHZhciBtYXggPSB0aWVyLnF1YW50TWF4KHN0eWxlKTtcbiAgICB2YXIgeXNjYWxlID0gKCgxLjAgKiBoZWlnaHQpIC8gKG1heCAtIG1pbikpO1xuICAgIHZhciB3aWR0aCA9IHN0eWxlLkxJTkVXSURUSCB8fCAxO1xuICAgIHZhciBjb2xvciA9IHN0eWxlLkZHQ09MT1IgfHwgc3R5bGUuQ09MT1IxIHx8ICdibGFjayc7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZlYXR1cmVzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2ZpXTtcblxuICAgICAgICB2YXIgcHggPSAoKCgoZi5taW58MCkgKyAoZi5tYXh8MCkpIC8gMikgLSBvcmlnaW4pICogc2NhbGU7XG4gICAgICAgIHZhciBzYyA9ICgoZi5zY29yZSAtICgxLjAqbWluKSkgKiB5c2NhbGUpfDA7XG4gICAgICAgIHZhciBweSA9IChoZWlnaHQgLSBzYyk7ICAvLyBGSVhNRSB5Pz8/XG4gICAgICAgIHBvaW50cy5wdXNoKHB4KTtcbiAgICAgICAgcG9pbnRzLnB1c2gocHkpO1xuICAgIH1cbiAgICB2YXIgbGdnID0gbmV3IExpbmVHcmFwaEdseXBoKHBvaW50cywgY29sb3IsIGhlaWdodCk7XG4gICAgbGdnLnF1YW50ID0ge21pbjogbWluLCBtYXg6IG1heH07XG5cbiAgICBpZiAoc3R5bGUuWklOREVYKSBcbiAgICAgICAgbGdnLnppbmRleCA9IHN0eWxlLlpJTkRFWHwwO1xuXG4gICAgcmV0dXJuIGxnZztcbn1cblxuRGFzVGllci5wcm90b3R5cGUucXVhbnRNaW4gPSBmdW5jdGlvbihzdHlsZSkge1xuICAgIGlmICh0aGlzLmZvcmNlTWluRHluYW1pYykge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RmVhdHVyZXNNaW5TY29yZSB8fCAwO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKHRoaXMuZm9yY2VNaW4pID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JjZU1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3R5bGUuTUlOIHx8IHRoaXMuY3VycmVudEZlYXR1cmVzTWluU2NvcmUgfHwgMDtcbiAgICB9XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnF1YW50TWF4ID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICBpZiAodGhpcy5mb3JjZU1heER5bmFtaWMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZlYXR1cmVzTWF4U2NvcmUgfHwgMDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZih0aGlzLmZvcmNlTWF4KSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9yY2VNYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0eWxlLk1BWCB8fCB0aGlzLmN1cnJlbnRGZWF0dXJlc01heFNjb3JlIHx8IDA7XG4gICAgfVxufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGRyYXdGZWF0dXJlVGllcjogZHJhd0ZlYXR1cmVUaWVyXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTFcbi8vXG4vLyBmZWF0dXJlLXBvcHVwLmpzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgcGljayA9IHV0aWxzLnBpY2s7XG4gICAgdmFyIHB1c2huZXcgPSB1dGlscy5wdXNobmV3O1xuICAgIHZhciBtYWtlRWxlbWVudCA9IHV0aWxzLm1ha2VFbGVtZW50O1xufVxuXG5cbnZhciBUQUdWQUxfTk9URV9SRSA9IG5ldyBSZWdFeHAoJ14oW0EtWmEtel8tXSspPSguKyknKTtcblxuQnJvd3Nlci5wcm90b3R5cGUuYWRkRmVhdHVyZUluZm9QbHVnaW4gPSBmdW5jdGlvbihoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLmZlYXR1cmVJbmZvUGx1Z2lucykge1xuICAgICAgICB0aGlzLmZlYXR1cmVJbmZvUGx1Z2lucyA9IFtdO1xuICAgIH1cbiAgICB0aGlzLmZlYXR1cmVJbmZvUGx1Z2lucy5wdXNoKGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBGZWF0dXJlSW5mbyhoaXQsIGZlYXR1cmUsIGdyb3VwKSB7XG4gICAgdmFyIG5hbWUgPSBwaWNrKGdyb3VwLnR5cGUsIGZlYXR1cmUudHlwZSk7XG4gICAgdmFyIGZpZCA9IHBpY2soZ3JvdXAubGFiZWwsIGZlYXR1cmUubGFiZWwsIGdyb3VwLmlkLCBmZWF0dXJlLmlkKTtcbiAgICBpZiAoZmlkICYmIGZpZC5pbmRleE9mKCdfX2RhenpsZScpICE9IDApIHtcbiAgICAgICAgbmFtZSA9IG5hbWUgKyAnOiAnICsgZmlkO1xuICAgIH1cblxuICAgIHRoaXMuaGl0ID0gaGl0O1xuICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgdGhpcy5ncm91cCA9IGdyb3VwO1xuICAgIHRoaXMudGl0bGUgPSBuYW1lO1xuICAgIHRoaXMuc2VjdGlvbnMgPSBbXTtcbn1cblxuRmVhdHVyZUluZm8ucHJvdG90eXBlLnNldFRpdGxlID0gZnVuY3Rpb24odCkge1xuICAgIHRoaXMudGl0bGUgPSB0O1xufVxuXG5GZWF0dXJlSW5mby5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24obGFiZWwsIGluZm8pIHtcbiAgICBpZiAodHlwZW9mIGluZm8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGluZm8gPSBtYWtlRWxlbWVudCgnc3BhbicsIGluZm8pO1xuICAgIH1cbiAgICB0aGlzLnNlY3Rpb25zLnB1c2goe2xhYmVsOiBsYWJlbCwgaW5mbzogaW5mb30pO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5mZWF0dXJlUG9wdXAgPSBmdW5jdGlvbihldiwgX19pZ25vcmVkX2ZlYXR1cmUsIGhpdCwgdGllcikge1xuICAgIHZhciBoaSA9IGhpdC5sZW5ndGg7XG4gICAgdmFyIGZlYXR1cmUgPSAtLWhpID49IDAgPyBoaXRbaGldIDoge307XG4gICAgdmFyIGdyb3VwID0gLS1oaSA+PSAwID8gaGl0W2hpXSA6IHt9O1xuXG4gICAgdmFyIGZlYXR1cmVJbmZvID0gbmV3IEZlYXR1cmVJbmZvKGhpdCwgZmVhdHVyZSwgZ3JvdXApO1xuICAgIGZlYXR1cmVJbmZvLnRpZXIgPSB0aWVyO1xuICAgIHZhciBmaXBzID0gdGhpcy5mZWF0dXJlSW5mb1BsdWdpbnMgfHwgW107XG4gICAgZm9yICh2YXIgZmlwaSA9IDA7IGZpcGkgPCBmaXBzLmxlbmd0aDsgKytmaXBpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaXBzW2ZpcGldKGZlYXR1cmUsIGZlYXR1cmVJbmZvKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZS5zdGFjayB8fCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaXBzID0gdGllci5mZWF0dXJlSW5mb1BsdWdpbnMgfHwgW107XG4gICAgZm9yIChmaXBpID0gMDsgZmlwaSA8IGZpcHMubGVuZ3RoOyArK2ZpcGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpcHNbZmlwaV0oZmVhdHVyZSwgZmVhdHVyZUluZm8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlLnN0YWNrIHx8IGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmVBbGxQb3B1cHMoKTtcblxuICAgIHZhciB0YWJsZSA9IG1ha2VFbGVtZW50KCd0YWJsZScsIG51bGwsIHtjbGFzc05hbWU6ICd0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWNvbmRlbnNlZCd9KTtcbiAgICB0YWJsZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICB0YWJsZS5zdHlsZS5tYXJnaW4gPSAnMHB4JztcblxuICAgIHZhciBpZHggPSAwO1xuICAgIGlmIChmZWF0dXJlLm1ldGhvZCkge1xuICAgICAgICB2YXIgcm93ID0gbWFrZUVsZW1lbnQoJ3RyJywgW1xuICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RoJywgJ01ldGhvZCcpLFxuICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgZmVhdHVyZS5tZXRob2QpXG4gICAgICAgIF0pO1xuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICArK2lkeDtcbiAgICB9XG4gICAge1xuICAgICAgICB2YXIgbG9jO1xuICAgICAgICBpZiAoZ3JvdXAuc2VnbWVudCkge1xuICAgICAgICAgICAgbG9jID0gZ3JvdXA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2MgPSBmZWF0dXJlO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3cgPSBtYWtlRWxlbWVudCgndHInLCBbXG4gICAgICAgICAgICBtYWtlRWxlbWVudCgndGgnLCAnTG9jYXRpb24nKSxcbiAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIGxvYy5zZWdtZW50ICsgJzonICsgbG9jLm1pbiArICctJyArIGxvYy5tYXgsIHt9LCB7bWluV2lkdGg6ICcyMDBweCd9KVxuICAgICAgICBdKTtcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgKytpZHg7XG4gICAgfVxuICAgIGlmIChmZWF0dXJlLnNjb3JlICE9PSB1bmRlZmluZWQgJiYgZmVhdHVyZS5zY29yZSAhPT0gbnVsbCAmJiBmZWF0dXJlLnNjb3JlICE9ICctJ1xuICAgICAgICAmJiAhZmVhdHVyZS5zdXBwcmVzc1Njb3JlKSB7XG4gICAgICAgIHZhciByb3cgPSBtYWtlRWxlbWVudCgndHInLCBbXG4gICAgICAgICAgICBtYWtlRWxlbWVudCgndGgnLCAnU2NvcmUnKSxcbiAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsICcnICsgZmVhdHVyZS5zY29yZSlcbiAgICAgICAgXSk7XG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICsraWR4O1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciBsaW5rcyA9IG1heWJlQ29uY2F0KGdyb3VwLmxpbmtzLCBmZWF0dXJlLmxpbmtzKTtcbiAgICAgICAgaWYgKGxpbmtzICYmIGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBtYWtlRWxlbWVudCgndHInLCBbXG4gICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RoJywgJ0xpbmtzJyksXG4gICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgbGlua3MubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFbGVtZW50KCdkaXYnLCBtYWtlRWxlbWVudCgnYScsIGwuZGVzYywge2hyZWY6IGwudXJpLCB0YXJnZXQ6ICdfbmV3J30pKTtcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgICAgICsraWR4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgICAgdmFyIG5vdGVzID0gbWF5YmVDb25jYXQoZ3JvdXAubm90ZXMsIGZlYXR1cmUubm90ZXMpO1xuICAgICAgICBmb3IgKHZhciBuaSA9IDA7IG5pIDwgbm90ZXMubGVuZ3RoOyArK25pKSB7XG4gICAgICAgICAgICB2YXIgayA9ICdOb3RlJztcbiAgICAgICAgICAgIHZhciB2ID0gbm90ZXNbbmldO1xuICAgICAgICAgICAgdmFyIG0gPSB2Lm1hdGNoKFRBR1ZBTF9OT1RFX1JFKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgayA9IG1bMV07XG4gICAgICAgICAgICAgICAgdiA9IG1bMl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByb3cgPSBtYWtlRWxlbWVudCgndHInLCBbXG4gICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RoJywgayksXG4gICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgdilcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgICAgICsraWR4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgZmlzaSA9IDA7IGZpc2kgPCBmZWF0dXJlSW5mby5zZWN0aW9ucy5sZW5ndGg7ICsrZmlzaSkge1xuICAgICAgICB2YXIgc2VjdGlvbiA9IGZlYXR1cmVJbmZvLnNlY3Rpb25zW2Zpc2ldO1xuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgndHInLCBbXG4gICAgICAgICAgICBtYWtlRWxlbWVudCgndGgnLCBzZWN0aW9uLmxhYmVsKSxcbiAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIHNlY3Rpb24uaW5mbyldKSk7XG4gICAgfSAgICAgICAgXG5cbiAgICB0aGlzLnBvcGl0KGV2LCBmZWF0dXJlSW5mby50aXRsZSB8fCAnRmVhdHVyZScsIHRhYmxlLCB7d2lkdGg6IDQ1MH0pO1xufVxuXG5mdW5jdGlvbiBtYXliZUNvbmNhdChhLCBiKSB7XG4gICAgdmFyIGwgPSBbXTtcbiAgICBpZiAoYSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHB1c2huZXcobCwgYVtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBwdXNobmV3KGwsIGJbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuICAgIHZhciBwdXNobyA9IHV0aWxzLnB1c2hvO1xuICAgIHZhciBwdXNobmV3byA9IHV0aWxzLnB1c2huZXdvO1xufVxuXG5mdW5jdGlvbiBzb3J0RmVhdHVyZXModGllcilcbntcbiAgICB2YXIgZG1pbiA9IHRpZXIuYnJvd3Nlci5kcmF3blN0YXJ0LCBkbWF4ID0gdGllci5icm93c2VyLmRyYXduRW5kO1xuICAgIHZhciB1bmdyb3VwZWRGZWF0dXJlcyA9IHt9O1xuICAgIHZhciBncm91cGVkRmVhdHVyZXMgPSB7fTtcbiAgICB2YXIgZHJhd25Hcm91cGVkRmVhdHVyZXMgPSB7fTtcbiAgICB2YXIgZ3JvdXBNaW5zID0ge30sIGdyb3VwTWF4ZXMgPSB7fTtcbiAgICB2YXIgZ3JvdXBzID0ge307XG4gICAgdmFyIHN1cGVyR3JvdXBzID0ge307XG4gICAgdmFyIGdyb3Vwc1RvU3VwZXJzID0ge307XG4gICAgdmFyIG5vblBvc2l0aW9uYWwgPSBbXTtcbiAgICB2YXIgbWluU2NvcmUsIG1heFNjb3JlO1xuICAgIHZhciBmYmlkO1xuXG4gICAgdmFyIGluaXRfZmJpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmYmlkID0ge307XG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCB0aWVyLmN1cnJlbnRGZWF0dXJlcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgIHZhciBmID0gdGllci5jdXJyZW50RmVhdHVyZXNbZmldO1xuICAgICAgICAgICAgaWYgKGYuaWQpIHtcbiAgICAgICAgICAgICAgICBmYmlkW2YuaWRdID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdmFyIHN1cGVyUGFyZW50c09mID0gZnVuY3Rpb24oZikge1xuICAgICAgICAvLyBGSVhNRTogc2hvdWxkIHJlY3VyLlxuICAgICAgICB2YXIgc3BpZHMgPSBbXTtcbiAgICAgICAgaWYgKGYucGFyZW50cykge1xuICAgICAgICAgICAgZm9yICh2YXIgcGkgPSAwOyBwaSA8IGYucGFyZW50cy5sZW5ndGg7ICsrcGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGlkID0gZi5wYXJlbnRzW3BpXTtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGZiaWRbcGlkXTtcbiAgICAgICAgICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFsZXJ0KHAudHlwZSArICc6JyArIHAudHlwZUN2KTtcbiAgICAgICAgICAgICAgICBpZiAocC50eXBlQ3YgPT0gJ1NPOjAwMDA3MDQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2huZXcoc3BpZHMsIHBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGlkcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgdGllci5jdXJyZW50RmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHZhciBmID0gdGllci5jdXJyZW50RmVhdHVyZXNbZmldO1xuICAgICAgICBpZiAoZi5wYXJ0cykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhd24gPSBmLm1pbiA8PSBkbWF4ICYmIGYubWF4ID49IGRtaW47XG5cbiAgICAgICAgaWYgKCFmLm1pbiB8fCAhZi5tYXgpIHtcbiAgICAgICAgICAgIG5vblBvc2l0aW9uYWwucHVzaChmKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGYuc2NvcmUgJiYgZi5zY29yZSAhPSAnLicgJiYgZi5zY29yZSAhPSAnLScpIHtcbiAgICAgICAgICAgIHZhciBzYyA9IDEuMCAqIGYuc2NvcmU7XG4gICAgICAgICAgICBpZiAoIW1pblNjb3JlIHx8IHNjIDwgbWluU2NvcmUpIHtcbiAgICAgICAgICAgICAgICBtaW5TY29yZSA9IHNjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXhTY29yZSB8fCBzYyA+IG1heFNjb3JlKSB7XG4gICAgICAgICAgICAgICAgbWF4U2NvcmUgPSBzYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmR3JvdXBzID0gW107XG4gICAgICAgIHZhciBmU3VwZXJHcm91cCA9IG51bGw7XG4gICAgICAgIGlmIChmLmdyb3Vwcykge1xuICAgICAgICAgICAgZm9yICh2YXIgZ2kgPSAwOyBnaSA8IGYuZ3JvdXBzLmxlbmd0aDsgKytnaSkge1xuICAgICAgICAgICAgICAgIHZhciBnID0gZi5ncm91cHNbZ2ldO1xuICAgICAgICAgICAgICAgIHZhciBnaWQgPSBnLmlkO1xuICAgICAgICAgICAgICAgIGlmIChnLnR5cGUgPT0gJ2dlbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExpa2UgYSBzdXBlci1ncm91cGVyLi4uXG4gICAgICAgICAgICAgICAgICAgIGZTdXBlckdyb3VwID0gZ2lkOyBcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2dpZF0gPSBnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZy50eXBlID09ICd0cmFuc2xhdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byBpZ25vcmUgdGhpcyB0byBnZXQgc2Vuc2libGUgcmVzdWx0cyBmcm9tIGJqLWUgOi0oLlxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hvKGdyb3VwZWRGZWF0dXJlcywgZ2lkLCBmKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBzW2dpZF0gPSBnO1xuICAgICAgICAgICAgICAgICAgICBmR3JvdXBzLnB1c2goZ2lkKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgb2dtID0gZ3JvdXBNaW5zW2dpZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2dtIHx8IGYubWluIDwgb2dtKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBNaW5zW2dpZF0gPSBmLm1pbjtcblxuICAgICAgICAgICAgICAgICAgICBvZ20gPSBncm91cE1heGVzW2dpZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghb2dtIHx8IGYubWF4ID4gb2dtKVxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBNYXhlc1tnaWRdID0gZi5tYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGYucGFyZW50cykge1xuICAgICAgICAgICAgaWYgKCFmYmlkKSB7XG4gICAgICAgICAgICAgICAgaW5pdF9mYmlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBwaSA9IDA7IHBpIDwgZi5wYXJlbnRzLmxlbmd0aDsgKytwaSkge1xuICAgICAgICAgICAgICAgIHZhciBwaWQgPSBmLnBhcmVudHNbcGldO1xuICAgICAgICAgICAgICAgIHZhciBwID0gZmJpZFtwaWRdO1xuICAgICAgICAgICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGVydChcImNvdWxkbid0IGZpbmQgXCIgKyBwaWQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwLnBhcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucGFydHMgPSBbZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHB1c2huZXdvKGdyb3VwZWRGZWF0dXJlcywgcGlkLCBwKTtcbiAgICAgICAgICAgICAgICBwdXNobyhncm91cGVkRmVhdHVyZXMsIHBpZCwgZik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFncm91cHNbcGlkXSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cHNbcGlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHAudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IHAubGFiZWwgfHwgcC5pZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmR3JvdXBzLnB1c2gocGlkKTtcblxuICAgICAgICAgICAgICAgIHZhciBvZ20gPSBncm91cE1pbnNbcGlkXTtcbiAgICAgICAgICAgICAgICBpZiAoIW9nbSB8fCBmLm1pbiA8IG9nbSlcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBNaW5zW3BpZF0gPSBmLm1pbjtcblxuICAgICAgICAgICAgICAgIG9nbSA9IGdyb3VwTWF4ZXNbcGlkXTtcbiAgICAgICAgICAgICAgICBpZiAoIW9nbSB8fCBmLm1heCA+IG9nbSlcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBNYXhlc1twaWRdID0gZi5tYXg7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2dzID0gc3VwZXJQYXJlbnRzT2YocCk7XG4gICAgICAgICAgICAgICAgaWYgKHNncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZTdXBlckdyb3VwID0gc2dzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3AgPSBmYmlkW3Nnc1swXV07XG4gICAgICAgICAgICAgICAgICAgIGdyb3Vwc1tzZ3NbMF1dID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogc3AudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzcC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBzcC5sYWJlbCB8fCBzcC5pZFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRpZXIuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpZXIuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgIFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZHcm91cHMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIGlmIChkcmF3bilcbiAgICAgICAgICAgICAgICBwdXNobyh1bmdyb3VwZWRGZWF0dXJlcywgZi50eXBlLCBmKTtcbiAgICAgICAgfSBlbHNlIGlmIChmU3VwZXJHcm91cCkge1xuICAgICAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBmR3JvdXBzLmxlbmd0aDsgKytnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdpZCA9IGZHcm91cHNbZ107XG4gICAgICAgICAgICAgICAgcHVzaG5ld28oc3VwZXJHcm91cHMsIGZTdXBlckdyb3VwLCBnaWQpO1xuICAgICAgICAgICAgICAgIGdyb3Vwc1RvU3VwZXJzW2dpZF0gPSBmU3VwZXJHcm91cDtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0gICAgICAgXG4gICAgfVxuXG4gICAgZm9yICh2YXIgZ2lkIGluIGdyb3VwZWRGZWF0dXJlcykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbZ2lkXTtcbiAgICAgICAgaWYgKHR5cGVvZihncm91cC5taW4pICE9PSAnbnVtYmVyJykgXG4gICAgICAgICAgICBncm91cC5taW4gPSBncm91cE1pbnNbZ2lkXTtcbiAgICAgICAgaWYgKHR5cGVvZihncm91cC5tYXgpICE9PSAnbnVtYmVyJykgXG4gICAgICAgICAgICBncm91cC5tYXggPSBncm91cE1heGVzW2dpZF07XG5cbiAgICAgICAgaWYgKGdyb3VwTWF4ZXNbZ2lkXSA+PSBkbWluICYmIGdyb3VwTWluc1tnaWRdIDw9IGRtYXgpXG4gICAgICAgICAgICBkcmF3bkdyb3VwZWRGZWF0dXJlc1tnaWRdID0gZ3JvdXBlZEZlYXR1cmVzW2dpZF07XG4gICAgfVxuXG4gICAgdGllci51bmdyb3VwZWRGZWF0dXJlcyA9IHVuZ3JvdXBlZEZlYXR1cmVzO1xuICAgIHRpZXIuZ3JvdXBlZEZlYXR1cmVzID0gZHJhd25Hcm91cGVkRmVhdHVyZXM7XG4gICAgdGllci5ncm91cHMgPSBncm91cHM7XG4gICAgdGllci5zdXBlckdyb3VwcyA9IHN1cGVyR3JvdXBzO1xuICAgIHRpZXIuZ3JvdXBzVG9TdXBlcnMgPSBncm91cHNUb1N1cGVycztcblxuICAgIGlmIChtaW5TY29yZSkge1xuICAgICAgICBpZiAobWluU2NvcmUgPiAwKSB7XG4gICAgICAgICAgICBtaW5TY29yZSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAobWF4U2NvcmUgPCAwKSB7XG4gICAgICAgICAgICBtYXhTY29yZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGllci5jdXJyZW50RmVhdHVyZXNNaW5TY29yZSA9IG1pblNjb3JlO1xuICAgICAgICB0aWVyLmN1cnJlbnRGZWF0dXJlc01heFNjb3JlID0gbWF4U2NvcmU7XG4gICAgfVxufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHNvcnRGZWF0dXJlczogc29ydEZlYXR1cmVzXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBnbHlwaHMuanM6IGNvbXBvbmVudHMgd2hpY2gga25vdyBob3cgdG8gZHJhdyB0aGVtc2VsdmVzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgc3BhbnMgPSByZXF1aXJlKCcuL3NwYW5zJyk7XG4gICAgdmFyIHVuaW9uID0gc3BhbnMudW5pb247XG4gICAgdmFyIFJhbmdlID0gc3BhbnMuUmFuZ2U7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIG1ha2VFbGVtZW50TlMgPSB1dGlscy5tYWtlRWxlbWVudE5TO1xuICAgIHZhciBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OID0gdXRpbHMuQU1JTk9fQUNJRF9UUkFOU0xBVElPTjtcblxuICAgIHZhciBzdmd1ID0gcmVxdWlyZSgnLi9zdmctdXRpbHMnKTtcbiAgICB2YXIgTlNfU1ZHID0gc3ZndS5OU19TVkc7XG4gICAgdmFyIE5TX1hMSU5LID0gc3ZndS5OU19YTElOSztcbiAgICB2YXIgU1ZHUGF0aCA9IHN2Z3UuU1ZHUGF0aDtcbn1cblxuZnVuY3Rpb24gUGF0aEdseXBoQmFzZShzdHJva2UsIGZpbGwpIHtcbiAgICB0aGlzLl9zdHJva2UgPSBzdHJva2U7XG4gICAgdGhpcy5fZmlsbCA9IGZpbGw7XG59XG5cblBhdGhHbHlwaEJhc2UucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnKSB7XG4gICAgZy5iZWdpblBhdGgoKTtcbiAgICB0aGlzLmRyYXdQYXRoKGcpO1xuXG4gICAgaWYgKHRoaXMuX2ZpbGwpIHtcbiAgICAgICAgZy5maWxsU3R5bGUgPSB0aGlzLl9maWxsO1xuICAgICAgICBnLmZpbGwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0cm9rZSkge1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgIH1cbn1cblxuUGF0aEdseXBoQmFzZS5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZyA9IG5ldyBTVkdQYXRoKCk7XG4gICAgdGhpcy5kcmF3UGF0aChnKTtcbiAgICBcbiAgICByZXR1cm4gbWFrZUVsZW1lbnROUyhcbiAgICAgICAgTlNfU1ZHLCAncGF0aCcsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHtkOiBnLnRvUGF0aERhdGEoKSxcbiAgICAgICAgIGZpbGw6IHRoaXMuX2ZpbGwgfHwgJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UgfHwgJ25vbmUnfSk7XG59XG5cblBhdGhHbHlwaEJhc2UucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24oZykge1xuICAgIHRocm93ICdkcmF3UGF0aCBtZXRob2Qgb24gUGF0aEdseXBoQmFzZSBtdXN0IGJlIG92ZXJyaWRkZW4nO1xufVxuXG5mdW5jdGlvbiBCb3hHbHlwaCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmaWxsLCBzdHJva2UsIGFscGhhLCByYWRpdXMpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5maWxsID0gZmlsbDtcbiAgICB0aGlzLnN0cm9rZSA9IHN0cm9rZTtcbiAgICB0aGlzLl9hbHBoYSA9IGFscGhhO1xuICAgIHRoaXMuX3JhZGl1cyA9IHJhZGl1cyB8fCAwO1xufVxuXG5Cb3hHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgciA9IHRoaXMuX3JhZGl1cztcblxuICAgIGlmIChyID4gMCkge1xuICAgICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgICBnLm1vdmVUbyh0aGlzLnggKyByLCB0aGlzLnkpO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLnggKyB0aGlzLl93aWR0aCAtIHIsIHRoaXMueSk7XG4gICAgICAgIGcuYXJjVG8odGhpcy54ICsgdGhpcy5fd2lkdGgsIHRoaXMueSwgdGhpcy54ICsgdGhpcy5fd2lkdGgsIHRoaXMueSArIHIsIHIpO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLnggKyB0aGlzLl93aWR0aCwgdGhpcy55ICsgdGhpcy5faGVpZ2h0IC0gcik7XG4gICAgICAgIGcuYXJjVG8odGhpcy54ICsgdGhpcy5fd2lkdGgsIHRoaXMueSArIHRoaXMuX2hlaWdodCwgdGhpcy54ICsgdGhpcy5fd2lkdGggLSByLCB0aGlzLnkgKyB0aGlzLl9oZWlnaHQsIHIpO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLnggKyByLCB0aGlzLnkgKyB0aGlzLl9oZWlnaHQpO1xuICAgICAgICBnLmFyY1RvKHRoaXMueCwgdGhpcy55ICsgdGhpcy5faGVpZ2h0LCB0aGlzLngsIHRoaXMueSArIHRoaXMuX2hlaWdodCAtIHIsIHIpO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLngsIHRoaXMueSArIHIpO1xuICAgICAgICBnLmFyY1RvKHRoaXMueCwgdGhpcy55LCB0aGlzLnggKyByLCB0aGlzLnksIHIpO1xuICAgICAgICBnLmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnLnNhdmUoKTtcbiAgICAgICAgICAgIGcuZ2xvYmFsQWxwaGEgPSB0aGlzLl9hbHBoYTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICAgICAgZy5maWxsU3R5bGUgPSB0aGlzLmZpbGw7XG4gICAgICAgICAgICBnLmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgICAgIGcuc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgICAgIGcubGluZVdpZHRoID0gMC41O1xuICAgICAgICAgICAgZy5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICBnLnNhdmUoKTtcbiAgICAgICAgICAgIGcuZ2xvYmFsQWxwaGEgPSB0aGlzLl9hbHBoYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmZpbGwpIHtcbiAgICAgICAgICAgIGcuZmlsbFN0eWxlID0gdGhpcy5maWxsO1xuICAgICAgICAgICAgZy5maWxsUmVjdCh0aGlzLngsIHRoaXMueSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgICAgIGcuc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgICAgIGcubGluZVdpZHRoID0gMC41O1xuICAgICAgICAgICAgZy5zdHJva2VSZWN0KHRoaXMueCwgdGhpcy55LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2FscGhhICE9IG51bGwpIHtcbiAgICAgICAgICAgIGcucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Cb3hHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9IG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAncmVjdCcsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAge3g6IHRoaXMueCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRoaXMueSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl93aWR0aCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6IHRoaXMuc3Ryb2tlIHx8ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IDAuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5maWxsIHx8ICdub25lJ30pO1xuICAgIGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKSB7XG4gICAgICAgIHMuc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5fYWxwaGEpO1xuICAgIH1cblxuICAgIHJldHVybiBzO1xufVxuXG5Cb3hHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMueDtcbn1cblxuQm94R2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnggKyB0aGlzLl93aWR0aDtcbn1cblxuQm94R2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLl9oZWlnaHQ7XG59XG5cblxuZnVuY3Rpb24gR3JvdXBHbHlwaChnbHlwaHMsIGNvbm5lY3Rvcikge1xuICAgIHRoaXMuZ2x5cGhzID0gZ2x5cGhzO1xuICAgIHRoaXMuY29ubmVjdG9yID0gY29ubmVjdG9yO1xuICAgIHRoaXMuaCA9IGdseXBoc1swXS5oZWlnaHQoKTtcblxuICAgIHZhciBjb3ZMaXN0ID0gW107XG4gICAgZm9yICh2YXIgZyA9IDA7IGcgPCBnbHlwaHMubGVuZ3RoOyArK2cpIHtcbiAgICAgICAgdmFyIGdnID0gZ2x5cGhzW2ddO1xuICAgICAgICBjb3ZMaXN0LnB1c2gobmV3IFJhbmdlKGdnLm1pbigpLCBnZy5tYXgoKSkpO1xuICAgICAgICB0aGlzLmggPSBNYXRoLm1heCh0aGlzLmgsIGdnLmhlaWdodCgpKTtcbiAgICB9XG4gICAgdGhpcy5jb3ZlcmFnZSA9IHVuaW9uKGNvdkxpc3QpO1xufVxuXG5Hcm91cEdseXBoLnByb3RvdHlwZS5kcmF3Q29ubmVjdG9ycyA9IGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgcmFuZ2VzID0gdGhpcy5jb3ZlcmFnZS5yYW5nZXMoKTtcbiAgICBmb3IgKHZhciByID0gMTsgciA8IHJhbmdlcy5sZW5ndGg7ICsrcikge1xuICAgICAgICB2YXIgZ2wgPSByYW5nZXNbcl07XG4gICAgICAgIHZhciBsYXN0ID0gcmFuZ2VzW3IgLSAxXTtcbiAgICAgICAgaWYgKGxhc3QgJiYgZ2wubWluKCkgPiBsYXN0Lm1heCgpKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBsYXN0Lm1heCgpO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGdsLm1pbigpO1xuICAgICAgICAgICAgdmFyIG1pZCA9IChzdGFydCtlbmQpLzJcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdG9yID09PSAnaGF0KycpIHtcbiAgICAgICAgICAgICAgICBnLm1vdmVUbyhzdGFydCwgdGhpcy5oLzIpO1xuICAgICAgICAgICAgICAgIGcubGluZVRvKG1pZCwgMCk7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8oZW5kLCB0aGlzLmgvMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29ubmVjdG9yID09PSAnaGF0LScpIHtcbiAgICAgICAgICAgICAgICBnLm1vdmVUbyhzdGFydCwgdGhpcy5oLzIpO1xuICAgICAgICAgICAgICAgIGcubGluZVRvKG1pZCwgdGhpcy5oKTtcbiAgICAgICAgICAgICAgICBnLmxpbmVUbyhlbmQsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25uZWN0b3IgPT09ICdjb2xsYXBzZWQrJykge1xuICAgICAgICAgICAgICAgIGcubW92ZVRvKHN0YXJ0LCB0aGlzLmgvMik7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8oZW5kLCB0aGlzLmgvMik7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCAtIHN0YXJ0ID4gNCkge1xuICAgICAgICAgICAgICAgICAgICBnLm1vdmVUbyhtaWQgLSAyLCAodGhpcy5oLzIpIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgIGcubGluZVRvKG1pZCArIDIsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgICAgICAgICAgZy5saW5lVG8obWlkIC0gMiwgKHRoaXMuaC8yKSArIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25uZWN0b3IgPT09ICdjb2xsYXBzZWQtJykge1xuICAgICAgICAgICAgICAgIGcubW92ZVRvKHN0YXJ0LCB0aGlzLmgvMik7XG4gICAgICAgICAgICAgICAgZy5saW5lVG8oZW5kLCB0aGlzLmgvMik7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCAtIHN0YXJ0ID4gNCkge1xuICAgICAgICAgICAgICAgICAgICBnLm1vdmVUbyhtaWQgKyAyLCAodGhpcy5oLzIpIC0gMyk7XG4gICAgICAgICAgICAgICAgICAgIGcubGluZVRvKG1pZCAtIDIsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgICAgICAgICAgZy5saW5lVG8obWlkICsgMiwgKHRoaXMuaC8yKSArIDMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZy5tb3ZlVG8oc3RhcnQsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgICAgICBnLmxpbmVUbyhlbmQsIHRoaXMuaC8yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0ID0gZ2w7XG4gICAgfVxufVxuXG5Hcm91cEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZywgb2MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ2x5cGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2x5cGhzW2ldO1xuICAgICAgICBnbC5kcmF3KGcsIG9jKTtcbiAgICB9XG5cbiAgICBnLnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuZHJhd0Nvbm5lY3RvcnMoZyk7XG4gICAgZy5zdHJva2UoKTtcbn1cblxuR3JvdXBHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZyA9IG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnZycpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbHlwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZy5hcHBlbmRDaGlsZCh0aGlzLmdseXBoc1tpXS50b1NWRygpKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBTVkdQYXRoKCk7XG4gICAgdGhpcy5kcmF3Q29ubmVjdG9ycyhwKTtcblxuICAgIHZhciBwYXRoRGF0YSA9IHAudG9QYXRoRGF0YSgpO1xuICAgIGlmIChwYXRoRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBwYXRoID0gbWFrZUVsZW1lbnROUyhcbiAgICAgICAgICAgIE5TX1NWRywgJ3BhdGgnLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHtkOiBwLnRvUGF0aERhdGEoKSxcbiAgICAgICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICAgICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiAwLjV9KTtcbiAgICAgICAgZy5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZztcbn1cblxuR3JvdXBHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY292ZXJhZ2UubWluKCk7XG59XG5cbkdyb3VwR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNvdmVyYWdlLm1heCgpO1xufVxuXG5Hcm91cEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5oO1xufVxuXG5cbmZ1bmN0aW9uIExpbmVHcmFwaEdseXBoKHBvaW50cywgY29sb3IsIGhlaWdodCkge1xuICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgfHwgNTA7XG59XG5cbkxpbmVHcmFwaEdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wb2ludHNbMF07XG59O1xuXG5MaW5lR3JhcGhHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMucG9pbnRzLmxlbmd0aCAtIDJdO1xufTtcblxuTGluZUdyYXBoR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59XG5cbkxpbmVHcmFwaEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIGcuc2F2ZSgpO1xuICAgIGcuc3Ryb2tlU3R5bGUgPSB0aGlzLmNvbG9yO1xuICAgIGcubGluZVdpZHRoID0gMjtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnBvaW50c1tpICsgMV07XG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIGcubW92ZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZy5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZy5zdHJva2UoKTtcbiAgICBnLnJlc3RvcmUoKTtcbn1cblxuTGluZUdyYXBoR2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSBuZXcgU1ZHUGF0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnBvaW50c1tpICsgMV07XG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHgsIHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoXG4gICAgICAgIE5TX1NWRywgJ3BhdGgnLFxuICAgICAgICBudWxsLFxuICAgICAgICB7ZDogcC50b1BhdGhEYXRhKCksXG4gICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICBzdHJva2U6IHRoaXMuY29sb3IsXG4gICAgICAgICBzdHJva2VXaWR0aDogJzJweCd9KTtcbn1cblxuZnVuY3Rpb24gTGFiZWxsZWRHbHlwaChHTE9CQUxfR0MsIGdseXBoLCB0ZXh0LCB1bm1lYXN1cmVkLCBhbmNob3IsIGFsaWduLCBmb250KSB7XG4gICAgdGhpcy5nbHlwaCA9IGdseXBoO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3IgfHwgJ2xlZnQnO1xuICAgIHRoaXMuYWxpZ24gPSBhbGlnbiB8fCAnYmVsb3cnO1xuICAgIGlmIChmb250KSB7XG4gICAgICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgR0xPQkFMX0dDLnNhdmUoKTtcbiAgICAgICAgR0xPQkFMX0dDLmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgfVxuICAgIHZhciBtZXRyaWNzID0gR0xPQkFMX0dDLm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgR0xPQkFMX0dDLnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0TGVuID0gbWV0cmljcy53aWR0aDtcbiAgICB0aGlzLnRleHRIZWlnaHQgPSA1O1xuICAgIHRoaXMuYnVtcCA9IGdseXBoLmJ1bXA7XG4gICAgdGhpcy5tZWFzdXJlZCA9ICF1bm1lYXN1cmVkO1xufVxuXG5MYWJlbGxlZEdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuZ2x5cGgudG9TVkcoKTtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIFxuICAgIGlmICh0aGlzLmFsaWduID09ICdhYm92ZScpIHtcbiAgICAgICAgY2hpbGQgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnLCBjaGlsZCwge3RyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMCwgXCIgKyAodGhpcy50ZXh0SGVpZ2h0fDAgKyAyKSArIFwiKVwifSk7XG4gICAgICAgIG9wdHMueSA9IHRoaXMudGV4dEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvcHRzLnkgPSB0aGlzLmdseXBoLmhlaWdodCgpICsgMTU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZm9udCkge1xuICAgICAgICBvcHRzLmZvbnRTaXplICA9IDc7XG4gICAgfVxuXG4gICAgaWYgKCdjZW50ZXInID09IHRoaXMuYW5jaG9yKSB7XG4gICAgICAgIG9wdHMueCA9ICh0aGlzLmdseXBoLm1pbigpICsgdGhpcy5nbHlwaC5tYXgoKSAtIHRoaXMudGV4dExlbikgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdHMueCA9IHRoaXMuZ2x5cGgubWluKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnZycsXG4gICAgICAgIFtjaGlsZCxcbiAgICAgICAgIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIHRoaXMudGV4dCwgb3B0cyldKTtcbn1cblxuTGFiZWxsZWRHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2x5cGgubWluKCk7XG59XG5cbkxhYmVsbGVkR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm1lYXN1cmVkKVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5nbHlwaC5tYXgoKSwgKDEuMCp0aGlzLmdseXBoLm1pbigpKSArIHRoaXMudGV4dExlbiArIDEwKTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLmdseXBoLm1heCgpO1xufVxuXG5MYWJlbGxlZEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaCA9IHRoaXMuZ2x5cGguaGVpZ2h0KCk7XG4gICAgaWYgKHRoaXMubWVhc3VyZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxpZ24gPT0gJ2Fib3ZlJykge1xuICAgICAgICAgICAgaCArPSB0aGlzLnRleHRIZWlnaHQgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaCArPSAyMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaDtcbn1cblxuTGFiZWxsZWRHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcsIG9jKSB7XG4gICAgaWYgKHRoaXMuYWxpZ24gPT0gJ2Fib3ZlJykge1xuICAgICAgICBnLnNhdmUoKTtcbiAgICAgICAgZy50cmFuc2xhdGUoMCwgdGhpcy50ZXh0SGVpZ2h0ICsgMik7XG4gICAgfVxuICAgIHRoaXMuZ2x5cGguZHJhdyhnKTtcbiAgICBpZiAodGhpcy5hbGlnbiA9PSAnYWJvdmUnKSB7XG4gICAgICAgIGcucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIG9jLnJlZ2lzdGVyR2x5cGgodGhpcyk7XG59XG5cbkxhYmVsbGVkR2x5cGgucHJvdG90eXBlLmRyYXdPdmVybGF5ID0gZnVuY3Rpb24oZywgbWluVmlzaWJsZSwgbWF4VmlzaWJsZSkge1xuICAgIGcuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICBpZiAodGhpcy5mb250KSB7XG4gICAgICAgIGcuc2F2ZSgpO1xuICAgICAgICBnLmZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgfVxuICAgIHZhciBwO1xuICAgIGlmICgnY2VudGVyJyA9PSB0aGlzLmFuY2hvcikge1xuICAgICAgICBwID0gKHRoaXMuZ2x5cGgubWluKCkgKyB0aGlzLmdseXBoLm1heCgpIC0gdGhpcy50ZXh0TGVuKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcCA9IHRoaXMuZ2x5cGgubWluKCk7XG4gICAgICAgIGlmIChwIDwgbWluVmlzaWJsZSkge1xuICAgICAgICAgICAgcCA9IE1hdGgubWluKG1pblZpc2libGUsIHRoaXMuZ2x5cGgubWF4KCkgLSB0aGlzLnRleHRMZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGcuZmlsbFRleHQodGhpcy50ZXh0LCBwLCB0aGlzLmFsaWduID09ICdhYm92ZScgPyB0aGlzLnRleHRIZWlnaHQgOiB0aGlzLmdseXBoLmhlaWdodCgpICsgMTUpO1xuICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgZy5yZXN0b3JlKCk7XG4gICAgfVxufVxuXG5cblxuZnVuY3Rpb24gQ3Jvc3NHbHlwaCh4LCBoZWlnaHQsIHN0cm9rZSkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9zdHJva2UgPSBzdHJva2U7XG59XG5cbkNyb3NzR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGhoID0gdGhpcy5faGVpZ2h0LzI7XG4gICAgXG4gICAgZy5iZWdpblBhdGgoKTtcbiAgICBnLm1vdmVUbyh0aGlzLl94LCAwKTtcbiAgICBnLmxpbmVUbyh0aGlzLl94LCB0aGlzLl9oZWlnaHQpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgaGgpO1xuICAgIGcubGluZVRvKHRoaXMuX3ggKyBoaCwgaGgpO1xuXG4gICAgZy5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZTtcbiAgICBnLmxpbmVXaWR0aCA9IDE7XG5cbiAgICBnLnN0cm9rZSgpO1xufVxuXG5Dcm9zc0dseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaCA9IHRoaXMuX2hlaWdodC8yO1xuXG4gICAgdmFyIGcgPSBuZXcgU1ZHUGF0aCgpO1xuICAgIGcubW92ZVRvKHRoaXMuX3gsIDApO1xuICAgIGcubGluZVRvKHRoaXMuX3gsIHRoaXMuX2hlaWdodCk7XG4gICAgZy5tb3ZlVG8odGhpcy5feCAtIGhoLCBoaCk7XG4gICAgZy5saW5lVG8odGhpcy5feCArIGhoLCBoaCk7XG4gICAgXG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoXG4gICAgICAgIE5TX1NWRywgJ3BhdGgnLFxuICAgICAgICBudWxsLFxuICAgICAgICB7ZDogZy50b1BhdGhEYXRhKCksXG4gICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICBzdHJva2U6IHRoaXMuX3N0cm9rZSxcbiAgICAgICAgIHN0cm9rZVdpZHRoOiAnMXB4J30pO1xufVxuXG5Dcm9zc0dseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCAtIHRoaXMuX2hlaWdodC8yO1xufVxuXG5Dcm9zc0dseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCArIHRoaXMuX2hlaWdodC8yO1xufVxuXG5Dcm9zc0dseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5mdW5jdGlvbiBFeEdseXBoKHgsIGhlaWdodCwgc3Ryb2tlKSB7XG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3N0cm9rZSA9IHN0cm9rZTtcbn1cblxuRXhHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgaGggPSB0aGlzLl9oZWlnaHQvMjtcbiAgICBcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgMCk7XG4gICAgZy5saW5lVG8odGhpcy5feCArIGhoLCB0aGlzLl9oZWlnaHQpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgdGhpcy5faGVpZ2h0KTtcbiAgICBnLmxpbmVUbyh0aGlzLl94ICsgaGgsIDApO1xuXG4gICAgZy5zdHJva2VTdHlsZSA9IHRoaXMuX3N0cm9rZTtcbiAgICBnLmxpbmVXaWR0aCA9IDE7XG5cbiAgICBnLnN0cm9rZSgpO1xufVxuXG5FeEdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBoaCA9IHRoaXMuX2hlaWdodC8yO1xuXG4gICAgdmFyIGcgPSBuZXcgU1ZHUGF0aCgpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgMCk7XG4gICAgZy5saW5lVG8odGhpcy5feCArIGhoLCB0aGlzLl9oZWlnaHQpO1xuICAgIGcubW92ZVRvKHRoaXMuX3ggLSBoaCwgdGhpcy5faGVpZ2h0KTtcbiAgICBnLmxpbmVUbyh0aGlzLl94ICsgaGgsIDApO1xuICAgIFxuICAgIHJldHVybiBtYWtlRWxlbWVudE5TKFxuICAgICAgICBOU19TVkcsICdwYXRoJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAge2Q6IGcudG9QYXRoRGF0YSgpLFxuICAgICAgICAgZmlsbDogJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UsXG4gICAgICAgICBzdHJva2VXaWR0aDogJzFweCd9KTtcbn1cblxuRXhHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggLSB0aGlzLl9oZWlnaHQvMjtcbn1cblxuRXhHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggKyB0aGlzLl9oZWlnaHQvMjtcbn1cblxuRXhHbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbn1cblxuXG5cbmZ1bmN0aW9uIFRyaWFuZ2xlR2x5cGgoeCwgaGVpZ2h0LCBkaXIsIHdpZHRoLCBmaWxsLCBzdHJva2UpIHtcbiAgICBQYXRoR2x5cGhCYXNlLmNhbGwodGhpcywgc3Ryb2tlLCBmaWxsKTtcblxuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9kaXIgPSBkaXI7XG4gICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbn1cblxuVHJpYW5nbGVHbHlwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhdGhHbHlwaEJhc2UucHJvdG90eXBlKTtcblxuVHJpYW5nbGVHbHlwaC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGhoID0gdGhpcy5faGVpZ2h0LzI7XG4gICAgdmFyIGh3ID0gdGhpcy5fd2lkdGgvMjtcblxuICAgIGlmICh0aGlzLl9kaXIgPT09ICdTJykge1xuICAgICAgICBnLm1vdmVUbyh0aGlzLl94LCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94IC0gaHcsIDApO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94ICsgaHcsIDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZGlyID09PSAnVycpIHtcbiAgICAgICAgZy5tb3ZlVG8odGhpcy5feCArIGh3LCBoaCk7XG4gICAgICAgIGcubGluZVRvKHRoaXMuX3ggLSBodywgMCk7XG4gICAgICAgIGcubGluZVRvKHRoaXMuX3ggLSBodywgdGhpcy5faGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RpciA9PT0gJ0UnKSB7XG4gICAgICAgIGcubW92ZVRvKHRoaXMuX3ggLSBodywgaGgpO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94ICsgaHcsIDApO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94ICsgaHcsIHRoaXMuX2hlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZy5tb3ZlVG8odGhpcy5feCAsIDApO1xuICAgICAgICBnLmxpbmVUbyh0aGlzLl94ICsgaHcsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIGcubGluZVRvKHRoaXMuX3ggLSBodywgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG5cbiAgICBnLmNsb3NlUGF0aCgpO1xufVxuXG5UcmlhbmdsZUdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCAtIHRoaXMuX2hlaWdodC8yO1xufVxuXG5UcmlhbmdsZUdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCArIHRoaXMuX2hlaWdodC8yO1xufVxuXG5UcmlhbmdsZUdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5cblxuXG5mdW5jdGlvbiBEb3RHbHlwaCh4LCBoZWlnaHQsIGZpbGwsIHN0cm9rZSkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9maWxsID0gZmlsbDtcbiAgICB0aGlzLl9zdHJva2UgPSBzdHJva2U7XG59XG5cbkRvdEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIHZhciBoaCA9IHRoaXMuX2hlaWdodC8yO1xuICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgZy5hcmModGhpcy5feCwgaGgsIGhoLCAwLCA2LjI5KTtcblxuICAgIGlmICh0aGlzLl9maWxsKSB7XG4gICAgICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fZmlsbDtcbiAgICAgICAgZy5maWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0cm9rZSkge1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgIH1cbn1cblxuRG90R2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGhoID0gdGhpcy5faGVpZ2h0LzI7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoXG4gICAgICAgIE5TX1NWRywgJ2NpcmNsZScsXG4gICAgICAgIG51bGwsXG4gICAgICAgIHtjeDogdGhpcy5feCwgY3k6IGhoLCByOiBoaCxcbiAgICAgICAgIGZpbGw6IHRoaXMuX2ZpbGwgfHwgJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UgfHwgJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxcHgnfSk7XG59XG5cbkRvdEdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCAtIHRoaXMuX2hlaWdodC8yO1xufVxuXG5Eb3RHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggKyB0aGlzLl9oZWlnaHQvMjtcbn1cblxuRG90R2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59XG5cblxuZnVuY3Rpb24gUGFkZGVkR2x5cGgoZ2x5cGgsIG1pbnAsIG1heHApIHtcbiAgICB0aGlzLmdseXBoID0gZ2x5cGg7XG4gICAgdGhpcy5fbWluID0gbWlucDtcbiAgICB0aGlzLl9tYXggPSBtYXhwO1xuICAgIGlmIChnbHlwaCkge1xuICAgICAgICB0aGlzLmJ1bXAgPSBnbHlwaC5idW1wO1xuICAgIH1cbn1cblxuUGFkZGVkR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnLCBvYykge1xuICAgIGlmICh0aGlzLmdseXBoKSBcbiAgICAgICAgdGhpcy5nbHlwaC5kcmF3KGcsIG9jKTtcbn1cblxuUGFkZGVkR2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuZ2x5cGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2x5cGgudG9TVkcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJyk7XG4gICAgfVxufVxuXG5QYWRkZWRHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbjtcbn1cblxuUGFkZGVkR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXg7XG59XG5cblBhZGRlZEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5nbHlwaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaC5oZWlnaHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gQUFycm93R2x5cGgobWluLCBtYXgsIGhlaWdodCwgZmlsbCwgc3Ryb2tlLCBvcmkpIHtcbiAgICBQYXRoR2x5cGhCYXNlLmNhbGwodGhpcywgc3Ryb2tlLCBmaWxsKTtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcmkgPSBvcmk7XG59XG5cbkFBcnJvd0dseXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGF0aEdseXBoQmFzZS5wcm90b3R5cGUpO1xuXG5BQXJyb3dHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbjtcbn1cblxuQUFycm93R2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXg7XG59XG5cbkFBcnJvd0dseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5BQXJyb3dHbHlwaC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIG1heFBvcyA9IHRoaXMuX21heDtcbiAgICB2YXIgbWluUG9zID0gdGhpcy5fbWluO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgdmFyIGxJbnNldCA9IDA7XG4gICAgdmFyIHJJbnNldCA9IDA7XG4gICAgdmFyIG1pbkxlbmd0aCA9IHRoaXMuX2hlaWdodCArIDI7XG4gICAgdmFyIGluc3RlcCA9IDAuMzMzMzMzICogdGhpcy5faGVpZ2h0O1xuICAgIHZhciB5ID0gMDtcblxuICAgIGlmICh0aGlzLl9vcmkpIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaSA9PT0gJysnKSB7XG4gICAgICAgICAgICBySW5zZXQgPSAwLjUgKiB0aGlzLl9oZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fb3JpID09PSAnLScpIHtcbiAgICAgICAgICAgIGxJbnNldCA9IDAuNSAqIHRoaXMuX2hlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhQb3MgLSBtaW5Qb3MgPCBtaW5MZW5ndGgpIHtcbiAgICAgICAgbWluUG9zID0gKG1heFBvcyArIG1pblBvcyAtIG1pbkxlbmd0aCkgLyAyO1xuICAgICAgICBtYXhQb3MgPSBtaW5Qb3MgKyBtaW5MZW5ndGg7XG4gICAgfVxuXG4gICAgZy5tb3ZlVG8obWluUG9zICsgbEluc2V0LCB5K2luc3RlcCk7XG4gICAgZy5saW5lVG8obWF4UG9zIC0gckluc2V0LCB5K2luc3RlcCk7XG4gICAgZy5saW5lVG8obWF4UG9zIC0gckluc2V0LCB5KTtcbiAgICBnLmxpbmVUbyhtYXhQb3MsIHkgKyB0aGlzLl9oZWlnaHQvMik7XG4gICAgZy5saW5lVG8obWF4UG9zIC0gckluc2V0LCB5K2hlaWdodCk7XG4gICAgZy5saW5lVG8obWF4UG9zIC0gckluc2V0LCB5K2luc3RlcCtpbnN0ZXApO1xuICAgIGcubGluZVRvKG1pblBvcyArIGxJbnNldCwgeStpbnN0ZXAraW5zdGVwKTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MgKyBsSW5zZXQsIHkraGVpZ2h0KTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MsIHkraGVpZ2h0LzIpO1xuICAgIGcubGluZVRvKG1pblBvcyArIGxJbnNldCwgeSk7XG4gICAgZy5saW5lVG8obWluUG9zICsgbEluc2V0LCB5K2luc3RlcCk7XG59XG5cbmZ1bmN0aW9uIFNwYW5HbHlwaChtaW4sIG1heCwgaGVpZ2h0LCBzdHJva2UpIHtcbiAgICBQYXRoR2x5cGhCYXNlLmNhbGwodGhpcywgc3Ryb2tlLCBudWxsKTtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbn1cblxuU3BhbkdseXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGF0aEdseXBoQmFzZS5wcm90b3R5cGUpO1xuXG5TcGFuR2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9taW59O1xuU3BhbkdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWF4fTtcblNwYW5HbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX2hlaWdodH07XG5cblNwYW5HbHlwaC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIG1pblBvcyA9IHRoaXMuX21pbiwgbWF4UG9zID0gdGhpcy5fbWF4O1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQsIGhoID0gaGVpZ2h0LzI7XG4gICAgZy5tb3ZlVG8obWluUG9zLCBoaCk7XG4gICAgZy5saW5lVG8obWF4UG9zLCBoaCk7XG4gICAgZy5tb3ZlVG8obWluUG9zLCAwKTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MsIGhlaWdodCk7XG4gICAgZy5tb3ZlVG8obWF4UG9zLCAwKTtcbiAgICBnLmxpbmVUbyhtYXhQb3MsIGhlaWdodCk7XG59XG5cbmZ1bmN0aW9uIExpbmVHbHlwaChtaW4sIG1heCwgaGVpZ2h0LCBzdHlsZSwgc3RyYW5kLCBzdHJva2UpIHtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuX3N0cmFuZCA9IHN0cmFuZDtcbiAgICB0aGlzLl9zdHJva2UgPSBzdHJva2U7XG59XG5cbkxpbmVHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX21pbn07XG5MaW5lR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9tYXh9O1xuTGluZUdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5faGVpZ2h0fTtcblxuTGluZUdseXBoLnByb3RvdHlwZS5kcmF3UGF0aCA9IGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgbWluUG9zID0gdGhpcy5fbWluLCBtYXhQb3MgPSB0aGlzLl9tYXg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodCwgaGggPSBoZWlnaHQvMjtcblxuICAgIGlmICh0aGlzLl9zdHlsZSA9PT0gJ2hhdCcpIHtcbiAgICAgICAgZy5tb3ZlVG8obWluUG9zLCBoaCk7XG4gICAgICAgIGcubGluZVRvKChtaW5Qb3MgKyBtYXhQb3MpLzIsIHRoaXMuX3N0cmFuZCA9PT0gJy0nID8gaGVpZ2h0IDogMCk7XG4gICAgICAgIGcubGluZVRvKG1heFBvcywgaGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGcubW92ZVRvKG1pblBvcywgaGgpO1xuICAgICAgICBnLmxpbmVUbyhtYXhQb3MsIGhoKTtcbiAgICB9XG59XG5cblxuTGluZUdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5kcmF3UGF0aChnKTtcbiAgICBnLnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgIGlmICh0aGlzLl9zdHlsZSA9PT0gJ2Rhc2hlZCcgJiYgZy5zZXRMaW5lRGFzaCkge1xuICAgICAgICBnLnNhdmUoKTtcbiAgICAgICAgZy5zZXRMaW5lRGFzaChbM10pO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgICAgICBnLnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgIH1cbn1cblxuTGluZUdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBnID0gbmV3IFNWR1BhdGgoKTtcbiAgICB0aGlzLmRyYXdQYXRoKGcpO1xuICAgIFxuICAgIHZhciBvcHRzID0ge2Q6IGcudG9QYXRoRGF0YSgpLFxuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UgfHwgJ25vbmUnfTtcbiAgICBpZiAodGhpcy5fc3R5bGUgPT09ICdkYXNoZWQnKSB7XG4gICAgICAgIG9wdHNbJ3N0cm9rZURhc2hhcnJheSddID0gJzMnO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlRWxlbWVudE5TKFxuICAgICAgICBOU19TVkcsICdwYXRoJyxcbiAgICAgICAgbnVsbCwgb3B0c1xuICAgICk7XG59XG5cblxuXG5cblxuZnVuY3Rpb24gUHJpbWVyc0dseXBoKG1pbiwgbWF4LCBoZWlnaHQsIGZpbGwsIHN0cm9rZSkge1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX2ZpbGwgPSBmaWxsO1xuICAgIHRoaXMuX3N0cm9rZSA9IHN0cm9rZTtcbn1cblxuUHJpbWVyc0dseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcblByaW1lcnNHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX21heH07XG5QcmltZXJzR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9oZWlnaHR9O1xuXG5cblByaW1lcnNHbHlwaC5wcm90b3R5cGUuZHJhd1N0ZW1QYXRoID0gZnVuY3Rpb24oZykge1xuICAgIHZhciBtaW5Qb3MgPSB0aGlzLl9taW4sIG1heFBvcyA9IHRoaXMuX21heDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0LCBoaCA9IGhlaWdodC8yO1xuICAgIGcubW92ZVRvKG1pblBvcywgaGgpO1xuICAgIGcubGluZVRvKG1heFBvcywgaGgpO1xufVxuXG5QcmltZXJzR2x5cGgucHJvdG90eXBlLmRyYXdUcmlnc1BhdGggPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIG1pblBvcyA9IHRoaXMuX21pbiwgbWF4UG9zID0gdGhpcy5fbWF4O1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9oZWlnaHQsIGhoID0gaGVpZ2h0LzI7XG4gICAgZy5tb3ZlVG8obWluUG9zLCAwKTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MgKyBoZWlnaHQsIGhoKTtcbiAgICBnLmxpbmVUbyhtaW5Qb3MsIGhlaWdodCk7XG4gICAgZy5saW5lVG8obWluUG9zLCAwKTtcbiAgICBnLm1vdmVUbyhtYXhQb3MsIDApO1xuICAgIGcubGluZVRvKG1heFBvcyAtIGhlaWdodCwgaGgpO1xuICAgIGcubGluZVRvKG1heFBvcywgaGVpZ2h0KTtcbiAgICBnLmxpbmVUbyhtYXhQb3MsIDApO1xufVxuXG5cblByaW1lcnNHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcpIHtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuZHJhd1N0ZW1QYXRoKGcpO1xuICAgIGcuc3Ryb2tlU3R5bGUgPSB0aGlzLl9zdHJva2U7XG4gICAgZy5zdHJva2UoKTtcbiAgICBnLmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuZHJhd1RyaWdzUGF0aChnKTtcbiAgICBnLmZpbGxTdHlsZSA9IHRoaXMuX2ZpbGw7XG4gICAgZy5maWxsKCk7XG59XG5cblByaW1lcnNHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9IG5ldyBTVkdQYXRoKCk7XG4gICAgdGhpcy5kcmF3U3RlbVBhdGgocyk7XG4gICAgdmFyIHQgPSBuZXcgU1ZHUGF0aCgpO1xuICAgIHRoaXMuZHJhd1RyaWdzUGF0aCh0KTtcbiAgICBcbiAgICByZXR1cm4gbWFrZUVsZW1lbnROUyhcbiAgICAgICAgTlNfU1ZHLCAnZycsXG4gICAgICAgIFttYWtlRWxlbWVudE5TKFxuICAgICAgICAgICAgTlNfU1ZHLCAncGF0aCcsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAge2Q6IHMudG9QYXRoRGF0YSgpLFxuICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlIHx8ICdub25lJ30pLFxuICAgICAgICAgbWFrZUVsZW1lbnROUyhcbiAgICAgICAgICAgICBOU19TVkcsICdwYXRoJyxcbiAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgIHtkOiB0LnRvUGF0aERhdGEoKSxcbiAgICAgICAgICAgICAgZmlsbDogdGhpcy5fZmlsbCB8fCAnbm9uZSd9KV0pO1xufVxuXG5mdW5jdGlvbiBBcnJvd0dseXBoKG1pbiwgbWF4LCBoZWlnaHQsIGNvbG9yLCBwYXJhbGxlbCwgc3csIG5lKSB7XG4gICAgUGF0aEdseXBoQmFzZS5jYWxsKHRoaXMsIG51bGwsIGNvbG9yKTtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9jb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuX3BhcmFsbGVsID0gcGFyYWxsZWw7XG4gICAgdGhpcy5fc3cgPSBzdztcbiAgICB0aGlzLl9uZSA9IG5lO1xufVxuXG5BcnJvd0dseXBoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGF0aEdseXBoQmFzZS5wcm90b3R5cGUpO1xuXG5BcnJvd0dseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcbkFycm93R2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9tYXh9O1xuQXJyb3dHbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX2hlaWdodH07XG5cbkFycm93R2x5cGgucHJvdG90eXBlLmRyYXdQYXRoID0gZnVuY3Rpb24oZykge1xuICAgIHZhciBtaW4gPSB0aGlzLl9taW4sIG1heCA9IHRoaXMuX21heCwgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgIFxuICAgIGlmICh0aGlzLl9wYXJhbGxlbCkge1xuICAgICAgICB2YXIgaGggPSBoZWlnaHQvMjtcbiAgICAgICAgdmFyIGluc3RlcCA9IDAuNCAqIGhlaWdodDtcbiAgICAgICAgaWYgKHRoaXMuX3N3KSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhtaW4gKyBoaCwgaGVpZ2h0LWluc3RlcCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtaW4gKyBoaCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGcubGluZVRvKG1pbiwgaGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWluICsgaGgsIDApO1xuICAgICAgICAgICAgZy5saW5lVG8obWluICsgaGgsIGluc3RlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhtaW4sIGhlaWdodC1pbnN0ZXApO1xuICAgICAgICAgICAgZy5saW5lVG8obWluLCBpbnN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9uZSkge1xuICAgICAgICAgICAgZy5saW5lVG8obWF4IC0gaGgsIGluc3RlcCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXggLSBoaCwgMCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXgsIGhoKTtcbiAgICAgICAgICAgIGcubGluZVRvKG1heCAtIGhoLCBoZWlnaHQpO1xuICAgICAgICAgICAgZy5saW5lVG8obWF4IC0gaGgsIGhlaWdodCAtIGluc3RlcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXgsIGluc3RlcCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXgsIGhlaWdodC1pbnN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIGcuY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1pZCA9IChtaW4rbWF4KS8yO1xuICAgICAgICB2YXIgaW5zdGVwID0gMC40KihtYXgtbWluKTtcbiAgICAgICAgdmFyIHRoID0gaGVpZ2h0LzM7XG5cbiAgICAgICAgaWYgKHRoaXMuX25lKSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhtaW4gKyBpbnN0ZXAsIHRoKTtcbiAgICAgICAgICAgIGcubGluZVRvKG1pbiwgdGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWlkLCAwKTtcbiAgICAgICAgICAgIGcubGluZVRvKG1heCwgdGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWF4IC0gaW5zdGVwLCB0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhtaW4raW5zdGVwLCAwKTtcbiAgICAgICAgICAgIGcubGluZVRvKG1heC1pbnN0ZXAsIDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdykge1xuICAgICAgICAgICAgZy5saW5lVG8obWF4IC0gaW5zdGVwLCBoZWlnaHQtdGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWF4LCBoZWlnaHQtdGgpO1xuICAgICAgICAgICAgZy5saW5lVG8obWlkLCBoZWlnaHQpO1xuICAgICAgICAgICAgZy5saW5lVG8obWluLCBoZWlnaHQtdGgpXG4gICAgICAgICAgICBnLmxpbmVUbyhtaW4gKyBpbnN0ZXAsIGhlaWdodC10aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnLmxpbmVUbyhtYXggLSBpbnN0ZXAsIGhlaWdodCk7XG4gICAgICAgICAgICBnLmxpbmVUbyhtaW4gKyBpbnN0ZXAsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZy5jbG9zZVBhdGgoKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gVG9vTWFueUdseXBoKG1pbiwgbWF4LCBoZWlnaHQsIGZpbGwsIHN0cm9rZSkge1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX2ZpbGwgPSBmaWxsO1xuICAgIHRoaXMuX3N0cm9rZSA9IHN0cm9rZTtcbn1cblxuVG9vTWFueUdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcblRvb01hbnlHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX21heH07XG5Ub29NYW55R2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9oZWlnaHR9O1xuXG5Ub29NYW55R2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAncmVjdCcsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAge3g6IHRoaXMuX21pbiwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5fbWF4IC0gdGhpcy5fbWluLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogdGhpcy5fc3Ryb2tlIHx8ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbDogdGhpcy5fZmlsbCB8fCAnbm9uZSd9KTtcbn1cblxuVG9vTWFueUdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIGlmICh0aGlzLl9maWxsKSB7XG4gICAgICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fZmlsbDtcbiAgICAgICAgZy5maWxsUmVjdCh0aGlzLl9taW4sIDAsIHRoaXMuX21heCAtIHRoaXMuX21pbiwgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0cm9rZSkge1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgICAgICBnLnN0cm9rZVJlY3QodGhpcy5fbWluLCAwLCB0aGlzLl9tYXggLSB0aGlzLl9taW4sIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAodmFyIG4gPSAyOyBuIDwgdGhpcy5faGVpZ2h0OyBuICs9IDMpIHtcbiAgICAgICAgICAgIGcubW92ZVRvKHRoaXMuX21pbiwgbik7XG4gICAgICAgICAgICBnLmxpbmVUbyh0aGlzLl9tYXgsIG4pO1xuICAgICAgICB9XG4gICAgICAgIGcuc3Ryb2tlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBUZXh0R2x5cGgoR0xPQkFMX0dDLCBtaW4sIG1heCwgaGVpZ2h0LCBmaWxsLCBzdHJpbmcpIHtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9maWxsID0gZmlsbDtcbiAgICB0aGlzLl9zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy5fdGV4dExlbiA9IEdMT0JBTF9HQy5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xufVxuXG5UZXh0R2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9taW59O1xuVGV4dEdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtyZXR1cm4gTWF0aC5tYXgodGhpcy5fbWF4LCB0aGlzLl9taW4gKyB0aGlzLl90ZXh0TGVuKX07XG5UZXh0R2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9oZWlnaHR9O1xuXG5UZXh0R2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnKSB7XG4gICAgZy5maWxsU3R5bGUgPSB0aGlzLl9maWxsO1xuICAgIGcuZmlsbFRleHQodGhpcy5fc3RyaW5nLCB0aGlzLl9taW4sIHRoaXMuX2hlaWdodCAtIDQpO1xufVxuXG5UZXh0R2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIHRoaXMuX3N0cmluZywge3g6IHRoaXMuX21pbiwgeTogdGhpcy5faGVpZ2h0IC0gNH0pO1xufTtcblxuZnVuY3Rpb24gYW1pbm9UaWxlQ29sb3IoYWEsIHN0YXJ0LCBjb2xvcikge1xuICAgIHZhciBBTFRFUk5BVEVfQ09MT1IgPSB7XG4gICAgICAgICdyZWQnOiAnZGFya3JlZCcsXG4gICAgICAgICdwdXJwbGUnOiAnbWVkaXVtcHVycGxlJyxcbiAgICAgICAgJ2JsdWUnOiAnZGFya2JsdWUnLFxuICAgICAgICAnZ3JlZW4nOiAnZGFya2dyZWVuJ1xuICAgIH07XG4gICAgdmFyIGNvbG9yMiA9IEFMVEVSTkFURV9DT0xPUltjb2xvci50b0xvd2VyQ2FzZSgpXTtcbiAgICB2YXIgdGlsZUNvbG9ycztcbiAgICBpZiAoIWNvbG9yMilcbiAgICAgICAgdGlsZUNvbG9ycyA9IFsncmdiKDczLCA2OCwgMTQ5KScsICdyZ2IoOSwgMCwgMTAzKSddO1xuICAgICAgICAvLyBkZWZhdWx0IHRvIFVDU0MgY29sb3JzXG4gICAgZWxzZVxuICAgICAgICB0aWxlQ29sb3JzID0gW2NvbG9yLCBjb2xvcjJdO1xuXG4gICAgaWYgKGFhID09ICc/JylcbiAgICAgICAgcmV0dXJuICdibGFjayc7XG4gICAgZWxzZSBpZiAoYWEgPT0gJ00nKVxuICAgICAgICByZXR1cm4gJ2dyZWVueWVsbG93JztcbiAgICBlbHNlIGlmIChhYSA9PSAnKicpXG4gICAgICAgIHJldHVybiAnY3JpbXNvbic7XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gdGlsZUNvbG9yc1tzdGFydCAlIDJdO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlQ29tcGxlbWVudChzZXF1ZW5jZSkge1xuICAgIHZhciBzZXFfZGljdCA9IHsnQSc6ICdUJywgJ1QnOiAnQScsICdHJzogJ0MnLCAnQyc6ICdHJ307XG4gICAgdmFyIHJldl9zZXEgPSBzZXF1ZW5jZS5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpO1xuICAgIHZhciByZXZfY29tcGxfc2VxID0gW107XG4gICAgZm9yICh2YXIgYiA9IDA7IGIgPCByZXZfc2VxLmxlbmd0aDsgKytiKSB7XG4gICAgICAgIHZhciBiYXNlID0gcmV2X3NlcS5zdWJzdHIoYiwgMSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgcmV2X2NvbXBsX3NlcS5wdXNoKGJhc2UgaW4gc2VxX2RpY3QgPyBzZXFfZGljdFtiYXNlXSA6ICdOJyk7XG4gICAgfVxuICAgIHJldHVybiByZXZfY29tcGxfc2VxLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiBBbWlub0FjaWRHbHlwaChtaW4sIG1heCwgaGVpZ2h0LCBmaWxsLCBzZXEsIG9yaWVudGF0aW9uLCByZWFkZnJhbWUpIHtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9maWxsID0gZmlsbDtcbiAgICB0aGlzLl9zZXEgPSBzZXE7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgICB0aGlzLl9yZWFkZnJhbWUgPSByZWFkZnJhbWU7XG59XG5cbkFtaW5vQWNpZEdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcbkFtaW5vQWNpZEdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWF4fTtcbkFtaW5vQWNpZEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5faGVpZ2h0fTtcblxuQW1pbm9BY2lkR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnYykge1xuICAgIHZhciBzZXEgPSB0aGlzLl9zZXE7XG4gICAgdmFyIGNvbG9yID0gdGhpcy5fZmlsbDtcblxuICAgIGlmICghc2VxKSByZXR1cm47XG5cbiAgICB2YXIgc2NhbGUgPSAodGhpcy5fbWF4IC0gdGhpcy5fbWluICsgMSkgLyBzZXEubGVuZ3RoO1xuXG4gICAgdmFyIHByZXZPdmVyaGFuZyA9ICgzIC0gdGhpcy5fcmVhZGZyYW1lKSAlIDM7XG4gICAgdmFyIG5leHRPdmVyaGFuZyA9IChzZXEubGVuZ3RoIC0gcHJldk92ZXJoYW5nKSAlIDM7XG4gICAgdmFyIGxlZnRPdmVyaGFuZyA9IHRoaXMuX29yaWVudGF0aW9uID09ICcrJyA/IHByZXZPdmVyaGFuZyA6IG5leHRPdmVyaGFuZztcbiAgICBcbiAgICBpZiAobGVmdE92ZXJoYW5nID4gMCkge1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgZ2MuZmlsbFJlY3QodGhpcy5fbWluLCAwLCBzY2FsZSAqIGxlZnRPdmVyaGFuZywgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBwID0gbGVmdE92ZXJoYW5nOyBwIDwgc2VxLmxlbmd0aDsgcCArPSAzKSB7XG4gICAgICAgIHZhciBjb2RvbiA9IHNlcS5zdWJzdHIocCwgMykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09ICctJylcbiAgICAgICAgICAgIGNvZG9uID0gcmV2ZXJzZUNvbXBsZW1lbnQoY29kb24pO1xuICAgICAgICB2YXIgYWEgPSBjb2RvbiBpbiBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OID8gQU1JTk9fQUNJRF9UUkFOU0xBVElPTltjb2Rvbl0gOiAnPyc7XG4gICAgICAgIGNvbG9yID0gY29kb24ubGVuZ3RoID09IDMgPyBhbWlub1RpbGVDb2xvcihhYSwgcCwgdGhpcy5fZmlsbCkgOiB0aGlzLl9maWxsO1xuICAgICAgICBnYy5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgZ2MuZmlsbFJlY3QodGhpcy5fbWluICsgcCAqIHNjYWxlLCAwLCBzY2FsZSAqIGNvZG9uLmxlbmd0aCwgdGhpcy5faGVpZ2h0KTtcblxuICAgICAgICBpZiAoc2NhbGUgPj0gOCAmJiBjb2Rvbi5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIGdjLmZpbGxUZXh0KGFhLCB0aGlzLl9taW4gKyAocCsxKSAqIHNjYWxlLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgICB9IFxuICAgIH1cbn1cblxuQW1pbm9BY2lkR2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGcgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnKTtcbiAgICB2YXIgc2VxID0gdGhpcy5fc2VxO1xuICAgIHZhciBjb2xvciA9IHRoaXMuX2ZpbGw7XG5cbiAgICBpZiAoIXNlcSlcbiAgICAgICAgcmV0dXJuIGc7XG5cbiAgICB2YXIgc2NhbGUgPSAodGhpcy5fbWF4IC0gdGhpcy5fbWluICsgMSkgLyBzZXEubGVuZ3RoO1xuXG4gICAgdmFyIHByZXZPdmVyaGFuZyA9ICgzIC0gdGhpcy5fcmVhZGZyYW1lKSAlIDM7XG4gICAgdmFyIG5leHRPdmVyaGFuZyA9IChzZXEubGVuZ3RoIC0gcHJldk92ZXJoYW5nKSAlIDM7XG4gICAgdmFyIGxlZnRPdmVyaGFuZyA9IHRoaXMuX29yaWVudGF0aW9uID09ICcrJyA/IHByZXZPdmVyaGFuZyA6IG5leHRPdmVyaGFuZztcblxuICAgIGlmIChsZWZ0T3ZlcmhhbmcgPiAwKSB7XG4gICAgICAgIGcuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3JlY3QnLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgeDogdGhpcy5fbWluLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNjYWxlICogbGVmdE92ZXJoYW5nLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgIGZpbGw6IGNvbG9yfSkpO1xuICAgIH1cbiAgICBmb3IgKHZhciBwID0gbGVmdE92ZXJoYW5nOyBwIDwgc2VxLmxlbmd0aDsgcCArPSAzKSB7XG4gICAgICAgIHZhciBjb2RvbiA9IHNlcS5zdWJzdHIocCwgMykudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX29yaWVudGF0aW9uID09ICctJylcbiAgICAgICAgICAgIGNvZG9uID0gcmV2ZXJzZUNvbXBsZW1lbnQoY29kb24pO1xuICAgICAgICB2YXIgYWEgPSBjb2RvbiBpbiBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OID8gQU1JTk9fQUNJRF9UUkFOU0xBVElPTltjb2Rvbl0gOiAnPyc7XG4gICAgICAgIGNvbG9yID0gY29kb24ubGVuZ3RoID09IDMgPyBhbWlub1RpbGVDb2xvcihhYSwgcCwgdGhpcy5fZmlsbCkgOiB0aGlzLl9maWxsO1xuICAgICAgICBnLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgbWFrZUVsZW1lbnROUyhOU19TVkcsICdyZWN0JywgbnVsbCwge1xuICAgICAgICAgICAgICAgIHg6IHRoaXMuX21pbiArIHAgKiBzY2FsZSxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzY2FsZSAqIGNvZG9uLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcn0pKTtcblxuICAgICAgICBpZiAoc2NhbGUgPj0gOCAmJiBjb2Rvbi5sZW5ndGggPT0gMykge1xuICAgICAgICAgICAgZy5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3RleHQnLCBhYSwge1xuICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLl9taW4gKyAocCsxKSAqIHNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB5OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZSd9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGc7XG59O1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcblxudmFyIGlzUmV0aW5hID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxO1xudmFyIF9fZGFsbGlhbmNlX1NlcXVlbmNlR2x5cGhDYWNoZSA9IHt9O1xudmFyIGFsdFBhdHRlcm4gPSBuZXcgUmVnRXhwKCdeW0FDR1QtXSQnKTtcbnZhciBpc0Nsb3NlVXAgPSBmdW5jdGlvbihzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSA+PSA4O1xufVxuXG5mdW5jdGlvbiBTZXF1ZW5jZUdseXBoKGJhc2VDb2xvcnMsIHN0cmFuZENvbG9yLCBtaW4sIG1heCwgaGVpZ2h0LCBzZXEsIHJlZiwgc2NoZW1lLCBxdWFscywgZmlsbGJnKSB7XG4gICAgdGhpcy5iYXNlQ29sb3JzID0gYmFzZUNvbG9ycztcbiAgICB0aGlzLl9zdHJhbmRDb2xvciA9IHN0cmFuZENvbG9yO1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3NlcSA9IHNlcTtcbiAgICB0aGlzLl9yZWYgPSByZWY7XG4gICAgdGhpcy5fc2NoZW1lID0gc2NoZW1lO1xuICAgIHRoaXMuX3F1YWxzID0gcXVhbHM7XG4gICAgdGhpcy5fZmlsbGJnID0gZmlsbGJnO1xufVxuXG5TZXF1ZW5jZUdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5fbWlufTtcblNlcXVlbmNlR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9tYXh9O1xuU2VxdWVuY2VHbHlwaC5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX2hlaWdodH07XG5cblxuU2VxdWVuY2VHbHlwaC5wcm90b3R5cGUuYWxwaGFGb3JRdWFsID0gZnVuY3Rpb24ocXVhbCkge1xuICAgIHJldHVybiAwLjEgKyAwLjkqTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigoMS4wICogcXVhbCkgLyAzMC4wLCAxLjApKTtcbn1cblxuU2VxdWVuY2VHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGdjKSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuX3NlcTtcbiAgICB2YXIgcmVmID0gdGhpcy5fcmVmO1xuICAgIHZhciBtaXNtYXRjaCA9IHRoaXMuX3NjaGVtZSA9PT0gJ21pc21hdGNoJyB8fCB0aGlzLl9zY2hlbWUgPT09ICdtaXNtYXRjaC1hbGwnO1xuICAgIHZhciBhbGwgPSB0aGlzLl9zY2hlbWUgPT09ICdtaXNtYXRjaC1hbGwnO1xuICAgIFxuICAgIHZhciBzZXFMZW5ndGggPSBzZXEgPyBzZXEubGVuZ3RoIDogKHRoaXMuX21heCAtIHRoaXMuX21pbiArIDEpO1xuICAgIHZhciBzY2FsZSA9ICh0aGlzLl9tYXggLSB0aGlzLl9taW4gKyAxKSAvIHNlcUxlbmd0aDtcblxuICAgIGlmIChtaXNtYXRjaCAmJiAhaXNDbG9zZVVwKHNjYWxlKSkge1xuICAgICAgICBnYy5maWxsU3R5bGUgPSB0aGlzLl9zdHJhbmRDb2xvcjtcbiAgICAgICAgZ2MuZmlsbFJlY3QodGhpcy5fbWluLCB0aGlzLl9oZWlnaHQvNCwgdGhpcy5fbWF4IC0gdGhpcy5fbWluLCB0aGlzLl9oZWlnaHQvMik7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBzZXFMZW5ndGg7ICsrcCkge1xuICAgICAgICB2YXIgYmFzZSA9IHNlcSA/IHNlcS5zdWJzdHIocCwgMSkudG9VcHBlckNhc2UoKSA6ICdOJztcbiAgICAgICAgXG4gICAgICAgIGlmICghYWx0UGF0dGVybi50ZXN0KGJhc2UpICYmICFpc0Nsb3NlVXAoc2NhbGUpKVxuICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5iYXNlQ29sb3JzW2Jhc2VdO1xuXG4gICAgICAgIGlmICh0aGlzLl9xdWFscykge1xuICAgICAgICAgICAgdmFyIHFjID0gdGhpcy5fcXVhbHMuY2hhckNvZGVBdChwKSAtIDMzO1xuICAgICAgICAgICAgdmFyIG9sZEFscGhhID0gZ2MuZ2xvYmFsQWxwaGE7ICAgICAgICAgICAgLy8gTkIgaG9pc3RlZCFcbiAgICAgICAgICAgIGdjLmdsb2JhbEFscGhhID0gdGhpcy5hbHBoYUZvclF1YWwocWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb2xvcikge1xuICAgICAgICAgICAgdmFyIHJlZkJhc2UgPSByZWYgPyByZWYuc3Vic3RyKHAsIDEpLnRvVXBwZXJDYXNlKCkgOiAnTic7XG4gICAgICAgICAgICBpZiAoYmFzZSA9PSAnTicgfHwgcmVmQmFzZSA9PSAnTicpXG4gICAgICAgICAgICAgICAgY29sb3IgPSAnZ3JheSc7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29sb3IgPSB0aGlzLl9zdHJhbmRDb2xvcjtcblxuICAgICAgICAgICAgaWYgKGFsbClcbiAgICAgICAgICAgICAgICBiYXNlID0gcmVmQmFzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGNvbG9yO1xuXG4gICAgICAgIHZhciBhbHQgPSBhbHRQYXR0ZXJuLnRlc3QoYmFzZSk7XG4gICAgICAgIGlmICh0aGlzLl9maWxsYmcgfHwgIWlzQ2xvc2VVcChzY2FsZSkgfHwgIWFsdClcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHRoaXMuX21pbiArIHAqc2NhbGUsIDAsIHNjYWxlLCB0aGlzLl9oZWlnaHQpO1xuXG4gICAgICAgIGlmIChpc0Nsb3NlVXAoc2NhbGUpICYmIGFsdCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGNvbG9yICsgJ18nICsgYmFzZVxuICAgICAgICAgICAgdmFyIGltZyA9IF9fZGFsbGlhbmNlX1NlcXVlbmNlR2x5cGhDYWNoZVtrZXldO1xuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZXRpbmEpIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nLndpZHRoID0gMTY7XG4gICAgICAgICAgICAgICAgICAgIGltZy5oZWlnaHQgPSAyMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWcud2lkdGggPSA4O1xuICAgICAgICAgICAgICAgICAgICBpbWcuaGVpZ2h0ID0gMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbWdHYyA9IGltZy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGlmIChpc1JldGluYSkge1xuICAgICAgICAgICAgICAgICAgICBpbWdHYy5zY2FsZSgyLCAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW1nR2MuZmlsbFN0eWxlID0gdGhpcy5fZmlsbGJnID8gJ2JsYWNrJyA6IGNvbG9yO1xuICAgICAgICAgICAgICAgIHZhciB3ID0gaW1nR2MubWVhc3VyZVRleHQoYmFzZSkud2lkdGg7XG4gICAgICAgICAgICAgICAgaW1nR2MuZmlsbFRleHQoYmFzZSwgMC41ICogKDguMCAtIHcpLCA4KTtcbiAgICAgICAgICAgICAgICBfX2RhbGxpYW5jZV9TZXF1ZW5jZUdseXBoQ2FjaGVba2V5XSA9IGltZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1JldGluYSlcbiAgICAgICAgICAgICAgICBnYy5kcmF3SW1hZ2UoaW1nLCB0aGlzLl9taW4gKyBwKnNjYWxlICsgMC41KihzY2FsZS04KSwgMCwgOCwgMTApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdjLmRyYXdJbWFnZShpbWcsIHRoaXMuX21pbiArIHAqc2NhbGUgKyAwLjUqKHNjYWxlLTgpLCAwKTtcbiAgICAgICAgfSBcblxuICAgICAgICBpZiAodGhpcy5fcXVhbHMpIHtcbiAgICAgICAgICAgIGdjLmdsb2JhbEFscGhhID0gb2xkQWxwaGE7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblNlcXVlbmNlR2x5cGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuX3NlcTtcbiAgICB2YXIgcmVmID0gdGhpcy5fcmVmO1xuICAgIHZhciBtaXNtYXRjaCA9IHRoaXMuX3NjaGVtZSA9PT0gJ21pc21hdGNoJyB8fCB0aGlzLl9zY2hlbWUgPT09ICdtaXNtYXRjaC1hbGwnO1xuICAgIHZhciBhbGwgPSB0aGlzLl9zY2hlbWUgPT09ICdtaXNtYXRjaC1hbGwnO1xuICAgIHZhciBzY2FsZSA9ICh0aGlzLl9tYXggLSB0aGlzLl9taW4gKyAxKSAvIHRoaXMuX3NlcS5sZW5ndGg7XG4gICAgdmFyICBnID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJyk7IFxuXG4gICAgZm9yICh2YXIgcCA9IDA7IHAgPCBzZXEubGVuZ3RoOyArK3ApIHtcbiAgICAgICAgdmFyIGJhc2UgPSBzZXEgPyBzZXEuc3Vic3RyKHAsIDEpLnRvVXBwZXJDYXNlKCkgOiAnTic7XG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMuYmFzZUNvbG9yc1tiYXNlXTtcblxuICAgICAgICBpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICB2YXIgcmVmQmFzZSA9IHJlZiA/IHJlZi5zdWJzdHIocCwgMSkudG9VcHBlckNhc2UoKSA6ICdOJztcbiAgICAgICAgICAgIGlmIChiYXNlID09ICdOJyB8fCByZWZCYXNlID09ICdOJylcbiAgICAgICAgICAgICAgICBjb2xvciA9ICdncmF5JztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb2xvciA9IHRoaXMuX3N0cmFuZENvbG9yO1xuXG4gICAgICAgICAgICBpZiAoYWxsKVxuICAgICAgICAgICAgICAgIGJhc2UgPSByZWZCYXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFscGhhID0gMS4wO1xuICAgICAgICBpZiAodGhpcy5fcXVhbHMpIHtcbiAgICAgICAgICAgIHZhciBxYyA9IHRoaXMuX3F1YWxzLmNoYXJDb2RlQXQocCkgLSAzMztcbiAgICAgICAgICAgIGFscGhhID0gdGhpcy5hbHBoYUZvclF1YWwocWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFsdCA9IGFsdFBhdHRlcm4udGVzdChiYXNlKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGxiZyB8fCAhaXNDbG9zZVVwKHNjYWxlKSB8fCAhYWx0KSB7XG4gICAgICAgICAgICBnLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAncmVjdCcsIG51bGwsIHtcbiAgICAgICAgICAgICAgICAgICAgeDp0aGlzLl9taW4gKyBwKnNjYWxlLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5faGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IGFscGhhfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQ2xvc2VVcChzY2FsZSkgJiYgYWx0KSB7XG4gICAgICAgICAgICBnLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIGJhc2UsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogdGhpcy5fbWluICsgKDAuNStwKSpzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgeTogOCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFuY2hvcjogJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgIGZpbGw6IHRoaXMuX2ZpbGxiZyA/ICdibGFjaycgOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IGFscGhhfSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGc7XG59XG5cbnNjb3BlLlNlcXVlbmNlR2x5cGggPSBTZXF1ZW5jZUdseXBoO1xuXG59KHRoaXMpKTtcblxuZnVuY3Rpb24gVHJhbnNsYXRlZEdseXBoKGdseXBoLCB4LCB5LCBoZWlnaHQpIHtcbiAgICB0aGlzLmdseXBoID0gZ2x5cGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX3kgPSB5O1xufVxuXG5UcmFuc2xhdGVkR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5nbHlwaC5oZWlnaHQoKSArIHRoaXMuX3k7XG4gICAgfVxufVxuXG5UcmFuc2xhdGVkR2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdseXBoLm1pbigpICsgdGhpcy5feDtcbn1cblxuVHJhbnNsYXRlZEdseXBoLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nbHlwaC5tYXgoKSArIHRoaXMuX3g7XG59XG5cblRyYW5zbGF0ZWRHbHlwaC5wcm90b3R5cGUubWluWSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl95O1xufVxuXG5UcmFuc2xhdGVkR2x5cGgucHJvdG90eXBlLm1heFkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feSArIHRoaXMuZ2x5cGguaGVpZ2h0KCk7XG59XG5cblRyYW5zbGF0ZWRHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcsIG8pIHtcbiAgICBnLnNhdmUoKTtcbiAgICBnLnRyYW5zbGF0ZSh0aGlzLl94LCB0aGlzLl95KTtcbiAgICB0aGlzLmdseXBoLmRyYXcoZywgbyk7XG4gICAgZy5yZXN0b3JlKCk7XG59XG5cblRyYW5zbGF0ZWRHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9ICB0aGlzLmdseXBoLnRvU1ZHKCk7XG4gICAgcy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHRoaXMuX3ggKyAnLCcgKyB0aGlzLl95ICsgJyknKTtcbiAgICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gUG9pbnRHbHlwaCh4LCB5LCBoZWlnaHQsIGZpbGwpIHtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fZmlsbCA9IGZpbGw7XG59XG5cblBvaW50R2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl94IC0gMjtcbn1cblxuUG9pbnRHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggKyAyO1xufVxuXG5Qb2ludEdseXBoLnByb3RvdHlwZS5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xufVxuXG5Qb2ludEdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oZykge1xuICAgIGcuc2F2ZSgpO1xuICAgIGcuZ2xvYmFsQWxwaGEgPSAwLjM7XG4gICAgZy5maWxsU3R5bGUgPSB0aGlzLl9maWxsO1xuICAgIGcuYmVnaW5QYXRoKCk7XG4gICAgZy5hcmModGhpcy5feCwgdGhpcy5feSwgMS41LCAwLCA2LjI5KTtcbiAgICBnLmZpbGwoKTtcbiAgICBnLnJlc3RvcmUoKTtcbn1cblxuUG9pbnRHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWFrZUVsZW1lbnROUyhcbiAgICAgICAgTlNfU1ZHLCAnY2lyY2xlJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAge2N4OiB0aGlzLl94LCBjeTogdGhpcy5feSwgcjogMixcbiAgICAgICAgIGZpbGw6IHRoaXMuX2ZpbGwsXG4gICAgICAgICBzdHJva2U6ICdub25lJ30pO1xufVxuXG5cbmZ1bmN0aW9uIEdyaWRHbHlwaChoZWlnaHQpIHtcbiAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQgfHwgNTA7XG59XG5cbkdyaWRHbHlwaC5wcm90b3R5cGUubm90U2VsZWN0YWJsZSA9IHRydWU7XG5cbkdyaWRHbHlwaC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIC0xMDAwMDA7XG59O1xuXG5HcmlkR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAxMDAwMDA7XG59O1xuXG5HcmlkR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59XG5cbkdyaWRHbHlwaC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGcpIHtcbiAgICBnLnNhdmUoKTtcbiAgICBnLnN0cm9rZVN0eWxlID0gJ2JsYWNrJ1xuICAgIGcubGluZVdpZHRoID0gMC4xO1xuXG4gICAgZy5iZWdpblBhdGgoKTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSB0aGlzLl9oZWlnaHQ7IHkgKz0gMTApIHtcbiAgICAgICAgZy5tb3ZlVG8oLTUwMDAsIHkpO1xuICAgICAgICBnLmxpbmVUbyg1MDAwLCB5KTtcbiAgICB9XG4gICAgZy5zdHJva2UoKTtcbiAgICBnLnJlc3RvcmUoKTtcbn1cblxuR3JpZEdseXBoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwID0gbmV3IFNWR1BhdGgoKTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSB0aGlzLl9oZWlnaHQ7IHkgKz0gMTApIHtcbiAgICAgICAgcC5tb3ZlVG8oLTUwMDAsIHkpO1xuICAgICAgICBwLmxpbmVUbyg1MDAwLCB5KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG1ha2VFbGVtZW50TlMoXG4gICAgICAgIE5TX1NWRywgJ3BhdGgnLFxuICAgICAgICBudWxsLFxuICAgICAgICB7ZDogcC50b1BhdGhEYXRhKCksXG4gICAgICAgICBmaWxsOiAnbm9uZScsXG4gICAgICAgICBzdHJva2U6ICdibGFjaycsXG4gICAgICAgICBzdHJva2VXaWR0aDogJzAuMXB4J30pO1xufVxuXG5mdW5jdGlvbiBTdGFyR2x5cGgoeCwgciwgcG9pbnRzLCBmaWxsLCBzdHJva2UpIHtcbiAgICBQYXRoR2x5cGhCYXNlLmNhbGwodGhpcywgc3Ryb2tlLCBmaWxsKTtcbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl9yID0gcjtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG59XG5cblN0YXJHbHlwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBhdGhHbHlwaEJhc2UucHJvdG90eXBlKTtcblxuU3RhckdseXBoLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5feCAtIHRoaXMuX3I7XG59XG5cblN0YXJHbHlwaC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ggKyB0aGlzLl9yO1xufVxuXG5TdGFyR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAyICogdGhpcy5fcjtcbn1cblxuU3RhckdseXBoLnByb3RvdHlwZS5kcmF3UGF0aCA9IGZ1bmN0aW9uKGcpIHtcbiAgICB2YXIgbWlkWCA9IHRoaXMuX3gsIG1pZFkgPSB0aGlzLl9yLCByID0gdGhpcy5fcjtcbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHRoaXMuX3BvaW50czsgKytwKSB7XG4gICAgICAgIHZhciB0aGV0YSA9IChwICogNi4yOCkgLyB0aGlzLl9wb2ludHM7XG4gICAgICAgIHZhciBweCA9IG1pZFggKyByKk1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgdmFyIHB5ID0gbWlkWSAtIHIqTWF0aC5jb3ModGhldGEpO1xuICAgICAgICBpZiAocCA9PSAwKSB7XG4gICAgICAgICAgICBnLm1vdmVUbyhweCwgcHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZy5saW5lVG8ocHgsIHB5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGV0YSA9ICgocCswLjUpICogNi4yOCkgLyB0aGlzLl9wb2ludHM7XG4gICAgICAgIHB4ID0gbWlkWCArIDAuNCpyKk1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgcHkgPSBtaWRZIC0gMC40KnIqTWF0aC5jb3ModGhldGEpO1xuICAgICAgICBnLmxpbmVUbyhweCwgcHkpO1xuICAgIH1cbiAgICBnLmNsb3NlUGF0aCgpO1xufVxuXG5mdW5jdGlvbiBQbGltc29sbEdseXBoKHgsIGhlaWdodCwgb3ZlcmhhbmcsIGZpbGwsIHN0cm9rZSkge1xuICAgIHRoaXMuX3ggPSB4O1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vdmVyaGFuZyA9IG92ZXJoYW5nO1xuICAgIHRoaXMuX2ZpbGwgPSBmaWxsO1xuICAgIHRoaXMuX3N0cm9rZSA9IHN0cm9rZTtcbiAgICB0aGlzLl9oaCA9IGhlaWdodCAvIDI7XG59XG5cblBsaW1zb2xsR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnKSB7XG4gICAgdmFyIGhoID0gdGhpcy5faGVpZ2h0LzI7XG4gICAgZy5maWxsU3R5bGUgPSB0aGlzLl9zdHJva2U7XG4gICAgZy5iZWdpblBhdGgoKTtcbiAgICBnLmFyYyh0aGlzLl94LCBoaCwgaGggLSB0aGlzLl9vdmVyaGFuZywgMCwgNi4yOSk7XG4gICAgZy5tb3ZlVG8odGhpcy5feCwgMCk7XG4gICAgZy5saW5lVG8odGhpcy5feCwgdGhpcy5faGVpZ2h0KTtcblxuICAgIGlmICh0aGlzLl9maWxsKSB7XG4gICAgICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fZmlsbDtcbiAgICAgICAgZy5maWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0cm9rZSkge1xuICAgICAgICBnLnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlO1xuICAgICAgICBnLnN0cm9rZSgpO1xuICAgIH1cbn1cblxuUGxpbXNvbGxHbHlwaC5wcm90b3R5cGUudG9TVkcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaGggPSB0aGlzLl9oaDtcbiAgICByZXR1cm4gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJywgXG4gICAgICAgIFttYWtlRWxlbWVudE5TKE5TX1NWRywgJ2NpcmNsZScsIG51bGwsIHtjeDogdGhpcy5feCwgY3k6IGhoLCByOiBoaCAtIHRoaXMuX292ZXJoYW5nfSksXG4gICAgICAgICBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2xpbmUnLCBudWxsLCB7eDE6IHRoaXMuX3gsIHkxOiAwLCB4MjogdGhpcy5feCwgeTI6IHRoaXMuX2hlaWdodH0pXSxcbiAgICAgICAge2ZpbGw6IHRoaXMuX2ZpbGwgfHwgJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlOiB0aGlzLl9zdHJva2UgfHwgJ25vbmUnLFxuICAgICAgICAgc3Ryb2tlV2lkdGg6ICcxcHgnfSk7XG59XG5cblBsaW1zb2xsR2x5cGgucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl94IC0gdGhpcy5faGg7XG59XG5cblBsaW1zb2xsR2x5cGgucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl94ICsgdGhpcy5faGg7XG59XG5cblBsaW1zb2xsR2x5cGgucHJvdG90eXBlLmhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG59XG5cblxuZnVuY3Rpb24gT3ZlcmxheUxhYmVsQ2FudmFzKCkge1xuICAgIHRoaXMub3ggPSAwO1xuICAgIHRoaXMub3kgPSAwO1xuICAgIHRoaXMuZ2x5cGhzID0gW107XG59XG5cbk92ZXJsYXlMYWJlbENhbnZhcy5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMub3ggKz0geDtcbiAgICB0aGlzLm95ICs9IHk7XG59XG5cbk92ZXJsYXlMYWJlbENhbnZhcy5wcm90b3R5cGUucmVnaXN0ZXJHbHlwaCA9IGZ1bmN0aW9uKGcpIHtcbiAgICB0aGlzLmdseXBocy5wdXNoKHtcbiAgICAgICAgeDogdGhpcy5veCxcbiAgICAgICAgeTogdGhpcy5veSxcbiAgICAgICAgZ2x5cGg6IGdcbiAgICB9KTtcbn1cblxuXG5PdmVybGF5TGFiZWxDYW52YXMucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihnLCBtaW5WaXNpYmxlLCBtYXhWaXNpYmxlKSB7XG4gICAgZm9yICh2YXIgZ2kgPSAwOyBnaSA8IHRoaXMuZ2x5cGhzLmxlbmd0aDsgKytnaSkge1xuICAgICAgICB2YXIgZ2cgPSB0aGlzLmdseXBoc1tnaV07XG4gICAgICAgIGcuc2F2ZSgpO1xuICAgICAgICBnLnRyYW5zbGF0ZShnZy54LCBnZy55KTtcbiAgICAgICAgZ2cuZ2x5cGguZHJhd092ZXJsYXkoZywgbWluVmlzaWJsZSwgbWF4VmlzaWJsZSk7XG4gICAgICAgIGcucmVzdG9yZSgpO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBCb3hHbHlwaDogQm94R2x5cGgsXG4gICAgICAgIEdyb3VwR2x5cGg6IEdyb3VwR2x5cGgsXG4gICAgICAgIExpbmVHcmFwaEdseXBoOiBMaW5lR3JhcGhHbHlwaCxcbiAgICAgICAgTGFiZWxsZWRHbHlwaDogTGFiZWxsZWRHbHlwaCxcbiAgICAgICAgQ3Jvc3NHbHlwaDogQ3Jvc3NHbHlwaCxcbiAgICAgICAgRXhHbHlwaDogRXhHbHlwaCxcbiAgICAgICAgVHJpYW5nbGVHbHlwaDogVHJpYW5nbGVHbHlwaCxcbiAgICAgICAgRG90R2x5cGg6IERvdEdseXBoLFxuICAgICAgICBQYWRkZWRHbHlwaDogUGFkZGVkR2x5cGgsXG4gICAgICAgIEFBcnJvd0dseXBoOiBBQXJyb3dHbHlwaCxcbiAgICAgICAgU3BhbkdseXBoOiBTcGFuR2x5cGgsXG4gICAgICAgIExpbmVHbHlwaDogTGluZUdseXBoLFxuICAgICAgICBQcmltZXJzR2x5cGg6IFByaW1lcnNHbHlwaCxcbiAgICAgICAgQXJyb3dHbHlwaDogQXJyb3dHbHlwaCxcbiAgICAgICAgVG9vTWFueUdseXBoOiBUb29NYW55R2x5cGgsXG4gICAgICAgIFRleHRHbHlwaDogVGV4dEdseXBoLFxuICAgICAgICBTZXF1ZW5jZUdseXBoOiB0aGlzLlNlcXVlbmNlR2x5cGgsXG4gICAgICAgIEFtaW5vQWNpZEdseXBoOiBBbWlub0FjaWRHbHlwaCxcbiAgICAgICAgVHJhbnNsYXRlZEdseXBoOiBUcmFuc2xhdGVkR2x5cGgsXG4gICAgICAgIEdyaWRHbHlwaDogR3JpZEdseXBoLFxuICAgICAgICBTdGFyR2x5cGg6IFN0YXJHbHlwaCxcbiAgICAgICAgUG9pbnRHbHlwaDogUG9pbnRHbHlwaCxcbiAgICAgICAgUGxpbXNvbGxHbHlwaDogUGxpbXNvbGxHbHlwaCxcblxuICAgICAgICBPdmVybGF5TGFiZWxDYW52YXM6IE92ZXJsYXlMYWJlbENhbnZhc1xuICAgIH1cbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTNcbi8vXG4vLyBqYmpzb24uanMgLS0gcXVlcnkgSkJyb3dzZS1zdHlsZSBSRVNUIGRhdGEgc3RvcmVzXG4vL1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBEQVNTdHlsZXNoZWV0ID0gZGFzLkRBU1N0eWxlc2hlZXQ7XG4gICAgdmFyIERBU1N0eWxlID0gZGFzLkRBU1N0eWxlO1xuICAgIHZhciBEQVNGZWF0dXJlID0gZGFzLkRBU0ZlYXR1cmU7XG4gICAgdmFyIERBU0dyb3VwID0gZGFzLkRBU0dyb3VwO1xufVxuXG5mdW5jdGlvbiBKQnJvd3NlU3RvcmUoYmFzZSwgcXVlcnkpIHtcbiAgICB0aGlzLmJhc2UgPSBiYXNlO1xuICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbn1cblxuSkJyb3dzZVN0b3JlLnByb3RvdHlwZS5mZWF0dXJlcyA9IGZ1bmN0aW9uKHNlZ21lbnQsIG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICB1cmwgPSB0aGlzLmJhc2UgKyAnL2ZlYXR1cmVzLycgKyBzZWdtZW50Lm5hbWU7XG5cbiAgICB2YXIgZmlsdGVycyA9IFtdO1xuICAgIGlmICh0aGlzLnF1ZXJ5KSB7XG5cdCAgIGZpbHRlcnMucHVzaCh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKHNlZ21lbnQuaXNCb3VuZGVkKSB7XG4gICAgXHRmaWx0ZXJzLnB1c2goJ3N0YXJ0PScgKyBzZWdtZW50LnN0YXJ0KTtcbiAgICBcdGZpbHRlcnMucHVzaCgnZW5kPScgKyBzZWdtZW50LmVuZCk7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA+IDApIHtcblx0ICAgIHVybCA9IHVybCArICc/JyArIGZpbHRlcnMuam9pbignJicpO1xuICAgIH1cblxuICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG5cdCAgICBpZiAocmVxLnN0YXR1cyA+PSAzMDApIHtcblx0XHQgICAgY2FsbGJhY2sobnVsbCwgJ0Vycm9yIGNvZGUgJyArIHJlcS5zdGF0dXMpO1xuXHQgICAgfSBlbHNlIHtcblx0XHR2YXIgamYgPSBKU09OLnBhcnNlKHJlcS5yZXNwb25zZSlbJ2ZlYXR1cmVzJ107XG5cdFx0dmFyIGZlYXR1cmVzID0gW107XG5cdFx0Zm9yIChmaSA9IDA7IGZpIDwgamYubGVuZ3RoOyArK2ZpKSB7XG5cdFx0ICAgIHZhciBqID0gamZbZmldO1xuXHRcdCAgICBcblx0XHQgICAgdmFyIGYgPSBuZXcgREFTRmVhdHVyZSgpO1xuXHRcdCAgICBmLnNlZ21lbnQgPSBzZWdtZW50Lm5hbWU7XG5cdFx0ICAgIGYubWluID0gKGpbJ3N0YXJ0J10gfCAwKSArIDE7XG5cdFx0ICAgIGYubWF4ID0galsnZW5kJ10gfCAwO1xuXHRcdCAgICBpZiAoai5uYW1lKSB7XG5cdFx0XHRmLmxhYmVsID0gai5uYW1lO1xuXHRcdCAgICB9XG5cdFx0ICAgIGYudHlwZSA9IGoudHlwZSB8fCAndW5rbm93bic7XG5cdFx0ICAgIFxuXHRcdCAgICBmZWF0dXJlcy5wdXNoKGYpO1xuXHRcdH1cblx0XHRjYWxsYmFjayhmZWF0dXJlcyk7XG5cdCAgICB9XG5cdH1cblx0XG4gICAgfTtcbiAgICBcbiAgICByZXEub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICByZXEucmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuICAgIHJlcS5zZW5kKCcnKTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBKQnJvd3NlU3RvcmU6IEpCcm93c2VTdG9yZVxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8ga3NwYWNlLmpzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIEF3YWl0ZWQgPSB1dGlscy5Bd2FpdGVkO1xuICAgIHZhciBwdXNobyA9IHV0aWxzLnB1c2hvO1xuXG4gICAgdmFyIHNhID0gcmVxdWlyZSgnLi9zb3VyY2VhZGFwdGVycycpO1xuICAgIHZhciBNYXBwZWRGZWF0dXJlU291cmNlID0gc2EuTWFwcGVkRmVhdHVyZVNvdXJjZTtcbiAgICB2YXIgQ2FjaGluZ0ZlYXR1cmVTb3VyY2UgPSBzYS5DYWNoaW5nRmVhdHVyZVNvdXJjZTtcbiAgICB2YXIgQldHRmVhdHVyZVNvdXJjZSA9IHNhLkJXR0ZlYXR1cmVTb3VyY2U7XG4gICAgdmFyIFJlbW90ZUJXR0ZlYXR1cmVTb3VyY2UgPSBzYS5SZW1vdGVCV0dGZWF0dXJlU291cmNlO1xuICAgIHZhciBCQU1GZWF0dXJlU291cmNlID0gc2EuQkFNRmVhdHVyZVNvdXJjZTtcbiAgICB2YXIgUmVtb3RlQkFNRmVhdHVyZVNvdXJjZSA9IHNhLlJlbW90ZUJBTUZlYXR1cmVTb3VyY2U7XG4gICAgdmFyIER1bW15U2VxdWVuY2VTb3VyY2UgPSBzYS5EdW1teVNlcXVlbmNlU291cmNlO1xuICAgIHZhciBEdW1teUZlYXR1cmVTb3VyY2UgPSBzYS5EdW1teUZlYXR1cmVTb3VyY2U7XG5cbiAgICB2YXIgT3ZlcmxheUZlYXR1cmVTb3VyY2UgPSByZXF1aXJlKCcuL292ZXJsYXknKS5PdmVybGF5RmVhdHVyZVNvdXJjZTtcblxuICAgIHZhciBzcGFucyA9IHJlcXVpcmUoJy4vc3BhbnMnKTtcbiAgICB2YXIgUmFuZ2UgPSBzcGFucy5SYW5nZTtcbiAgICB2YXIgdW5pb24gPSBzcGFucy51bmlvbjtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gc3BhbnMuaW50ZXJzZWN0aW9uO1xuXG4gICAgdmFyIHNhbXBsZSA9IHJlcXVpcmUoJy4vc2FtcGxlJyk7XG4gICAgdmFyIGRvd25zYW1wbGUgPSBzYW1wbGUuZG93bnNhbXBsZTtcbiAgICB2YXIgZ2V0QmFzZUNvdmVyYWdlID0gc2FtcGxlLmdldEJhc2VDb3ZlcmFnZTtcblxuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBEQVNTZXF1ZW5jZSA9IGRhcy5EQVNTZXF1ZW5jZTtcbiAgICBcbiAgICB2YXIgUHJvbWlzZSA9IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gRmV0Y2hQb29sKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLnJlcXMgPSBbXTtcbiAgICB0aGlzLmF3YWl0ZWRGZWF0dXJlcyA9IHt9O1xuICAgIHRoaXMucmVxdWVzdHNJc3N1ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5ub3RpZnlSZXF1ZXN0c0lzc3VlZCA9IHJlc29sdmU7XG4gICAgfSk7XG59XG5cbkZldGNoUG9vbC5wcm90b3R5cGUuYWRkUmVxdWVzdCA9IGZ1bmN0aW9uKHhocikge1xuICAgIHRoaXMucmVxcy5wdXNoKHhocik7XG59XG5cbkZldGNoUG9vbC5wcm90b3R5cGUuYWJvcnRBbGwgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmVxcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLnJlcXNbaV0uYWJvcnQoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIEtTQ2FjaGVCYXRvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgZmVhdHVyZXMsIHN0YXR1cywgY292ZXJhZ2UpIHtcbiAgICB0aGlzLmNociA9IGNocjtcbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgICB0aGlzLmNvdmVyYWdlID0gY292ZXJhZ2U7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcyB8fCBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbn1cblxuS1NDYWNoZUJhdG9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmNociArIFwiOlwiICsgdGhpcy5taW4gKyBcIi4uXCIgKyB0aGlzLm1heCArIFwiO3NjYWxlPVwiICsgdGhpcy5zY2FsZTtcbn1cblxuZnVuY3Rpb24gS25vd25TcGFjZSh0aWVyTWFwLCBjaHIsIG1pbiwgbWF4LCBzY2FsZSwgc2VxU291cmNlKSB7XG4gICAgdGhpcy50aWVyTWFwID0gdGllck1hcDtcbiAgICB0aGlzLmNociA9IGNocjtcbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5zZXFTb3VyY2UgPSBzZXFTb3VyY2UgfHwgbmV3IER1bW15U2VxdWVuY2VTb3VyY2UoKTtcbiAgICB0aGlzLnZpZXdDb3VudCA9IDA7XG5cbiAgICB0aGlzLmZlYXR1cmVDYWNoZSA9IHt9O1xuICAgIHRoaXMubGF0ZXN0Vmlld3MgPSB7fTtcbn1cblxuS25vd25TcGFjZS5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xufVxuXG5Lbm93blNwYWNlLnByb3RvdHlwZS5iZXN0Q2FjaGVPdmVybGFwcGluZyA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgpIHtcbiAgICB2YXIgYmF0b24gPSB0aGlzLmZlYXR1cmVDYWNoZVt0aGlzLnRpZXJNYXBbMF1dO1xuICAgIGlmIChiYXRvbikge1xuICAgICAgICByZXR1cm4gYmF0b247XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG5Lbm93blNwYWNlLnByb3RvdHlwZS52aWV3RmVhdHVyZXMgPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSkge1xuICAgIGlmIChzY2FsZSAhPSBzY2FsZSkge1xuICAgICAgICB0aHJvdyBcInZpZXdGZWF0dXJlcyBjYWxsZWQgd2l0aCBzaWxseSBzY2FsZVwiO1xuICAgIH1cblxuICAgIGlmIChjaHIgIT0gdGhpcy5jaHIpIHtcbiAgICAgICAgdGhyb3cgXCJDYW4ndCBleHRlbmQgS25vd24gU3BhY2UgdG8gYSBuZXcgY2hyb21vc29tZVwiO1xuICAgIH1cbiAgICBpZiAobWluIDwgMSkge1xuICAgICAgICBtaW4gPSAxO1xuICAgIH1cblxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcblxuICAgIGlmICh0aGlzLnBvb2wpIHtcbiAgICAgICAgdGhpcy5wb29sLmFib3J0QWxsKCk7XG4gICAgfVxuICAgIHRoaXMucG9vbCA9IG5ldyBGZXRjaFBvb2woKTtcbiAgICB0aGlzLmF3YWl0ZWRTZXEgPSBuZXcgQXdhaXRlZCgpO1xuICAgIHRoaXMuc2VxV2FzRmV0Y2hlZCA9IGZhbHNlO1xuICAgIHRoaXMudmlld0NvdW50Kys7XG4gICAgXG4gICAgdGhpcy5zdGFydEZldGNoZXNGb3JUaWVycyh0aGlzLnRpZXJNYXApO1xuICAgIHRoaXMucG9vbC5ub3RpZnlSZXF1ZXN0c0lzc3VlZCgpO1xufVxuICAgIFxuZnVuY3Rpb24gZmlsdGVyRmVhdHVyZXMoZmVhdHVyZXMsIG1pbiwgbWF4KSB7XG4gICAgdmFyIGZmID0gW107XG4gICAgdmFyIGZlYXR1cmVzQnlHcm91cCA9IHt9O1xuXG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZlYXR1cmVzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2ZpXTtcbiAgICAgICAgaWYgKCFmLm1pbiB8fCAhZi5tYXgpIHtcbiAgICAgICAgICAgIGZmLnB1c2goZik7XG4gICAgICAgIH0gZWxzZSBpZiAoZi5ncm91cHMgJiYgZi5ncm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcHVzaG8oZmVhdHVyZXNCeUdyb3VwLCBmLmdyb3Vwc1swXS5pZCwgZik7XG4gICAgICAgIH0gZWxzZSBpZiAoZi5taW4gPD0gbWF4ICYmIGYubWF4ID49IG1pbikge1xuICAgICAgICAgICAgZmYucHVzaChmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGdpZCBpbiBmZWF0dXJlc0J5R3JvdXApIHtcbiAgICAgICAgdmFyIGdmID0gZmVhdHVyZXNCeUdyb3VwW2dpZF07XG4gICAgICAgIHZhciBnbWluID0gMTAwMDAwMDAwMDAwLCBnbWF4ID0gLTEwMDAwMDAwMDAwMDtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGdmLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgdmFyIGYgPSBnZltmaV07XG4gICAgICAgICAgICBnbWluID0gTWF0aC5taW4oZ21pbiwgZi5taW4pO1xuICAgICAgICAgICAgZ21heCA9IE1hdGgubWF4KGdtYXgsIGYubWF4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ21pbiA8PSBtYXggfHwgZ21heCA+PSBtaW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBnZi5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICBmZi5wdXNoKGdmW2ZpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmY7XG59XG5cbktub3duU3BhY2UucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbih0aWVyKSB7XG4gICAgaWYgKCF0aGlzLnBvb2wpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmVhdHVyZUNhY2hlW3RpZXJdID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0RmV0Y2hlc0ZvclRpZXJzKFt0aWVyXSk7XG59XG5cbktub3duU3BhY2UucHJvdG90eXBlLnN0YXJ0RmV0Y2hlc0ZvclRpZXJzID0gZnVuY3Rpb24odGllcnMpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgdmFyIGF3YWl0ZWRTZXEgPSB0aGlzLmF3YWl0ZWRTZXE7XG4gICAgdmFyIG5lZWRTZXEgPSBmYWxzZTtcblxuICAgIHZhciBnZXg7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRpZXJzLmxlbmd0aDsgKyt0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydEZldGNoZXNGb3IodGllcnNbdF0sIGF3YWl0ZWRTZXEpKSB7XG4gICAgICAgICAgICAgICAgbmVlZFNlcSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB2YXIgdGllciA9IHRpZXJzW3RdO1xuICAgICAgICAgICAgdGllci5jdXJyZW50RmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIHRpZXIuY3VycmVudFNlcXVlbmNlID0gbnVsbDtcbiAgICAgICAgICAgIHRpZXIuZHJhdygpO1xuICAgICAgICAgICAgdGllci51cGRhdGVIZWlnaHQoKTtcbiAgICAgICAgICAgIHRpZXIudXBkYXRlU3RhdHVzKGV4KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBmZXRjaGluZyB0aWVyIHNvdXJjZScpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXgpO1xuICAgICAgICAgICAgZ2V4ID0gZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZFNlcSAmJiAhdGhpcy5zZXFXYXNGZXRjaGVkKSB7XG4gICAgICAgIHRoaXMuc2VxV2FzRmV0Y2hlZCA9IHRydWU7XG4gICAgICAgIHZhciBzbWluID0gdGhpcy5taW4sIHNtYXggPSB0aGlzLm1heDtcblxuICAgICAgICBpZiAodGhpcy5jcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3Muc3RhcnQgPD0gc21pbiAmJiB0aGlzLmNzLmVuZCA+PSBzbWF4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNhY2hlZFNlcTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jcy5zdGFydCA9PSBzbWluICYmIHRoaXMuY3MuZW5kID09IHNtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkU2VxID0gdGhpcy5jcztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWNoZWRTZXEgPSBuZXcgREFTU2VxdWVuY2UodGhpcy5jcy5uYW1lLCBzbWluLCBzbWF4LCB0aGlzLmNzLmFscGhhYmV0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3Muc2VxLnN1YnN0cmluZyhzbWluIC0gdGhpcy5jcy5zdGFydCwgc21heCArIDEgLSB0aGlzLmNzLnN0YXJ0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdGVkU2VxLnByb3ZpZGUoY2FjaGVkU2VxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXFTb3VyY2UuZmV0Y2godGhpcy5jaHIsIHNtaW4sIHNtYXgsIHRoaXMucG9vbCwgZnVuY3Rpb24oZXJyLCBzZXEpIHtcbiAgICAgICAgICAgIGlmIChzZXEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXNCLmNzIHx8IChzbWluIDw9IHRoaXNCLmNzLnN0YXJ0ICYmIHNtYXggPj0gdGhpc0IuY3MuZW5kKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgKHNtaW4gPj0gdGhpc0IuY3MuZW5kKSB8fCAoc21heCA8PSB0aGlzQi5jcy5zdGFydCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICgoc21heCAtIHNtaW4pID4gKHRoaXNCLmNzLmVuZCAtIHRoaXNCLmNzLnN0YXJ0KSkpIFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IuY3MgPSBzZXE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0ZWRTZXEucHJvdmlkZShzZXEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2VxdWVuY2UgbG9hZGluZyBmYWlsZWQnLCBlcnIpO1xuICAgICAgICAgICAgICAgIGF3YWl0ZWRTZXEucHJvdmlkZShudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBcblxuICAgIGlmIChnZXgpXG4gICAgICAgIHRocm93IGdleDtcbn1cblxuS25vd25TcGFjZS5wcm90b3R5cGUuc3RhcnRGZXRjaGVzRm9yID0gZnVuY3Rpb24odGllciwgYXdhaXRlZFNlcSkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG5cbiAgICB2YXIgdmlld0lEID0gdGhpcy52aWV3Q291bnQ7XG4gICAgdmFyIHNvdXJjZSA9IHRpZXIuZ2V0U291cmNlKCkgfHwgbmV3IER1bW15RmVhdHVyZVNvdXJjZSgpO1xuICAgIHZhciBuZWVkc1NlcSA9IHRpZXIubmVlZHNTZXF1ZW5jZSh0aGlzLnNjYWxlKTtcbiAgICB2YXIgYmF0b24gPSB0aGlzQi5mZWF0dXJlQ2FjaGVbdGllcl07XG4gICAgdmFyIHN0eWxlRmlsdGVycyA9IHRpZXIuZ2V0QWN0aXZlU3R5bGVGaWx0ZXJzKHRoaXMuc2NhbGUpO1xuICAgIHZhciB3YW50ZWRUeXBlcztcbiAgICBpZiAoc3R5bGVGaWx0ZXJzKVxuICAgICAgICB3YW50ZWRUeXBlcyA9IHN0eWxlRmlsdGVycy50eXBlTGlzdCgpO1xuICAgIHZhciBjaHIgPSB0aGlzLmNociwgbWluID0gdGhpcy5taW4sIG1heCA9IHRoaXMubWF4O1xuXG5cbiAgICBpZiAod2FudGVkVHlwZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYXRvbiAmJiBiYXRvbi5jaHIgPT09IHRoaXMuY2hyICYmIGJhdG9uLm1pbiA8PSBtaW4gJiYgYmF0b24ubWF4ID49IG1heCkge1xuICAgICAgICB2YXIgY2FjaGVkRmVhdHVyZXMgPSBiYXRvbi5mZWF0dXJlcztcbiAgICAgICAgaWYgKGJhdG9uLm1pbiA8IG1pbiB8fCBiYXRvbi5tYXggPiBtYXgpIHtcbiAgICAgICAgICAgIGNhY2hlZEZlYXR1cmVzID0gZmlsdGVyRmVhdHVyZXMoY2FjaGVkRmVhdHVyZXMsIG1pbiwgbWF4KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpc0IucHJvdmlzaW9uKHRpZXIsIGJhdG9uLmNociwgaW50ZXJzZWN0aW9uKGJhdG9uLmNvdmVyYWdlLCBuZXcgUmFuZ2UobWluLCBtYXgpKSwgYmF0b24uc2NhbGUsIHdhbnRlZFR5cGVzLCBjYWNoZWRGZWF0dXJlcywgYmF0b24uc3RhdHVzLCBuZWVkc1NlcSA/IGF3YWl0ZWRTZXEgOiBudWxsKTtcblxuICAgICAgICB2YXIgYXZhaWxhYmxlU2NhbGVzID0gc291cmNlLmdldFNjYWxlcygpO1xuICAgICAgICBpZiAoYmF0b24uc2NhbGUgPD0gdGhpcy5zY2FsZSB8fCAhYXZhaWxhYmxlU2NhbGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmVlZHNTZXE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc291cmNlLmluc3RydW1lbnQpXG4gICAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyAgZmV0Y2ggJyArIHZpZXdJRCArICcgKCcgKyBtaW4gKyAnLCAnICsgbWF4ICsgJyknKTtcbiAgICBzb3VyY2UuZmV0Y2goY2hyLCBtaW4sIG1heCwgdGhpcy5zY2FsZSwgd2FudGVkVHlwZXMsIHRoaXMucG9vbCwgZnVuY3Rpb24oc3RhdHVzLCBmZWF0dXJlcywgc2NhbGUsIGNvdmVyYWdlKSB7XG4gICAgXHRpZiAoc291cmNlLmluc3RydW1lbnQpXG4gICAgXHQgICAgY29uc29sZS5sb2coJ0ZpbmlzaGluZyBmZXRjaCAnICsgdmlld0lEKTtcblxuICAgIFx0dmFyIGxhdGVzdFZpZXdJRCA9IHRoaXNCLmxhdGVzdFZpZXdzW3RpZXJdIHx8IC0xO1xuICAgIFx0aWYgKHRoaXNCLmNhbmNlbGxlZCB8fCBsYXRlc3RWaWV3SUQgPiB2aWV3SUQpIHtcbiAgICBcdCAgICByZXR1cm47XG4gICAgXHR9XG5cbiAgICAgICAgaWYgKCFjb3ZlcmFnZSkge1xuICAgICAgICAgICAgY292ZXJhZ2UgPSBuZXcgUmFuZ2UobWluLCBtYXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFiYXRvbiB8fCAobWluIDwgYmF0b24ubWluKSB8fCAobWF4ID4gYmF0b24ubWF4KSkgeyAgICAgICAgIC8vIEZJWE1FIHNob3VsZCBiZSBtZXJnaW5nIGluIHNvbWUgY2FzZXM/XG4gICAgICAgICAgICB0aGlzQi5mZWF0dXJlQ2FjaGVbdGllcl0gPSBuZXcgS1NDYWNoZUJhdG9uKGNociwgbWluLCBtYXgsIHNjYWxlLCBmZWF0dXJlcywgc3RhdHVzLCBjb3ZlcmFnZSk7XG4gICAgICAgIH1cblxuXHQgICAgdGhpc0IubGF0ZXN0Vmlld3NbdGllcl0gPSB2aWV3SUQ7XG4gICAgICAgIHRoaXNCLnByb3Zpc2lvbih0aWVyLCBjaHIsIGNvdmVyYWdlLCBzY2FsZSwgd2FudGVkVHlwZXMsIGZlYXR1cmVzLCBzdGF0dXMsIG5lZWRzU2VxID8gYXdhaXRlZFNlcSA6IG51bGwpO1xuICAgIH0sIHN0eWxlRmlsdGVycyk7XG4gICAgcmV0dXJuIG5lZWRzU2VxO1xufVxuXG5Lbm93blNwYWNlLnByb3RvdHlwZS5wcm92aXNpb24gPSBmdW5jdGlvbih0aWVyLCBjaHIsIGNvdmVyYWdlLCBhY3R1YWxTY2FsZSwgd2FudGVkVHlwZXMsIGZlYXR1cmVzLCBzdGF0dXMsIGF3YWl0ZWRTZXEpIHtcbiAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHRpZXIuY3VycmVudEZlYXR1cmVzID0gW107XG4gICAgICAgIHRpZXIuY3VycmVudFNlcXVlbmNlID0gbnVsbDtcbiAgICAgICAgdGllci5kcmF3KCk7XG4gICAgICAgIHRpZXIudXBkYXRlSGVpZ2h0KCk7XG4gICAgfVxuICAgIHRpZXIudXBkYXRlU3RhdHVzKHN0YXR1cyk7XG4gICBcbiAgICBpZiAoIXN0YXR1cykge1xuICAgICAgICB2YXIgbWF5RG93bnNhbXBsZSA9IGZhbHNlO1xuICAgICAgICB2YXIgbmVlZEJhc2VDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgICAgICB2YXIgc3JjID0gdGllci5nZXRTb3VyY2UoKTtcbiAgICAgICAgd2hpbGUgKE1hcHBlZEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yoc3JjKSB8fCBDYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihzcmMpIHx8IE92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHNyYykpIHtcblx0ICAgICAgICBpZiAoT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yoc3JjKSkge1xuXHRcdCAgICAgICAgc3JjID0gc3JjLnNvdXJjZXNbMF07XG5cdCAgICAgICAgfSBlbHNlIHtcblx0XHQgICAgICAgIHNyYyA9IHNyYy5zb3VyY2U7XG5cdCAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChCV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHNyYykgfHwgUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihzcmMpIHx8IEJBTUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yoc3JjKSB8fCBSZW1vdGVCQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKHNyYykpIHtcbiAgICAgICAgICAgIG1heURvd25zYW1wbGUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICBcdGlmICghc3JjLm9wdHMgfHwgKCFzcmMub3B0cy5mb3JjZVJlZHVjdGlvbiAmJiAhc3JjLm9wdHMubm9Eb3duc2FtcGxlKSkge1xuICAgICAgICAgICAgaWYgKC8qIChhY3R1YWxTY2FsZSA8ICh0aGlzLnNjYWxlLzIpICYmIGZlYXR1cmVzLmxlbmd0aCA+IDIwMCkgIHx8ICovXG5cdFx0ICAgICAgICAobWF5RG93bnNhbXBsZSAmJiB3YW50ZWRUeXBlcyAmJiB3YW50ZWRUeXBlcy5sZW5ndGggPT0gMSAmJiB3YW50ZWRUeXBlcy5pbmRleE9mKCdkZW5zaXR5JykgPj0gMCkpXG4gICAgICAgICAgICB7XG5cdFx0ICAgICAgICBmZWF0dXJlcyA9IGRvd25zYW1wbGUoZmVhdHVyZXMsIHRoaXMuc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgIFx0fVxuXG4gICAgICAgIGlmICh3YW50ZWRUeXBlcyAmJiB3YW50ZWRUeXBlcy5sZW5ndGggPT0gMSAmJiB3YW50ZWRUeXBlcy5pbmRleE9mKCdiYXNlLWNvdmVyYWdlJykgPj0gMClcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gQmFzZS1jb21wb3NpdGlvbiBjb3ZlcmFnZSB0cmFja1xuICAgICAgICAgICAgbmVlZEJhc2VDb21wb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF3YWl0ZWRTZXEpIHtcbiAgICAgICAgICAgIGF3YWl0ZWRTZXEuYXdhaXQoZnVuY3Rpb24oc2VxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5lZWRCYXNlQ29tcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXMgPSBnZXRCYXNlQ292ZXJhZ2UoZmVhdHVyZXMsIHNlcSwgdGllci5icm93c2VyLmJhc2VDb2xvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aWVyLnZpZXdGZWF0dXJlcyhjaHIsIGNvdmVyYWdlLCBhY3R1YWxTY2FsZSwgZmVhdHVyZXMsIHNlcSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpZXIudmlld0ZlYXR1cmVzKGNociwgY292ZXJhZ2UsIGFjdHVhbFNjYWxlLCBmZWF0dXJlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgS25vd25TcGFjZTogS25vd25TcGFjZVxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDExXG4vL1xuLy8gbGgzdXRpbHMuanM6IGNvbW1vbiBzdXBwb3J0IGZvciBsaDMncyBmaWxlIGZvcm1hdHNcbi8vXG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGpzemxpYiA9IHJlcXVpcmUoJ2pzemxpYicpO1xuICAgIHZhciBqc3psaWJfaW5mbGF0ZV9idWZmZXIgPSBqc3psaWIuaW5mbGF0ZUJ1ZmZlcjtcbiAgICB2YXIgYXJyYXlDb3B5ID0ganN6bGliLmFycmF5Q29weTtcbn1cblxuZnVuY3Rpb24gVm9iKGIsIG8pIHtcbiAgICB0aGlzLmJsb2NrID0gYjtcbiAgICB0aGlzLm9mZnNldCA9IG87XG59XG5cblZvYi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLmJsb2NrICsgJzonICsgdGhpcy5vZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIHJlYWRWb2IoYmEsIG9mZnNldCkge1xuICAgIHZhciBibG9jayA9ICgoYmFbb2Zmc2V0KzZdICYgMHhmZikgKiAweDEwMDAwMDAwMCkgKyAoKGJhW29mZnNldCs1XSAmIDB4ZmYpICogMHgxMDAwMDAwKSArICgoYmFbb2Zmc2V0KzRdICYgMHhmZikgKiAweDEwMDAwKSArICgoYmFbb2Zmc2V0KzNdICYgMHhmZikgKiAweDEwMCkgKyAoKGJhW29mZnNldCsyXSAmIDB4ZmYpKTtcbiAgICB2YXIgYmludCA9IChiYVtvZmZzZXQrMV0gPDwgOCkgfCAoYmFbb2Zmc2V0XSk7XG4gICAgaWYgKGJsb2NrID09IDAgJiYgYmludCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAgLy8gU2hvdWxkIG9ubHkgaGFwcGVuIGluIHRoZSBsaW5lYXIgaW5kZXg/XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2IoYmxvY2ssIGJpbnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdW5iZ3pmKGRhdGEsIGxpbSkge1xuICAgIGxpbSA9IE1hdGgubWluKGxpbSB8fCAxLCBkYXRhLmJ5dGVMZW5ndGggLSA1MCk7XG4gICAgdmFyIG9CbG9ja0xpc3QgPSBbXTtcbiAgICB2YXIgcHRyID0gWzBdO1xuICAgIHZhciB0b3RhbFNpemUgPSAwO1xuXG4gICAgd2hpbGUgKHB0clswXSA8IGxpbSkge1xuICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShkYXRhLCBwdHJbMF0sIDEyKTsgLy8gRklYTUUgaXMgdGhpcyBlbm91Z2ggZm9yIGFsbCBjcmVkaWJsZSBCR1pGIGJsb2NrIGhlYWRlcnM/XG4gICAgICAgIHZhciB4bGVuID0gKGJhWzExXSA8PCA4KSB8IChiYVsxMF0pO1xuICAgICAgICAvLyBkbG9nKCd4bGVuWycgKyAocHRyWzBdKSArJ109JyArIHhsZW4pO1xuICAgICAgICB2YXIgdW5jID0ganN6bGliX2luZmxhdGVfYnVmZmVyKGRhdGEsIDEyICsgeGxlbiArIHB0clswXSwgTWF0aC5taW4oNjU1MzYsIGRhdGEuYnl0ZUxlbmd0aCAtIDEyIC0geGxlbiAtIHB0clswXSksIHB0cik7XG4gICAgICAgIHB0clswXSArPSA4O1xuICAgICAgICB0b3RhbFNpemUgKz0gdW5jLmJ5dGVMZW5ndGg7XG4gICAgICAgIG9CbG9ja0xpc3QucHVzaCh1bmMpO1xuICAgIH1cblxuICAgIGlmIChvQmxvY2tMaXN0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJldHVybiBvQmxvY2tMaXN0WzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xuICAgICAgICB2YXIgY3Vyc29yID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5ldyBVaW50OEFycmF5KG9CbG9ja0xpc3RbaV0pO1xuICAgICAgICAgICAgYXJyYXlDb3B5KGIsIDAsIG91dCwgY3Vyc29yLCBiLmxlbmd0aCk7XG4gICAgICAgICAgICBjdXJzb3IgKz0gYi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dC5idWZmZXI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBDaHVuayhtaW52LCBtYXh2KSB7XG4gICAgdGhpcy5taW52ID0gbWludjsgdGhpcy5tYXh2ID0gbWF4djtcbn1cblxuXG4vL1xuLy8gQmlubmluZyAodHJhbnNsaXRlcmF0ZWQgZnJvbSBTQU0xLjMgc3BlYylcbi8vXG5cbi8qIGNhbGN1bGF0ZSBiaW4gZ2l2ZW4gYW4gYWxpZ25tZW50IGNvdmVyaW5nIFtiZWcsZW5kKSAoemVyby1iYXNlZCwgaGFsZi1jbG9zZS1oYWxmLW9wZW4pICovXG5mdW5jdGlvbiByZWcyYmluKGJlZywgZW5kKVxue1xuICAgIC0tZW5kO1xuICAgIGlmIChiZWc+PjE0ID09IGVuZD4+MTQpIHJldHVybiAoKDE8PDE1KS0xKS83ICsgKGJlZz4+MTQpO1xuICAgIGlmIChiZWc+PjE3ID09IGVuZD4+MTcpIHJldHVybiAoKDE8PDEyKS0xKS83ICsgKGJlZz4+MTcpO1xuICAgIGlmIChiZWc+PjIwID09IGVuZD4+MjApIHJldHVybiAoKDE8PDkpLTEpLzcgKyAoYmVnPj4yMCk7XG4gICAgaWYgKGJlZz4+MjMgPT0gZW5kPj4yMykgcmV0dXJuICgoMTw8NiktMSkvNyArIChiZWc+PjIzKTtcbiAgICBpZiAoYmVnPj4yNiA9PSBlbmQ+PjI2KSByZXR1cm4gKCgxPDwzKS0xKS83ICsgKGJlZz4+MjYpO1xuICAgIHJldHVybiAwO1xufVxuXG4vKiBjYWxjdWxhdGUgdGhlIGxpc3Qgb2YgYmlucyB0aGF0IG1heSBvdmVybGFwIHdpdGggcmVnaW9uIFtiZWcsZW5kKSAoemVyby1iYXNlZCkgKi9cbnZhciBNQVhfQklOID0gKCgoMTw8MTgpLTEpLzcpO1xuZnVuY3Rpb24gcmVnMmJpbnMoYmVnLCBlbmQpIFxue1xuICAgIHZhciBpID0gMCwgaywgbGlzdCA9IFtdO1xuICAgIC0tZW5kO1xuICAgIGxpc3QucHVzaCgwKTtcbiAgICBmb3IgKGsgPSAxICsgKGJlZz4+MjYpOyBrIDw9IDEgKyAoZW5kPj4yNik7ICsraykgbGlzdC5wdXNoKGspO1xuICAgIGZvciAoayA9IDkgKyAoYmVnPj4yMyk7IGsgPD0gOSArIChlbmQ+PjIzKTsgKytrKSBsaXN0LnB1c2goayk7XG4gICAgZm9yIChrID0gNzMgKyAoYmVnPj4yMCk7IGsgPD0gNzMgKyAoZW5kPj4yMCk7ICsraykgbGlzdC5wdXNoKGspO1xuICAgIGZvciAoayA9IDU4NSArIChiZWc+PjE3KTsgayA8PSA1ODUgKyAoZW5kPj4xNyk7ICsraykgbGlzdC5wdXNoKGspO1xuICAgIGZvciAoayA9IDQ2ODEgKyAoYmVnPj4xNCk7IGsgPD0gNDY4MSArIChlbmQ+PjE0KTsgKytrKSBsaXN0LnB1c2goayk7XG4gICAgcmV0dXJuIGxpc3Q7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgdW5iZ3pmOiB1bmJnemYsXG4gICAgICAgIHJlYWRWb2I6IHJlYWRWb2IsXG4gICAgICAgIHJlZzJiaW46IHJlZzJiaW4sXG4gICAgICAgIHJlZzJiaW5zOiByZWcyYmlucyxcbiAgICAgICAgQ2h1bms6IENodW5rXG4gICAgfTtcbn0iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE0XG4vL1xuLy8gbWVtc3RvcmUuanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzYSA9IHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTtcbiAgICB2YXIgZGFsbGlhbmNlX3JlZ2lzdGVyU291cmNlQWRhcHRlckZhY3RvcnkgPSBzYS5yZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5O1xuICAgIHZhciBkYWxsaWFuY2VfbWFrZVBhcnNlciA9IHNhLm1ha2VQYXJzZXI7XG4gICAgdmFyIEZlYXR1cmVTb3VyY2VCYXNlID0gc2EuRmVhdHVyZVNvdXJjZUJhc2U7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU3R5bGVzaGVldCA9IGRhcy5EQVNTdHlsZXNoZWV0O1xuICAgIHZhciBEQVNTdHlsZSA9IGRhcy5EQVNTdHlsZTtcbiAgICB2YXIgREFTRmVhdHVyZSA9IGRhcy5EQVNGZWF0dXJlO1xuICAgIHZhciBEQVNHcm91cCA9IGRhcy5EQVNHcm91cDtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgQXdhaXRlZCA9IHV0aWxzLkF3YWl0ZWQ7XG4gICAgdmFyIHRleHRYSFIgPSB1dGlscy50ZXh0WEhSO1xufVxuXG5mdW5jdGlvbiBNZW1TdG9yZSgpIHtcbiAgICB0aGlzLmZlYXR1cmVzQnlDaHIgPSB7fTtcbiAgICB0aGlzLm1heExlbmd0aCA9IDE7XG4gICAgdGhpcy5jaHJSaW5nID0gbnVsbDtcbn1cblxuTWVtU3RvcmUucHJvdG90eXBlLmFkZEZlYXR1cmVzID0gZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICB2YXIgZGlydHkgPSB7fTtcbiAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHZhciBmID0gZmVhdHVyZXNbZmldO1xuICAgICAgICB2YXIgY2hyID0gZi5zZWdtZW50IHx8IGYuY2hyO1xuICAgICAgICB2YXIgZmEgPSB0aGlzLmZlYXR1cmVzQnlDaHJbY2hyXTtcbiAgICAgICAgaWYgKCFmYSkge1xuICAgICAgICAgICAgZmEgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNCeUNocltjaHJdID0gZmE7XG4gICAgICAgIH1cbiAgICAgICAgZmEucHVzaChmKTtcbiAgICAgICAgZGlydHlbY2hyXSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGxlbiA9IGYubWF4IC0gZi5taW4gKyAxO1xuICAgICAgICBpZiAobGVuID4gdGhpcy5tYXhMZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm1heExlbmd0aCA9IGxlbjtcbiAgICB9XG5cbiAgICBmb3IgKGNociBpbiBkaXJ0eSkge1xuICAgICAgICB2YXIgZmEgPSB0aGlzLmZlYXR1cmVzQnlDaHJbY2hyXTtcbiAgICAgICAgZmEuc29ydChmdW5jdGlvbihmMSwgZjIpIHtcbiAgICAgICAgICAgIHZhciBkID0gZjEubWluIC0gZjIubWluO1xuICAgICAgICAgICAgaWYgKGQgIT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIHJldHVybiBmMS5tYXggLSBmMi5tYXg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNoclJpbmcgPSBudWxsO1xufVxuXG5NZW1TdG9yZS5wcm90b3R5cGUuX2luZGV4Rm9yID0gZnVuY3Rpb24oZmEsIHApIHtcbiAgICB2YXIgbGIgPSAwLCB1YiA9IGZhLmxlbmd0aDtcbiAgICB3aGlsZSAodWIgPiBsYikge1xuICAgICAgICB2YXIgbWlkID0gKChsYiArIHViKS8yKXwwO1xuICAgICAgICBpZiAobWlkID49IGZhLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYS5sZW5ndGg7XG4gICAgICAgIHZhciBtZyA9IGZhW21pZF07XG4gICAgICAgIGlmIChwIDwgbWcubWluKSB7XG4gICAgICAgICAgICB1YiA9IG1pZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxiID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdWI7XG59XG5cbk1lbVN0b3JlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgpIHtcbiAgICB2YXIgZmEgPSB0aGlzLmZlYXR1cmVzQnlDaHJbY2hyXTtcbiAgICBpZiAoIWZhKSB7XG4gICAgICAgIGlmIChjaHIuaW5kZXhPZignY2hyJykgPT0gMClcbiAgICAgICAgICAgIGZhID0gdGhpcy5mZWF0dXJlc0J5Q2hyW2Noci5zdWJzdHJpbmcoMyldO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmYSA9IHRoaXMuZmVhdHVyZXNCeUNoclsnY2hyJyArIGNocl07XG4gICAgfVxuICAgIGlmICghZmEpXG4gICAgICAgIHJldHVybiBbXTtcblxuICAgIHZhciBtaW5pID0gTWF0aC5tYXgoMCwgdGhpcy5faW5kZXhGb3IoZmEsIG1pbiAtIHRoaXMubWF4TGVuZ3RoIC0gMSkpO1xuICAgIHZhciBtYXhpID0gTWF0aC5taW4oZmEubGVuZ3RoIC0gMSwgdGhpcy5faW5kZXhGb3IoZmEsIG1heCkpO1xuXG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGZpID0gbWluaTsgZmkgPD0gbWF4aTsgKytmaSkge1xuICAgICAgICB2YXIgZiA9IGZhW2ZpXTtcbiAgICAgICAgaWYgKGYubWluIDw9IG1heCAmJiBmLm1heCA+PSBtaW4pXG4gICAgICAgICAgICByZXMucHVzaChmKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuTWVtU3RvcmUucHJvdG90eXBlLmZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIpIHtcbiAgICBpZiAodGhpcy5jaHJSaW5nID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaHJSaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGNociBpbiB0aGlzLmZlYXR1cmVzQnlDaHIpIHtcbiAgICAgICAgICAgIHRoaXMuY2hyUmluZy5wdXNoKGNocik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaHJSaW5nLnNvcnQoKTtcbiAgICB9XG5cbiAgICB2YXIgZmEgPSB0aGlzLmZlYXR1cmVzQnlDaHJbY2hyXTtcbiAgICBpZiAoIWZhKSB7XG4gICAgICAgIGlmIChjaHIuaW5kZXhPZignY2hyJykgPT0gMCkge1xuICAgICAgICAgICAgY2hyID0gY2hyLnN1YnN0cmluZygzKTtcbiAgICAgICAgICAgIGZhID0gdGhpcy5mZWF0dXJlc0J5Q2hyW2Nocl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSAnY2hyJyArIGNocjtcbiAgICAgICAgICAgIGZhID0gdGhpcy5mZWF0dXJlc0J5Q2hyW2Nocl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmYSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuX2luZGV4Rm9yKGZhLCBwb3MpLCBmYS5sZW5ndGggLSAxKSk7XG4gICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgd2hpbGUgKGkgPCBmYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmFbaSsrXTtcbiAgICAgICAgICAgIGlmIChmLm1pbiA+IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hySW5kID0gdGhpcy5jaHJSaW5nLmluZGV4T2YoY2hyKSArIDE7XG4gICAgICAgIGlmIChjaHJJbmQgPj0gdGhpcy5jaHJSaW5nLmxlbmd0aClcbiAgICAgICAgICAgIGNockluZCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmROZXh0RmVhdHVyZSh0aGlzLmNoclJpbmdbY2hySW5kXSwgMCwgZGlyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgICAgICB2YXIgZiA9IGZhW2ktLV07XG4gICAgICAgICAgICBpZiAoZi5tYXggPCBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNockluZCA9IHRoaXMuY2hyUmluZy5pbmRleE9mKGNocikgLSAxO1xuICAgICAgICBpZiAoY2hySW5kIDwgMClcbiAgICAgICAgICAgIGNockluZCA9IHRoaXMuY2hyUmluZy5sZW5ndGggLSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kTmV4dEZlYXR1cmUodGhpcy5jaHJSaW5nW2NockluZF0sIDEwMDAwMDAwMDAwLCBkaXIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gTWVtU3RvcmVGZWF0dXJlU291cmNlKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIEZlYXR1cmVTb3VyY2VCYXNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5zdG9yZUhvbGRlciA9IG5ldyBBd2FpdGVkKCk7XG4gICAgdGhpcy5wYXJzZXIgPSBkYWxsaWFuY2VfbWFrZVBhcnNlcihzb3VyY2UucGF5bG9hZCk7XG4gICAgaWYgKCF0aGlzLnBhcnNlcikge1xuICAgICAgICB0aHJvdyBcIlVuc3VwcG9ydGVkIG1lbXN0b3JlIHBheWxvYWQ6IFwiICsgc291cmNlLnBheWxvYWQ7XG4gICAgfVxuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLl9sb2FkKGZ1bmN0aW9uKHJlc3AsIGVycikge1xuICAgICAgICBpZiAoIXJlc3ApIHtcbiAgICAgICAgICAgIHRoaXNCLmVycm9yID0gZXJyIHx8IFwiTm8gZGF0YVwiXG4gICAgICAgICAgICB0aGlzQi5zdG9yZUhvbGRlci5wcm92aWRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gbmV3IE1lbVN0b3JlKCk7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBsaW5lcyA9IHJlc3Auc3BsaXQoJ1xcbicpO1xuXG4gICAgICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXNCLnBhcnNlci5jcmVhdGVTZXNzaW9uKGZ1bmN0aW9uKGYpIHtmZWF0dXJlcy5wdXNoKGYpfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgbGluZXMubGVuZ3RoOyArK2xpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsaV07XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLnBhcnNlKGxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlc3Npb24uZmx1c2goKTtcblxuICAgICAgICAgICAgc3RvcmUuYWRkRmVhdHVyZXMoZmVhdHVyZXMpO1xuXG4gICAgICAgICAgICB0aGlzQi5zdG9yZUhvbGRlci5wcm92aWRlKHN0b3JlKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5NZW1TdG9yZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUpO1xuXG5NZW1TdG9yZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLl9sb2FkID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zb3VyY2UuYmxvYikge1xuICAgICAgICB2YXIgciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soci5yZXN1bHQsIHIuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHIucmVhZEFzVGV4dCh0aGlzLnNvdXJjZS5ibG9iKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UuY3JlZGVudGlhbHMpXG4gICAgICAgICAgICB2YXIgb3B0cyA9IHtjcmVkZW50aWFscyA6IHRoaXMuc291cmNlLmNyZWRlbnRpYWxzfTtcbiAgICAgICAgdGV4dFhIUih0aGlzLnNvdXJjZS51cmksIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9XG59XG5cbk1lbVN0b3JlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNudCkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy5zdG9yZUhvbGRlci5hd2FpdChmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHZhciBmID0gc3RvcmUuZmV0Y2goY2hyLCBtaW4sIG1heCk7XG4gICAgICAgICAgICByZXR1cm4gY250KG51bGwsIGYsIDEwMDAwMDAwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY250KHRoaXNCLmVycm9yKVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbk1lbVN0b3JlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyICYmIHRoaXMucGFyc2VyLmdldFN0eWxlU2hlZXQpXG4gICAgICAgIHRoaXMucGFyc2VyLmdldFN0eWxlU2hlZXQoY2FsbGJhY2spXG59XG5cbk1lbVN0b3JlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZJUHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnBhcnNlciAmJiB0aGlzLnBhcnNlci5nZXREZWZhdWx0RklQcylcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0RGVmYXVsdEZJUHMoY2FsbGJhY2spO1xufVxuXG5NZW1TdG9yZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFNjYWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAxMDAwMDAwMDA7XG59XG5cbk1lbVN0b3JlRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmluZE5leHRGZWF0dXJlID0gZnVuY3Rpb24oY2hyLCBwb3MsIGRpciwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuc3RvcmVIb2xkZXIuYXdhaXQoZnVuY3Rpb24oc3RvcmUpIHtcbiAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soc3RvcmUuZmluZE5leHRGZWF0dXJlKGNociwgcG9zLCBkaXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0aGlzQi5lcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuXG5NZW1TdG9yZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmNhcGFiaWxpdGllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYXBzID0ge2xlYXA6IHRydWV9O1xuICAgIHJldHVybiBjYXBzO1xufVxuXG5kYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSgnbWVtc3RvcmUnLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICByZXR1cm4ge2ZlYXR1cmVzOiBuZXcgTWVtU3RvcmVGZWF0dXJlU291cmNlKHNvdXJjZSl9O1xufSk7XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE0XG4vL1xuLy8gbWVtc3RvcmUuanNcbi8vXG5cbmZ1bmN0aW9uIGZvcm1hdExvbmdJbnQobikge1xuICAgIHJldHVybiAobnwwKS50b1N0cmluZygpLnJlcGxhY2UoL1xcQig/PShcXGR7M30pKyg/IVxcZCkpL2csICcsJylcbn1cblxuZnVuY3Rpb24gZm9ybWF0UXVhbnRMYWJlbCh2KSB7XG4gICAgdmFyIHQgPSAnJyArIHY7XG4gICAgdmFyIGRvdCA9IHQuaW5kZXhPZignLicpO1xuICAgIGlmIChkb3QgPCAwKSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkb3RUaHJlc2hvbGQgPSAyO1xuICAgICAgICBpZiAodC5zdWJzdHJpbmcoMCwgMSkgPT0gJy0nKSB7XG4gICAgICAgICAgICArK2RvdFRocmVzaG9sZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb3QgPj0gZG90VGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXR1cm4gdC5zdWJzdHJpbmcoMCwgZG90KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0LnN1YnN0cmluZygwLCBkb3QgKyAyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBmb3JtYXRMb25nSW50OiBmb3JtYXRMb25nSW50LFxuICAgICAgICBmb3JtYXRRdWFudExhYmVsOiBmb3JtYXRRdWFudExhYmVsXG4gICAgfTtcbn0iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gb3ZlcmxheS5qczogZmVhdHVyZXNvdXJjZXMgY29tcG9zZWQgZnJvbSBtdWx0aXBsZSB1bmRlcmx5aW5nIHNvdXJjZXNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcbiAgICB2YXIgYXJyYXlJbmRleE9mID0gdXRpbHMuYXJyYXlJbmRleE9mO1xufVxuXG5mdW5jdGlvbiBPdmVybGF5RmVhdHVyZVNvdXJjZShzb3VyY2VzLCBvcHRzKSB7XG4gICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICB0aGlzLm9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5idXNpbmVzcyA9IFtdO1xuICAgIHRoaXMucmVhZGluZXNzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmluaXROKGkpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Yob3B0cy5tZXJnZSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5tZXJnZSA9IG9wdHMubWVyZ2U7XG4gICAgfSBlbHNlIGlmIChvcHRzLm1lcmdlID09ICdjb25jYXQnKSB7XG4gICAgICAgIHRoaXMubWVyZ2UgPSBPdmVybGF5RmVhdHVyZVNvdXJjZV9tZXJnZV9jb25jYXQ7XG4gICAgfSBlbHNlIGlmIChvcHRzLm1lcmdlID09ICdhbHRlcm5hdGVzJykge1xuICAgICAgICB0aGlzLm1lcmdlID0gT3ZlcmxheUZlYXR1cmVTb3VyY2VfbWVyZ2VfY29uY2F0O1xuICAgICAgICB0aGlzLmZpbHRlckRpc3BhdGNoT25NZXRob2QgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWVyZ2UgPSBPdmVybGF5RmVhdHVyZVNvdXJjZV9tZXJnZV9ieUtleTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5pbml0TiA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgcyA9IHRoaXMuc291cmNlc1tuXTtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuYnVzaW5lc3Nbbl0gPSAwO1xuXG4gICAgaWYgKHMuYWRkQWN0aXZpdHlMaXN0ZW5lcikge1xuICAgICAgICBzLmFkZEFjdGl2aXR5TGlzdGVuZXIoZnVuY3Rpb24oYikge1xuICAgICAgICAgICAgdGhpc0IuYnVzaW5lc3Nbbl0gPSBiO1xuICAgICAgICAgICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzLmFkZENoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIHMuYWRkQ2hhbmdlTGlzdGVuZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlDaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzLmFkZFJlYWRpbmVzc0xpc3RlbmVyKSB7XG4gICAgICAgIHMuYWRkUmVhZGluZXNzTGlzdGVuZXIoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgdGhpc0IucmVhZGluZXNzW25dID0gcjtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeVJlYWRpbmVzcygpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5hZGRSZWFkaW5lc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycy5wdXNoKGwpO1xuICAgIHRoaXMubm90aWZ5UmVhZGluZXNzTGlzdGVuZXIobCk7XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5yZW1vdmVSZWFkaW5lc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMucmVhZGluZXNzTGlzdGVuZXJzLCBsKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5yZWFkaW5lc3NMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUubm90aWZ5UmVhZGluZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLm5vdGlmeVJlYWRpbmVzc0xpc3RlbmVyKHRoaXMucmVhZGluZXNzTGlzdGVuZXJzW2ldKTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5ub3RpZnlSZWFkaW5lc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgciA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlYWRpbmVzcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5yZWFkaW5lc3NbaV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgciA9IHRoaXMucmVhZGluZXNzW2ldOyBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBsKHIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgfVxufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuYWRkQWN0aXZpdHlMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgICB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLnB1c2gobCk7XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIHZhciBpZHggPSBhcnJheUluZGV4T2YodGhpcy5hY3Rpdml0eUxpc3RlbmVycywgbCk7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUubm90aWZ5QWN0aXZpdHkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYnVzeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1c2luZXNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1c3kgKz0gdGhpcy5idXNpbmVzc1tpXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgdGhpcy5hY3Rpdml0eUxpc3RlbmVycy5sZW5ndGg7ICsrbGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnNbbGldKGJ1c3kpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmFkZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnJlbW92ZUNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIHZhciBpZHggPSBhcnJheUluZGV4T2YodGhpcy5jaGFuZ2VMaXN0ZW5lcnMsIGwpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgdGhpcy5jaGFuZ2VMaXN0ZW5lcnMubGVuZ3RoOyArK2xpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZUxpc3RlbmVyc1tsaV0odGhpcy5idXN5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzWzBdLmdldFNjYWxlcygpO1xufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc1swXS5nZXRTdHlsZVNoZWV0KGNhbGxiYWNrKTtcbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmNhcGFiaWxpdGllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYXBzID0ge307XG4gICAgdmFyIHMwID0gdGhpcy5zb3VyY2VzWzBdO1xuICAgIGlmIChzMC5jYXBhYmlsaXRpZXMpIFxuICAgICAgICBjYXBzID0gc2hhbGxvd0NvcHkoczAuY2FwYWJpbGl0aWVzKCkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHNpID0gdGhpcy5zb3VyY2VzW2ldO1xuICAgICAgICBpZiAoc2kuY2FwYWJpbGl0aWVzKSB7XG4gICAgICAgICAgICB2YXIgY28gPSBzaS5jYXBhYmlsaXRpZXMoKTtcbiAgICAgICAgICAgIGlmIChjby5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICBjYXBzLnNlYXJjaCA9IGNvLnNlYXJjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjYXBzO1xufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKF9zb3VyY2VBZGFwdGVySXNDYXBhYmxlKHRoaXMuc291cmNlc1tpXSwgJ3NlYXJjaCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VzW2ldLnNlYXJjaChxdWVyeSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrLCBzdHlsZUZpbHRlcnMpIHtcbiAgICB2YXIgc291cmNlcztcbiAgICBpZiAodGhpcy5maWx0ZXJEaXNwYXRjaE9uTWV0aG9kKSB7XG4gICAgICAgIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdmFyIHNmbCA9IHN0eWxlRmlsdGVycy5saXN0KCk7XG4gICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2VzW3NpXTtcbiAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBzZmwubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpbHRlciA9IHNmbFtmaV07XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIubWV0aG9kIHx8IGZpbHRlci5tZXRob2QgPT0gc291cmNlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZXMgPSB0aGlzLnNvdXJjZXM7XG4gICAgfVxuXG4gICAgdmFyIGJhdG9uID0gbmV3IE92ZXJsYXlCYXRvbih0aGlzLCBjYWxsYmFjaywgc291cmNlcyk7XG4gICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNvdXJjZXMubGVuZ3RoOyArK3NpKSB7XG5cdCAgIHRoaXMuZmV0Y2hOKGJhdG9uLCBzaSwgc291cmNlc1tzaV0sIGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgc3R5bGVGaWx0ZXJzKTtcbiAgICB9XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5mZXRjaE4gPSBmdW5jdGlvbihiYXRvbiwgc2ksIHNvdXJjZSwgY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBzdHlsZUZpbHRlcnMpIHtcbiAgICAvLyBGSVhNRSBzaG91bGQgd2UgdHJ5IHRvIHBydW5lIHN0eWxlRmlsdGVycz9cbiAgICBzb3VyY2UuZmV0Y2goY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBmdW5jdGlvbihzdGF0dXMsIGZlYXR1cmVzLCBzY2FsZSkge1xuXHQgICByZXR1cm4gYmF0b24uY29tcGxldGVkKHNpLCBzdGF0dXMsIGZlYXR1cmVzLCBzY2FsZSk7XG4gICAgfSwgc3R5bGVGaWx0ZXJzKTtcbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnF1YW50RmluZE5leHRGZWF0dXJlID0gZnVuY3Rpb24oY2hyLCBwb3MsIGRpciwgdGhyZXNob2xkLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZXNbMF0ucXVhbnRGaW5kTmV4dEZlYXR1cmUoY2hyLCBwb3MsIGRpciwgdGhyZXNob2xkLCBjYWxsYmFjayk7XG59XG5cbk92ZXJsYXlGZWF0dXJlU291cmNlLnByb3RvdHlwZS5maW5kTmV4dEZlYXR1cmUgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZXNbMF0uZmluZE5leHRGZWF0dXJlKGNociwgcG9zLCBkaXIsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gT3ZlcmxheUJhdG9uKHNvdXJjZSwgY2FsbGJhY2ssIHNvdXJjZXMpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5zb3VyY2VzID0gc291cmNlcztcbiAgICB0aGlzLmNvdW50ID0gc291cmNlcy5sZW5ndGg7XG5cbiAgICB0aGlzLnJldHVybkNvdW50ID0gMDtcbiAgICB0aGlzLnN0YXR1c0NvdW50ID0gMDtcbiAgICB0aGlzLnJldHVybnMgPSBbXTtcbiAgICB0aGlzLmZlYXR1cmVzID0gW11cbiAgICB0aGlzLnN0YXR1c2VzID0gW107XG4gICAgdGhpcy5zY2FsZSA9IG51bGw7XG59XG5cbk92ZXJsYXlCYXRvbi5wcm90b3R5cGUuY29tcGxldGVkID0gZnVuY3Rpb24oaW5kZXgsIHN0YXR1cywgZmVhdHVyZXMsIHNjYWxlKSB7XG4gICAgaWYgKHRoaXMuc2NhbGUgPT0gbnVsbCB8fCBpbmRleCA9PSAwKSBcblx0ICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuXG4gICAgaWYgKHRoaXMucmV0dXJuc1tpbmRleF0pXG5cdCAgIHRocm93ICdNdWx0aXBsZSByZXR1cm5zIGZvciBzb3VyY2UgJyArIGluZGV4O1xuXG4gICAgdGhpcy5yZXR1cm5zW2luZGV4XSA9IHRydWU7XG4gICAgdGhpcy5yZXR1cm5Db3VudCsrO1xuXG4gICAgdGhpcy5mZWF0dXJlc1tpbmRleF0gPSBmZWF0dXJlcztcblxuICAgIGlmIChzdGF0dXMpIHtcbiAgICBcdHRoaXMuc3RhdHVzZXNbaW5kZXhdID0gc3RhdHVzO1xuICAgIFx0dGhpcy5zdGF0dXNDb3VudCsrO1xuICAgIH1cblxuXG4gICAgaWYgKHRoaXMucmV0dXJuQ291bnQgPT0gdGhpcy5jb3VudCkge1xuICAgIFx0aWYgKHRoaXMuc3RhdHVzQ291bnQgPiAwKSB7XG4gICAgXHQgICAgdmFyIG1lc3NhZ2UgPSAnJztcbiAgICBcdCAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgdGhpcy5jb3VudDsgKytzaSkge1xuICAgICAgICBcdFx0dmFyIHMgPSB0aGlzLnN0YXR1c2VzW3NpXTtcbiAgICAgICAgXHRcdGlmIChzKSB7XG4gICAgICAgIFx0XHQgICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gMCkgXG4gICAgICAgIFx0XHRcdG1lc3NhZ2UgKz0gJywgJztcbiAgICAgICAgXHRcdCAgICBtZXNzYWdlICs9IHM7XG4gICAgICAgIFx0XHR9XG4gICAgXHQgICAgfVxuICAgIFx0ICAgIHJldHVybiB0aGlzLmNhbGxiYWNrKG1lc3NhZ2UsIG51bGwsIHRoaXMuc2NhbGUpO1xuICAgIFx0fSBlbHNlIHtcbiAgICBcdCAgICB0aGlzLmNhbGxiYWNrKG51bGwsIHRoaXMuc291cmNlLm1lcmdlKHRoaXMuZmVhdHVyZXMsIHRoaXMuc291cmNlcyksIHRoaXMuc2NhbGUpO1xuICAgIFx0fVxuICAgIH1cbn1cblxuT3ZlcmxheUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldERlZmF1bHRGSVBzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgdGhpcy5zb3VyY2VzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICB2YXIgcyA9IHRoaXMuc291cmNlc1tzaV07XG4gICAgICAgIGlmIChzLmdldERlZmF1bHRGSVBzKVxuICAgICAgICAgICAgcy5nZXREZWZhdWx0RklQcyhjYWxsYmFjayk7XG4gICAgfVxufVxuXG5PdmVybGF5RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUua2V5Rm9yRmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICByZXR1cm4gJycgKyBmZWF0dXJlLm1pbiArICcuLicgKyBmZWF0dXJlLm1heDtcbn1cblxuZnVuY3Rpb24gT3ZlcmxheUZlYXR1cmVTb3VyY2VfbWVyZ2VfYnlLZXkoZmVhdHVyZVNldHMpIHtcbiAgICB2YXIgb21hcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGZzaSA9IDE7IGZzaSA8IGZlYXR1cmVTZXRzLmxlbmd0aDsgKytmc2kpIHtcbiAgICAgICAgdmFyIG9tID0ge307XG4gICAgICAgIHZhciBvZiA9IGZlYXR1cmVTZXRzW2ZzaV07XG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBvZi5sZW5ndGg7ICsrZmkpIHtcbiAgICBcdCAgIG9tW3RoaXMua2V5Rm9yRmVhdHVyZShvZltmaV0pXSA9IG9mW2ZpXTtcbiAgICAgICAgfVxuICAgICAgICBvbWFwcy5wdXNoKG9tKTtcbiAgICB9XG5cblxuICAgIHZhciBtZiA9IFtdO1xuICAgIHZhciBmbCA9IGZlYXR1cmVTZXRzWzBdO1xuICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmbC5sZW5ndGg7ICsrZmkpIHtcbiAgICBcdHZhciBmID0gZmxbZmldO1xuXG4gICAgICAgIGZvciAodmFyIG9pID0gMDsgb2kgPCBvbWFwcy5sZW5ndGg7ICsrb2kpIHtcbiAgICAgICAgICAgIHZhciBvbSA9IG9tYXBzW29pXTtcbiAgICAgICAgXHRvZiA9IG9tW3RoaXMua2V5Rm9yRmVhdHVyZShmKV1cbiAgICAgICAgXHRpZiAob2YpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIG9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrID09PSAnc2NvcmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnNjb3JlMiA9IG9mLnNjb3JlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGsgPT09ICdtaW4nIHx8IGsgPT09ICdtYXgnIHx8IGsgPT09ICdzZWdtZW50JyB8fCBrID09PSAnX2NhY2hlZFN0eWxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZltrXSA9IG9mW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBcdH1cbiAgICAgICAgfVxuICAgIFx0bWYucHVzaChmKTtcbiAgICB9XG4gICAgcmV0dXJuIG1mO1xufVxuXG5mdW5jdGlvbiBPdmVybGF5RmVhdHVyZVNvdXJjZV9tZXJnZV9jb25jYXQoZmVhdHVyZVNldHMsIHNvdXJjZXMpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICBmb3IgKHZhciBmc2kgPSAwOyBmc2kgPCBmZWF0dXJlU2V0cy5sZW5ndGg7ICsrZnNpKSB7XG4gICAgICAgIHZhciBmcyA9IGZlYXR1cmVTZXRzW2ZzaV07XG4gICAgICAgIHZhciBuYW1lID0gc291cmNlc1tmc2ldLm5hbWU7XG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgIHZhciBmID0gZnNbZmldO1xuICAgICAgICAgICAgZi5tZXRob2QgPSBuYW1lO1xuICAgICAgICAgICAgZmVhdHVyZXMucHVzaChmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIF9zb3VyY2VBZGFwdGVySXNDYXBhYmxlKHMsIGNhcCkge1xuICAgIGlmICghcy5jYXBhYmlsaXRpZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBlbHNlIFxuICAgICAgICByZXR1cm4gcy5jYXBhYmlsaXRpZXMoKVtjYXBdO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIE92ZXJsYXlGZWF0dXJlU291cmNlOiBPdmVybGF5RmVhdHVyZVNvdXJjZVxuICAgIH07XG59XG5cblxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIGJlZHdpZy5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG4gICAgdmFyIFVSTEZldGNoYWJsZSA9IGJpbi5VUkxGZXRjaGFibGU7XG4gICAgdmFyIEJsb2JGZXRjaGFibGUgPSBiaW4uQmxvYkZldGNoYWJsZTtcbiAgICB2YXIgcmVhZEludCA9IGJpbi5yZWFkSW50O1xuXG4gICAgdmFyIGJiaSA9IHJlcXVpcmUoJy4vYmlnd2lnJyk7XG4gICAgdmFyIEJJR19XSUdfTUFHSUMgPSBiYmkuQklHX1dJR19NQUdJQztcbiAgICB2YXIgQklHX0JFRF9NQUdJQyA9IGJiaS5CSUdfQkVEX01BR0lDO1xuXG4gICAgdmFyIGxoM3V0aWxzID0gcmVxdWlyZSgnLi9saDN1dGlscycpO1xuICAgIHZhciB1bmJnemYgPSBsaDN1dGlscy51bmJnemY7XG5cbiAgICB2YXIgYmFtID0gcmVxdWlyZSgnLi9iYW0nKTtcbiAgICB2YXIgQkFNX01BR0lDID0gYmFtLkJBTV9NQUdJQztcbiAgICB2YXIgQkFJX01BR0lDID0gYmFtLkJBSV9NQUdJQztcblxuICAgIHZhciB0YmkgPSByZXF1aXJlKCcuL3RhYml4Jyk7XG4gICAgdmFyIFRBQklYX01BR0lDID0gdGJpLlRBQklYX01BR0lDO1xuXG4gICAgdmFyIEVuY29kZUZldGNoYWJsZSA9IHJlcXVpcmUoJy4vZW5jb2RlJykuRW5jb2RlRmV0Y2hhYmxlO1xufVxuXG5mdW5jdGlvbiBwcm9iZVJlc291cmNlKHNvdXJjZSwgbGlzdGVuZXIsIHJldHJ5KSB7XG4gICAgdmFyIEJFRF9SRUdFWFAgPSBuZXcgUmVnRXhwKCdeXFxcXHcrXFxcXHNbMC05XStcXFxcc1swLTldKy4qJCcpO1xuICAgIHZhciBLVl9SRUdFWFA9LyhbXj1dKyk9XFxcIj8oW15cXFwiXSspXFxcIj8vO1xuICAgIHZhciBWQ0ZIRUFEX1JFID0gL14jI1xccypmaWxlZm9ybWF0PVZDRnY0XFwuLisvO1xuXG4gICAgdmFyIGZldGNoYWJsZTtcbiAgICBpZiAoc291cmNlLmJsb2IpXG4gICAgICAgIGZldGNoYWJsZSA9IG5ldyBCbG9iRmV0Y2hhYmxlKHNvdXJjZS5ibG9iKTtcbiAgICBlbHNlIGlmIChzb3VyY2UudHJhbnNwb3J0ID09ICdlbmNvZGUnKVxuICAgICAgICBmZXRjaGFibGUgPSBuZXcgRW5jb2RlRmV0Y2hhYmxlKHNvdXJjZS51cmkpO1xuICAgIGVsc2VcbiAgICAgICAgZmV0Y2hhYmxlID0gbmV3IFVSTEZldGNoYWJsZShzb3VyY2UudXJpLCB7Y3JlZGVudGlhbHM6IHNvdXJjZS5jcmVkZW50aWFsc30pO1xuXG4gICAgZmV0Y2hhYmxlLnNsaWNlKDAsIDE8PDE2KS5zYWx0ZWQoKS5mZXRjaChmdW5jdGlvbihyZXN1bHQsIGVycm9yKSB7XG4gICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoIXJldHJ5KSB7XG4gICAgICAgICAgICAgICAgc291cmNlLmNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcm9iZVJlc291cmNlKHNvdXJjZSwgbGlzdGVuZXIsIHRydWUpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihzb3VyY2UsIFwiQ291bGRuJ3QgZmV0Y2ggZGF0YVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KHJlc3VsdCk7XG4gICAgICAgIHZhciBsYSA9IG5ldyBVaW50MzJBcnJheShyZXN1bHQsIDAsIDEpO1xuICAgICAgICB2YXIgbWFnaWMgPSBsYVswXTtcbiAgICAgICAgaWYgKG1hZ2ljID09IEJJR19XSUdfTUFHSUMgfHwgbWFnaWMgPT0gQklHX0JFRF9NQUdJQykge1xuICAgICAgICAgICAgc291cmNlLnRpZXJfdHlwZSA9ICdid2cnO1xuICAgICAgICAgICAgdmFyIG5hbWVFeHRyYWN0UGF0dGVybiA9IG5ldyBSZWdFeHAoJy8/KFteL10rPykoLmJ3fC5iYnwuYmlnV2lnfC5iaWdCZWQpPyQnKTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IG5hbWVFeHRyYWN0UGF0dGVybi5leGVjKHNvdXJjZS51cmkgfHwgc291cmNlLmJsb2IubmFtZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UubmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBudWxsKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYWdpYyA9PSBCQUlfTUFHSUMpIHtcbiAgICAgICAgICAgIHNvdXJjZS50aWVyX3R5cGUgPSAnYmFpJztcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihzb3VyY2UsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGJhWzBdID09IDMxIHx8IGJhWzFdID09IDEzOSkge1xuICAgICAgICAgICAgdmFyIHVuYyA9IHVuYmd6ZihyZXN1bHQpO1xuICAgICAgICAgICAgdmFyIHVuY2JhID0gbmV3IFVpbnQ4QXJyYXkodW5jKTtcbiAgICAgICAgICAgIG1hZ2ljID0gcmVhZEludCh1bmNiYSwgMCk7XG4gICAgICAgICAgICBpZiAobWFnaWMgPT0gQkFNX01BR0lDKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLnRpZXJfdHlwZSA9ICdiYW0nO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lRXh0cmFjdFBhdHRlcm4gPSBuZXcgUmVnRXhwKCcvPyhbXi9dKz8pKC5iYW0pPyQnKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBuYW1lRXh0cmFjdFBhdHRlcm4uZXhlYyhzb3VyY2UudXJpIHx8IHNvdXJjZS5ibG9iLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UubmFtZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihzb3VyY2UsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYWdpYyA9PSBUQUJJWF9NQUdJQykge1xuICAgICAgICAgICAgICAgIHNvdXJjZS50aWVyX3R5cGUgPSAndGFiaXgtaW5kZXgnO1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcihzb3VyY2UsIG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYWdpYyA9PSAweDY5NjYyMzIzKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLnRpZXJfdHlwZSA9ICd0YWJpeCc7XG4gICAgICAgICAgICAgICAgc291cmNlLnBheWxvYWQgPSAndmNmJztcbiAgICAgICAgICAgICAgICB2YXIgbmFtZUV4dHJhY3RQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnLz8oW14vXSs/KSgudmNmKT8oLmd6KT8kJyk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbmFtZUV4dHJhY3RQYXR0ZXJuLmV4ZWMoc291cmNlLnVyaSB8fCBzb3VyY2UuYmxvYi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLm5hbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ21hZ2ljID0gJyArIG1hZ2ljLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBcIlVuc3VwcG9ydGVkIGZvcm1hdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYSk7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xuXG4gICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMCAmJiBWQ0ZIRUFEX1JFLnRlc3QobGluZXNbMF0pKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLnRpZXJfdHlwZSA9ICdtZW1zdG9yZSc7XG4gICAgICAgICAgICAgICAgc291cmNlLnBheWxvYWQgPSAndmNmJztcbiAgICAgICAgICAgICAgICB2YXIgbmFtZUV4dHJhY3RQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnLz8oW14vXSs/KShcXC52Y2YpPyQnKTtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBuYW1lRXh0cmFjdFBhdHRlcm4uZXhlYyhzb3VyY2UudXJpIHx8IHNvdXJjZS5ibG9iLm5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCAmJiAhc291cmNlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLm5hbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCBsaW5lcy5sZW5ndGg7ICsrbGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2xpXS5yZXBsYWNlKCdcXHInLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignYnJvd3NlcicpID09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZigndHJhY2snKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZVR5cGUgPSAnYmVkJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva3MgPSBsaW5lLnNwbGl0KC9cXHMvKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdGkgPSAxOyB0aSA8IHRva3MubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IEtWX1JFR0VYUC5leGVjKHRva3NbdGldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1bMV0gPT0gJ3R5cGUnICYmIG1bMl0gPT0gJ3dpZ2dsZV8wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZVR5cGUgPSAnd2lnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobVswXSA9PSAnbmFtZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLm5hbWUgPSBtWzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFByb2JlQmVkV2lnKHNvdXJjZSwgbWF5YmVUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignZml4ZWRTdGVwJykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hQcm9iZUJlZFdpZyhzb3VyY2UsICd3aWcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZigndmFyaWFibGVTdGVwJykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hQcm9iZUJlZFdpZyhzb3VyY2UsICd3aWcnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKEJFRF9SRUdFWFAudGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hQcm9iZUJlZFdpZyhzb3VyY2UsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGlzdGVuZXIoc291cmNlLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyKHNvdXJjZSwgXCJVbnN1cHBvcnRlZCBmb3JtYXRcIik7XG4gICAgICAgIH1cbiAgICB9LCB7dGltZW91dDogMTUwMH0pOyAgLy8gVGltZW91dCB0byBjYXRjaCBtaXhlZC1vcmlnaW4gY2FzZSBvbiBDaHJvbWl1bS5cbn1cblxuZnVuY3Rpb24gZmluaXNoUHJvYmVCZWRXaWcoc291cmNlLCBtYXliZVR5cGUpIHtcbiAgICBzb3VyY2UudGllcl90eXBlID0gJ21lbXN0b3JlJztcbiAgICB2YXIgbmFtZUV4dHJhY3RQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnLz8oW14vXSs/KSguKGJlZHx3aWcpKT8kJyk7XG4gICAgdmFyIG1hdGNoID0gbmFtZUV4dHJhY3RQYXR0ZXJuLmV4ZWMoc291cmNlLnVyaSB8fCBzb3VyY2UuYmxvYi5uYW1lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UubmFtZSlcbiAgICAgICAgICAgIHNvdXJjZS5uYW1lID0gbWF0Y2hbMV07XG4gICAgICAgIGlmICghbWF5YmVUeXBlICYmIG1hdGNoWzNdKSB7XG4gICAgICAgICAgICBtYXliZVR5cGUgPSBtYXRjaFszXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2UucGF5bG9hZCA9IG1heWJlVHlwZSB8fCAnYmVkJztcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBwcm9iZVJlc291cmNlOiBwcm9iZVJlc291cmNlXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBzYW1wbGUuanM6IGRvd25zYW1wbGluZyBvZiBxdWFudGl0YXRpdmUgZmVhdHVyZXNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBEQVNGZWF0dXJlID0gZGFzLkRBU0ZlYXR1cmU7XG5cbiAgICB2YXIgcGFyc2VDaWdhciA9IHJlcXVpcmUoJy4vY2lnYXInKS5wYXJzZUNpZ2FyO1xuXG4gICAgdmFyIHNoYWxsb3dDb3B5ID0gcmVxdWlyZSgnLi91dGlscycpLnNoYWxsb3dDb3B5O1xufVxuXG52YXIgX19EU19TQ0FMRVMgPSBbMSwgMiwgNV07XG5cbmZ1bmN0aW9uIGRzX3NjYWxlKG4pIHtcbiAgICByZXR1cm4gX19EU19TQ0FMRVNbbiAlIF9fRFNfU0NBTEVTLmxlbmd0aF0gKiBNYXRoLnBvdygxMCwgKG4gLyBfX0RTX1NDQUxFUy5sZW5ndGgpfDApO1xufVxuXG5cbmZ1bmN0aW9uIERTQmluKHNjYWxlLCBtaW4sIG1heCkge1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnRvdCA9IDA7XG4gICAgdGhpcy5jbnQgPSAwO1xuICAgIHRoaXMuaGFzU2NvcmUgPSBmYWxzZTtcbiAgICB0aGlzLm1pbiA9IG1pbjsgdGhpcy5tYXggPSBtYXg7XG4gICAgdGhpcy5mZWF0dXJlcyA9IFtdO1xufVxuXG5mdW5jdGlvbiBfZmVhdHVyZU9yZGVyKGEsIGIpIHtcbiAgICBpZiAoYS5taW4gPCBiLm1pbikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChhLm1pbiA+IGIubWluKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYS5tYXggPCBiLm1heCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChiLm1heCA+IGEubWF4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cblxuRFNCaW4ucHJvdG90eXBlLnNjb3JlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuY250ID09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc1Njb3JlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdCAvIHRoaXMuY250O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuZmVhdHVyZXM7XG4gICAgICAgIGZlYXR1cmVzLnNvcnQoX2ZlYXR1cmVPcmRlcik7XG5cbiAgICAgICAgdmFyIG1heFNlZW4gPSAtMTAwMDAwMDAwMDA7XG4gICAgICAgIHZhciBjb3Y9MCwgbGFwPTA7XG5cbiAgICAgICAgZm9yICh2YXIgZmkgPSAxOyBmaSA8IGZlYXR1cmVzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmZWF0dXJlc1tmaV07XG4gICAgICAgICAgICB2YXIgbE1pbiA9IE1hdGgubWF4KGYubWluLCB0aGlzLm1pbik7XG4gICAgICAgICAgICB2YXIgbE1heCA9IE1hdGgubWluKGYubWF4LCB0aGlzLm1heCk7XG4gICAgICAgICAgICBsYXAgKz0gKGxNYXggLSBsTWluICsgMSk7XG5cbiAgICAgICAgICAgIGlmIChsTWluID4gbWF4U2Vlbikge1xuICAgICAgICAgICAgICAgIGNvdiArPSBsTWF4IC0gbE1pbiArIDE7XG4gICAgICAgICAgICAgICAgbWF4U2VlbiA9IGxNYXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsTWF4ID4gbWF4U2Vlbikge1xuICAgICAgICAgICAgICAgICAgICBjb3YgKz0gKGxNYXggLSBtYXhTZWVuKTtcbiAgICAgICAgICAgICAgICAgICAgbWF4U2VlbiA9IGxNYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvdiA+IDApXG4gICAgICAgICAgICByZXR1cm4gKDEuMCAqIGxhcCkgLyBjb3Y7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cblxuRFNCaW4ucHJvdG90eXBlLmZlYXR1cmUgPSBmdW5jdGlvbihmKSB7XG4gICAgaWYgKGYuc2NvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnRvdCArPSBmLnNjb3JlO1xuICAgICAgICB0aGlzLmhhc1Njb3JlID0gdHJ1ZVxuICAgIH1cblxuICAgICsrdGhpcy5jbnQ7XG4gICAgdGhpcy5mZWF0dXJlcy5wdXNoKGYpO1xufVxuXG5mdW5jdGlvbiBkb3duc2FtcGxlKGZlYXR1cmVzLCB0YXJnZXRSZXopIHtcbiAgICB2YXIgc24gPSAwO1xuICAgIHdoaWxlIChkc19zY2FsZShzbiArIDEpIDwgdGFyZ2V0UmV6KSB7XG4gICAgICAgICsrc247XG4gICAgfVxuICAgIHZhciBzY2FsZSA9IGRzX3NjYWxlKHNuKTtcblxuICAgIHZhciBiaW5Ub3RzID0gW107XG4gICAgdmFyIG1heEJpbiA9IC0xMDAwMDAwMDAwMDtcbiAgICB2YXIgbWluQmluID0gMTAwMDAwMDAwMDA7XG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZlYXR1cmVzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICB2YXIgZiA9IGZlYXR1cmVzW2ZpXTtcbiAgICAgICAgaWYgKGYuZ3JvdXBzICYmIGYuZ3JvdXBzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIERvbid0IGRvd25zYW1wbGUgY29tcGxleCBmZWF0dXJlcyAoPylcbiAgICAgICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5MYXAgPSAoZi5taW4gLyBzY2FsZSl8MDtcbiAgICAgICAgdmFyIG1heExhcCA9IChmLm1heCAvIHNjYWxlKXwwO1xuICAgICAgICBtYXhCaW4gPSBNYXRoLm1heChtYXhCaW4sIG1heExhcCk7XG4gICAgICAgIG1pbkJpbiA9IE1hdGgubWluKG1pbkJpbiwgbWluTGFwKTtcbiAgICAgICAgZm9yICh2YXIgYiA9IG1pbkxhcDsgYiA8PSBtYXhMYXA7ICsrYikge1xuICAgICAgICAgICAgdmFyIGJtID0gYmluVG90c1tiXTtcbiAgICAgICAgICAgIGlmICghYm0pIHtcbiAgICAgICAgICAgICAgICBibSA9IG5ldyBEU0JpbihzY2FsZSwgYiAqIHNjYWxlLCAoYiArIDEpICogc2NhbGUgLSAxKTtcbiAgICAgICAgICAgICAgICBiaW5Ub3RzW2JdID0gYm07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibS5mZWF0dXJlKGYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNhbXBsZWRGZWF0dXJlcyA9IFtdO1xuICAgIGZvciAodmFyIGIgPSBtaW5CaW47IGIgPD0gbWF4QmluOyArK2IpIHtcbiAgICAgICAgdmFyIGJtID0gYmluVG90c1tiXTtcbiAgICAgICAgaWYgKGJtKSB7XG4gICAgICAgICAgICB2YXIgZiA9IG5ldyBEQVNGZWF0dXJlKCk7XG4gICAgICAgICAgICBmLnNlZ21lbnQgPSBmZWF0dXJlc1swXS5zZWdtZW50O1xuICAgICAgICAgICAgZi5taW4gPSAoYiAqIHNjYWxlKSArIDE7XG4gICAgICAgICAgICBmLm1heCA9IChiICsgMSkgKiBzY2FsZTtcbiAgICAgICAgICAgIGYuc2NvcmUgPSBibS5zY29yZSgpO1xuICAgICAgICAgICAgZi50eXBlID0gJ2RlbnNpdHknO1xuICAgICAgICAgICAgc2FtcGxlZEZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWZ0ZXJEUyA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIHNhbXBsZWRGZWF0dXJlcztcbn1cblxuLyoqIERhdGEgc3RydWN0dXJlIHRvIHN0b3JlIGluZm9ybWF0aW9uIGZvclxuYSBiYXNlIHBvc2l0aW9uOlxuXG5wb3M6IHBvc2l0aW9uIG9mIHRoZSBiYXNlLlxuKi9cbmZ1bmN0aW9uIEJhc2VCaW4ocG9zKSB7XG5cbiAgICB0aGlzLl9wb3MgPSBwb3M7XG4gICAgdGhpcy5fYmFzZXMgPSB7fTtcbiAgICB0aGlzLl90b3RhbENvdW50ID0gMDtcbn1cblxuLyoqIEtlZXAgcmVjb3JkIGZvciBpbmNpZGVuY2Ugb2YgYSBiYXNlLFxud2l0aCByZWxhdGVkIHF1YWwgc2NvcmUgYW5kIHN0cmFuZCBmb3IgYSBwb3NpdGlvbi5cblxuUGFyYW1zXG4gICAgYmFzZTogYmFzZSAoZS5nIEEsIFQsIEcsIEMsIE4pIG9ic2VydmVkIGF0IHBvc2l0aW9uLlxuICAgIHF1YWw6IG51bWVyaWMgcXVhbGl0eSBzY29yZS5cbiAgICBzdHJhbmQ6ICcrJyBvciAnLScuXG4qL1xuQmFzZUJpbi5wcm90b3R5cGUucmVjb3JkQmFzZSA9IGZ1bmN0aW9uKGJhc2UsIHF1YWwsIHN0cmFuZCkge1xuICAgIGlmICghdGhpcy5fYmFzZXNbYmFzZV0pIHtcbiAgICAgICAgdmFyIHN0cmFuZENvbXBvc2l0aW9uID0geycrJzogMCwgJy0nOiAwfTtcbiAgICAgICAgc3RyYW5kQ29tcG9zaXRpb25bc3RyYW5kXSsrO1xuICAgICAgICB0aGlzLl9iYXNlc1tiYXNlXSA9IHtcbiAgICAgICAgICAgIGNudDogMSxcbiAgICAgICAgICAgIHRvdGFsUXVhbDogcXVhbCxcbiAgICAgICAgICAgIHN0cmFuZENudDogc3RyYW5kQ29tcG9zaXRpb25cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmFzZUNvbXBvc2l0aW9uID0gdGhpcy5fYmFzZXNbYmFzZV07XG4gICAgICAgIGJhc2VDb21wb3NpdGlvbi5jbnQrKztcbiAgICAgICAgYmFzZUNvbXBvc2l0aW9uLnRvdGFsUXVhbCArPSBxdWFsO1xuICAgICAgICBiYXNlQ29tcG9zaXRpb24uc3RyYW5kQ250W3N0cmFuZF0rKztcbiAgICB9XG4gICAgdGhpcy5fdG90YWxDb3VudCsrO1xufTtcblxuLyoqIFJldHVybnMgY291bnQgb2YgdG90YWwgbnVtYmVyIG9mIGJhc2VzIG9ic2VydmVkIGF0IHBvc2l0aW9uICovXG5CYXNlQmluLnByb3RvdHlwZS50b3RhbENvdW50ID0gZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuX3RvdGFsQ291bnQ7fTtcblxuLyoqIFJldHVybnMgdGhlIGJhc2UgcG9zaXRpb24gKi9cbkJhc2VCaW4ucHJvdG90eXBlLnBvcyA9IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLl9wb3M7fTtcblxuLyoqIENyZWF0ZXMgYSBsaXN0IG9mIHRhZywgaW5mbyBwYWlycyBpbiB0aGUgZm9ybVxuW3RhZ109W2luZm9dIGZvciBlYWNoIGJhc2UsIGZvciB1c2UgaW4gZmVhdHVyZS1wb3B1cCAqL1xuQmFzZUJpbi5wcm90b3R5cGUuaW5mb0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IFtdO1xuICAgIHZhciB0b3RhbENvdW50ID0gdGhpcy5fdG90YWxDb3VudDtcbiAgICB2YXIgdG90YWxDb3VudFN0ciA9IFwiRGVwdGg9XCIgKyB0b3RhbENvdW50LnRvU3RyaW5nKCk7XG4gICAgaW5mby5wdXNoKHRvdGFsQ291bnRTdHIpO1xuICAgIGZvciAodmFyIGJhc2UgaW4gdGhpcy5fYmFzZXMpIHtcbiAgICAgICAgdmFyIGJhc2VDb21wb3NpdGlvbiA9IHRoaXMuX2Jhc2VzW2Jhc2VdO1xuICAgICAgICB2YXIgYmFzZUNudCA9IGJhc2VDb21wb3NpdGlvbi5jbnQ7XG4gICAgICAgIHZhciBiYXNlUGVyY2VudGFnZSA9IChiYXNlQ250ICogMTAwIC8gdG90YWxDb3VudCk7IFxuICAgICAgICB2YXIgcGx1c1N0cmFuZENudCA9IGJhc2VDb21wb3NpdGlvbi5zdHJhbmRDbnRbJysnXTtcbiAgICAgICAgdmFyIG1pbnVzU3RyYW5kQ250ID0gYmFzZUNvbXBvc2l0aW9uLnN0cmFuZENudFsnLSddO1xuICAgICAgICB2YXIgbWVhblF1YWwgPSBiYXNlQ29tcG9zaXRpb24udG90YWxRdWFsL2Jhc2VDbnQ7XG5cbiAgICAgICAgdmFyIGJhc2VJbmZvU3RyaW5nID0gW2Jhc2UsICc9JywgYmFzZUNudCwgJyAoJywgYmFzZVBlcmNlbnRhZ2UudG9GaXhlZCgwKSwgJyUsICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVzU3RyYW5kQ250LCAnICssICcsIG1pbnVzU3RyYW5kQ250LCAnIC0sIFF1YWw6ICcsIG1lYW5RdWFsLnRvRml4ZWQoMCksICcpJ107XG4gICAgICAgIGluZm8ucHVzaChiYXNlSW5mb1N0cmluZy5qb2luKCcnKSk7XG4gICAgfVxuICAgIHJldHVybiBpbmZvO1xufTtcblxuLyoqIFJldHVybiBhIGxpc3Qgb2Ygb2JqZWN0cyBmb3IgY3JlYXRpbmcgYVxuaGlzdG9ncmFtIHNob3dpbmcgY29tcG9zaXRpb24gb2YgZGlmZmVyZW50IGJhc2VzIGF0IGFcbmdpdmVuIGxvY2F0aW9uLlxuXG5DdXJyZW50IGltcGxlbWVudGF0aW9uIGlzIGhhY2t5OiB0aGUgbG9naWMgaW52b2x2ZXNcbm92ZXJsYXlpbmcgQm94R2x5cGhzIG9uIHRvcCBvZiBlYWNoIG90aGVyLCB0aHVzIHRoZSBzY29yZVxuaXMgbm90IG1lYW5pbmdmdWwsIGJ1dCBvbmx5IHVzZWQgdG8gbWFuaXB1bGF0ZSBoZWlnaHQuXG5cblBhcmFtczpcbiAgcmVmOiByZWZlcmVuY2UgYmFzZSBhdCBwb3NpdGlvblxuICB0aHJlc2hvbGQ6IHZhbHVlIGJldHdlZW4gMCBhbmQgMSByZXByZXNlbnRpbmcgbWluIGFsbGVsZSBmcmVxdWVuY3lcbiAgICAgICAgICAgICAgYmVsb3cgd2hpY2ggdGhlIGFsbGVsZSB3aWxsIGJlIGlnbm9yZWQgaW4gaGlzdG9ncmFtLlxuICAgICAgICAgICAgICAoaW50ZXJwcmV0ZWQgYXMgbm9pc2UpXG4gICAgICAgICAgICAgIFNpbWlsYXIgdG8gJ2FsbGVsZSB0aHJlc2hvbGQnIHBhcmFtZXRlciBpbiBJR1ZcblxuUmV0dXJucyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIDIgcHJvcGVydGllc1xuICAgIGJhc2U6IHN1Y2ggYXMgQSwgVCwgRywgQywgTiwgLSAoZGVsKVxuICAgIHNjb3JlOiBhIG51bWVyaWMgc2NvcmUgZm9yIGRldGVybWluaW5nIGhlaWdodCBvZiBoaXN0b2dyYW1cblRoZSBsaXN0IGlzIG9yZGVyZWQgc3VjaCB0aGF0IGEgcHJlY2VlZGluZyBvYmplY3QgYWx3YXlzIGhhdmUgYVxuc2NvcmUgPj0gdGhlIGN1cnJlbnQgb2JqZWN0LCBhbmQgdGhlIHJlZiBiYXNlIHdpbGwgYmUgdGhlIGxhc3QgaXRlbS5cblxuRXhhbXBsZTogVGhlcmUgYXJlIDUwIFQncyBhbmQgNDAgQSdzICh0b3RhbCBkZXB0aCA9IDkwKVxuYXQgYSBiYXNlIHdoZXJlIHJlZj1BLiBUaGUgZnVuY3Rpb24gd2lsbCByZXR1cm5cbltUOiA5MCwgQTogNDBdLiBXaGVuIGNyZWF0aW5nIGEgaGlzdG9ncmFtIHdpdGggb3ZlcmxhcCxcbnRoaXMgd2lsbCBnaXZlIGFuIGFwcGVhcmFuY2Ugb2YgNDAgQSdzIChib3R0b20pIGFuZCA1MCBUJ3MgKHRvcCk6XG4jIyMjIyMjXG4jICBUICAjXG4jICBUICAjXG4jICBUICAjXG4jICBUICAjXG4jICBUICAjXG4jIyMjIyMjXG4jICBBICAjXG4jICBBICAjXG4jICBBICAjXG4jICBBICAjXG4jIyMjIyMjXG4qL1xuQmFzZUJpbi5wcm90b3R5cGUuYmFzZVNjb3JlTGlzdCA9IGZ1bmN0aW9uKHJlZiwgdGhyZXNob2xkKSB7XG4gICAgdmFyIGJhc2VTY29yZUxpc3QgPSBbXTtcbiAgICB2YXIgdG90YWxDb3VudCA9IHRoaXMuX3RvdGFsQ291bnQ7XG4gICAgdmFyIG1pbkNvdW50ID0gdGhyZXNob2xkICogdG90YWxDb3VudDtcbiAgICBmb3IgKHZhciBiYXNlIGluIHRoaXMuX2Jhc2VzKSB7XG4gICAgICAgIHZhciBiYXNlQ291bnQgPSB0aGlzLl9iYXNlc1tiYXNlXS5jbnQ7XG4gICAgICAgIGlmIChiYXNlQ291bnQgPCBtaW5Db3VudCB8fCBiYXNlID09IHJlZilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgYmFzZVNjb3JlUGFpciA9IHtiYXNlOiBiYXNlLCBzY29yZTogdG90YWxDb3VudH07XG4gICAgICAgIGJhc2VTY29yZUxpc3QucHVzaChiYXNlU2NvcmVQYWlyKTtcbiAgICAgICAgdG90YWxDb3VudCAtPSBiYXNlQ291bnQ7XG4gICAgfVxuICAgIGJhc2VTY29yZUxpc3QucHVzaCh7YmFzZTogcmVmLCBzY29yZTogdG90YWxDb3VudH0pO1xuICAgIHJldHVybiBiYXNlU2NvcmVMaXN0O1xufTtcblxuLyoqIEdlbmVyYXRlcyBhbiBhbGlnbmVkIHJlYWQgZnJvbSB0aGUgcmF3IHNlcXVlbmNlIG9mIGEgQkFNIHJlY29yZFxudXNpbmcgZ2l2ZW4gY2lnYXIgc3RyaW5nLlxuXG5QYXJhbXM6XG4gIHJhd3NlcTogdW5hbGlnbmVkIHJlYWQgc2VxdWVuY2UgZnJvbSBCYW0gcmVjb3JkXG4gIHJhd3F1YWxzOiB1bmFsaWduZWQgcmVhZCBxdWFscyBmcm9tIEJhbSByZWNvcmRcbiAgY2lnYXI6IEJhbSBjaWdhciBzdHJpbmcgZnJvbSBCYW0gcmVjb3JkXG5cblJldHVybnMgYW4gb2JqZWN0IHdpdGggMiBwcm9wZXJ0aWVzOlxuICBzZXE6IHN0cmluZyBjb250YWluaW5nIGFsaWduZWQgcmVhZFxuICBxdWFsczogc3RyaW5nIGNvbnRhaW5pbmcgcHJpbnRhYmxlLWNoYXJhY3RlciByZXByZXNlbnRhdGlvblxuICAgICAgICAgb2Ygc2VxdWVuY2luZyBxdWFsaXR5IHNjb3JlXG4qL1xuZnVuY3Rpb24gYWxpZ25TZXFVc2luZ0NpZ2FyKHJhd3NlcSwgcmF3cXVhbHMsIGNpZ2FyKSB7XG4gICAgdmFyIG9wcyA9IHBhcnNlQ2lnYXIoY2lnYXIpO1xuICAgIHZhciBzZXEgPSBbXTtcbiAgICB2YXIgcXVhbHMgPSBbXTtcbiAgICB2YXIgY3Vyc29yID0gMDtcbiAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgb3BzLmxlbmd0aDsgKytjaSkge1xuICAgICAgICB2YXIgY28gPSBvcHNbY2ldO1xuICAgICAgICBpZiAoY28ub3AgPT0gJ00nKSB7XG4gICAgICAgICAgICBzZXEucHVzaChyYXdzZXEuc3Vic3RyKGN1cnNvciwgY28uY250KSk7XG4gICAgICAgICAgICBxdWFscy5wdXNoKHJhd3F1YWxzLnN1YnN0cihjdXJzb3IsIGNvLmNudCkpO1xuICAgICAgICAgICAgY3Vyc29yICs9IGNvLmNudDtcbiAgICAgICAgfSBlbHNlIGlmIChjby5vcCA9PSAnRCcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG9pID0gMDsgb2kgPCBjby5jbnQ7ICsrb2kpIHtcbiAgICAgICAgICAgICAgICBzZXEucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgIHF1YWxzLnB1c2goJ1onKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjby5vcCA9PSAnSScpIHtcbiAgICAgICAgICAgIGN1cnNvciArPSBjby5jbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY28ub3AgPT0gJ1MnKSB7XG4gICAgICAgICAgICBjdXJzb3IgKz0gY28uY250O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3Vua25vd24gY2lnb3AnICsgY28ub3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBwcm9jZXNzZWRTZXEgPSB7c2VxOiBzZXEuam9pbignJyksIHF1YWxzOiBxdWFscy5qb2luKCcnKX07XG4gICAgcmV0dXJuIHByb2Nlc3NlZFNlcTtcbn1cblxuLyoqIENvbnN0cnVjdHMgdGhlIHJlZmVyZW5jZSBzZXF1ZW5jZSBmb3IgYSBnaXZlbiB3aW5kb3cuXG5cblBhcmFtc1xuICAgIGN1cnJlbnRTZXF1ZW5jZTogRGFzU2VxdWVuY2Ugb2JqZWN0IGNvbnRhaW5pbmcgcmVmIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgICBpbiBjdXJyZW50IGJyb3dzZXIgdmlldy5cbiAgICBtaW4sIG1heDogbWluIGFuZCBtYXggcG9zaXRpb24gZm9yIHdpbmRvdy5cblxuUmV0dXJucyBhIHN0cmluZyBjb250YWluaW5nIHRoZSByZWZzZXEsIHBhZGRlZCB3aXRoICdOJyB3aGVyZSBzZXF1ZW5jZSBpcyBub3RcbiAgICBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZ2V0UmVmU2VxKGN1cnJlbnRTZXF1ZW5jZSwgbWluLCBtYXgpIHtcbiAgICB2YXIgcmVmU2VxID0gW107XG4gICAgaWYgKGN1cnJlbnRTZXF1ZW5jZSkge1xuICAgICAgICB2YXIgY3NTdGFydCA9IGN1cnJlbnRTZXF1ZW5jZS5zdGFydHwwO1xuICAgICAgICB2YXIgY3NFbmQgPSBjdXJyZW50U2VxdWVuY2UuZW5kfDA7XG4gICAgICAgIGlmIChjc1N0YXJ0IDw9IG1heCAmJiBjc0VuZCA+PSBtaW4pIHtcbiAgICAgICAgICAgIHZhciBzZk1pbiA9IE1hdGgubWF4KG1pbiwgY3NTdGFydCk7XG4gICAgICAgICAgICB2YXIgc2ZNYXggPSBNYXRoLm1pbihtYXgsIGNzRW5kKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZk1pbiAtIG1pbjsgaSsrKVxuICAgICAgICAgICAgICAgIHJlZlNlcS5wdXNoKCdOJyk7XG4gICAgICAgICAgICByZWZTZXEucHVzaChjdXJyZW50U2VxdWVuY2Uuc2VxLnN1YnN0cihzZk1pbiAtIGNzU3RhcnQsIHNmTWF4IC0gc2ZNaW4gKyAxKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heCAtIHNmTWF4OyBpKyspXG4gICAgICAgICAgICAgICAgcmVmU2VxLnB1c2goJ04nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVmU2VxLmpvaW4oJycpO1xufVxuXG4vKiogQ29uc3RydWN0cyBmZWF0dXJlcyBuZWNlc3NhcnkgZm9yIGEgY292ZXJhZ2UgdHJhY2sgc2hvd2luZ1xuYmFzZSBjb21wb3NpdGlvbiBmb3IgQkFNIHJlYWRzXG5cblBhcmFtc1xuICAgIGZlYXR1cmVzOiBhIGxpc3Qgb2YgZmVhdHVyZXMgZnJvbSBCQU0gcmVjb3Jkcy5cbiAgICBjdXJyZW50UmVmU2VxOiBhIERBU1NlcXVlbmNlIG9iamVjdCBjb250YWluaW5nIHJlZmVyZW5jZSBzZXF1ZW5jZS5cbiAgICBiYXNlQ29sb3JzOiBhbiBvYmplY3QgbWFwcGluZyBiYXNlIHRvIGRlc2lyZWQgY29sb3JzLlxuXG5SZXR1cm5zIGEgbGlzdCBvZiBmZWF0dXJlcyBvZiB0eXBlIGJhc2UtY292ZXJhZ2UuXG4qL1xuZnVuY3Rpb24gZ2V0QmFzZUNvdmVyYWdlKGZlYXR1cmVzLCBjdXJyZW50UmVmU2VxLCBiYXNlQ29sb3JzKSB7XG4gICAgdmFyIG1pbkJpbiA9IG51bGw7XG4gICAgdmFyIG1heEJpbiA9IG51bGw7XG5cbiAgICB2YXIgYWxsQmlucyA9IFtdO1xuXG4gICAgLy8gUG9wdWxhdGUgQmFzZUJpbnNcbiAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHZhciBmID0gZmVhdHVyZXNbZmldO1xuICAgICAgICBpZiAoZi5ncm91cHMgJiYgZi5ncm91cHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgZG93bnNhbXBsZSBjb21wbGV4IGZlYXR1cmVzXG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2Nlc3NlZFNlcSA9IGFsaWduU2VxVXNpbmdDaWdhcihmLnNlcSwgZi5xdWFscywgZi5jaWdhcik7XG4gICAgICAgIHZhciBzZXEgPSBwcm9jZXNzZWRTZXEuc2VxO1xuICAgICAgICB2YXIgcXVhbHMgPSBwcm9jZXNzZWRTZXEucXVhbHM7XG4gICAgICAgIHZhciBzdHJhbmQgPSBmLm9yaWVudGF0aW9uO1xuICAgICAgICB2YXIgbWluRm9yRmVhdHVyZSA9IGYubWluIHx8IDA7XG4gICAgICAgIHZhciBtYXhGb3JGZWF0dXJlID0gZi5tYXggfHwgMDtcbiAgICAgICAgdmFyIGluZCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgYiA9IG1pbkZvckZlYXR1cmU7IGIgPD0gbWF4Rm9yRmVhdHVyZTsgKytiKSB7XG4gICAgICAgICAgICB2YXIgYm0gPSBhbGxCaW5zW2JdO1xuICAgICAgICAgICAgaWYgKCFibSkge1xuICAgICAgICAgICAgICAgIGJtID0gbmV3IEJhc2VCaW4oYik7XG4gICAgICAgICAgICAgICAgYWxsQmluc1tiXSA9IGJtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJhc2UgPSBzZXEuY2hhckF0KGluZCk7XG4gICAgICAgICAgICB2YXIgcXVhbCA9IHF1YWxzLmNoYXJDb2RlQXQoaW5kKSAtIDMzOyAvLyBHZW5lcmF0ZSBudW1lcmljIHF1YWwgc2NvcmVcbiAgICAgICAgICAgIGJtLnJlY29yZEJhc2UoYmFzZSwgcXVhbCwgc3RyYW5kKTtcbiAgICAgICAgICAgIGluZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtaW5CaW4pXG4gICAgICAgICAgICBtaW5CaW4gPSBtaW5Gb3JGZWF0dXJlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtaW5CaW4gPSBNYXRoLm1pbihtaW5CaW4sIG1pbkZvckZlYXR1cmUpO1xuICAgICAgICBpZiAoIW1heEJpbilcbiAgICAgICAgICAgIG1heEJpbiA9IG1heEZvckZlYXR1cmU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heEJpbiA9IE1hdGgubWF4KG1heEJpbiwgbWF4Rm9yRmVhdHVyZSk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgY292ZXJhZ2UgZmVhdHVyZXNcbiAgICB2YXIgcmVmU2VxID0gZ2V0UmVmU2VxKGN1cnJlbnRSZWZTZXEsIG1pbkJpbiwgbWF4QmluKTtcbiAgICB2YXIgYmFzZUZlYXR1cmVzID0gW107XG4gICAgdmFyIGluZCA9IDA7XG4gICAgZm9yICh2YXIgYiA9IG1pbkJpbjsgYiA8PSBtYXhCaW47ICsrYikge1xuICAgICAgICB2YXIgYm0gPSBhbGxCaW5zW2JdO1xuICAgICAgICBpZiAoYm0pIHtcbiAgICAgICAgICAgIHZhciBmID0gbmV3IERBU0ZlYXR1cmUoKTtcbiAgICAgICAgICAgIGYuc2VnbWVudCA9IGZlYXR1cmVzWzBdLnNlZ21lbnQ7XG4gICAgICAgICAgICBmLm1pbiA9IGJtLnBvcygpO1xuICAgICAgICAgICAgZi5tYXggPSBmLm1pbjtcbiAgICAgICAgICAgIGYubm90ZXMgPSBbXTtcbiAgICAgICAgICAgIGYubm90ZXMgPSBmLm5vdGVzLmNvbmNhdChibS5pbmZvTGlzdCgpKTtcbiAgICAgICAgICAgIGYudHlwZSA9ICdiYXNlLWNvdmVyYWdlJztcbiAgICAgICAgICAgIGYuc3VwcHJlc3NTY29yZSA9IHRydWU7XG4gICAgICAgICAgICBpZiAocmVmU2VxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlZkJhc2UgPSByZWZTZXEuY2hhckF0KGluZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZlN0cmluZyA9ICdSZWY9JyArIHJlZkJhc2U7XG4gICAgICAgICAgICAgICAgZi5ub3Rlcy51bnNoaWZ0KHJlZlN0cmluZyk7XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VTY29yZUxpc3QgPSBibS5iYXNlU2NvcmVMaXN0KHJlZkJhc2UsIDAuMik7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2hpZnQgMC4yIHRocmVzaG9sZCB0byBhIGNvbmZpZyBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VTY29yZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2UgPSBiYXNlU2NvcmVMaXN0W2ldLmJhc2U7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY29yZSA9IGJhc2VTY29yZUxpc3RbaV0uc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmQmFzZSA9IHNoYWxsb3dDb3B5KGYpO1xuICAgICAgICAgICAgICAgICAgICBmQmFzZS5zY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb2xvciBieSBiYXNlQ29sb3Igd2hlbiBtaXNtYXRjaCBvY2N1cnNcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBCb3hHbHlwaCB0byBDT0xPUjEgaW4gc3R5bGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhc2VTY29yZUxpc3QubGVuZ3RoID4gMSB8fCBiYXNlICE9IHJlZkJhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBmQmFzZS5pdGVtUmdiID0gYmFzZUNvbG9yc1tiYXNlXTtcblxuICAgICAgICAgICAgICAgICAgICBiYXNlRmVhdHVyZXMucHVzaChmQmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyByZWZTZXEsIG9ubHkgc2hvdyBjb3ZlcmFnZSBoZWlnaHQuXG4gICAgICAgICAgICAgICAgYmFzZUZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5kICsrO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZUZlYXR1cmVzO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGRvd25zYW1wbGU6IGRvd25zYW1wbGUsXG4gICAgICAgIGdldEJhc2VDb3ZlcmFnZTogZ2V0QmFzZUNvdmVyYWdlXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTFcbi8vXG4vLyBiaW4uanMgZ2VuZXJhbCBiaW5hcnkgZGF0YSBzdXBwb3J0XG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciBiaW4gPSByZXF1aXJlKCcuL2JpbicpO1xuICAgIHZhciBVUkxGZXRjaGFibGUgPSBiaW4uVVJMRmV0Y2hhYmxlO1xuXG4gICAgdmFyIGNvbm5lY3RUcml4ID0gcmVxdWlyZSgnLi90cml4JykuY29ubmVjdFRyaXg7XG59XG5cbnZhciBSRUdJT05fUEFUVEVSTiA9IC9eKFtcXGQrLFxcdyxcXC4sXFxfLFxcLV0rKTooWzAtOSxcXC5dKz8pKFtLa01tR2ddKT8oKC18XFwuXFwuKSsoWzAtOSxcXC5dKykoW0trTW1HZ10pPyk/JC87XG5cbmZ1bmN0aW9uIHBhcnNlTG9jQ2FyZGluYWwobiwgbSkge1xuICAgIHZhciBpID0gcGFyc2VGbG9hdChuLnJlcGxhY2UoLywvZywgJycpKTtcbiAgICBpZiAobSA9PT0gJ2snIHx8IG0gPT09ICdLJykge1xuICAgICAgICByZXR1cm4gKGkgKiAxMDAwKXwwO1xuICAgIH0gZWxzZSBpZiAobSA9PSAnbScgfHwgbSA9PT0gJ00nKSB7XG4gICAgICAgIHJldHVybiAoaSAqIDEwMDAwMDApfDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGl8MDtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKGcsIHN0YXR1c0NhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgbSA9IFJFR0lPTl9QQVRURVJOLmV4ZWMoZyk7XG5cbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgY2hyID0gbVsxXSwgc3RhcnQsIGVuZDtcbiAgICAgICAgaWYgKG1bNl0pIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcGFyc2VMb2NDYXJkaW5hbChtWzJdLCAgbVszXSk7XG4gICAgICAgICAgICBlbmQgPSBwYXJzZUxvY0NhcmRpbmFsKG1bNl0sIG1bN10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQgKyAxO1xuICAgICAgICAgICAgc3RhcnQgPSAocGFyc2VMb2NDYXJkaW5hbChtWzJdLCBtWzNdKSAtICh3aWR0aC8yKSl8MDtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgd2lkdGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0TG9jYXRpb24oY2hyLCBzdGFydCwgZW5kLCBzdGF0dXNDYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFnIHx8IGcubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWFyY2hDb3VudCA9IDA7XG4gICAgICAgIHZhciBmb3VuZExhdGNoID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIHNlYXJjaENhbGxiYWNrID0gZnVuY3Rpb24oZm91bmQsIGVycikge1xuICAgICAgICAgICAgLS1zZWFyY2hDb3VudDtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHVzQ2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFmb3VuZCkgZm91bmQgPSBbXTtcbiAgICAgICAgICAgIHZhciBtaW4gPSA1MDAwMDAwMDAsIG1heCA9IC0xMDAwMDAwMDA7XG4gICAgICAgICAgICB2YXIgbmNociA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZm91bmQubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBmb3VuZFtmaV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobmNociA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5jaHIgPSBmLnNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgZi5taW4pO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZi5tYXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIW5jaHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoQ291bnQgPT0gMCAmJiAhZm91bmRMYXRjaClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXR1c0NhbGxiYWNrKFwibm8gbWF0Y2ggZm9yICdcIiArIGcgKyBcIidcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvdW5kTGF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXNCLmhpZ2hsaWdodFJlZ2lvbihuY2hyLCBtaW4sIG1heCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IE1hdGgubWF4KDI1MDAsICgwLjMgKiAobWF4IC0gbWluICsgMSkpfDApO1xuICAgICAgICAgICAgICAgIHRoaXNCLnNldExvY2F0aW9uKG5jaHIsIG1pbiAtIHBhZGRpbmcsIG1heCArIHBhZGRpbmcsIHN0YXR1c0NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb1RyaXhTZWFyY2ggPSBmdW5jdGlvbih0aWVyLCB0cml4KSB7XG4gICAgICAgICAgICB0cml4Lmxvb2t1cChnLCBmdW5jdGlvbihyZXN1bHQsIHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCByZXN1bHQubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGllci5mZWF0dXJlU291cmNlLnNlYXJjaChnLCBzZWFyY2hDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhpdCA9IHJlc3VsdFsxXS5zcGxpdCgnLCcpWzBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGllci5mZWF0dXJlU291cmNlLnNlYXJjaChoaXQsIHNlYXJjaENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlYXJjaEVuZHBvaW50KSB7XG4gICAgICAgICAgICBzZWFyY2hDb3VudCA9IDE7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0Rhc1NlYXJjaCh0aGlzQi5zZWFyY2hFbmRwb2ludCwgZywgc2VhcmNoQ2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHRoaXMudGllcnMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24odGllcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzQi5zb3VyY2VBZGFwdGVySXNDYXBhYmxlKHRpZXIuZmVhdHVyZVNvdXJjZSwgJ3NlYXJjaCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWVyLmRhc1NvdXJjZS50cml4VVJJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3NlYXJjaENvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpZXIudHJpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVHJpeFNlYXJjaCh0aWVyLCB0aWVyLnRyaXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0VHJpeChuZXcgVVJMRmV0Y2hhYmxlKHRpZXIuZGFzU291cmNlLnRyaXhVUkkpLCBuZXcgVVJMRmV0Y2hhYmxlKHRpZXIuZGFzU291cmNlLnRyaXhVUkkgKyAneCcpLCBmdW5jdGlvbih0cml4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpZXIudHJpeCA9IHRyaXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVHJpeFNlYXJjaCh0aWVyLCB0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICsrc2VhcmNoQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWVyLmZlYXR1cmVTb3VyY2Uuc2VhcmNoKGcsIHNlYXJjaENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGllci5kYXNTb3VyY2UucHJvdmlkZXNfc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgICsrc2VhcmNoQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLmRvRGFzU2VhcmNoKHRpZXIuZGFzU291cmNlLCBnLCBzZWFyY2hDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkodGhpcy50aWVyc1t0aV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5kb0Rhc1NlYXJjaCA9IGZ1bmN0aW9uKHNvdXJjZSwgZywgc2VhcmNoQ2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHNvdXJjZS5mZWF0dXJlcyhudWxsLCB7Z3JvdXA6IGcsIHR5cGU6ICd0cmFuc2NyaXB0J30sIGZ1bmN0aW9uKGZvdW5kKSB7XG4gICAgICAgIGlmICghZm91bmQpIGZvdW5kID0gW107XG4gICAgICAgIHZhciBtaW4gPSA1MDAwMDAwMDAsIG1heCA9IC0xMDAwMDAwMDA7XG4gICAgICAgIHZhciBuY2hyID0gbnVsbDtcblxuICAgICAgICB2YXIgZm91bmQyID0gW107XG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmb3VuZC5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgIHZhciBmID0gZm91bmRbZmldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZi5sYWJlbC50b0xvd2VyQ2FzZSgpICE9IGcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIC8vIC4uLmJlY2F1c2UgRGF6emxlIGNhbiByZXR1cm4gc3B1cmlvdXMgb3ZlcmxhcHBpbmcgZmVhdHVyZXMuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3VuZDIucHVzaChmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWFyY2hDYWxsYmFjayhmb3VuZDIpO1xuICAgIH0sIGZhbHNlKTtcbn0iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEyXG4vL1xuLy8gc2VxdWVuY2UtZHJhdy5qczogcmVuZGVyZXJzIGZvciBzZXF1ZW5jZS1yZWxhdGVkIGRhdGFcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgZm9ybWF0TG9uZ0ludCA9IHV0aWxzLmZvcm1hdExvbmdJbnQ7XG4gICAgdmFyIG1ha2VFbGVtZW50TlMgPSB1dGlscy5tYWtlRWxlbWVudE5TO1xuXG4gICAgdmFyIHN2Z3UgPSByZXF1aXJlKCcuL3N2Zy11dGlscycpO1xuICAgIHZhciBOU19TVkcgPSBzdmd1Lk5TX1NWRztcbiAgICB2YXIgTlNfWExJTksgPSBzdmd1Lk5TX1hMSU5LO1xuICAgIHZhciBTVkdQYXRoID0gc3ZndS5TVkdQYXRoO1xuXG4gICAgdmFyIG5mID0gcmVxdWlyZSgnLi9udW1mb3JtYXRzJyk7XG4gICAgdmFyIGZvcm1hdExvbmdJbnQgPSBuZi5mb3JtYXRMb25nSW50O1xufVxuXG52YXIgTUlOX1RJTEUgPSAxMDA7XG52YXIgcnVsZXJUaWxlQ29sb3JzID0gWydibGFjaycsICd3aGl0ZSddO1xuXG52YXIgc3RlcHMgPSBbMSwyLDVdO1xuXG5cbnZhciBOU19TVkcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG5cbmZ1bmN0aW9uIHRpbGVTaXplRm9yU2NhbGUoc2NhbGUsIG1pbilcbntcbiAgICBpZiAoIW1pbikge1xuICAgICAgICBtaW4gPSBNSU5fVElMRTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cyhwKSB7XG4gICAgICAgIHJldHVybiBzdGVwc1twICUgc3RlcHMubGVuZ3RoXSAqIE1hdGgucG93KDEwLCAocCAvIHN0ZXBzLmxlbmd0aCl8MCk7XG4gICAgfVxuICAgIHZhciBwb3cgPSBzdGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKHNjYWxlICogdHMocG93KSA8IG1pbikge1xuICAgICAgICArK3BvdztcbiAgICB9XG4gICAgcmV0dXJuIHRzKHBvdyk7XG59XG5cbmZ1bmN0aW9uIGRyYXdTZXFUaWVyKHRpZXIsIHNlcSkge1xuICAgIHZhciBnYyA9IHRpZXIudmlld3BvcnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgcmV0aW5hID0gdGllci5icm93c2VyLnJldGluYSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDE7XG4gICAgdmFyIGRlc2lyZWRXaWR0aCA9IHRpZXIuYnJvd3Nlci5mZWF0dXJlUGFuZWxXaWR0aCArIDIwMDA7XG4gICAgaWYgKHJldGluYSkge1xuICAgICAgICBkZXNpcmVkV2lkdGggKj0gMjtcbiAgICB9XG4gICAgdmFyIGZwdyA9IHRpZXIudmlld3BvcnQud2lkdGh8MDsgLy8gdGhpcy5icm93c2VyLmZlYXR1cmVQYW5lbFdpZHRoO1xuICAgIGlmIChmcHcgPCBkZXNpcmVkV2lkdGggLSA1MCkge1xuICAgICAgICB0aWVyLnZpZXdwb3J0LndpZHRoID0gZnB3ID0gZGVzaXJlZFdpZHRoO1xuICAgIH1cblxuICAgIHZhciBoZWlnaHQgPSA1MDtcbiAgICBpZiAoc2VxICYmIHNlcS5zZXEpIHtcbiAgICAgICAgaGVpZ2h0ICs9IDI1O1xuICAgIH1cblxuICAgIHZhciBjYW52YXNIZWlnaHQgPSBoZWlnaHQ7XG4gICAgaWYgKHJldGluYSkgXG4gICAgICAgIGNhbnZhc0hlaWdodCAqPSAyO1xuXG4gICAgdGllci52aWV3cG9ydC5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgdGllci52aWV3cG9ydC5zdHlsZS5oZWlnaHQgPSAnJyArIGhlaWdodCArICdweCc7XG4gICAgdGllci52aWV3cG9ydC5zdHlsZS53aWR0aCA9IHJldGluYSA/ICgnJyArIChmcHcvMikgKyAncHgnKSA6ICgnJyArIGZwdyArICdweCcpO1xuICAgIHRpZXIubGF5b3V0SGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRpZXIudXBkYXRlSGVpZ2h0KCk7XG5cbiAgICBcbiAgICBpZiAodGllci5iYWNrZ3JvdW5kKSB7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IHRpZXIuYmFja2dyb3VuZDtcbiAgICAgICAgZ2MuZmlsbFJlY3QoMCwgMCwgZnB3LCB0aWVyLnZpZXdwb3J0LmhlaWdodCk7XG4gICAgfVxuICAgIGlmIChyZXRpbmEpIHtcbiAgICAgICAgZ2Muc2NhbGUoMiwgMik7XG4gICAgfVxuXG4gICAgZ2MudHJhbnNsYXRlKDEwMDAsMCk7XG4gICAgZHJhd1NlcVRpZXJHQyh0aWVyLCBzZXEsIGdjKTtcbiAgICB0aWVyLm5vcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuICAgIHRpZXIudmlld3BvcnRIb2xkZXIuc3R5bGUubGVmdCA9ICctMTAwMHB4Jztcbn1cblxuZnVuY3Rpb24gZHJhd1NlcVRpZXJHQyh0aWVyLCBzZXEsIGdjKVxue1xuICAgIHZhciBzY2FsZSA9IHRpZXIuYnJvd3Nlci5zY2FsZSwga25vd25TdGFydCA9IHRpZXIuYnJvd3Nlci52aWV3U3RhcnQgLSAoMTAwMC9zY2FsZSl8MCwga25vd25FbmQgPSB0aWVyLmJyb3dzZXIudmlld0VuZCArICgyMDAwL3NjYWxlKSwgY3VycmVudFNlcU1heCA9IHRpZXIuYnJvd3Nlci5jdXJyZW50U2VxTWF4O1xuXG4gICAgdmFyIHNlcVRpZXJNYXggPSBrbm93bkVuZDtcbiAgICBpZiAoY3VycmVudFNlcU1heCA+IDAgJiYgY3VycmVudFNlcU1heCA8IGtub3duRW5kKSB7XG4gICAgICAgIHNlcVRpZXJNYXggPSBjdXJyZW50U2VxTWF4O1xuICAgIH1cbiAgICB2YXIgdGlsZSA9IHRpbGVTaXplRm9yU2NhbGUoc2NhbGUpO1xuICAgIHZhciBwb3MgPSBNYXRoLm1heCgwLCAoKGtub3duU3RhcnQgLyB0aWxlKXwwKSAqIHRpbGUpO1xuICAgIFxuICAgIHZhciBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgd2hpbGUgKHBvcyA8PSBzZXFUaWVyTWF4KSB7XG5cdFx0Z2MuZmlsbFN0eWxlID0gKChwb3MgLyB0aWxlKSAlIDIgPT0gMCkgPyAnd2hpdGUnIDogJ2JsYWNrJztcblx0XHRnYy5zdHJva2VTdHlsZSA9ICdibGFjayc7XG5cdFx0Z2MuZmlsbFJlY3QoKHBvcyAtIG9yaWdpbikgKiBzY2FsZSxcblx0XHRcdCAgICA4LFxuXHRcdFx0ICAgIHRpbGUqc2NhbGUsXG5cdFx0XHQgICAgMyk7XG5cdFx0Z2Muc3Ryb2tlUmVjdCgocG9zIC0gb3JpZ2luKSAqIHNjYWxlLFxuXHRcdFx0ICAgICAgOCxcblx0XHRcdCAgICAgIHRpbGUqc2NhbGUsXG5cdFx0XHQgICAgICAzKTtcblxuXHRcdGdjLmZpbGxTdHlsZSA9ICdibGFjayc7XG5cdFx0Z2MuZmlsbFRleHQoZm9ybWF0TG9uZ0ludChwb3MpLCAoKHBvcyAtIG9yaWdpbikgKiBzY2FsZSksIDIyKTtcblx0XHRcblxuXHRcdHBvcyArPSB0aWxlO1xuICAgIH1cblxuICAgIGlmIChzZXEgJiYgc2VxLnNlcSkge1xuXHRcdGZvciAodmFyIHAgPSBrbm93blN0YXJ0OyBwIDw9IGtub3duRW5kOyArK3ApIHtcblx0XHQgICAgaWYgKHAgPj0gc2VxLnN0YXJ0ICYmIHAgPD0gc2VxLmVuZCkge1xuXHRcdFx0XHR2YXIgYmFzZSA9IHNlcS5zZXEuc3Vic3RyKHAgLSBzZXEuc3RhcnQsIDEpLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHRcdHZhciBjb2xvciA9IHRpZXIuYnJvd3Nlci5iYXNlQ29sb3JzW2Jhc2VdO1xuXHRcdFx0XHRpZiAoIWNvbG9yKSB7XG5cdFx0ICAgICAgICAgICAgY29sb3IgPSAnZ3JheSc7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRnYy5maWxsU3R5bGUgPSBjb2xvcjtcblxuXHRcdFx0XHRpZiAoc2NhbGUgPj0gOCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdyA9IGdjLm1lYXN1cmVUZXh0KGJhc2UpLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhzY2FsZS13KTtcblx0XHRcdFx0ICAgIGdjLmZpbGxUZXh0KGJhc2UsIChwIC0gb3JpZ2luKSAqIHNjYWxlICsgKChzY2FsZS13KSowLjUpICwgNTIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQgICAgZ2MuZmlsbFJlY3QoKHAgLSBvcmlnaW4pICogc2NhbGUsIDQyLCBzY2FsZSwgMTIpOyBcblx0XHRcdFx0fVxuXHRcdCAgICB9XG5cdFx0fVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc3ZnU2VxVGllcih0aWVyLCBzZXEpIHtcbiAgICB2YXIgc2NhbGUgPSB0aWVyLmJyb3dzZXIuc2NhbGUsIGtub3duU3RhcnQgPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0IC0gKDEwMDAvc2NhbGUpfDAsIGtub3duRW5kID0gdGllci5icm93c2VyLnZpZXdFbmQgKyAoMjAwMC9zY2FsZSksIGN1cnJlbnRTZXFNYXggPSB0aWVyLmJyb3dzZXIuY3VycmVudFNlcU1heDtcblxuICAgIHZhciBmcHcgPSB0aWVyLnZpZXdwb3J0LndpZHRofDA7IFxuXG4gICAgdmFyIHNlcVRpZXJNYXggPSBrbm93bkVuZDtcbiAgICBpZiAoY3VycmVudFNlcU1heCA+IDAgJiYgY3VycmVudFNlcU1heCA8IGtub3duRW5kKSB7XG4gICAgICAgIHNlcVRpZXJNYXggPSBjdXJyZW50U2VxTWF4O1xuICAgIH1cbiAgICB2YXIgdGlsZSA9IHRpbGVTaXplRm9yU2NhbGUoc2NhbGUpO1xuICAgIHZhciBwb3MgPSBNYXRoLm1heCgwLCAoKGtub3duU3RhcnQgLyB0aWxlKXwwKSAqIHRpbGUpO1xuICAgIFxuICAgIHZhciBvcmlnaW4gPSB0aWVyLmJyb3dzZXIudmlld1N0YXJ0O1xuXG4gICAgdmFyICBnID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJywgW10sIHtmb250U2l6ZTogJzhwdCd9KTsgXG4gICAgd2hpbGUgKHBvcyA8PSBzZXFUaWVyTWF4KSB7XG4gICAgXHRnLmFwcGVuZENoaWxkKFxuICAgIFx0ICAgIG1ha2VFbGVtZW50TlMoXG4gICAgXHRcdE5TX1NWRywgJ3JlY3QnLFxuICAgIFx0XHRudWxsLFxuICAgIFx0XHR7eDogKHBvcy1vcmlnaW4pKnNjYWxlLFxuICAgIFx0XHQgeTogOCxcbiAgICBcdFx0IHdpZHRoOiB0aWxlKnNjYWxlLFxuICAgIFx0XHQgaGVpZ2h0OiAzLFxuICAgIFx0XHQgZmlsbDogKChwb3MgLyB0aWxlKSAlIDIgPT0gMCkgPyAnd2hpdGUnIDogJ2JsYWNrJyxcbiAgICBcdFx0IHN0cm9rZTogJ2JsYWNrJ30pKTtcblxuICAgIFx0Zy5hcHBlbmRDaGlsZChcbiAgICBcdCAgICBtYWtlRWxlbWVudE5TKFxuICAgIFx0XHROU19TVkcsICd0ZXh0JyxcbiAgICBcdFx0Zm9ybWF0TG9uZ0ludChwb3MpLFxuICAgIFx0XHR7eDogKHBvcy1vcmlnaW4pKnNjYWxlLFxuICAgIFx0XHQgeTogMjgsXG4gICAgXHRcdCBmaWxsOiAnYmxhY2snLCBzdHJva2U6ICdub25lJ30pKTtcbiAgICBcdFxuICAgIFx0cG9zICs9IHRpbGU7XG4gICAgfVxuXG4gICAgaWYgKHNlcSAmJiBzZXEuc2VxKSB7XG4gICAgXHRmb3IgKHZhciBwID0ga25vd25TdGFydDsgcCA8PSBrbm93bkVuZDsgKytwKSB7XG4gICAgXHQgICAgaWYgKHAgPj0gc2VxLnN0YXJ0ICYmIHAgPD0gc2VxLmVuZCkge1xuICAgICAgICBcdFx0dmFyIGJhc2UgPSBzZXEuc2VxLnN1YnN0cihwIC0gc2VxLnN0YXJ0LCAxKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBcdFx0dmFyIGNvbG9yID0gdGllci5icm93c2VyLmJhc2VDb2xvcnNbYmFzZV07XG4gICAgICAgIFx0XHRpZiAoIWNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gJ2dyYXknO1xuICAgICAgICBcdFx0fVxuXG4gICAgICAgIFx0XHRpZiAoc2NhbGUgPj0gOCkge1xuICAgICAgICBcdFx0ICAgIGcuYXBwZW5kQ2hpbGQoXG4gICAgICAgIFx0XHRcdG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIGJhc2UsIHtcbiAgICAgICAgXHRcdFx0ICAgIHg6ICgwLjUrcC1vcmlnaW4pKnNjYWxlLFxuICAgICAgICBcdFx0XHQgICAgeTogNTIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgICAgXHRcdFx0ICAgIGZpbGw6IGNvbG9yfSkpO1xuICAgICAgICBcdFx0fSBlbHNlIHtcbiAgICAgICAgXHRcdCAgICBnLmFwcGVuZENoaWxkKFxuICAgICAgICBcdFx0XHRtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3JlY3QnLCBudWxsLCB7XG4gICAgICAgIFx0XHRcdCAgICB4OiAocCAtIG9yaWdpbikqc2NhbGUsXG4gICAgICAgIFx0XHRcdCAgICB5OiA0MixcbiAgICAgICAgXHRcdFx0ICAgIHdpZHRoOiBzY2FsZSxcbiAgICAgICAgXHRcdFx0ICAgIGhlaWdodDogMTIsXG4gICAgICAgIFx0ICAgICAgICAgICAgZmlsbDogY29sb3J9KSk7XG5cbiAgICAgICAgXHRcdH1cbiAgICBcdCAgICB9XG4gICAgXHR9XG4gICAgfSBcblxuICAgIHJldHVybiBnO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGRyYXdTZXFUaWVyOiBkcmF3U2VxVGllcixcbiAgICAgICAgZHJhd1NlcVRpZXJHQzogZHJhd1NlcVRpZXJHQyxcbiAgICAgICAgc3ZnU2VxVGllcjogc3ZnU2VxVGllclxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gc2Vzc2lvbi5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciBzYyA9IHJlcXVpcmUoJy4vc291cmNlY29tcGFyZScpO1xuICAgIHZhciBzb3VyY2VEYXRhVVJJID0gc2Muc291cmNlRGF0YVVSSTtcbiAgICB2YXIgc291cmNlc0FyZUVxdWFsID0gc2Muc291cmNlc0FyZUVxdWFsO1xuXG4gICAgdmFyIFZFUlNJT04gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWluaUpTT05pZnkgPSB1dGlscy5taW5pSlNPTmlmeTtcblxuICAgIHZhciBzaGExID0gcmVxdWlyZSgnLi9zaGExJyk7XG4gICAgdmFyIGhleF9zaGExID0gc2hhMS5oZXhfc2hhMTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubnVrZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctY2hyJ107XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcudmlldy1zdGFydCddO1xuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctZW5kJ107XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuY3VycmVudC1zZXEtbGVuZ3RoJ107XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuc2hvd2luZy1hbHQtem9vbSddO1xuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNhdmVkLXpvb20nXTtcblxuICAgIGRlbGV0ZSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNvdXJjZXMnXTtcbiAgICBkZWxldGUgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5odWJzJ107XG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcudmVyc2lvbiddO1xuXG4gICAgZGVsZXRlIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcucmV2ZXJzZS1zY3JvbGxpbmcnXTtcbiAgICBkZWxldGUgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5yZXZlcnNlLWtleS1zY3JvbGxpbmcnXTtcbiAgICBkZWxldGUgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5ydWxlci1sb2NhdGlvbiddO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5zdG9yZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcmVWaWV3U3RhdHVzKCk7XG4gICAgdGhpcy5zdG9yZVRpZXJTdGF0dXMoKTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUuc3RvcmVWaWV3U3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmNvb2tpZUtleSB8fCB0aGlzLm5vUGVyc2lzdCB8fCB0aGlzLm5vUGVyc2lzdFZpZXcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcudmlldy1jaHInXSA9IHRoaXMuY2hyO1xuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcudmlldy1zdGFydCddID0gdGhpcy52aWV3U3RhcnR8MDtcbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctZW5kJ10gPSB0aGlzLnZpZXdFbmR8MFxuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuc2hvd2luZy1hbHQtem9vbSddID0gJycgKyB0aGlzLmlzU25hcFpvb21pbmc7XG4gICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5zYXZlZC16b29tJ10gPSB0aGlzLnNhdmVkWm9vbTtcbiAgICBpZiAodGhpcy5jdXJyZW50U2VxTWF4KSB7XG5cdCAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuY3VycmVudC1zZXEtbGVuZ3RoJ10gPSB0aGlzLmN1cnJlbnRTZXFNYXg7XG4gICAgfVxufVxuXG5cbkJyb3dzZXIucHJvdG90eXBlLnN0b3JlVGllclN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jb29raWVLZXkgfHwgdGhpcy5ub1BlcnNpc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50U291cmNlTGlzdCA9IFtdO1xuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGhpcy50aWVycy5sZW5ndGg7ICsrdCkge1xuICAgICAgICB2YXIgdHQgPSB0aGlzLnRpZXJzW3RdO1xuICAgICAgICB2YXIgdHMgPSB0dC5kYXNTb3VyY2U7XG4gICAgICAgIGlmICghdHMubm9QZXJzaXN0KSB7XG4gICAgICAgICAgICBjdXJyZW50U291cmNlTGlzdC5wdXNoKHtzb3VyY2U6IHR0LmRhc1NvdXJjZSwgY29uZmlnOiB0dC5jb25maWcgfHwge319KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNvdXJjZXMnXSA9IEpTT04uc3RyaW5naWZ5KGN1cnJlbnRTb3VyY2VMaXN0KTtcblxuXG4gICAgdmFyIGNvdmVyZWRIdWJVUkxzID0ge307XG4gICAgdmFyIGN1cnJlbnRIdWJMaXN0ID0gW107XG4gICAgZm9yICh2YXIgaGkgPSAwOyBoaSA8IHRoaXMuaHViT2JqZWN0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgdmFyIHRkYiA9IHRoaXMuaHViT2JqZWN0c1toaV07XG4gICAgICAgIHZhciBoYyA9IHt1cmw6IHRkYi5odWIudXJsLCBnZW5vbWU6IHRkYi5nZW5vbWV9O1xuICAgICAgICBpZiAodGRiLmNyZWRlbnRpYWxzKVxuICAgICAgICAgICAgaGMuY3JlZGVudGlhbHMgPSB0ZGIuY3JlZGVudGlhbHM7XG4gICAgICAgIGlmICh0ZGIubWFwcGluZylcbiAgICAgICAgICAgIGhjLm1hcHBpbmcgPSB0ZGIubWFwcGluZztcbiAgICAgICAgY292ZXJlZEh1YlVSTHNbaGMudXJsXSA9IHRydWU7XG4gICAgICAgIGN1cnJlbnRIdWJMaXN0LnB1c2goaGMpO1xuICAgIH1cblxuICAgIC8vIE5lZWRlZCB0byBoYW5kbGUgaHVicyB0aGF0IGZhaWxlZCB0byBjb25uZWN0LCBvciBodWJzIHRoYXQgaGF2ZW4ndFxuICAgIC8vIGNvbm5lY3RlZCB5ZXQgd2hlbiB3ZSdyZSBjYWxsZWQgc29vbiBhZnRlciBzdGFydHVwLlxuICAgIGZvciAodmFyIGhpID0gMDsgaGkgPCB0aGlzLmh1YnMubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgIHZhciBoYyA9IHRoaXMuaHVic1toaV07XG4gICAgICAgIGlmICh0eXBlb2YgaGMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgaGMgPSB7dXJsOiBoY307XG4gICAgICAgIGlmICghY292ZXJlZEh1YlVSTHNbaGMudXJsXSlcbiAgICAgICAgICAgIGN1cnJlbnRIdWJMaXN0LnB1c2goaGMpO1xuICAgIH1cblxuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuaHVicyddID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudEh1Ykxpc3QpO1xuXG4gICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5yZXZlcnNlLXNjcm9sbGluZyddID0gdGhpcy5yZXZlcnNlU2Nyb2xsaW5nO1xuICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcucmV2ZXJzZS1rZXktc2Nyb2xsaW5nJ10gPSB0aGlzLnJldmVyc2VLZXlTY3JvbGxpbmc7XG4gICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5zaW5nbGUtYmFzZS1oaWdobGlnaHQnXSA9IHRoaXMuc2luZ2xlQmFzZUhpZ2hsaWdodDtcbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnJ1bGVyLWxvY2F0aW9uJ10gPSB0aGlzLnJ1bGVyTG9jYXRpb247XG5cbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLmV4cG9ydC1ydWxlciddID0gdGhpcy5leHBvcnRSdWxlcjtcbiAgICBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLmV4cG9ydC1oaWdobGlnaHRzJ10gPSB0aGlzLmV4cG9ydEhpZ2hsaWdodHM7XG4gICAgXG4gICAgbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy52ZXJzaW9uJ10gPSBWRVJTSU9OLkNPTkZJRztcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVzdG9yZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm5vUGVyc2lzdClcbiAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgIHZhciBzdG9yZWRDb25maWdWZXJzaW9uID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy52ZXJzaW9uJ107XG4gICAgaWYgKHN0b3JlZENvbmZpZ1ZlcnNpb24pIHtcbiAgICAgICAgc3RvcmVkQ29uZmlnVmVyc2lvbiA9IHN0b3JlZENvbmZpZ1ZlcnNpb258MDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZWRDb25maWdWZXJzaW9uID0gLTEwMDtcbiAgICB9XG4gICAgaWYgKFZFUlNJT04uQ09ORklHICE9IHN0b3JlZENvbmZpZ1ZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdG9yZWRDb25maWdIYXNoID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5jb25maWdIYXNoJ10gfHwgJyc7XG4gICAgdmFyIHBhZ2VDb25maWdIYXNoID0gaGV4X3NoYTEobWluaUpTT05pZnkoe3NvdXJjZXM6IHRoaXMuc291cmNlcywgaHViczogdGhpcy5odWJzfSkpO1xuICAgIGlmIChwYWdlQ29uZmlnSGFzaCAhPSBzdG9yZWRDb25maWdIYXNoKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuY29uZmlnSGFzaCddID0gcGFnZUNvbmZpZ0hhc2g7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFNvdXJjZXNCeVVSSSA9IHt9O1xuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aGlzLnNvdXJjZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbc2ldO1xuICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciB1cmkgPSBzb3VyY2VEYXRhVVJJKHNvdXJjZSk7XG4gICAgICAgIHZhciB1bCA9IGRlZmF1bHRTb3VyY2VzQnlVUklbdXJpXTtcbiAgICAgICAgaWYgKCF1bClcbiAgICAgICAgICAgIGRlZmF1bHRTb3VyY2VzQnlVUklbdXJpXSA9IHVsID0gW107XG4gICAgICAgIHVsLnB1c2goc291cmNlKTtcbiAgICAgICAgXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm5vUGVyc2lzdFZpZXcpIHtcbiAgICAgICAgdmFyIHFDaHIgPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctY2hyJ107XG4gICAgICAgIHZhciBxTWluID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy52aWV3LXN0YXJ0J118MDtcbiAgICAgICAgdmFyIHFNYXggPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnZpZXctZW5kJ118MDtcbiAgICAgICAgaWYgKHFDaHIgJiYgcU1pbiAmJiBxTWF4KSB7XG4gICAgICAgIFx0dGhpcy5jaHIgPSBxQ2hyO1xuICAgICAgICBcdHRoaXMudmlld1N0YXJ0ID0gcU1pbjtcbiAgICAgICAgXHR0aGlzLnZpZXdFbmQgPSBxTWF4O1xuICAgICAgICBcdFxuICAgICAgICBcdHZhciBjc20gPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLmN1cnJlbnQtc2VxLWxlbmd0aCddO1xuICAgICAgICBcdGlmIChjc20pIHtcbiAgICAgICAgXHQgICAgdGhpcy5jdXJyZW50U2VxTWF4ID0gY3NtfDA7XG4gICAgICAgIFx0fVxuXG4gICAgICAgICAgICB0aGlzLmlzU25hcFpvb21pbmcgPSAobG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5zaG93aW5nLWFsdC16b29tJ10pID09ICd0cnVlJztcblxuICAgICAgICAgICAgdmFyIHN6ID0gcGFyc2VGbG9hdChsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNhdmVkLXpvb20nXSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN6ID09PSAnbnVtYmVyJyAmJiAhaXNOYU4oc3opKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYXZlZFpvb20gPSBzejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBycyA9IGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcucmV2ZXJzZS1zY3JvbGxpbmcnXTtcbiAgICB0aGlzLnJldmVyc2VTY3JvbGxpbmcgPSAocnMgJiYgcnMgPT0gJ3RydWUnKTtcbiAgICB2YXIgcmtzID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5yZXZlcnNlLWtleS1zY3JvbGxpbmcnXTtcbiAgICB0aGlzLnJldmVyc2VLZXlTY3JvbGxpbmcgPSAocmtzICYmIHJrcyA9PSAndHJ1ZScpO1xuICAgIHZhciBzYmggPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLnNpbmdsZS1iYXNlLWhpZ2hsaWdodCddO1xuICAgIHRoaXMuc2luZ2xlQmFzZUhpZ2hsaWdodCA9IChzYmggJiYgc2JoID09ICd0cnVlJyk7XG4gXG4gICAgdmFyIHJsID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5ydWxlci1sb2NhdGlvbiddO1xuICAgIGlmIChybClcbiAgICAgICAgdGhpcy5ydWxlckxvY2F0aW9uID0gcmw7XG5cbiAgICB2YXIgeCA9IGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuZXhwb3J0LXJ1bGVyJ107XG4gICAgaWYgKHgpXG4gICAgICAgIHRoaXMuZXhwb3J0UnVsZXIgPSAoeCA9PT0gJ3RydWUnKTtcbiAgICB2YXIgeCA9IGxvY2FsU3RvcmFnZVsnZGFsbGlhbmNlLicgKyB0aGlzLmNvb2tpZUtleSArICcuZXhwb3J0LWhpZ2hsaWdodHMnXTtcbiAgICBpZiAoeClcbiAgICAgICAgdGhpcy5leHBvcnRIaWdobGlnaHRzID0gKHggPT09ICd0cnVlJyk7XG5cbiAgICB2YXIgc291cmNlU3RyID0gbG9jYWxTdG9yYWdlWydkYWxsaWFuY2UuJyArIHRoaXMuY29va2llS2V5ICsgJy5zb3VyY2VzJ107XG4gICAgaWYgKHNvdXJjZVN0cikge1xuXHQgICAgdmFyIHN0b3JlZFNvdXJjZXMgPSBKU09OLnBhcnNlKHNvdXJjZVN0cik7XG4gICAgICAgIHRoaXMuc291cmNlcyA9IFtdO1xuICAgICAgICB0aGlzLnJlc3RvcmVkQ29uZmlncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc3RvcmVkU291cmNlcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZXNbc2ldID0gc3RvcmVkU291cmNlc1tzaV0uc291cmNlO1xuICAgICAgICAgICAgdGhpcy5yZXN0b3JlZENvbmZpZ3Nbc2ldID0gc3RvcmVkU291cmNlc1tzaV0uY29uZmlnO1xuICAgICAgICAgICAgdmFyIHVyaSA9IHNvdXJjZURhdGFVUkkoc291cmNlKTtcbiAgICAgICAgICAgIHZhciB1bCA9IGRlZmF1bHRTb3VyY2VzQnlVUklbdXJpXSB8fCBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIG9zaSA9IDA7IG9zaSA8IHVsLmxlbmd0aDsgKytvc2kpIHsgICAgXG4gICAgICAgICAgICAgICAgdmFyIG9sZFNvdXJjZSA9IHVsW29zaV07XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZXNBcmVFcXVhbChzb3VyY2UsIG9sZFNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvbGRTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbGRTb3VyY2UuaGFzT3duUHJvcGVydHkoaykgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZihvbGRTb3VyY2Vba10pID09PSAnZnVuY3Rpb24nIHx8IG9sZFNvdXJjZVtrXSBpbnN0YW5jZW9mIEJsb2IpKVxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZVtrXSA9IG9sZFNvdXJjZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBodWJTdHIgPSBsb2NhbFN0b3JhZ2VbJ2RhbGxpYW5jZS4nICsgdGhpcy5jb29raWVLZXkgKyAnLmh1YnMnXTtcbiAgICBpZiAoaHViU3RyKSB7XG4gICAgICAgIHRoaXMuaHVicyA9IEpTT04ucGFyc2UoaHViU3RyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy50aWVycy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgIHRoaXMucmVtb3ZlVGllcih7aW5kZXg6IGl9LCB0cnVlKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRlZmF1bHRTb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5kZWZhdWx0U291cmNlc1tpXTtcbiAgICAgICAgaWYgKCFzLmRpc2FibGVkKSBcbiAgICAgICAgICAgIHRoaXMuYWRkVGllcih0aGlzLmRlZmF1bHRTb3VyY2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZ2hsaWdodHMuc3BsaWNlKDAsIHRoaXMuaGlnaGxpZ2h0cy5sZW5ndGgpO1xuXG4gICAgdGhpcy5zZXRMb2NhdGlvbih0aGlzLmRlZmF1bHRDaHIsIHRoaXMuZGVmYXVsdFN0YXJ0LCB0aGlzLmRlZmF1bHRFbmQpO1xufVxuIiwiLypcclxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBTZWN1cmUgSGFzaCBBbGdvcml0aG0sIFNIQS0xLCBhcyBkZWZpbmVkXHJcbiAqIGluIEZJUFMgMTgwLTFcclxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDkuXHJcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcclxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXHJcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxyXG4gKi9cclxuXHJcbiBcInVzZSBzdHJpY3RcIjtcclxuXHJcbi8qXHJcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcclxuICogdGhlIHNlcnZlci1zaWRlLCBidXQgdGhlIGRlZmF1bHRzIHdvcmsgaW4gbW9zdCBjYXNlcy5cclxuICovXHJcbnZhciBoZXhjYXNlID0gMDsgIC8qIGhleCBvdXRwdXQgZm9ybWF0LiAwIC0gbG93ZXJjYXNlOyAxIC0gdXBwZXJjYXNlICAgICAgICAqL1xyXG52YXIgYjY0cGFkICA9IFwiXCI7IC8qIGJhc2UtNjQgcGFkIGNoYXJhY3Rlci4gXCI9XCIgZm9yIHN0cmljdCBSRkMgY29tcGxpYW5jZSAgICovXHJcblxyXG4vKlxyXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcclxuICogVGhleSB0YWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgaGV4IG9yIGJhc2UtNjQgZW5jb2RlZCBzdHJpbmdzXHJcbiAqL1xyXG5mdW5jdGlvbiBoZXhfc2hhMShzKSAgICB7IHJldHVybiByc3RyMmhleChyc3RyX3NoYTEoc3RyMnJzdHJfdXRmOChzKSkpOyB9XHJcbmZ1bmN0aW9uIGI2NF9zaGExKHMpICAgIHsgcmV0dXJuIHJzdHIyYjY0KHJzdHJfc2hhMShzdHIycnN0cl91dGY4KHMpKSk7IH1cclxuZnVuY3Rpb24gYW55X3NoYTEocywgZSkgeyByZXR1cm4gcnN0cjJhbnkocnN0cl9zaGExKHN0cjJyc3RyX3V0ZjgocykpLCBlKTsgfVxyXG5mdW5jdGlvbiBoZXhfaG1hY19zaGExKGssIGQpXHJcbiAgeyByZXR1cm4gcnN0cjJoZXgocnN0cl9obWFjX3NoYTEoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSkpOyB9XHJcbmZ1bmN0aW9uIGI2NF9obWFjX3NoYTEoaywgZClcclxuICB7IHJldHVybiByc3RyMmI2NChyc3RyX2htYWNfc2hhMShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cclxuZnVuY3Rpb24gYW55X2htYWNfc2hhMShrLCBkLCBlKVxyXG4gIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfaG1hY19zaGExKHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpLCBlKTsgfVxyXG5cclxuLypcclxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGExX3ZtX3Rlc3QoKVxyXG57XHJcbiAgcmV0dXJuIGhleF9zaGExKFwiYWJjXCIpLnRvTG93ZXJDYXNlKCkgPT0gXCJhOTk5M2UzNjQ3MDY4MTZhYmEzZTI1NzE3ODUwYzI2YzljZDBkODlkXCI7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZSB0aGUgU0hBMSBvZiBhIHJhdyBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIHJzdHJfc2hhMShzKVxyXG57XHJcbiAgcmV0dXJuIGJpbmIycnN0cihiaW5iX3NoYTEocnN0cjJiaW5iKHMpLCBzLmxlbmd0aCAqIDgpKTtcclxufVxyXG5cclxuLypcclxuICogQ2FsY3VsYXRlIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSAocmF3IHN0cmluZ3MpXHJcbiAqL1xyXG5mdW5jdGlvbiByc3RyX2htYWNfc2hhMShrZXksIGRhdGEpXHJcbntcclxuICB2YXIgYmtleSA9IHJzdHIyYmluYihrZXkpO1xyXG4gIGlmKGJrZXkubGVuZ3RoID4gMTYpIGJrZXkgPSBiaW5iX3NoYTEoYmtleSwga2V5Lmxlbmd0aCAqIDgpO1xyXG5cclxuICB2YXIgaXBhZCA9IEFycmF5KDE2KSwgb3BhZCA9IEFycmF5KDE2KTtcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcclxuICB7XHJcbiAgICBpcGFkW2ldID0gYmtleVtpXSBeIDB4MzYzNjM2MzY7XHJcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XHJcbiAgfVxyXG5cclxuICB2YXIgaGFzaCA9IGJpbmJfc2hhMShpcGFkLmNvbmNhdChyc3RyMmJpbmIoZGF0YSkpLCA1MTIgKyBkYXRhLmxlbmd0aCAqIDgpO1xyXG4gIHJldHVybiBiaW5iMnJzdHIoYmluYl9zaGExKG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxNjApKTtcclxufVxyXG5cclxuLypcclxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXHJcbiAqL1xyXG5mdW5jdGlvbiByc3RyMmhleChpbnB1dClcclxue1xyXG4gIC8vIHRyeSB7IGhleGNhc2UgfSBjYXRjaChlKSB7IGhleGNhc2U9MDsgfVxyXG4gIHZhciBoZXhfdGFiID0gaGV4Y2FzZSA/IFwiMDEyMzQ1Njc4OUFCQ0RFRlwiIDogXCIwMTIzNDU2Nzg5YWJjZGVmXCI7XHJcbiAgdmFyIG91dHB1dCA9IFwiXCI7XHJcbiAgdmFyIHg7XHJcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxyXG4gIHtcclxuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgb3V0cHV0ICs9IGhleF90YWIuY2hhckF0KCh4ID4+PiA0KSAmIDB4MEYpXHJcbiAgICAgICAgICAgKyAgaGV4X3RhYi5jaGFyQXQoIHggICAgICAgICYgMHgwRik7XHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgYmFzZS02NCBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIHJzdHIyYjY0KGlucHV0KVxyXG57XHJcbiAgLy8gdHJ5IHsgYjY0cGFkIH0gY2F0Y2goZSkgeyBiNjRwYWQ9Jyc7IH1cclxuICB2YXIgdGFiID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7XHJcbiAgdmFyIG91dHB1dCA9IFwiXCI7XHJcbiAgdmFyIGxlbiA9IGlucHV0Lmxlbmd0aDtcclxuICBmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDMpXHJcbiAge1xyXG4gICAgdmFyIHRyaXBsZXQgPSAoaW5wdXQuY2hhckNvZGVBdChpKSA8PCAxNilcclxuICAgICAgICAgICAgICAgIHwgKGkgKyAxIDwgbGVuID8gaW5wdXQuY2hhckNvZGVBdChpKzEpIDw8IDggOiAwKVxyXG4gICAgICAgICAgICAgICAgfCAoaSArIDIgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrMikgICAgICA6IDApO1xyXG4gICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKylcclxuICAgIHtcclxuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGlucHV0Lmxlbmd0aCAqIDgpIG91dHB1dCArPSBiNjRwYWQ7XHJcbiAgICAgIGVsc2Ugb3V0cHV0ICs9IHRhYi5jaGFyQXQoKHRyaXBsZXQgPj4+IDYqKDMtaikpICYgMHgzRik7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFyYml0cmFyeSBzdHJpbmcgZW5jb2RpbmdcclxuICovXHJcbmZ1bmN0aW9uIHJzdHIyYW55KGlucHV0LCBlbmNvZGluZylcclxue1xyXG4gIHZhciBkaXZpc29yID0gZW5jb2RpbmcubGVuZ3RoO1xyXG4gIHZhciByZW1haW5kZXJzID0gQXJyYXkoKTtcclxuICB2YXIgaSwgcSwgeCwgcXVvdGllbnQ7XHJcblxyXG4gIC8qIENvbnZlcnQgdG8gYW4gYXJyYXkgb2YgMTYtYml0IGJpZy1lbmRpYW4gdmFsdWVzLCBmb3JtaW5nIHRoZSBkaXZpZGVuZCAqL1xyXG4gIHZhciBkaXZpZGVuZCA9IEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyAyKSk7XHJcbiAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXHJcbiAge1xyXG4gICAgZGl2aWRlbmRbaV0gPSAoaW5wdXQuY2hhckNvZGVBdChpICogMikgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIFJlcGVhdGVkbHkgcGVyZm9ybSBhIGxvbmcgZGl2aXNpb24uIFRoZSBiaW5hcnkgYXJyYXkgZm9ybXMgdGhlIGRpdmlkZW5kLFxyXG4gICAqIHRoZSBsZW5ndGggb2YgdGhlIGVuY29kaW5nIGlzIHRoZSBkaXZpc29yLiBPbmNlIGNvbXB1dGVkLCB0aGUgcXVvdGllbnRcclxuICAgKiBmb3JtcyB0aGUgZGl2aWRlbmQgZm9yIHRoZSBuZXh0IHN0ZXAuIFdlIHN0b3Agd2hlbiB0aGUgZGl2aWRlbmQgaXMgemVyby5cclxuICAgKiBBbGwgcmVtYWluZGVycyBhcmUgc3RvcmVkIGZvciBsYXRlciB1c2UuXHJcbiAgICovXHJcbiAgd2hpbGUoZGl2aWRlbmQubGVuZ3RoID4gMClcclxuICB7XHJcbiAgICBxdW90aWVudCA9IEFycmF5KCk7XHJcbiAgICB4ID0gMDtcclxuICAgIGZvcihpID0gMDsgaSA8IGRpdmlkZW5kLmxlbmd0aDsgaSsrKVxyXG4gICAge1xyXG4gICAgICB4ID0gKHggPDwgMTYpICsgZGl2aWRlbmRbaV07XHJcbiAgICAgIHEgPSBNYXRoLmZsb29yKHggLyBkaXZpc29yKTtcclxuICAgICAgeCAtPSBxICogZGl2aXNvcjtcclxuICAgICAgaWYocXVvdGllbnQubGVuZ3RoID4gMCB8fCBxID4gMClcclxuICAgICAgICBxdW90aWVudFtxdW90aWVudC5sZW5ndGhdID0gcTtcclxuICAgIH1cclxuICAgIHJlbWFpbmRlcnNbcmVtYWluZGVycy5sZW5ndGhdID0geDtcclxuICAgIGRpdmlkZW5kID0gcXVvdGllbnQ7XHJcbiAgfVxyXG5cclxuICAvKiBDb252ZXJ0IHRoZSByZW1haW5kZXJzIHRvIHRoZSBvdXRwdXQgc3RyaW5nICovXHJcbiAgdmFyIG91dHB1dCA9IFwiXCI7XHJcbiAgZm9yKGkgPSByZW1haW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgb3V0cHV0ICs9IGVuY29kaW5nLmNoYXJBdChyZW1haW5kZXJzW2ldKTtcclxuXHJcbiAgLyogQXBwZW5kIGxlYWRpbmcgemVybyBlcXVpdmFsZW50cyAqL1xyXG4gIHZhciBmdWxsX2xlbmd0aCA9IE1hdGguY2VpbChpbnB1dC5sZW5ndGggKiA4IC9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKE1hdGgubG9nKGVuY29kaW5nLmxlbmd0aCkgLyBNYXRoLmxvZygyKSkpXHJcbiAgZm9yKGkgPSBvdXRwdXQubGVuZ3RoOyBpIDwgZnVsbF9sZW5ndGg7IGkrKylcclxuICAgIG91dHB1dCA9IGVuY29kaW5nWzBdICsgb3V0cHV0O1xyXG5cclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG4vKlxyXG4gKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLTguXHJcbiAqIEZvciBlZmZpY2llbmN5LCB0aGlzIGFzc3VtZXMgdGhlIGlucHV0IGlzIHZhbGlkIHV0Zi0xNi5cclxuICovXHJcbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjgoaW5wdXQpXHJcbntcclxuICB2YXIgb3V0cHV0ID0gXCJcIjtcclxuICB2YXIgaSA9IC0xO1xyXG4gIHZhciB4LCB5O1xyXG5cclxuICB3aGlsZSgrK2kgPCBpbnB1dC5sZW5ndGgpXHJcbiAge1xyXG4gICAgLyogRGVjb2RlIHV0Zi0xNiBzdXJyb2dhdGUgcGFpcnMgKi9cclxuICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xyXG4gICAgeSA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckNvZGVBdChpICsgMSkgOiAwO1xyXG4gICAgaWYoMHhEODAwIDw9IHggJiYgeCA8PSAweERCRkYgJiYgMHhEQzAwIDw9IHkgJiYgeSA8PSAweERGRkYpXHJcbiAgICB7XHJcbiAgICAgIHggPSAweDEwMDAwICsgKCh4ICYgMHgwM0ZGKSA8PCAxMCkgKyAoeSAmIDB4MDNGRik7XHJcbiAgICAgIGkrKztcclxuICAgIH1cclxuXHJcbiAgICAvKiBFbmNvZGUgb3V0cHV0IGFzIHV0Zi04ICovXHJcbiAgICBpZih4IDw9IDB4N0YpXHJcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xyXG4gICAgZWxzZSBpZih4IDw9IDB4N0ZGKVxyXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEMwIHwgKCh4ID4+PiA2ICkgJiAweDFGKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xyXG4gICAgZWxzZSBpZih4IDw9IDB4RkZGRilcclxuICAgICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhFMCB8ICgoeCA+Pj4gMTIpICYgMHgwRiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCB4ICAgICAgICAgJiAweDNGKSk7XHJcbiAgICBlbHNlIGlmKHggPD0gMHgxRkZGRkYpXHJcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RjAgfCAoKHggPj4+IDE4KSAmIDB4MDcpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiAxMikgJiAweDNGKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gNiApICYgMHgzRiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoIHggICAgICAgICAmIDB4M0YpKTtcclxuICB9XHJcbiAgcmV0dXJuIG91dHB1dDtcclxufVxyXG5cclxuLypcclxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi0xNlxyXG4gKi9cclxuZnVuY3Rpb24gc3RyMnJzdHJfdXRmMTZsZShpbnB1dClcclxue1xyXG4gIHZhciBvdXRwdXQgPSBcIlwiO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKylcclxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5wdXQuY2hhckNvZGVBdChpKSA+Pj4gOCkgJiAweEZGKTtcclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBzdHIycnN0cl91dGYxNmJlKGlucHV0KVxyXG57XHJcbiAgdmFyIG91dHB1dCA9IFwiXCI7XHJcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxyXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0LmNoYXJDb2RlQXQoaSkgPj4+IDgpICYgMHhGRixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYpO1xyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHNcclxuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiByc3RyMmJpbmIoaW5wdXQpXHJcbntcclxuICB2YXIgb3V0cHV0ID0gQXJyYXkoaW5wdXQubGVuZ3RoID4+IDIpO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspXHJcbiAgICBvdXRwdXRbaV0gPSAwO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiA4OyBpICs9IDgpXHJcbiAgICBvdXRwdXRbaT4+NV0gfD0gKGlucHV0LmNoYXJDb2RlQXQoaSAvIDgpICYgMHhGRikgPDwgKDI0IC0gaSAlIDMyKTtcclxuICByZXR1cm4gb3V0cHV0O1xyXG59XHJcblxyXG4vKlxyXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcclxuICovXHJcbmZ1bmN0aW9uIGJpbmIycnN0cihpbnB1dClcclxue1xyXG4gIHZhciBvdXRwdXQgPSBcIlwiO1xyXG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiAzMjsgaSArPSA4KVxyXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2k+PjVdID4+PiAoMjQgLSBpICUgMzIpKSAmIDB4RkYpO1xyXG4gIHJldHVybiBvdXRwdXQ7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENhbGN1bGF0ZSB0aGUgU0hBLTEgb2YgYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aFxyXG4gKi9cclxuZnVuY3Rpb24gYmluYl9zaGExKHgsIGxlbilcclxue1xyXG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXHJcbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBsZW4gJSAzMik7XHJcbiAgeFsoKGxlbiArIDY0ID4+IDkpIDw8IDQpICsgMTVdID0gbGVuO1xyXG5cclxuICB2YXIgdyA9IEFycmF5KDgwKTtcclxuICB2YXIgYSA9ICAxNzMyNTg0MTkzO1xyXG4gIHZhciBiID0gLTI3MTczMzg3OTtcclxuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xyXG4gIHZhciBkID0gIDI3MTczMzg3ODtcclxuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xyXG5cclxuICBmb3IodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpXHJcbiAge1xyXG4gICAgdmFyIG9sZGEgPSBhO1xyXG4gICAgdmFyIG9sZGIgPSBiO1xyXG4gICAgdmFyIG9sZGMgPSBjO1xyXG4gICAgdmFyIG9sZGQgPSBkO1xyXG4gICAgdmFyIG9sZGUgPSBlO1xyXG5cclxuICAgIGZvcih2YXIgaiA9IDA7IGogPCA4MDsgaisrKVxyXG4gICAge1xyXG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcclxuICAgICAgZWxzZSB3W2pdID0gYml0X3JvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XHJcbiAgICAgIHZhciB0ID0gc2FmZV9hZGQoc2FmZV9hZGQoYml0X3JvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgc2FmZV9hZGQoc2FmZV9hZGQoZSwgd1tqXSksIHNoYTFfa3QoaikpKTtcclxuICAgICAgZSA9IGQ7XHJcbiAgICAgIGQgPSBjO1xyXG4gICAgICBjID0gYml0X3JvbChiLCAzMCk7XHJcbiAgICAgIGIgPSBhO1xyXG4gICAgICBhID0gdDtcclxuICAgIH1cclxuXHJcbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XHJcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XHJcbiAgICBjID0gc2FmZV9hZGQoYywgb2xkYyk7XHJcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XHJcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XHJcbiAgfVxyXG4gIHJldHVybiBBcnJheShhLCBiLCBjLCBkLCBlKTtcclxuXHJcbn1cclxuXHJcbi8qXHJcbiAqIFBlcmZvcm0gdGhlIGFwcHJvcHJpYXRlIHRyaXBsZXQgY29tYmluYXRpb24gZnVuY3Rpb24gZm9yIHRoZSBjdXJyZW50XHJcbiAqIGl0ZXJhdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gc2hhMV9mdCh0LCBiLCBjLCBkKVxyXG57XHJcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XHJcbiAgaWYodCA8IDQwKSByZXR1cm4gYiBeIGMgXiBkO1xyXG4gIGlmKHQgPCA2MCkgcmV0dXJuIChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKTtcclxuICByZXR1cm4gYiBeIGMgXiBkO1xyXG59XHJcblxyXG4vKlxyXG4gKiBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGFkZGl0aXZlIGNvbnN0YW50IGZvciB0aGUgY3VycmVudCBpdGVyYXRpb25cclxuICovXHJcbmZ1bmN0aW9uIHNoYTFfa3QodClcclxue1xyXG4gIHJldHVybiAodCA8IDIwKSA/ICAxNTE4NTAwMjQ5IDogKHQgPCA0MCkgPyAgMTg1OTc3NTM5MyA6XHJcbiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xyXG59XHJcblxyXG4vKlxyXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XHJcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXHJcbiAqL1xyXG5mdW5jdGlvbiBzYWZlX2FkZCh4LCB5KVxyXG57XHJcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcclxuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XHJcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XHJcbn1cclxuXHJcbi8qXHJcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cclxuICovXHJcbmZ1bmN0aW9uIGJpdF9yb2wobnVtLCBjbnQpXHJcbntcclxuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XHJcbn1cclxuXHJcbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGI2NF9zaGExOiBiNjRfc2hhMSxcclxuICAgIGhleF9zaGExOiBoZXhfc2hhMVxyXG4gIH1cclxufVxyXG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gc291cmNlYWRhcHRlcnMuanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBicm93c2VyID0gcmVxdWlyZSgnLi9jYnJvd3NlcicpO1xuICAgIHZhciBCcm93c2VyID0gYnJvd3Nlci5Ccm93c2VyO1xuXG4gICAgdmFyIHRpZXIgPSByZXF1aXJlKCcuL3RpZXInKTtcbiAgICB2YXIgRGFzVGllciA9IHRpZXIuRGFzVGllcjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuICAgIHZhciBBd2FpdGVkID0gdXRpbHMuQXdhaXRlZDtcbiAgICB2YXIgYXJyYXlJbmRleE9mID0gdXRpbHMuYXJyYXlJbmRleE9mO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xuICAgIHZhciByZXNvbHZlVXJsVG9QYWdlID0gdXRpbHMucmVzb2x2ZVVybFRvUGFnZTtcblxuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBEQVNTdHlsZXNoZWV0ID0gZGFzLkRBU1N0eWxlc2hlZXQ7XG4gICAgdmFyIERBU1N0eWxlID0gZGFzLkRBU1N0eWxlO1xuICAgIHZhciBEQVNTb3VyY2UgPSBkYXMuREFTU291cmNlO1xuICAgIHZhciBEQVNTZWdtZW50ID0gZGFzLkRBU1NlZ21lbnQ7XG4gICAgdmFyIERBU0ZlYXR1cmUgPSBkYXMuREFTRmVhdHVyZTtcbiAgICB2YXIgREFTU2VxdWVuY2UgPSBkYXMuREFTU2VxdWVuY2U7XG4gICAgdmFyIERBU0xpbmsgPSBkYXMuREFTTGluaztcblxuICAgIHZhciBiaW4gPSByZXF1aXJlKCcuL2JpbicpO1xuICAgIHZhciBVUkxGZXRjaGFibGUgPSBiaW4uVVJMRmV0Y2hhYmxlO1xuICAgIHZhciBCbG9iRmV0Y2hhYmxlID0gYmluLkJsb2JGZXRjaGFibGU7XG5cbiAgICB2YXIgdHdvQml0ID0gcmVxdWlyZSgnLi90d29CaXQnKTtcbiAgICB2YXIgbWFrZVR3b0JpdCA9IHR3b0JpdC5tYWtlVHdvQml0O1xuXG4gICAgdmFyIGJiaSA9IHJlcXVpcmUoJy4vYmlnd2lnJyk7XG4gICAgdmFyIG1ha2VCd2cgPSBiYmkubWFrZUJ3ZztcblxuICAgIHZhciBiYW0gPSByZXF1aXJlKCcuL2JhbScpO1xuICAgIHZhciBtYWtlQmFtID0gYmFtLm1ha2VCYW07XG4gICAgdmFyIEJhbUZsYWdzID0gYmFtLkJhbUZsYWdzO1xuXG4gICAgdmFyIHNwYW5zID0gcmVxdWlyZSgnLi9zcGFucycpO1xuICAgIHZhciBSYW5nZSA9IHNwYW5zLlJhbmdlO1xuICAgIHZhciB1bmlvbiA9IHNwYW5zLnVuaW9uO1xuXG4gICAgdmFyIHBhcnNlQ2lnYXIgPSByZXF1aXJlKCcuL2NpZ2FyJykucGFyc2VDaWdhcjtcblxuICAgIHZhciBPdmVybGF5RmVhdHVyZVNvdXJjZSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpLk92ZXJsYXlGZWF0dXJlU291cmNlO1xuXG4gICAgdmFyIEpCcm93c2VTdG9yZSA9IHJlcXVpcmUoJy4vamJqc29uJykuSkJyb3dzZVN0b3JlO1xuXG4gICAgdmFyIENoYWluc2V0ID0gcmVxdWlyZSgnLi9jaGFpbnNldCcpLkNoYWluc2V0O1xuXG4gICAgdmFyIHN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuICAgIHZhciBTdHlsZUZpbHRlclNldCA9IHN0eWxlLlN0eWxlRmlsdGVyU2V0O1xuXG4gICAgdmFyIEVuY29kZUZldGNoYWJsZSA9IHJlcXVpcmUoJy4vZW5jb2RlJykuRW5jb2RlRmV0Y2hhYmxlO1xufVxuXG52YXIgX19kYWxsaWFuY2Vfc291cmNlQWRhcHRlckZhY3RvcmllcyA9IHt9O1xuXG5mdW5jdGlvbiBkYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSh0eXBlLCBmYWN0b3J5KSB7XG4gICAgX19kYWxsaWFuY2Vfc291cmNlQWRhcHRlckZhY3Rvcmllc1t0eXBlXSA9IGZhY3Rvcnk7XG59O1xuXG5cbnZhciBfX2RhbGxpYW5jZV9wYXJzZXJGYWN0b3JpZXMgPSB7fTtcblxuZnVuY3Rpb24gZGFsbGlhbmNlX3JlZ2lzdGVyUGFyc2VyRmFjdG9yeSh0eXBlLCBmYWN0b3J5KSB7XG4gICAgX19kYWxsaWFuY2VfcGFyc2VyRmFjdG9yaWVzW3R5cGVdID0gZmFjdG9yeTtcbn07XG5cbmZ1bmN0aW9uIGRhbGxpYW5jZV9tYWtlUGFyc2VyKHR5cGUpIHtcbiAgICBpZiAoX19kYWxsaWFuY2VfcGFyc2VyRmFjdG9yaWVzW3R5cGVdKSB7XG4gICAgICAgIHJldHVybiBfX2RhbGxpYW5jZV9wYXJzZXJGYWN0b3JpZXNbdHlwZV0odHlwZSk7XG4gICAgfVxufTtcblxuXG5EYXNUaWVyLnByb3RvdHlwZS5pbml0U291cmNlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzVGllciA9IHRoaXM7XG5cbiAgICB2YXIgc291cmNlcyA9IHRoaXMuYnJvd3Nlci5jcmVhdGVTb3VyY2VzKHRoaXMuZGFzU291cmNlKTtcbiAgICB0aGlzLmZlYXR1cmVTb3VyY2UgPSBzb3VyY2VzLmZlYXR1cmVzIHx8IG5ldyBEdW1teUZlYXR1cmVTb3VyY2UoKTtcbiAgICB0aGlzLnNlcXVlbmNlU291cmNlID0gc291cmNlcy5zZXF1ZW5jZTtcblxuICAgIGlmICh0aGlzLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5mZWF0dXJlU291cmNlLmFkZENoYW5nZUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZVNvdXJjZS5hZGRDaGFuZ2VMaXN0ZW5lcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXNUaWVyLmJyb3dzZXIucmVmcmVzaFRpZXIodGhpc1RpZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmNyZWF0ZVNvdXJjZXMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB2YXIgc291cmNlcyA9IHRoaXMuc291cmNlQ2FjaGUuZ2V0KGNvbmZpZyk7XG4gICAgaWYgKHNvdXJjZXMpXG4gICAgICAgIHJldHVybiBzb3VyY2VzO1xuXG4gICAgdmFyIGZzLCBzcztcblxuICAgIGlmIChjb25maWcudGllcl90eXBlID09ICdzZXF1ZW5jZScgfHwgY29uZmlnLnR3b0JpdFVSSSB8fCBjb25maWcudHdvQml0QmxvYikge1xuICAgICAgICBpZiAoY29uZmlnLnR3b0JpdFVSSSB8fCBjb25maWcudHdvQml0QmxvYikge1xuICAgICAgICAgICAgc3MgPSBuZXcgVHdvQml0U2VxdWVuY2VTb3VyY2UoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNzID0gbmV3IERBU1NlcXVlbmNlU291cmNlKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbmZpZy50aWVyX3R5cGUgJiYgX19kYWxsaWFuY2Vfc291cmNlQWRhcHRlckZhY3Rvcmllc1tjb25maWcudGllcl90eXBlXSkge1xuICAgICAgICB2YXIgc2FmID0gX19kYWxsaWFuY2Vfc291cmNlQWRhcHRlckZhY3Rvcmllc1tjb25maWcudGllcl90eXBlXTtcbiAgICAgICAgdmFyIG5zID0gc2FmKGNvbmZpZyk7XG4gICAgICAgIGZzID0gbnMuZmVhdHVyZXM7XG4gICAgICAgIHNzID0gbnMuc2VxdWVuY2U7XG4gICAgfSBlbHNlIGlmIChjb25maWcuYndnVVJJIHx8IGNvbmZpZy5id2dCbG9iKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSB0aGlzLmdldFdvcmtlcigpO1xuICAgICAgICBpZiAod29ya2VyKVxuICAgICAgICAgICAgZnMgPSBuZXcgUmVtb3RlQldHRmVhdHVyZVNvdXJjZShjb25maWcsIHdvcmtlcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZzID0gbmV3IEJXR0ZlYXR1cmVTb3VyY2UoY29uZmlnKTtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZy5iYW1VUkkgfHwgY29uZmlnLmJhbUJsb2IpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHRoaXMuZ2V0V29ya2VyKCk7XG4gICAgICAgIGlmICh3b3JrZXIpXG4gICAgICAgICAgICBmcyA9IG5ldyBSZW1vdGVCQU1GZWF0dXJlU291cmNlKGNvbmZpZywgd29ya2VyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZnMgPSBuZXcgQkFNRmVhdHVyZVNvdXJjZShjb25maWcpO1xuICAgIH0gZWxzZSBpZiAoY29uZmlnLmpiVVJJKSB7XG4gICAgICAgIGZzID0gbmV3IEpCcm93c2VGZWF0dXJlU291cmNlKGNvbmZpZyk7XG4gICAgfSBlbHNlIGlmIChjb25maWcudXJpIHx8IGNvbmZpZy5mZWF0dXJlc191cmkpIHtcbiAgICAgICAgZnMgPSBuZXcgREFTRmVhdHVyZVNvdXJjZShjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcub3ZlcmxheSkge1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBpZiAoZnMpXG4gICAgICAgICAgICBzb3VyY2VzLnB1c2gobmV3IENhY2hpbmdGZWF0dXJlU291cmNlKGZzKSk7XG5cbiAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IGNvbmZpZy5vdmVybGF5Lmxlbmd0aDsgKytvaSkge1xuICAgICAgICAgICAgdmFyIGNzID0gdGhpcy5jcmVhdGVTb3VyY2VzKGNvbmZpZy5vdmVybGF5W29pXSk7XG4gICAgICAgICAgICBpZiAoY3MgJiYgY3MuZmVhdHVyZXMpXG4gICAgICAgICAgICAgICAgc291cmNlcy5wdXNoKGNzLmZlYXR1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICBmcyA9IG5ldyBPdmVybGF5RmVhdHVyZVNvdXJjZShzb3VyY2VzLCBjb25maWcpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuc2VxdWVuY2VBbGlhc2VzKSB7XG4gICAgICAgIGZzID0gbmV3IE1hcHBlZEZlYXR1cmVTb3VyY2UoZnMsIG5ldyBDaGFpbnNldCh7dHlwZTogJ2FsaWFzJywgc2VxdWVuY2VBbGlhc2VzOiBjb25maWcuc2VxdWVuY2VBbGlhc2VzfSkpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubWFwcGluZykge1xuICAgICAgICBmcyA9IG5ldyBNYXBwZWRGZWF0dXJlU291cmNlKGZzLCB0aGlzLmNoYWluc1tjb25maWcubWFwcGluZ10pO1xuICAgIH1cblxuICAgIGlmIChjb25maWcubmFtZSAmJiBmcyAmJiAhZnMubmFtZSkge1xuICAgICAgICBmcy5uYW1lID0gY29uZmlnLm5hbWU7XG4gICAgfVxuXG4gICAgaWYgKGZzICE9IG51bGwpIHtcbiAgICAgICAgZnMgPSBuZXcgQ2FjaGluZ0ZlYXR1cmVTb3VyY2UoZnMpO1xuICAgIH1cblxuICAgIGlmIChmcyAhPSBudWxsIHx8IHNzICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlcyA9IHtcbiAgICAgICAgICAgIGZlYXR1cmVzOiBmcyxcbiAgICAgICAgICAgIHNlcXVlbmNlOiBzc1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNvdXJjZUNhY2hlLnB1dChjb25maWcsIHNvdXJjZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzb3VyY2VzO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5mZXRjaFN0eWxlc2hlZXQgPSBmdW5jdGlvbihjYikge1xuICAgIHZhciBzc1NvdXJjZTtcbiAgICAvLyBTb21ld2hhdCB1Z2x5IHdvcmthcm91bmQgZm9yIHRoZSBzcGVjaWFsIGNhc2Ugb2YgREFTIHNvdXJjZXMuLi5cbiAgICBpZiAodGhpcy5kYXNTb3VyY2Uuc3R5bGVzaGVldF91cmkgfHwgKFxuICAgICAgICAhdGhpcy5kYXNTb3VyY2UudGllcl90eXBlICYmXG4gICAgICAgICF0aGlzLmRhc1NvdXJjZS5id2dVUkkgJiZcbiAgICAgICAgIXRoaXMuZGFzU291cmNlLmJ3Z0Jsb2IgJiZcbiAgICAgICAgIXRoaXMuZGFzU291cmNlLmJhbVVSSSAmJlxuICAgICAgICAhdGhpcy5kYXNTb3VyY2UuYmFtQmxvYiAmJlxuICAgICAgICAhdGhpcy5kYXNTb3VyY2UudHdvQml0VVJJICYmXG4gICAgICAgICF0aGlzLmRhc1NvdXJjZS50d29CaXRCbG9iICYmXG4gICAgICAgICF0aGlzLmRhc1NvdXJjZS5qYlVSSSAmJlxuICAgICAgICAhdGhpcy5kYXNTb3VyY2Uub3ZlcmxheSkpXG4gICAge1xuICAgICAgICBzc1NvdXJjZSA9IG5ldyBEQVNGZWF0dXJlU291cmNlKHRoaXMuZGFzU291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzc1NvdXJjZSA9IHRoaXMuZ2V0U291cmNlKCk7XG4gICAgfVxuICAgIHNzU291cmNlLmdldFN0eWxlU2hlZXQoY2IpO1xufVxuXG52YXIgX19jZnNfaWRfc2VlZCA9IDA7XG5cbmZ1bmN0aW9uIENhY2hpbmdGZWF0dXJlU291cmNlKHNvdXJjZSkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG5cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmNmc2lkID0gJ2NmcycgKyAoKytfX2Nmc19pZF9zZWVkKTtcbiAgICBpZiAoc291cmNlLm5hbWUpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gc291cmNlLm5hbWU7XG4gICAgfVxuICAgIGlmIChzb3VyY2UuYWRkQ2hhbmdlTGlzdGVuZXIpIHtcbiAgICAgICAgc291cmNlLmFkZENoYW5nZUxpc3RlbmVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpc0IuY2ZzaWQgPSAnY2ZzJyArICgrK19fY2ZzX2lkX3NlZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5hZGRSZWFkaW5lc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLmFkZFJlYWRpbmVzc0xpc3RlbmVyKVxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuYWRkUmVhZGluZXNzTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGVsc2VcbiAgICAgICAgbGlzdGVuZXIobnVsbCk7XG59XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5yZW1vdmVSZWFkaW5lc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLnJlbW92ZVJlYWRpbmVzc0xpc3RlbmVyKVxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UucmVtb3ZlUmVhZGluZXNzTGlzdGVuZXIobGlzdGVuZXIpO1xufVxuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24ocXVlcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLnNlYXJjaClcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnNlYXJjaChxdWVyeSwgY2FsbGJhY2spO1xufVxuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZJUHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnNvdXJjZS5nZXREZWZhdWx0RklQcylcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmdldERlZmF1bHRGSVBzKGNhbGxiYWNrKTsgXG59XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLnNvdXJjZS5nZXRTdHlsZVNoZWV0KGNhbGxiYWNrKTtcbn1cblxuQ2FjaGluZ0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFNjYWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5nZXRTY2FsZXMoKTtcbn1cblxuQ2FjaGluZ0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmFkZEFjdGl2aXR5TGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLmFkZEFjdGl2aXR5TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UuYWRkQWN0aXZpdHlMaXN0ZW5lcihsKTtcbiAgICB9XG59XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIGlmICh0aGlzLnNvdXJjZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc291cmNlLnJlbW92ZUFjdGl2aXR5TGlzdGVuZXIobCk7XG4gICAgfVxufVxuXG5DYWNoaW5nRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuYWRkQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbihsKSB7XG4gICAgaWYgKHRoaXMuc291cmNlLmFkZENoYW5nZUxpc3RlbmVyKVxuICAgICAgICB0aGlzLnNvdXJjZS5hZGRDaGFuZ2VMaXN0ZW5lcihsKTtcbn1cblxuQ2FjaGluZ0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnJlbW92ZUNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIGlmICh0aGlzLnNvdXJjZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lcilcbiAgICAgICAgdGhpcy5zb3VyY2UucmVtb3ZlQ2hhbmdlTGlzdGVuZXIobCk7XG59XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5maW5kTmV4dEZlYXR1cmUgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuc291cmNlLmZpbmROZXh0RmVhdHVyZShjaHIsIHBvcywgZGlyLCBjYWxsYmFjayk7XG59XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5xdWFudEZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIHRocmVzaG9sZCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnNvdXJjZS5xdWFudEZpbmROZXh0RmVhdHVyZShjaHIsIHBvcywgZGlyLCB0aHJlc2hvbGQsIGNhbGxiYWNrKTtcbn1cblxuQ2FjaGluZ0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmNhcGFiaWxpdGllcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNvdXJjZS5jYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNhcGFiaWxpdGllcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59XG5cbkNhY2hpbmdGZWF0dXJlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY2FsbGJhY2ssIHN0eWxlRmlsdGVycykge1xuICAgIGlmICghcG9vbCkge1xuICAgICAgICB0aHJvdyBFcnJvcignRmV0Y2ggcG9vbCBpcyBudWxsJyk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYWNoZUtleSA9IHRoaXMuY2ZzaWQ7XG5cbiAgICB2YXIgYXdhaXRlZEZlYXR1cmVzID0gcG9vbC5hd2FpdGVkRmVhdHVyZXNbY2FjaGVLZXldO1xuICAgIGlmIChhd2FpdGVkRmVhdHVyZXMgJiYgYXdhaXRlZEZlYXR1cmVzLnN0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKGF3YWl0ZWRGZWF0dXJlcy5zdHlsZUZpbHRlcnMuZG9lc05vdENvbnRhaW4oc3R5bGVGaWx0ZXJzKSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0ZldGNoIGFscmVhZHkgc3RhcnRlZCB3aXRoIHdyb25nIHBhcmFtZXRlcnMsIHNraXBwaW5nIGNhY2hlLicpO1xuICAgICAgICAgICAgc2VsZi5zb3VyY2UuZmV0Y2goY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaywgc3R5bGVGaWx0ZXJzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXdhaXRlZEZlYXR1cmVzKSB7XG4gICAgICAgIGF3YWl0ZWRGZWF0dXJlcy5zdHlsZUZpbHRlcnMuYWRkQWxsKHN0eWxlRmlsdGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXRlZEZlYXR1cmVzID0gbmV3IEF3YWl0ZWQoKTtcbiAgICAgICAgYXdhaXRlZEZlYXR1cmVzLnN0eWxlRmlsdGVycyA9IHN0eWxlRmlsdGVycztcbiAgICAgICAgcG9vbC5hd2FpdGVkRmVhdHVyZXNbY2FjaGVLZXldID0gYXdhaXRlZEZlYXR1cmVzO1xuXG4gICAgICAgIHBvb2wucmVxdWVzdHNJc3N1ZWQudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGF3YWl0ZWRGZWF0dXJlcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYuc291cmNlLmZldGNoKFxuICAgICAgICAgICAgICAgIGNociwgXG4gICAgICAgICAgICAgICAgbWluLCBcbiAgICAgICAgICAgICAgICBtYXgsIFxuICAgICAgICAgICAgICAgIHNjYWxlLCBcbiAgICAgICAgICAgICAgICBhd2FpdGVkRmVhdHVyZXMuc3R5bGVGaWx0ZXJzLnR5cGVMaXN0KCksIFxuICAgICAgICAgICAgICAgIHBvb2wsIFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHN0YXR1cywgZmVhdHVyZXMsIHNjYWxlLCBjb3ZlcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWF3YWl0ZWRGZWF0dXJlcy5yZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdGVkRmVhdHVyZXMucHJvdmlkZSh7c3RhdHVzOiBzdGF0dXMsIGZlYXR1cmVzOiBmZWF0dXJlcywgc2NhbGU6IHNjYWxlLCBjb3ZlcmFnZTogY292ZXJhZ2V9KTtcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICBhd2FpdGVkRmVhdHVyZXMuc3R5bGVGaWx0ZXJzKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICB9KTtcbiAgICB9IFxuXG4gICAgYXdhaXRlZEZlYXR1cmVzLmF3YWl0KGZ1bmN0aW9uKGFmKSB7XG4gICAgICAgIGNhbGxiYWNrKGFmLnN0YXR1cywgYWYuZmVhdHVyZXMsIGFmLnNjYWxlLCBhZi5jb3ZlcmFnZSk7XG4gICAgfSk7XG59XG4gICAgXG5mdW5jdGlvbiBGZWF0dXJlU291cmNlQmFzZSgpIHtcbiAgICB0aGlzLmJ1c3kgPSAwO1xuICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMucmVhZGluZXNzID0gbnVsbDtcbn1cblxuRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlLmFkZFJlYWRpbmVzc0xpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICBsaXN0ZW5lcih0aGlzLnJlYWRpbmVzcyk7XG59XG5cbkZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZS5yZW1vdmVSZWFkaW5lc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgdmFyIGlkeCA9IGFycmF5SW5kZXhPZih0aGlzLnJlYWRpbmVzc0xpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG59XG5cbkZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZS5ub3RpZnlSZWFkaW5lc3MgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgdGhpcy5yZWFkaW5lc3NMaXN0ZW5lcnMubGVuZ3RoOyArK2xpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRpbmVzc0xpc3RlbmVyc1tsaV0odGhpcy5yZWFkaW5lc3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlLmFkZEFjdGl2aXR5TGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG59XG5cbkZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG59XG5cbkZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZS5ub3RpZnlBY3Rpdml0eSA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVyc1tsaV0odGhpcy5idXN5KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjbnQpIHtcbiAgICByZXR1cm4gY250KG51bGwsIFtdLCAxMDAwMDAwMDAwKTtcbn1cblxuRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlLmdldFN0eWxlU2hlZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcbiAgICB2YXIgZGVmU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICBkZWZTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgIGRlZlN0eWxlLkJHQ09MT1IgPSAnYmx1ZSc7XG4gICAgZGVmU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZWZhdWx0J30sIG51bGwsIGRlZlN0eWxlKTtcbiAgICByZXR1cm4gY2FsbGJhY2soc3R5bGVzaGVldCk7XG59XG5cblxuXG5mdW5jdGlvbiBEQVNGZWF0dXJlU291cmNlKGRhc1NvdXJjZSkge1xuICAgIHRoaXMuZGFzU291cmNlID0gbmV3IERBU1NvdXJjZShkYXNTb3VyY2UpO1xuICAgIHRoaXMuYnVzeSA9IDA7XG4gICAgdGhpcy5hY3Rpdml0eUxpc3RlbmVycyA9IFtdO1xufVxuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5hZGRBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xufVxuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBpZiAoaWR4ID49IDApXG4gICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG59XG5cblxuREFTRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUubm90aWZ5QWN0aXZpdHkgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgdGhpcy5hY3Rpdml0eUxpc3RlbmVycy5sZW5ndGg7ICsrbGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnNbbGldKHRoaXMuYnVzeSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB0aGlzLmRhc1NvdXJjZS5zdHlsZXNoZWV0KGZ1bmN0aW9uKHN0eWxlc2hlZXQpIHtcblx0Y2FsbGJhY2soc3R5bGVzaGVldCk7XG4gICAgfSwgZnVuY3Rpb24oKSB7XG5cdGNhbGxiYWNrKG51bGwsIFwiQ291bGRuJ3QgZmV0Y2ggREFTIHN0eWxlc2hlZXRcIik7XG4gICAgfSk7XG59XG5cbkRBU0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlcyAmJiB0eXBlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBbXSwgc2NhbGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRhc1NvdXJjZS51cmkgJiYgIXRoaXMuZGFzU291cmNlLmZlYXR1cmVzX3VyaSkge1xuICAgICAgICAvLyBGSVhNRSBzaG91bGQgdGhpcyBiZSBtYWtpbmcgYW4gZXJyb3IgY2FsbGJhY2s/Pz9cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmRhc1NvdXJjZS5kYXNTdGF0aWNGZWF0dXJlcyAmJiB0aGlzLmNhY2hlZFN0YXRpY0ZlYXR1cmVzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0aGlzLmNhY2hlZFN0YXRpY0ZlYXR1cmVzLCB0aGlzLmNhY2hlZFN0YXRpY1NjYWxlKTtcbiAgICB9XG5cbiAgICB2YXIgdHJ5TWF4QmlucyA9ICh0aGlzLmRhc1NvdXJjZS5tYXhiaW5zICE9PSBmYWxzZSk7XG4gICAgdmFyIGZvcHMgPSB7XG4gICAgICAgIHR5cGU6IHR5cGVzXG4gICAgfTtcbiAgICBpZiAodHJ5TWF4Qmlucykge1xuICAgICAgICBmb3BzLm1heGJpbnMgPSAxICsgKCgobWF4IC0gbWluKSAvIHNjYWxlKSB8IDApO1xuICAgIH1cbiAgICBcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXNCLmJ1c3krKztcbiAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgdGhpcy5kYXNTb3VyY2UuZmVhdHVyZXMoXG4gICAgICAgIG5ldyBEQVNTZWdtZW50KGNociwgbWluLCBtYXgpLFxuICAgICAgICBmb3BzLFxuICAgICAgICBmdW5jdGlvbihmZWF0dXJlcywgc3RhdHVzKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG5cbiAgICAgICAgICAgIHZhciByZXRTY2FsZSA9IHNjYWxlO1xuICAgICAgICAgICAgaWYgKCF0cnlNYXhCaW5zKSB7XG4gICAgICAgICAgICAgICAgcmV0U2NhbGUgPSAwLjE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0YXR1cyAmJiB0aGlzQi5kYXNTb3VyY2UuZGFzU3RhdGljRmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzQi5jYWNoZWRTdGF0aWNGZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgICAgICAgICAgICAgIHRoaXNCLmNhY2hlZFN0YXRpY1NjYWxlID0gcmV0U2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhzdGF0dXMsIGZlYXR1cmVzLCByZXRTY2FsZSk7XG4gICAgICAgIH1cbiAgICApO1xufVxuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5maW5kTmV4dEZlYXR1cmUgPSB0aGlzLnNvdXJjZUZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuZGFzU291cmNlLmNhcGFiaWxpdGllcyAmJiBhcnJheUluZGV4T2YodGhpcy5kYXNTb3VyY2UuY2FwYWJpbGl0aWVzLCAnZGFzMTphZGphY2VudC1mZWF0dXJlJykgPj0gMCkge1xuICAgICAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5kYXNBZGpMb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS5sb2coJ0FscmVhZHkgbG9va2luZyBmb3IgYSBuZXh0IGZlYXR1cmUsIGJlIHBhdGllbnQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXNBZGpMb2NrID0gdHJ1ZTtcbiAgICAgICAgdmFyIGZvcHMgPSB7XG4gICAgICAgICAgICBhZGphY2VudDogY2hyICsgJzonICsgKHBvc3wwKSArICc6JyArIChkaXIgPiAwID8gJ0YnIDogJ0InKVxuICAgICAgICB9XG4gICAgICAgIHZhciB0eXBlcyA9IHRoaXNUaWVyLmdldERlc2lyZWRUeXBlcyh0aGlzVGllci5icm93c2VyLnNjYWxlKTtcbiAgICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgICAgICBmb3BzLnR5cGVzID0gdHlwZXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1RpZXIuZGFzU291cmNlLmZlYXR1cmVzKG51bGwsIGZvcHMsIGZ1bmN0aW9uKHJlcykge1xuICAgICAgICAgICAgdGhpc0IuZGFzQWRqTG9jayA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAwICYmIHJlc1swXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gREFTU2VxdWVuY2VTb3VyY2UoZGFzU291cmNlKSB7XG4gICAgdGhpcy5kYXNTb3VyY2UgPSBuZXcgREFTU291cmNlKGRhc1NvdXJjZSk7XG4gICAgdGhpcy5hd2FpdGVkRW50cnlQb2ludHMgPSBuZXcgQXdhaXRlZCgpO1xuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmRhc1NvdXJjZS5lbnRyeVBvaW50cyhcbiAgICAgICAgZnVuY3Rpb24oZXApIHtcbiAgICAgICAgICAgIHRoaXNCLmF3YWl0ZWRFbnRyeVBvaW50cy5wcm92aWRlKGVwKTtcbiAgICAgICAgfSk7XG59XG5cblxuREFTU2VxdWVuY2VTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgcG9vbCwgY2FsbGJhY2spIHtcbiAgICB0aGlzLmRhc1NvdXJjZS5zZXF1ZW5jZShcbiAgICAgICAgbmV3IERBU1NlZ21lbnQoY2hyLCBtaW4sIG1heCksXG4gICAgICAgIGZ1bmN0aW9uKHNlcXMpIHtcbiAgICAgICAgICAgIGlmIChzZXFzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHNlcXNbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soXCJEaWRuJ3QgZ2V0IHNlcXVlbmNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcbn1cblxuREFTU2VxdWVuY2VTb3VyY2UucHJvdG90eXBlLmdldFNlcUluZm8gPSBmdW5jdGlvbihjaHIsIGNudCkge1xuICAgIHRoaXMuYXdhaXRlZEVudHJ5UG9pbnRzLmF3YWl0KGZ1bmN0aW9uKGVwKSB7XG4gICAgICAgIGZvciAodmFyIGVwaSA9IDA7IGVwaSA8IGVwLmxlbmd0aDsgKytlcGkpIHtcbiAgICAgICAgICAgIGlmIChlcFtlcGldLm5hbWUgPT0gY2hyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNudCh7bGVuZ3RoOiBlcFtlcGldLmVuZH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbnQoKTtcbiAgICB9KTtcbn1cbiAgICBcblxuZnVuY3Rpb24gVHdvQml0U2VxdWVuY2VTb3VyY2Uoc291cmNlKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnR3b0JpdCA9IG5ldyBBd2FpdGVkKCk7XG4gICAgdmFyIGRhdGE7XG4gICAgaWYgKHNvdXJjZS50d29CaXRVUkkpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBVUkxGZXRjaGFibGUoc291cmNlLnR3b0JpdFVSSSk7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UudHdvQml0QmxvYikge1xuICAgICAgICBkYXRhID0gbmV3IEJsb2JGZXRjaGFibGUoc291cmNlLnR3b0JpdEJsb2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiTm8gdHdvQml0VVJJIG9yIHR3b0JpdEJsb2IgcGFyYW1ldGVyXCIpO1xuICAgIH1cblxuICAgIG1ha2VUd29CaXQoZGF0YSwgZnVuY3Rpb24odGIsIGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc0IudHdvQml0LnByb3ZpZGUodGIpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cblR3b0JpdFNlcXVlbmNlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMudHdvQml0LmF3YWl0KGZ1bmN0aW9uKHRiKSB7XG4gICAgICAgICAgICB0Yi5mZXRjaChjaHIsIG1pbiwgbWF4LFxuICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oc2VxLCBlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXF1ZW5jZSA9IG5ldyBEQVNTZXF1ZW5jZShjaHIsIG1pbiwgbWF4LCAnRE5BJywgc2VxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHNlcXVlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbn1cblxuVHdvQml0U2VxdWVuY2VTb3VyY2UucHJvdG90eXBlLmdldFNlcUluZm8gPSBmdW5jdGlvbihjaHIsIGNudCkge1xuICAgIHRoaXMudHdvQml0LmF3YWl0KGZ1bmN0aW9uKHRiKSB7XG4gICAgICAgIHZhciBzZXEgPSB0Yi5nZXRTZXEoY2hyKTtcbiAgICAgICAgaWYgKHNlcSkge1xuICAgICAgICAgICAgdGIuZ2V0U2VxKGNocikubGVuZ3RoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgICAgICBjbnQoe2xlbmd0aDogbH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbnQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5EQVNGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW107XG59XG5cbnZhciBid2dfcHJlZmxpZ2h0cyA9IHt9O1xuXG5mdW5jdGlvbiBCV0dGZWF0dXJlU291cmNlKGJ3Z1NvdXJjZSkge1xuICAgIEZlYXR1cmVTb3VyY2VCYXNlLmNhbGwodGhpcyk7XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMucmVhZGluZXNzID0gJ0Nvbm5lY3RpbmcnO1xuICAgIHRoaXMuYndnU291cmNlID0gdGhpcy5vcHRzID0gYndnU291cmNlOyAgICBcbiAgICB0aGlzQi5id2dIb2xkZXIgPSBuZXcgQXdhaXRlZCgpO1xuXG4gICAgaWYgKHRoaXMub3B0cy5wcmVmbGlnaHQpIHtcbiAgICAgICAgdmFyIHBmcyA9IGJ3Z19wcmVmbGlnaHRzW3RoaXMub3B0cy5wcmVmbGlnaHRdO1xuICAgICAgICBpZiAoIXBmcykge1xuICAgICAgICAgICAgcGZzID0gbmV3IEF3YWl0ZWQoKTtcbiAgICAgICAgICAgIGJ3Z19wcmVmbGlnaHRzW3RoaXMub3B0cy5wcmVmbGlnaHRdID0gcGZzO1xuXG4gICAgICAgICAgICB2YXIgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICByZXEub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZWFkeVN0YXRlID09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZnMucHJvdmlkZSgnc3VjY2VzcycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGZzLnByb3ZpZGUoJ2ZhaWx1cmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEub3BlbignZ2V0JywgdGhpcy5vcHRzLnByZWZsaWdodCArICc/JyArIGhleF9zaGExKCdzYWx0JyArIERhdGUubm93KCkpLCB0cnVlKTsgICAgLy8gSW5zdGVhZCwgZW5zdXJlIHdlIGFsd2F5cyBwcmVmbGlnaHQgYSB1bmlxdWUgVVJJLlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxLnNlbmQoJycpO1xuICAgICAgICB9XG4gICAgICAgIHBmcy5hd2FpdChmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgICAgIHRoaXNCLmluaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc0IuaW5pdCgpO1xuICAgIH1cbn1cblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZlYXR1cmVTb3VyY2VCYXNlLnByb3RvdHlwZSk7XG5cbkJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHZhciBhcmc7XG5cbiAgICB2YXIgdXJpID0gdGhpcy5id2dTb3VyY2UudXJpIHx8IHRoaXMuYndnU291cmNlLmJ3Z1VSSTtcbiAgICBpZiAodXJpKSB7XG4gICAgICAgIGlmICh0aGlzLmJ3Z1NvdXJjZS50cmFuc3BvcnQgPT09ICdlbmNvZGUnKSB7XG4gICAgICAgICAgICBhcmcgPSBuZXcgRW5jb2RlRmV0Y2hhYmxlKHVyaSwge2NyZWRlbnRpYWxzOiB0aGlzLm9wdHMuY3JlZGVudGlhbHN9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZyA9IG5ldyBVUkxGZXRjaGFibGUodXJpLCB7Y3JlZGVudGlhbHM6IHRoaXMub3B0cy5jcmVkZW50aWFsc30pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYXJnID0gbmV3IEJsb2JGZXRjaGFibGUodGhpcy5id2dTb3VyY2UuYndnQmxvYik7XG4gICAgfVxuXG4gICAgbWFrZUJ3ZyhhcmcsIGZ1bmN0aW9uKGJ3ZywgZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXNCLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgdGhpc0IucmVhZGluZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeVJlYWRpbmVzcygpO1xuICAgICAgICAgICAgdGhpc0IuYndnSG9sZGVyLnByb3ZpZGUobnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzQi5id2dIb2xkZXIucHJvdmlkZShid2cpO1xuICAgICAgICAgICAgdGhpc0IucmVhZGluZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeVJlYWRpbmVzcygpO1xuICAgICAgICAgICAgaWYgKGJ3Zy50eXBlID09ICdiaWdiZWQnKSB7XG4gICAgICAgICAgICAgICAgYndnLmdldEV4dHJhSW5kaWNlcyhmdW5jdGlvbihlaSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5leHRyYUluZGljZXMgPSBlaTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5CV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5jYXBhYmlsaXRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FwcyA9IHtsZWFwOiB0cnVlfTtcbiAgICBpZiAodGhpcy5id2dIb2xkZXIucmVzICYmIHRoaXMuYndnSG9sZGVyLnJlcy50eXBlID09ICdiaWd3aWcnKVxuICAgICAgICBjYXBzLnF1YW50TGVhcCA9IHRydWU7XG4gICAgaWYgKHRoaXMuZXh0cmFJbmRpY2VzICYmIHRoaXMuZXh0cmFJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2Fwcy5zZWFyY2ggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgZWlpID0gMDsgZWlpIDwgdGhpcy5leHRyYUluZGljZXMubGVuZ3RoOyArK2VpaSkge1xuICAgICAgICAgICAgY2Fwcy5zZWFyY2gucHVzaCh0aGlzLmV4dHJhSW5kaWNlc1tlaWldLmZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2Fwcztcbn1cblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmJ3Z0hvbGRlci5hd2FpdChmdW5jdGlvbihid2cpIHtcbiAgICAgICAgaWYgKGJ3ZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpc0IuZXJyb3IgfHwgXCJDYW4ndCBhY2Nlc3MgYmluYXJ5IGZpbGVcIiwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgdmFyIHdhbnREZW5zaXR5ID0gIXR5cGVzIHx8IHR5cGVzLmxlbmd0aCA9PSAwIHx8IGFycmF5SW5kZXhPZih0eXBlcywgJ2RlbnNpdHknKSA+PSAwO1xuICAgICAgICBpZiAodGhpc0Iub3B0cy5jbGllbnRCaW4pIHtcbiAgICAgICAgICAgIHdhbnREZW5zaXR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ3Zy50eXBlID09ICdiaWd3aWcnIHx8IHdhbnREZW5zaXR5IHx8ICh0eXBlb2YgdGhpc0Iub3B0cy5mb3JjZVJlZHVjdGlvbiAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICB2YXIgem9vbSA9IC0xO1xuICAgICAgICAgICAgZm9yICh2YXIgeiA9IDA7IHogPCBid2cuem9vbUxldmVscy5sZW5ndGg7ICsreikge1xuICAgICAgICAgICAgICAgIGlmIChid2cuem9vbUxldmVsc1t6XS5yZWR1Y3Rpb24gPD0gc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgem9vbSA9IHo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzQi5vcHRzLmZvcmNlUmVkdWN0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHpvb20gPSB0aGlzQi5vcHRzLmZvcmNlUmVkdWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoem9vbSA8IDApIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYndnLmdldFVuem9vbWVkVmlldygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gYndnLmdldFpvb21lZFZpZXcoem9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gYndnLmdldFVuem9vbWVkVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzQi5idXN5Kys7XG4gICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG4gICAgICAgIGRhdGEucmVhZFdpZ0RhdGEoY2hyLCBtaW4sIG1heCwgZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG5cbiAgICAgICAgICAgIHZhciBmcyA9IDEwMDAwMDAwMDA7XG4gICAgICAgICAgICBpZiAoYndnLnR5cGUgPT09ICdiaWd3aWcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzID0gKG1heCAtIG1pbikgLyBmZWF0dXJlcy5sZW5ndGggLyAyO1xuICAgICAgICAgICAgICAgIGlmIChpcyA8IGZzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzID0gaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNCLm9wdHMubGluaykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmZWF0dXJlcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmZWF0dXJlc1tmaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmxpbmtzID0gW25ldyBEQVNMaW5rKCdMaW5rJywgdGhpc0Iub3B0cy5saW5rLnJlcGxhY2UoL1xcJFxcJC8sIGYubGFiZWwpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBmZWF0dXJlcywgZnMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUucXVhbnRGaW5kTmV4dEZlYXR1cmUgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCB0aHJlc2hvbGQsIGNhbGxiYWNrKSB7XG4gICAgLy8gdmFyIGJlZm9yZVFGTkYgPSBEYXRlLm5vdygpfDA7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzQi5idXN5Kys7XG4gICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcbiAgICB0aGlzLmJ3Z0hvbGRlci5yZXMudGhyZXNob2xkU2VhcmNoKGNociwgcG9zLCBkaXIsIHRocmVzaG9sZCwgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG4gICAgICAgIC8vIHZhciBhZnRlclFGTkYgPSBEYXRlLm5vdygpfDA7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdRRk5GIHRvb2sgJyArIChhZnRlclFGTkYgLSBiZWZvcmVRRk5GKSArICdtcycpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soYSwgYik7XG4gICAgfSk7XG59XG5cbkJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzQi5idXN5Kys7XG4gICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcbiAgICB0aGlzLmJ3Z0hvbGRlci5yZXMuZ2V0VW56b29tZWRWaWV3KCkuZ2V0Rmlyc3RBZGphY2VudChjaHIsIHBvcywgZGlyLCBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgdGhpc0IuYnVzeS0tO1xuICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDAgJiYgcmVzWzBdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc1swXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U2NhbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJ3ZyA9IHRoaXMuYndnSG9sZGVyLnJlcztcbiAgICBpZiAoYndnIC8qICYmIGJ3Zy50eXBlID09ICdiaWd3aWcnICovKSB7XG4gICAgICAgIHZhciBzY2FsZXMgPSBbMV07ICAvLyBDYW4gd2UgYmUgc21hcnRlciBhYm91dCBpbmZlcnJpbmcgYmFzZWxpbmUgc2NhbGU/XG4gICAgICAgIGZvciAodmFyIHogPSAwOyB6IDwgYndnLnpvb21MZXZlbHMubGVuZ3RoOyArK3opIHtcbiAgICAgICAgICAgIHNjYWxlcy5wdXNoKGJ3Zy56b29tTGV2ZWxzW3pdLnJlZHVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjYWxlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbkJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5leHRyYUluZGljZXMgfHwgdGhpcy5leHRyYUluZGljZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsICdObyBpbmRpY2VzIGF2YWlsYWJsZScpO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuZXh0cmFJbmRpY2VzWzBdO1xuICAgIHJldHVybiBpbmRleC5sb29rdXAocXVlcnksIGNhbGxiYWNrKTtcbn1cblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0RGVmYXVsdEZJUHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLm9wdHMubm9FeHRyYUZlYXR1cmVJbmZvKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHRoaXMuYndnSG9sZGVyLmF3YWl0KGZ1bmN0aW9uKGJ3Zykge1xuICAgICAgICBpZiAoIWJ3ZykgcmV0dXJuO1xuXG4gICAgICAgIGlmIChid2cuc2NoZW1hICYmIGJ3Zy5kZWZpbmVkRmllbGRDb3VudCA8IGJ3Zy5zY2hlbWEuZmllbGRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZpcCA9IGZ1bmN0aW9uKGZlYXR1cmUsIGZlYXR1cmVJbmZvKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaGkgPSAwOyBoaSA8IGZlYXR1cmVJbmZvLmhpdC5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVJbmZvLmhpdFtoaV0uaXNTdXBlckdyb3VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmaSA9IGJ3Zy5kZWZpbmVkRmllbGRDb3VudDsgZmkgPCBid2cuc2NoZW1hLmZpZWxkcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBid2cuc2NoZW1hLmZpZWxkc1tmaV07XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVJbmZvLmFkZChmLmNvbW1lbnQsIGZlYXR1cmVbZi5uYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2FsbGJhY2soZmlwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHRoaXMuYndnSG9sZGVyLmF3YWl0KGZ1bmN0aW9uKGJ3Zykge1xuICAgICAgICBpZiAoIWJ3Zykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsICdiYmkgZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgXHR2YXIgc3R5bGVzaGVldCA9IG5ldyBEQVNTdHlsZXNoZWV0KCk7XG4gICAgICAgIGlmIChid2cudHlwZSA9PSAnYmlnYmVkJykge1xuICAgICAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICAgICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgICAgICAgICB3aWdTdHlsZS5CR0NPTE9SID0gJ2JsdWUnXG4gICAgICAgICAgICB3aWdTdHlsZS5IRUlHSFQgPSA4O1xuICAgICAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5MQUJFTCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnYmlnYmVkJ30sIG51bGwsIHdpZ1N0eWxlKTtcblx0ICAgIFxuICAgICAgICAgICAgd2lnU3R5bGUuZ2x5cGggPSAnQk9YJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgICAgICAgICAgd2lnU3R5bGUuQkdDT0xPUiA9ICdyZWQnXG4gICAgICAgICAgICB3aWdTdHlsZS5IRUlHSFQgPSAxMDtcbiAgICAgICAgICAgIHdpZ1N0eWxlLkJVTVAgPSB0cnVlO1xuICAgICAgICAgICAgd2lnU3R5bGUuWklOREVYID0gMjA7XG4gICAgICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3RyYW5zbGF0aW9uJ30sIG51bGwsIHdpZ1N0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdHNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICAgICAgdHNTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICAgICAgdHNTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHRzU3R5bGUuQkdDT0xPUiA9ICd3aGl0ZSc7XG4gICAgICAgICAgICB0c1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgICAgICAgICAgdHNTdHlsZS5aSU5ERVggPSAxMDtcbiAgICAgICAgICAgIHRzU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB0c1N0eWxlLkxBQkVMID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNjcmlwdCd9LCBudWxsLCB0c1N0eWxlKTtcblxuICAgICAgICAgICAgdmFyIGRlbnNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICAgICAgZGVuc1N0eWxlLmdseXBoID0gJ0hJU1RPR1JBTSc7XG4gICAgICAgICAgICBkZW5zU3R5bGUuQ09MT1IxID0gJ3doaXRlJztcbiAgICAgICAgICAgIGRlbnNTdHlsZS5DT0xPUjIgPSAnYmxhY2snO1xuICAgICAgICAgICAgZGVuc1N0eWxlLkhFSUdIVD0zMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVuc2l0eSd9LCBudWxsLCBkZW5zU3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdISVNUT0dSQU0nO1xuICAgICAgICAgICAgd2lnU3R5bGUuQ09MT1IxID0gJ3doaXRlJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkNPTE9SMiA9ICdibGFjayc7XG4gICAgICAgICAgICB3aWdTdHlsZS5IRUlHSFQ9MzA7XG4gICAgICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJ3Zy5kZWZpbmVkRmllbGRDb3VudCA9PSAxMiAmJiBid2cuZmllbGRDb3VudCA+PSAxNCkge1xuICAgICAgICAgICAgc3R5bGVzaGVldC5nZW5lSGludCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgIFx0cmV0dXJuIGNhbGxiYWNrKHN0eWxlc2hlZXQpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBSZW1vdGVCV0dGZWF0dXJlU291cmNlKGJ3Z1NvdXJjZSwgd29ya2VyKSB7XG4gICAgRmVhdHVyZVNvdXJjZUJhc2UuY2FsbCh0aGlzKTtcblxuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy53b3JrZXIgPSB3b3JrZXI7XG4gICAgdGhpcy5yZWFkaW5lc3MgPSAnQ29ubmVjdGluZyc7XG4gICAgdGhpcy5id2dTb3VyY2UgPSB0aGlzLm9wdHMgPSBid2dTb3VyY2U7XG4gICAgdGhpcy5rZXlIb2xkZXIgPSBuZXcgQXdhaXRlZCgpO1xuXG4gICAgdGhpcy5pbml0KCk7XG59XG5cblJlbW90ZUJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUpO1xuXG5SZW1vdGVCV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB2YXIgdXJpID0gdGhpcy51cmkgfHwgdGhpcy5id2dTb3VyY2UudXJpIHx8IHRoaXMuYndnU291cmNlLmJ3Z1VSSTtcbiAgICB2YXIgYmxvYiA9IHRoaXMuYndnU291cmNlLmJsb2IgfHwgdGhpcy5id2dTb3VyY2UuYndnQmxvYjtcblxuICAgIHZhciBjbnQgPSBmdW5jdGlvbihrZXksIGVycikge1xuICAgICAgICB0aGlzQi5yZWFkaW5lc3MgPSBudWxsO1xuICAgICAgICB0aGlzQi5ub3RpZnlSZWFkaW5lc3MoKTtcblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICB0aGlzQi53b3JrZXIucG9zdENvbW1hbmQoe2NvbW1hbmQ6ICdtZXRhJywgY29ubmVjdGlvbjoga2V5fSwgZnVuY3Rpb24obWV0YSwgZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iua2V5SG9sZGVyLnByb3ZpZGUobnVsbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0IubWV0YSA9IG1ldGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNCLmtleUhvbGRlci5wcm92aWRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzQi5lcnJvciA9IGVycjtcbiAgICAgICAgICAgIHRoaXNCLmtleUhvbGRlci5wcm92aWRlKG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmIChibG9iKSB7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAnY29ubmVjdEJCSScsIGJsb2I6IGJsb2J9LCBjbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29ya2VyLnBvc3RDb21tYW5kKHtcbiAgICAgICAgICAgIGNvbW1hbmQ6ICdjb25uZWN0QkJJJywgXG4gICAgICAgICAgICB1cmk6IHJlc29sdmVVcmxUb1BhZ2UodXJpKSwgXG4gICAgICAgICAgICB0cmFuc3BvcnQ6IHRoaXMuYndnU291cmNlLnRyYW5zcG9ydCxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmJ3Z1NvdXJjZS5jcmVkZW50aWFsc30sIFxuICAgICAgICAgIGNudCk7IFxuICAgIH1cbn1cblxuUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuY2FwYWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhcHMgPSB7bGVhcDogdHJ1ZX07XG5cbiAgICBpZiAodGhpcy5tZXRhICYmIHRoaXMubWV0YS50eXBlID09ICdiaWd3aWcnKVxuICAgICAgICBjYXBzLnF1YW50TGVhcCA9IHRydWU7XG4gICAgaWYgKHRoaXMubWV0YSAmJiB0aGlzLm1ldGEuZXh0cmFJbmRpY2VzICYmIHRoaXMubWV0YS5leHRyYUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjYXBzLnNlYXJjaCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBlaWkgPSAwOyBlaWkgPCB0aGlzLm1ldGEuZXh0cmFJbmRpY2VzLmxlbmd0aDsgKytlaWkpIHtcbiAgICAgICAgICAgIGNhcHMuc2VhcmNoLnB1c2godGhpcy5tZXRhLmV4dHJhSW5kaWNlc1tlaWldLmZpZWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2Fwcztcbn1cblxuUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHRoaXNCLmJ1c3krKztcbiAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgdGhpcy5rZXlIb2xkZXIuYXdhaXQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXNCLmVycm9yIHx8IFwiQ2FuJ3QgYWNjZXNzIGJpbmFyeSBmaWxlXCIsIG51bGwsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHpvb20gPSAtMTtcbiAgICAgICAgdmFyIHdhbnREZW5zaXR5ID0gIXR5cGVzIHx8IHR5cGVzLmxlbmd0aCA9PSAwIHx8IGFycmF5SW5kZXhPZih0eXBlcywgJ2RlbnNpdHknKSA+PSAwO1xuICAgICAgICBpZiAodGhpc0Iub3B0cy5jbGllbnRCaW4pIHtcbiAgICAgICAgICAgIHdhbnREZW5zaXR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNCLm1ldGEudHlwZSA9PSAnYmlnd2lnJyB8fCB3YW50RGVuc2l0eSB8fCAodHlwZW9mIHRoaXNCLm9wdHMuZm9yY2VSZWR1Y3Rpb24gIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeiA9IDE7IHogPCB0aGlzQi5tZXRhLnpvb21MZXZlbHMubGVuZ3RoOyArK3opIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0IubWV0YS56b29tTGV2ZWxzW3pdIDw9IHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvb20gPSB6IC0gMTsgLy8gU2NhbGVzIHJldHVybmVkIGluIG1ldGFkYXRhIHN0YXJ0IGF0IDEsIHVubGlrZSBcInJlYWxcIiB6b29tIGxldmVscy5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNCLm9wdHMuZm9yY2VSZWR1Y3Rpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgem9vbSA9IHRoaXNCLm9wdHMuZm9yY2VSZWR1Y3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXNCLndvcmtlci5wb3N0Q29tbWFuZCh7Y29tbWFuZDogJ2ZldGNoJywgY29ubmVjdGlvbjoga2V5LCBjaHI6IGNociwgbWluOiBtaW4sIG1heDogbWF4LCB6b29tOiB6b29tfSwgZnVuY3Rpb24oZmVhdHVyZXMsIGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgICB2YXIgZnMgPSAxMDAwMDAwMDAwO1xuICAgICAgICAgICAgaWYgKHRoaXNCLm1ldGEudHlwZSA9PT0gJ2JpZ3dpZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXMgPSAobWF4IC0gbWluKSAvIGZlYXR1cmVzLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICAgICAgaWYgKGlzIDwgZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZnMgPSBpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgaWYgKHRoaXNCLm9wdHMubGluaykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmZWF0dXJlcy5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmZWF0dXJlc1tmaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLmxpbmtzID0gW25ldyBEQVNMaW5rKCdMaW5rJywgdGhpc0Iub3B0cy5saW5rLnJlcGxhY2UoL1xcJFxcJC8sIGYubGFiZWwpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IsIGZlYXR1cmVzLCBmcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5cblJlbW90ZUJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnF1YW50RmluZE5leHRGZWF0dXJlID0gZnVuY3Rpb24oY2hyLCBwb3MsIGRpciwgdGhyZXNob2xkLCBjYWxsYmFjaykge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy5idXN5Kys7XG4gICAgdGhpcy5ub3RpZnlBY3Rpdml0eSgpO1xuICAgIHRoaXMud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAncXVhbnRMZWFwJywgY29ubmVjdGlvbjogdGhpcy5rZXlIb2xkZXIucmVzLCBjaHI6IGNociwgcG9zOiBwb3MsIGRpcjogZGlyLCB0aHJlc2hvbGQ6IHRocmVzaG9sZCwgdW5kZXI6IGZhbHNlfSwgZnVuY3Rpb24ocmVzdWx0LCBlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LCBlcnIpO1xuICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHQsIGVycik7XG4gICAgfSk7XG59XG5cblJlbW90ZUJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZpbmROZXh0RmVhdHVyZSA9IGZ1bmN0aW9uKGNociwgcG9zLCBkaXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmJ1c3krKztcbiAgICB0aGlzLm5vdGlmeUFjdGl2aXR5KCk7XG4gICAgdGhpcy53b3JrZXIucG9zdENvbW1hbmQoe2NvbW1hbmQ6ICdsZWFwJywgY29ubmVjdGlvbjogdGhpcy5rZXlIb2xkZXIucmVzLCBjaHI6IGNociwgcG9zOiBwb3MsIGRpcjogZGlyfSwgZnVuY3Rpb24ocmVzdWx0LCBlcnIpIHtcbiAgICAgICAgdGhpc0IuYnVzeS0tO1xuICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDAgJiYgcmVzdWx0WzBdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3VsdFswXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuUmVtb3RlQldHRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U2NhbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1ldGEgPSB0aGlzLm1ldGE7XG4gICAgaWYgKG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIG1ldGEuem9vbUxldmVscztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cblJlbW90ZUJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5tZXRhLmV4dHJhSW5kaWNlcyB8fCB0aGlzLm1ldGEuZXh0cmFJbmRpY2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnTm8gaW5kaWNlcyBhdmFpbGFibGUnKTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuYnVzeSsrO1xuICAgIHRoaXMubm90aWZ5QWN0aXZpdHkoKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLm1ldGEuZXh0cmFJbmRpY2VzWzBdO1xuICAgIHRoaXMud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAnc2VhcmNoJywgY29ubmVjdGlvbjogdGhpcy5rZXlIb2xkZXIucmVzLCBxdWVyeTogcXVlcnksIGluZGV4OiBpbmRleH0sIGZ1bmN0aW9uKHJlc3VsdCwgZXJyKSB7XG4gICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcblxuICAgICAgICBjYWxsYmFjayhyZXN1bHQsIGVycik7XG4gICAgfSk7XG59XG5cblJlbW90ZUJXR0ZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldERlZmF1bHRGSVBzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5vcHRzLm5vRXh0cmFGZWF0dXJlSW5mbylcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMua2V5SG9sZGVyLmF3YWl0KGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgYndnID0gdGhpc0IubWV0YTtcbiAgICAgICAgaWYgKCFid2cpIHJldHVybjtcblxuICAgICAgICBpZiAoYndnLnNjaGVtYSAmJiBid2cuZGVmaW5lZEZpZWxkQ291bnQgPCBid2cuc2NoZW1hLmZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmaXAgPSBmdW5jdGlvbihmZWF0dXJlLCBmZWF0dXJlSW5mbykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGhpID0gMDsgaGkgPCBmZWF0dXJlSW5mby5oaXQubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlSW5mby5oaXRbaGldLmlzU3VwZXJHcm91cClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmkgPSBid2cuZGVmaW5lZEZpZWxkQ291bnQ7IGZpIDwgYndnLnNjaGVtYS5maWVsZHMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gYndnLnNjaGVtYS5maWVsZHNbZmldO1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlSW5mby5hZGQoZi5jb21tZW50LCBmZWF0dXJlW2YubmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGNhbGxiYWNrKGZpcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyBuZWVkIHRvIGRvIGFueXRoaW5nLlxuICAgICAgICB9XG4gICAgfSk7XG59IFxuXG5SZW1vdGVCV0dGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgdGhpcy5rZXlIb2xkZXIuYXdhaXQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBid2cgPSB0aGlzQi5tZXRhO1xuICAgICAgICBpZiAoIWJ3Zykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsICdiYmkgZXJyb3InKTtcbiAgICAgICAgfSBcblxuICAgICAgICB2YXIgc3R5bGVzaGVldCA9IG5ldyBEQVNTdHlsZXNoZWV0KCk7XG4gICAgICAgIGlmIChid2cudHlwZSA9PSAnYmlnYmVkJykge1xuICAgICAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICAgICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgICAgICAgICB3aWdTdHlsZS5CR0NPTE9SID0gJ2JsdWUnXG4gICAgICAgICAgICB3aWdTdHlsZS5IRUlHSFQgPSA4O1xuICAgICAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5MQUJFTCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnYmlnYmVkJ30sIG51bGwsIHdpZ1N0eWxlKTtcbiAgICAgICAgXG4gICAgICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgICAgICAgICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgICAgICAgICB3aWdTdHlsZS5CR0NPTE9SID0gJ3JlZCdcbiAgICAgICAgICAgIHdpZ1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgICAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgICAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAndHJhbnNsYXRpb24nfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciB0c1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICB0c1N0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgICAgICAgICB0c1N0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgICAgICAgICAgdHNTdHlsZS5CR0NPTE9SID0gJ3doaXRlJztcbiAgICAgICAgICAgIHRzU3R5bGUuSEVJR0hUID0gMTA7XG4gICAgICAgICAgICB0c1N0eWxlLlpJTkRFWCA9IDEwO1xuICAgICAgICAgICAgdHNTdHlsZS5CVU1QID0gdHJ1ZTtcbiAgICAgICAgICAgIHRzU3R5bGUuTEFCRUwgPSB0cnVlO1xuICAgICAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICd0cmFuc2NyaXB0J30sIG51bGwsIHRzU3R5bGUpO1xuXG4gICAgICAgICAgICB2YXIgZGVuc1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgICAgICBkZW5zU3R5bGUuZ2x5cGggPSAnSElTVE9HUkFNJztcbiAgICAgICAgICAgIGRlbnNTdHlsZS5DT0xPUjEgPSAnd2hpdGUnO1xuICAgICAgICAgICAgZGVuc1N0eWxlLkNPTE9SMiA9ICdibGFjayc7XG4gICAgICAgICAgICBkZW5zU3R5bGUuSEVJR0hUPTMwO1xuICAgICAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZW5zaXR5J30sIG51bGwsIGRlbnNTdHlsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgd2lnU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgICAgIHdpZ1N0eWxlLmdseXBoID0gJ0hJU1RPR1JBTSc7XG4gICAgICAgICAgICB3aWdTdHlsZS5DT0xPUjEgPSAnd2hpdGUnO1xuICAgICAgICAgICAgd2lnU3R5bGUuQ09MT1IyID0gJ2JsYWNrJztcbiAgICAgICAgICAgIHdpZ1N0eWxlLkhFSUdIVD0zMDtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVmYXVsdCd9LCBudWxsLCB3aWdTdHlsZSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmIChid2cuZGVmaW5lZEZpZWxkQ291bnQgPT0gMTIgJiYgYndnLmZpZWxkQ291bnQgPj0gMTQpIHtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQuZ2VuZUhpbnQgPSB0cnVlO1xuICAgICAgICB9IFxuXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYmFtUmVjb3JkVG9GZWF0dXJlKHIsIGdyb3VwKSB7XG4gICAgaWYgKHIuZmxhZyAmIEJhbUZsYWdzLlNFR01FTlRfVU5NQVBQRUQpXG4gICAgICAgIHJldHVybjsgXG4gICAgXG4gICAgdmFyIGxlbjtcbiAgICBpZiAoci5zZXEpXG4gICAgICAgIGxlbiA9IHIuc2VxLmxlbmd0aDtcbiAgICBlbHNlIFxuICAgICAgICBsZW4gPSByLnNlcUxlbmd0aDtcbiAgICBcbiAgICBpZiAoci5jaWdhcikge1xuICAgICAgICBsZW4gPSAwO1xuICAgICAgICB2YXIgb3BzID0gcGFyc2VDaWdhcihyLmNpZ2FyKTtcbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IG9wcy5sZW5ndGg7ICsrY2kpIHtcbiAgICAgICAgICAgIHZhciBjbyA9IG9wc1tjaV07XG4gICAgICAgICAgICBpZiAoY28ub3AgPT0gJ00nIHx8IGNvLm9wID09ICdEJylcbiAgICAgICAgICAgICAgICBsZW4gKz0gY28uY250O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGYgPSBuZXcgREFTRmVhdHVyZSgpO1xuICAgIGYubWluID0gci5wb3MgKyAxO1xuICAgIGYubWF4ID0gci5wb3MgKyBsZW47XG4gICAgZi5zZWdtZW50ID0gci5zZWdtZW50O1xuICAgIGYudHlwZSA9ICdiYW0nO1xuICAgIGYuaWQgPSByLnJlYWROYW1lO1xuICAgIGYubm90ZXMgPSBbLyogJ1NlcXVlbmNlPScgKyByLnNlcSwgJ0NJR0FSPScgKyByLmNpZ2FyLCAqLyAnTVE9JyArIHIubXFdO1xuICAgIGYuY2lnYXIgPSByLmNpZ2FyO1xuICAgIGYuc2VxID0gci5zZXE7XG4gICAgZi5xdWFscyA9IHIucXVhbHM7XG4gICAgZi5vcmllbnRhdGlvbiA9IChyLmZsYWcgJiBCYW1GbGFncy5SRVZFUlNFX0NPTVBMRU1FTlQpID8gJy0nIDogJysnO1xuICAgIGYuYmFtUmVjb3JkID0gcjtcblxuICAgIGlmIChncm91cCAmJiAoci5mbGFnICYgQmFtRmxhZ3MuTVVMVElQTEVfU0VHTUVOVFMpKSB7XG4gICAgICAgIGYuZ3JvdXBzID0gW3tpZDogci5yZWFkTmFtZSwgXG4gICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmVhZHBhaXInfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGY7XG59XG5cbmZ1bmN0aW9uIEJBTUZlYXR1cmVTb3VyY2UoYmFtU291cmNlKSB7XG4gICAgRmVhdHVyZVNvdXJjZUJhc2UuY2FsbCh0aGlzKTtcblxuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdGhpcy5iYW1Tb3VyY2UgPSBiYW1Tb3VyY2U7XG4gICAgdGhpcy5vcHRzID0ge2NyZWRlbnRpYWxzOiBiYW1Tb3VyY2UuY3JlZGVudGlhbHMsIHByZWZsaWdodDogYmFtU291cmNlLnByZWZsaWdodCwgYmFtR3JvdXA6IGJhbVNvdXJjZS5iYW1Hcm91cH07XG4gICAgdGhpcy5iYW1Ib2xkZXIgPSBuZXcgQXdhaXRlZCgpO1xuICAgIFxuICAgIGlmICh0aGlzLm9wdHMucHJlZmxpZ2h0KSB7XG4gICAgICAgIHZhciBwZnMgPSBid2dfcHJlZmxpZ2h0c1t0aGlzLm9wdHMucHJlZmxpZ2h0XTtcbiAgICAgICAgaWYgKCFwZnMpIHtcbiAgICAgICAgICAgIHBmcyA9IG5ldyBBd2FpdGVkKCk7XG4gICAgICAgICAgICBid2dfcHJlZmxpZ2h0c1t0aGlzLm9wdHMucHJlZmxpZ2h0XSA9IHBmcztcblxuICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXEuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGZzLnByb3ZpZGUoJ3N1Y2Nlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBmcy5wcm92aWRlKCdmYWlsdXJlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gcmVxLnNldFJlcXVlc3RIZWFkZXIoJ2NhY2hlLWNvbnRyb2wnLCAnbm8tY2FjaGUnKTsgICAgLyogRG9lc24ndCB3b3JrLCBub3QgYW4gYWxsb3dlZCByZXF1ZXN0IGhlYWRlciBpbiBDT1JTICovXG4gICAgICAgICAgICByZXEub3BlbignZ2V0JywgdGhpcy5vcHRzLnByZWZsaWdodCArICc/JyArIGhleF9zaGExKCdzYWx0JyArIERhdGUubm93KCkpLCB0cnVlKTsgICAgLy8gSW5zdGVhZCwgZW5zdXJlIHdlIGFsd2F5cyBwcmVmbGlnaHQgYSB1bmlxdWUgVVJJLlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSAndHJ1ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuc2VuZCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGZzLmF3YWl0KGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IuaW5pdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzQi5pbml0KCk7XG4gICAgfVxufVxuXG5CQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlKTtcblxuQkFNRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdmFyIGJhbUYsIGJhaUY7XG4gICAgaWYgKHRoaXMuYmFtU291cmNlLmJhbUJsb2IpIHtcbiAgICAgICAgYmFtRiA9IG5ldyBCbG9iRmV0Y2hhYmxlKHRoaXMuYmFtU291cmNlLmJhbUJsb2IpO1xuICAgICAgICBiYWlGID0gbmV3IEJsb2JGZXRjaGFibGUodGhpcy5iYW1Tb3VyY2UuYmFpQmxvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmFtRiA9IG5ldyBVUkxGZXRjaGFibGUodGhpcy5iYW1Tb3VyY2UuYmFtVVJJLCB7Y3JlZGVudGlhbHM6IHRoaXMub3B0cy5jcmVkZW50aWFsc30pO1xuICAgICAgICBiYWlGID0gbmV3IFVSTEZldGNoYWJsZSh0aGlzLmJhbVNvdXJjZS5iYWlVUkkgfHwgKHRoaXMuYmFtU291cmNlLmJhbVVSSSArICcuYmFpJyksIHtjcmVkZW50aWFsczogdGhpcy5vcHRzLmNyZWRlbnRpYWxzfSk7XG4gICAgfVxuICAgIG1ha2VCYW0oYmFtRiwgYmFpRiwgbnVsbCwgZnVuY3Rpb24oYmFtLCBlcnIpIHtcbiAgICAgICAgdGhpc0IucmVhZGluZXNzID0gbnVsbDtcbiAgICAgICAgdGhpc0Iubm90aWZ5UmVhZGluZXNzKCk7XG5cbiAgICAgICAgaWYgKGJhbSkge1xuICAgICAgICAgICAgdGhpc0IuYmFtSG9sZGVyLnByb3ZpZGUoYmFtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNCLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgdGhpc0IuYmFtSG9sZGVyLnByb3ZpZGUobnVsbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuQkFNRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpZ2h0ID0gdHlwZXMgJiYgKHR5cGVzLmxlbmd0aCA9PSAxKSAmJiAodHlwZXNbMF0gPT0gJ2RlbnNpdHknKTtcblxuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgXG4gICAgdGhpc0IuYnVzeSsrO1xuICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG4gICAgXG4gICAgdGhpcy5iYW1Ib2xkZXIuYXdhaXQoZnVuY3Rpb24oYmFtKSB7XG4gICAgICAgIGlmICghYmFtKSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXNCLmVycm9yIHx8IFwiQ291bGRuJ3QgZmV0Y2ggQkFNXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFtLmZldGNoKGNociwgbWluLCBtYXgsIGZ1bmN0aW9uKGJhbVJlY29yZHMsIGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJpID0gMDsgcmkgPCBiYW1SZWNvcmRzLmxlbmd0aDsgKytyaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGJhbVJlY29yZHNbcmldO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gYmFtUmVjb3JkVG9GZWF0dXJlKHIsIHRoaXNCLm9wdHMuYmFtR3JvdXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZilcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZlYXR1cmVzLCAxMDAwMDAwMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge2xpZ2h0OiBsaWdodH0pO1xuICAgIH0pO1xufVxuXG5CQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMTAwMDAwMDAwMDtcbn1cblxuQkFNRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5iYW1Ib2xkZXIuYXdhaXQoZnVuY3Rpb24oYmFtKSB7XG5cdCAgICB2YXIgc3R5bGVzaGVldCA9IG5ldyBEQVNTdHlsZXNoZWV0KCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHZhciBkZW5zU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgZGVuc1N0eWxlLmdseXBoID0gJ0hJU1RPR1JBTSc7XG4gICAgICAgIGRlbnNTdHlsZS5DT0xPUjEgPSAnYmxhY2snO1xuICAgICAgICBkZW5zU3R5bGUuQ09MT1IyID0gJ3JlZCc7XG4gICAgICAgIGRlbnNTdHlsZS5IRUlHSFQ9MzA7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVuc2l0eSd9LCAnbG93JywgZGVuc1N0eWxlKTtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZW5zaXR5J30sICdtZWRpdW0nLCBkZW5zU3R5bGUpO1xuXG4gICAgICAgIHZhciB3aWdTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdfX1NFUVVFTkNFJztcbiAgICAgICAgd2lnU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSAnYmx1ZSdcbiAgICAgICAgd2lnU3R5bGUuSEVJR0hUID0gODtcbiAgICAgICAgd2lnU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgICAgIHdpZ1N0eWxlLkxBQkVMID0gZmFsc2U7XG4gICAgICAgIHdpZ1N0eWxlLlpJTkRFWCA9IDIwO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2JhbSd9LCAnaGlnaCcsIHdpZ1N0eWxlKTtcblxuXHQgICAgcmV0dXJuIGNhbGxiYWNrKHN0eWxlc2hlZXQpO1xuICAgIH0pO1xufVxuXG5cbmZ1bmN0aW9uIFJlbW90ZUJBTUZlYXR1cmVTb3VyY2UoYmFtU291cmNlLCB3b3JrZXIpIHtcbiAgICBGZWF0dXJlU291cmNlQmFzZS5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcbiAgICB0aGlzLmJhbVNvdXJjZSA9IGJhbVNvdXJjZTtcbiAgICB0aGlzLndvcmtlciA9IHdvcmtlcjtcbiAgICB0aGlzLm9wdHMgPSB7Y3JlZGVudGlhbHM6IGJhbVNvdXJjZS5jcmVkZW50aWFscywgcHJlZmxpZ2h0OiBiYW1Tb3VyY2UucHJlZmxpZ2h0LCBiYW1Hcm91cDogYmFtU291cmNlLmJhbUdyb3VwfTtcbiAgICB0aGlzLmtleUhvbGRlciA9IG5ldyBBd2FpdGVkKCk7XG4gICAgXG4gICAgdGhpcy5pbml0KCk7XG59XG5cblJlbW90ZUJBTUZlYXR1cmVTb3VyY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShGZWF0dXJlU291cmNlQmFzZS5wcm90b3R5cGUpO1xuXG5SZW1vdGVCQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7ICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgdmFyIHVyaSA9IHRoaXMuYmFtU291cmNlLnVyaSB8fCB0aGlzLmJhbVNvdXJjZS5iYW1VUkk7XG4gICAgdmFyIGluZGV4VXJpID0gdGhpcy5iYW1Tb3VyY2UuaW5kZXhVcmkgfHwgdGhpcy5iYW1Tb3VyY2UuYmFpVVJJIHx8IHVyaSArICcuYmFpJztcblxuICAgIHZhciBibG9iID0gdGhpcy5iYW1Tb3VyY2UuYmFtQmxvYiB8fCB0aGlzLmJhbVNvdXJjZS5ibG9iO1xuICAgIHZhciBpbmRleEJsb2IgPSB0aGlzLmJhbVNvdXJjZS5iYWlCbG9iIHx8IHRoaXMuYmFtU291cmNlLmluZGV4QmxvYjtcblxuICAgIHZhciBjbnQgPSBmdW5jdGlvbihyZXN1bHQsIGVycikge1xuICAgICAgICB0aGlzQi5yZWFkaW5lc3MgPSBudWxsO1xuICAgICAgICB0aGlzQi5ub3RpZnlSZWFkaW5lc3MoKTtcblxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzQi5rZXlIb2xkZXIucHJvdmlkZShyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc0IuZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB0aGlzQi5rZXlIb2xkZXIucHJvdmlkZShudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoYmxvYikge1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0Q29tbWFuZCh7Y29tbWFuZDogJ2Nvbm5lY3RCQU0nLCBibG9iOiBibG9iLCBpbmRleEJsb2I6IGluZGV4QmxvYn0sIGNudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdENvbW1hbmQoe1xuICAgICAgICAgICAgY29tbWFuZDogJ2Nvbm5lY3RCQU0nLCBcbiAgICAgICAgICAgIHVyaTogcmVzb2x2ZVVybFRvUGFnZSh1cmkpLCBcbiAgICAgICAgICAgIGluZGV4VXJpOiByZXNvbHZlVXJsVG9QYWdlKGluZGV4VXJpKSxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiB0aGlzLmJhbVNvdXJjZS5jcmVkZW50aWFscyxcbiAgICAgICAgICAgIGluZGV4Q2h1bmtzOiB0aGlzLmJhbVNvdXJjZS5pbmRleENodW5rc30sXG4gICAgICAgICAgY250KTsgXG4gICAgfVxufVxuXG5SZW1vdGVCQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGlnaHQgPSB0eXBlcyAmJiAodHlwZXMubGVuZ3RoID09IDEpICYmICh0eXBlc1swXSA9PSAnZGVuc2l0eScpO1xuICAgIHZhciB0aGlzQiA9IHRoaXM7XG4gICAgXG4gICAgdGhpc0IuYnVzeSsrO1xuICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG4gICAgXG4gICAgdGhpcy5rZXlIb2xkZXIuYXdhaXQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXNCLmVycm9yIHx8IFwiQ291bGRuJ3QgZmV0Y2ggQkFNXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpc0Iud29ya2VyLnBvc3RDb21tYW5kKHtjb21tYW5kOiAnZmV0Y2gnLCBjb25uZWN0aW9uOiBrZXksIGNocjogY2hyLCBtaW46IG1pbiwgbWF4OiBtYXgsIG9wdHM6IHtsaWdodDogbGlnaHR9fSwgZnVuY3Rpb24oYmFtUmVjb3JkcywgZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZXRyaWV2ZWQgJyArIGJhbVJlY29yZHMubGVuZ3RoICsgJyB2aWEgd29ya2VyLicpO1xuXG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJpID0gMDsgcmkgPCBiYW1SZWNvcmRzLmxlbmd0aDsgKytyaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGJhbVJlY29yZHNbcmldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGJhbVJlY29yZFRvRmVhdHVyZShyLCB0aGlzQi5vcHRzLmJhbUdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBmZWF0dXJlcywgMTAwMDAwMDAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5SZW1vdGVCQU1GZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gMTAwMDAwMDAwMDtcbn1cblxuUmVtb3RlQkFNRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5rZXlIb2xkZXIuYXdhaXQoZnVuY3Rpb24oYmFtKSB7XG4gICAgICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgdmFyIGRlbnNTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICBkZW5zU3R5bGUuZ2x5cGggPSAnSElTVE9HUkFNJztcbiAgICAgICAgZGVuc1N0eWxlLkNPTE9SMSA9ICdibGFjayc7XG4gICAgICAgIGRlbnNTdHlsZS5DT0xPUjIgPSAncmVkJztcbiAgICAgICAgZGVuc1N0eWxlLkhFSUdIVD0zMDtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZW5zaXR5J30sICdsb3cnLCBkZW5zU3R5bGUpO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlbnNpdHknfSwgJ21lZGl1bScsIGRlbnNTdHlsZSk7XG5cbiAgICAgICAgdmFyIHdpZ1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgICAgIHdpZ1N0eWxlLmdseXBoID0gJ19fU0VRVUVOQ0UnO1xuICAgICAgICB3aWdTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgd2lnU3R5bGUuQkdDT0xPUiA9ICdibHVlJ1xuICAgICAgICB3aWdTdHlsZS5IRUlHSFQgPSA4O1xuICAgICAgICB3aWdTdHlsZS5CVU1QID0gdHJ1ZTtcbiAgICAgICAgd2lnU3R5bGUuTEFCRUwgPSBmYWxzZTtcbiAgICAgICAgd2lnU3R5bGUuWklOREVYID0gMjA7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnYmFtJ30sICdoaWdoJywgd2lnU3R5bGUpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soc3R5bGVzaGVldCk7XG4gICAgfSk7XG59XG5cblxuZnVuY3Rpb24gTWFwcGVkRmVhdHVyZVNvdXJjZShzb3VyY2UsIG1hcHBpbmcpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLm1hcHBpbmcgPSBtYXBwaW5nO1xuICAgIFxuICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLmJ1c3kgPSAwO1xufVxuXG5NYXBwZWRGZWF0dXJlU291cmNlLnByb3RvdHlwZS5hZGRBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xufVxuXG5NYXBwZWRGZWF0dXJlU291cmNlLnByb3RvdHlwZS5yZW1vdmVBY3Rpdml0eUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBpZiAoaWR4ID49IDApXG4gICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMCk7XG59XG5cbk1hcHBlZEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLm5vdGlmeUFjdGl2aXR5ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IHRoaXMuYWN0aXZpdHlMaXN0ZW5lcnMubGVuZ3RoOyArK2xpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2aXR5TGlzdGVuZXJzW2xpXSh0aGlzLmJ1c3kpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuTWFwcGVkRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlLmdldFN0eWxlU2hlZXQoY2FsbGJhY2spO1xufVxuXG5NYXBwZWRGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UuZ2V0U2NhbGVzKCk7XG59XG5cbk1hcHBlZEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldERlZmF1bHRGSVBzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5zb3VyY2UuZ2V0RGVmYXVsdEZJUHMpXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5nZXREZWZhdWx0RklQcyhjYWxsYmFjayk7XG59XG5cbk1hcHBlZEZlYXR1cmVTb3VyY2UucHJvdG90eXBlLnNpbXBsaWZ5U2VnbWVudHMgPSBmdW5jdGlvbihzZWdzLCBtaW5HYXApIHtcbiAgICBpZiAoc2Vncy5sZW5ndGggPT0gMCkgcmV0dXJuIHNlZ3M7XG5cbiAgICBzZWdzLnNvcnQoZnVuY3Rpb24oczEsIHMyKSB7XG4gICAgICAgIHZhciBkID0gczEubmFtZSAtIHMyLm5hbWU7XG4gICAgICAgIGlmIChkKVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIGQgPSBzMS5zdGFydCAtIHMyLnN0YXJ0O1xuICAgICAgICBpZiAoZClcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gczEuZW5kIC0gczIuZW5kOyAgIC8vIFNob3VsZCBuZXZlciBjb21lIHRvIHRoaXMuLi4/XG4gICAgfSk7XG5cbiAgICB2YXIgc3NlZ3MgPSBbXTtcbiAgICB2YXIgY3VycmVudFNlZyA9IHNlZ3NbMF07XG4gICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNlZ3MubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBucyA9IHNlZ3Nbc2ldO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG5zLm5hbWUgKyAnICcgKyBucy5zdGFydCArICcgJyArIG5zLmVuZCk7XG4gICAgICAgIGlmIChucy5uYW1lICE9IGN1cnJlbnRTZWcubmFtZSB8fCBucy5zdGFydCA+IChjdXJyZW50U2VnLmVuZCArIG1pbkdhcCkpIHtcbiAgICAgICAgICAgIHNzZWdzLnB1c2goY3VycmVudFNlZyk7XG4gICAgICAgICAgICBjdXJyZW50U2VnID0gbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50U2VnID0gbmV3IERBU1NlZ21lbnQoY3VycmVudFNlZy5uYW1lLCBNYXRoLm1pbihjdXJyZW50U2VnLnN0YXJ0LCBucy5zdGFydCksIE1hdGgubWF4KGN1cnJlbnRTZWcuZW5kLCBucy5lbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzc2Vncy5wdXNoKGN1cnJlbnRTZWcpO1xuICAgIHJldHVybiBzc2Vncztcbn1cblxuTWFwcGVkRmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNhbGxiYWNrLCBzdHlsZUZpbHRlcnMpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHZhciBmZXRjaExlbmd0aCA9IG1heCAtIG1pbiArIDE7XG5cbiAgICB0aGlzQi5idXN5Kys7XG4gICAgdGhpc0Iubm90aWZ5QWN0aXZpdHkoKTtcblxuICAgIHRoaXMubWFwcGluZy5zb3VyY2VCbG9ja3NGb3JSYW5nZShjaHIsIG1pbiwgbWF4LCBmdW5jdGlvbihtc2VnKSB7XG4gICAgICAgIGlmIChtc2VnLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzQi5idXN5LS07XG4gICAgICAgICAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhcIk5vIG1hcHBpbmcgYXZhaWxhYmxlIGZvciB0aGlzIHJlZ2lvbnNcIiwgW10sIHNjYWxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1zZWcgPSB0aGlzQi5zaW1wbGlmeVNlZ21lbnRzKG1zZWcsIE1hdGgubWF4KDEwMCwgMC4wNSAqIGZldGNoTGVuZ3RoKSk7XG5cbiAgICAgICAgICAgIHZhciBtYXBwZWRGZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIG1hcHBlZExvYyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBtc2VnLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBmaW5hbFN0YXR1cztcblxuICAgICAgICAgICAgbXNlZy5tYXAoZnVuY3Rpb24oc2VnKSB7XG4gICAgICAgICAgICAgICAgdGhpc0Iuc291cmNlLmZldGNoKHNlZy5uYW1lLCBzZWcuc3RhcnQsIHNlZy5lbmQsIHNjYWxlLCB0eXBlcywgcG9vbCwgZnVuY3Rpb24oc3RhdHVzLCBmZWF0dXJlcywgZnNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgJiYgIWZpbmFsU3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxTdGF0dXMgPSBzdGF0dXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgZmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSBmZWF0dXJlc1tmaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNuID0gZi5zZWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbi5pbmRleE9mKCdjaHInKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNuID0gc24uc3Vic3RyKDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXBwaW5ncyA9IHRoaXNCLm1hcHBpbmcubWFwU2VnbWVudChzbiwgZi5taW4sIGYubWF4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5ncy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZi5wYXJ0cyAmJiBmLnBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWRGZWF0dXJlcy5wdXNoKGYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbWkgPSAwOyBtaSA8IG1hcHBpbmdzLmxlbmd0aDsgKyttaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG0gPSBtYXBwaW5nc1ttaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWYgPSBzaGFsbG93Q29weShmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1mLnNlZ21lbnQgPSBtLnNlZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZi5taW4gPSBtLm1pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1mLm1heCA9IG0ubWF4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ucGFydGlhbE1pbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZi5wYXJ0aWFsTWluID0gbS5wYXJ0aWFsTWluO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ucGFydGlhbE1heClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZi5wYXJ0aWFsTWF4ID0gbS5wYXJ0aWFsTWF4O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5mbGlwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGYub3JpZW50YXRpb24gPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1mLm9yaWVudGF0aW9uID0gJysnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZi5vcmllbnRhdGlvbiA9PSAnKycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWYub3JpZW50YXRpb24gPSAnLSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkRmVhdHVyZXMucHVzaChtZik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbTEgPSB0aGlzQi5tYXBwaW5nLm1hcFBvaW50KHNlZy5uYW1lLCBzZWcuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbTIgPSB0aGlzQi5tYXBwaW5nLm1hcFBvaW50KHNlZy5uYW1lLCBzZWcuZW5kKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobTEgJiYgbTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWdEZXN0Q292ZXJhZ2UgPSBuZXcgUmFuZ2UobTEucG9zLCBtMi5wb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHBlZExvYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwZWRMb2MgPSB1bmlvbihtYXBwZWRMb2MsIHNlZ0Rlc3RDb3ZlcmFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGVkTG9jID0gc2VnRGVzdENvdmVyYWdlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLS1jb3VudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50ID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhmaW5hbFN0YXR1cywgbWFwcGVkRmVhdHVyZXMsIGZzY2FsZSwgbWFwcGVkTG9jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHN0eWxlRmlsdGVycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBEdW1teUZlYXR1cmVTb3VyY2UoKSB7XG59XG5cbkR1bW15RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZ2V0U2NhbGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbkR1bW15RmVhdHVyZVNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjaHIsIG1pbiwgbWF4LCBzY2FsZSwgdHlwZXMsIHBvb2wsIGNudCkge1xuICAgIHJldHVybiBjbnQobnVsbCwgW10sIDEwMDAwMDAwMDApO1xufVxuXG5EdW1teUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFN0eWxlU2hlZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcbiAgICB2YXIgZGVmU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICBkZWZTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgIGRlZlN0eWxlLkJHQ09MT1IgPSAnYmx1ZSc7XG4gICAgZGVmU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZWZhdWx0J30sIG51bGwsIGRlZlN0eWxlKTtcbiAgICByZXR1cm4gY2FsbGJhY2soc3R5bGVzaGVldCk7XG59XG5cbmZ1bmN0aW9uIER1bW15U2VxdWVuY2VTb3VyY2UoKSB7XG59XG5cbkR1bW15U2VxdWVuY2VTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgcG9vbCwgY250KSB7XG4gICAgcmV0dXJuIGNudChudWxsLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gSkJyb3dzZUZlYXR1cmVTb3VyY2Uoc291cmNlKSB7XG4gICAgdGhpcy5zdG9yZSA9IG5ldyBKQnJvd3NlU3RvcmUoc291cmNlLmpiVVJJLCBzb3VyY2UuamJRdWVyeSk7XG59XG5cbkpCcm93c2VGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTY2FsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuSkJyb3dzZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmdldFN0eWxlU2hlZXQgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcbiAgICB2YXIgd2lnU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICB3aWdTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgIHdpZ1N0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSAnZ3JlZW4nXG4gICAgd2lnU3R5bGUuSEVJR0hUID0gODtcbiAgICB3aWdTdHlsZS5CVU1QID0gdHJ1ZTtcbiAgICB3aWdTdHlsZS5MQUJFTCA9IHRydWU7XG4gICAgd2lnU3R5bGUuWklOREVYID0gMjA7XG4gICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdkZWZhdWx0J30sIG51bGwsIHdpZ1N0eWxlKTtcblxuICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbn1cblxuSkJyb3dzZUZlYXR1cmVTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgc2NhbGUsIHR5cGVzLCBwb29sLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlcyAmJiB0eXBlcy5sZW5ndGggPT0gMCkge1xuICAgICAgICBjYWxsYmFjayhudWxsLCBbXSwgc2NhbGUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciBmb3BzID0ge307XG5cbiAgICB0aGlzLnN0b3JlLmZlYXR1cmVzKFxuICAgICAgICBuZXcgREFTU2VnbWVudChjaHIsIG1pbiwgbWF4KSxcbiAgICAgICAgZm9wcyxcbiAgICAgICAgZnVuY3Rpb24oZmVhdHVyZXMsIHN0YXR1cykge1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhdHVzLCBmZWF0dXJlcywgMTAwMDAwKTtcbiAgICAgICAgfVxuICAgICk7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUgPSBmdW5jdGlvbihzLCBjYXApIHtcbiAgICBpZiAoIXMuY2FwYWJpbGl0aWVzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZWxzZSByZXR1cm4gcy5jYXBhYmlsaXRpZXMoKVtjYXBdO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIEZlYXR1cmVTb3VyY2VCYXNlOiBGZWF0dXJlU291cmNlQmFzZSxcblxuICAgICAgICBUd29CaXRTZXF1ZW5jZVNvdXJjZTogVHdvQml0U2VxdWVuY2VTb3VyY2UsXG4gICAgICAgIERBU1NlcXVlbmNlU291cmNlOiBEQVNTZXF1ZW5jZVNvdXJjZSxcbiAgICAgICAgTWFwcGVkRmVhdHVyZVNvdXJjZTogTWFwcGVkRmVhdHVyZVNvdXJjZSxcbiAgICAgICAgQ2FjaGluZ0ZlYXR1cmVTb3VyY2U6IENhY2hpbmdGZWF0dXJlU291cmNlLFxuICAgICAgICBCV0dGZWF0dXJlU291cmNlOiBCV0dGZWF0dXJlU291cmNlLFxuICAgICAgICBSZW1vdGVCV0dGZWF0dXJlU291cmNlOiBSZW1vdGVCV0dGZWF0dXJlU291cmNlLFxuICAgICAgICBCQU1GZWF0dXJlU291cmNlOiBCQU1GZWF0dXJlU291cmNlLFxuICAgICAgICBSZW1vdGVCQU1GZWF0dXJlU291cmNlOiBSZW1vdGVCQU1GZWF0dXJlU291cmNlLFxuICAgICAgICBEdW1teUZlYXR1cmVTb3VyY2U6IER1bW15RmVhdHVyZVNvdXJjZSxcbiAgICAgICAgRHVtbXlTZXF1ZW5jZVNvdXJjZTogRHVtbXlTZXF1ZW5jZVNvdXJjZSxcblxuICAgICAgICByZWdpc3RlclNvdXJjZUFkYXB0ZXJGYWN0b3J5OiBkYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSxcbiAgICAgICAgcmVnaXN0ZXJQYXJzZXJGYWN0b3J5OiBkYWxsaWFuY2VfcmVnaXN0ZXJQYXJzZXJGYWN0b3J5LFxuICAgICAgICBtYWtlUGFyc2VyOiBkYWxsaWFuY2VfbWFrZVBhcnNlclxuICAgIH1cblxuICAgIC8vIFN0YW5kYXJkIHNldCBvZiBwbHVnaW5zLlxuICAgIHJlcXVpcmUoJy4vZW5zZW1ibGpzb24nKTtcbiAgICByZXF1aXJlKCcuL3RhYml4LXNvdXJjZScpO1xuICAgIHJlcXVpcmUoJy4vbWVtc3RvcmUnKTtcbiAgICByZXF1aXJlKCcuL2JlZHdpZycpO1xuICAgIHJlcXVpcmUoJy4vdmNmJyk7XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE1XG4vL1xuLy8gc291cmNlY29tcGFyZS5qc1xuLy9cblxuXG5mdW5jdGlvbiBzb3VyY2VEYXRhVVJJKGNvbmYpIHtcbiAgICBpZiAoY29uZi51cmkpIHtcbiAgICAgICAgcmV0dXJuIGNvbmYudXJpO1xuICAgIH0gZWxzZSBpZiAoY29uZi5ibG9iKSB7XG4gICAgICAgIHJldHVybiAnZmlsZTonICsgY29uZi5ibG9iLm5hbWU7XG4gICAgfSBlbHNlIGlmIChjb25mLmJ3Z0Jsb2IpIHtcbiAgICAgICAgcmV0dXJuICdmaWxlOicgKyBjb25mLmJ3Z0Jsb2IubmFtZTtcbiAgICB9IGVsc2UgaWYgKGNvbmYuYmFtQmxvYikge1xuICAgICAgICByZXR1cm4gJ2ZpbGU6JyArIGNvbmYuYmFtQmxvYi5uYW1lO1xuICAgIH0gZWxzZSBpZiAoY29uZi50d29CaXRCbG9iKSB7XG4gICAgICAgIHJldHVybiAnZmlsZTonICsgY29uZi50d29CaXRCbG9iLm5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmYuYndnVVJJIHx8IGNvbmYuYmFtVVJJIHx8IGNvbmYuamJVUkkgfHwgY29uZi50d29CaXRVUkkgfHwgJ2h0dHBzOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvbWFnaWMvbm9fdXJpJztcbn1cblxuZnVuY3Rpb24gc291cmNlU3R5bGVVUkkoY29uZikge1xuICAgIGlmIChjb25mLnN0eWxlc2hlZXRfdXJpKVxuICAgICAgICByZXR1cm4gY29uZi5zdHlsZXNoZWV0X3VyaTtcbiAgICBlbHNlIGlmIChjb25mLnRpZXJfdHlwZSA9PSAnc2VxdWVuY2UnIHx8IGNvbmYudHdvQml0VVJJIHx8IGNvbmYudHdvQml0QmxvYilcbiAgICAgICAgcmV0dXJuICdodHRwczovL3d3dy5iaW9kYWxsaWFuY2Uub3JnL21hZ2ljL3NlcXVlbmNlJ1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHNvdXJjZURhdGFVUkkoY29uZik7XG59XG5cbmZ1bmN0aW9uIHNvdXJjZXNBcmVFcXVhbE1vZHVsb1N0eWxlKGEsIGIpIHtcbiAgICBpZiAoc291cmNlRGF0YVVSSShhKSAhPSBzb3VyY2VEYXRhVVJJKGIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYS5tYXBwaW5nICE9IGIubWFwcGluZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGEudGllcl90eXBlICE9IGIudGllcl90eXBlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYS5vdmVybGF5KSB7XG4gICAgICAgIGlmICghYi5vdmVybGF5IHx8IGIub3ZlcmxheS5sZW5ndGggIT0gYS5vdmVybGF5Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IGEub3ZlcmxheS5sZW5ndGg7ICsrb2kpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlc0FyZUVxdWFsTW9kdWxvU3R5bGUoYS5vdmVybGF5W29pXSwgYi5vdmVybGF5W29pXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGIub3ZlcmxheSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gc291cmNlc0FyZUVxdWFsKGEsIGIpIHtcbiAgICBpZiAoc291cmNlRGF0YVVSSShhKSAhPSBzb3VyY2VEYXRhVVJJKGIpIHx8XG4gICAgICAgIHNvdXJjZVN0eWxlVVJJKGEpICE9IHNvdXJjZVN0eWxlVVJJKGIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYS5tYXBwaW5nICE9IGIubWFwcGluZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGEudGllcl90eXBlICE9IGIudGllcl90eXBlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYS5vdmVybGF5KSB7XG4gICAgICAgIGlmICghYi5vdmVybGF5IHx8IGIub3ZlcmxheS5sZW5ndGggIT0gYS5vdmVybGF5Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgb2kgPSAwOyBvaSA8IGEub3ZlcmxheS5sZW5ndGg7ICsrb2kpIHtcbiAgICAgICAgICAgIGlmICghc291cmNlc0FyZUVxdWFsKGEub3ZlcmxheVtvaV0sIGIub3ZlcmxheVtvaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChiLm92ZXJsYXkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgc291cmNlc0FyZUVxdWFsOiBzb3VyY2VzQXJlRXF1YWwsXG4gICAgICAgIHNvdXJjZXNBcmVFcXVhbE1vZHVsb1N0eWxlOiBzb3VyY2VzQXJlRXF1YWxNb2R1bG9TdHlsZSxcbiAgICAgICAgc291cmNlRGF0YVVSSTogc291cmNlRGF0YVVSSSxcbiAgICAgICAgc291cmNlU3R5bGVVUkk6IHNvdXJjZVN0eWxlVVJJXG4gICAgfTtcbn1cbiIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyBzcGFucy5qczogSmF2YVNjcmlwdCBJbnRzZXQvTG9jYXRpb24gcG9ydC5cbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFJhbmdlKG1pbiwgbWF4KVxue1xuICAgIGlmICh0eXBlb2YobWluKSAhPSAnbnVtYmVyJyB8fCB0eXBlb2YobWF4KSAhPSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgJ0JhZCByYW5nZSAnICsgbWluICsgJywnICsgbWF4O1xuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG59XG5cblJhbmdlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWluO1xufVxuXG5SYW5nZS5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21heDtcbn1cblxuUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgcmV0dXJuIHBvcyA+PSB0aGlzLl9taW4gJiYgcG9zIDw9IHRoaXMuX21heDtcbn1cblxuUmFuZ2UucHJvdG90eXBlLmlzQ29udGlndW91cyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xufVxuXG5SYW5nZS5wcm90b3R5cGUucmFuZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFt0aGlzXTtcbn1cblxuUmFuZ2UucHJvdG90eXBlLl9wdXNoUmFuZ2VzID0gZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgcmFuZ2VzLnB1c2godGhpcyk7XG59XG5cblJhbmdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnWycgKyB0aGlzLl9taW4gKyAnLScgKyB0aGlzLl9tYXggKyAnXSc7XG59XG5cbmZ1bmN0aW9uIF9Db21wb3VuZChyYW5nZXMpIHtcbiAgICAvLyBnaXZlbjogYSBzZXQgb2YgdW5zb3J0ZWQgcG9zc2libHkgb3ZlcmxhcHBpbmcgcmFuZ2VzXG4gICAgLy8gc29ydCB0aGUgaW5wdXQgcmFuZ2VzXG4gICAgdmFyIHNvcnRlZCA9IHJhbmdlcy5zb3J0KF9yYW5nZU9yZGVyKTtcbiAgICAvLyBtZXJnZSBvdmVybGFwcyBiZXR3ZWVuIGFkamFjZW50IHJhbmdlc1xuICAgIHZhciBtZXJnZWQgPSBbXTtcbiAgICB2YXIgY3VycmVudCA9IHNvcnRlZC5zaGlmdCgpO1xuICAgIHNvcnRlZC5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgIGlmIChyYW5nZS5fbWluIDw9IGN1cnJlbnQuX21heCkge1xuICAgICAgICAgICAgaWYgKHJhbmdlLl9tYXggPiBjdXJyZW50Ll9tYXgpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Ll9tYXggPSByYW5nZS5fbWF4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgICBjdXJyZW50ID0gcmFuZ2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtZXJnZWQucHVzaChjdXJyZW50KTtcbiAgICB0aGlzLl9yYW5nZXMgPSBtZXJnZWQ7XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhbmdlc1swXS5taW4oKTtcbn1cblxuX0NvbXBvdW5kLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFuZ2VzW3RoaXMuX3Jhbmdlcy5sZW5ndGggLSAxXS5tYXgoKTtcbn1cblxuLy8gcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHJhbmdlIHRoYXQgaXMgbm90IGxlc3MgdGhhbiBwb3Ncbl9Db21wb3VuZC5wcm90b3R5cGUubG93ZXJfYm91bmQgPSBmdW5jdGlvbihwb3MpIHtcbiAgICAvLyBmaXJzdCBjaGVjayBpZiBwb3MgaXMgb3V0IG9mIHJhbmdlXG4gICAgdmFyIHIgPSB0aGlzLnJhbmdlcygpO1xuICAgIGlmIChwb3MgPiB0aGlzLm1heCgpKSByZXR1cm4gci5sZW5ndGg7XG4gICAgaWYgKHBvcyA8IHRoaXMubWluKCkpIHJldHVybiAwO1xuICAgIC8vIGRvIGEgYmluYXJ5IHNlYXJjaFxuICAgIHZhciBhPTAsIGI9ci5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChhIDw9IGIpIHtcbiAgICAgICAgdmFyIG0gPSBNYXRoLmZsb29yKChhK2IpLzIpO1xuICAgICAgICBpZiAocG9zID4gclttXS5fbWF4KSB7XG4gICAgICAgICAgICBhID0gbSsxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBvcyA8IHJbbV0uX21pbikge1xuICAgICAgICAgICAgYiA9IG0tMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuXG5fQ29tcG91bmQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24ocG9zKSB7XG4gICAgdmFyIGxiID0gdGhpcy5sb3dlcl9ib3VuZChwb3MpO1xuICAgIGlmIChsYiA8IHRoaXMuX3Jhbmdlcy5sZW5ndGggJiYgdGhpcy5fcmFuZ2VzW2xiXS5jb250YWlucyhwb3MpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUuaW5zZXJ0UmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgIHZhciBsYiA9IHRoaXMubG93ZXJfYm91bmQocmFuZ2UuX21pbik7XG4gICAgaWYgKGxiID09PSB0aGlzLl9yYW5nZXMubGVuZ3RoKSB7IC8vIHJhbmdlIGZvbGxvd3MgdGhpc1xuICAgICAgICB0aGlzLl9yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdmFyIHIgPSB0aGlzLnJhbmdlcygpO1xuICAgIGlmIChyYW5nZS5fbWF4IDwgcltsYl0uX21pbikgeyAvLyByYW5nZSBwcmVjZWVkcyBsYlxuICAgICAgICB0aGlzLl9yYW5nZXMuc3BsaWNlKGxiLDAscmFuZ2UpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gcmFuZ2Ugb3ZlcmxhcHMgbGIgKGF0IGxlYXN0KVxuICAgIGlmIChyW2xiXS5fbWluIDwgcmFuZ2UuX21pbikgcmFuZ2UuX21pbiA9IHJbbGJdLl9taW47XG4gICAgdmFyIHViID0gbGIrMTtcbiAgICB3aGlsZSAodWIgPCByLmxlbmd0aCAmJiByW3ViXS5fbWluIDw9IHJhbmdlLl9tYXgpIHtcbiAgICAgICAgdWIrKztcbiAgICB9XG4gICAgdWItLTtcbiAgICAvLyB1YiBpcyB0aGUgdXBwZXIgYm91bmQgb2YgdGhlIG5ldyByYW5nZVxuICAgIGlmIChyW3ViXS5fbWF4ID4gcmFuZ2UuX21heCkgcmFuZ2UuX21heCA9IHJbdWJdLl9tYXg7XG4gICAgXG4gICAgLy8gc3BsaWNlIHJhbmdlIGludG8gdGhpcy5fcmFuZ2VzXG4gICAgdGhpcy5fcmFuZ2VzLnNwbGljZShsYix1Yi1sYisxLHJhbmdlKTtcbiAgICByZXR1cm47XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUuaXNDb250aWd1b3VzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jhbmdlcy5sZW5ndGggPiAxO1xufVxuXG5fQ29tcG91bmQucHJvdG90eXBlLnJhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZXM7XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUuX3B1c2hSYW5nZXMgPSBmdW5jdGlvbihyYW5nZXMpIHtcbiAgICBmb3IgKHZhciByaSA9IDA7IHJpIDwgdGhpcy5fcmFuZ2VzLmxlbmd0aDsgKytyaSlcbiAgICAgICAgcmFuZ2VzLnB1c2godGhpcy5fcmFuZ2VzW3JpXSk7XG59XG5cbl9Db21wb3VuZC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIGZvciAodmFyIHIgPSAwOyByIDwgdGhpcy5fcmFuZ2VzLmxlbmd0aDsgKytyKSB7XG4gICAgICAgIGlmIChyPjApIHtcbiAgICAgICAgICAgIHMgPSBzICsgJywnO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzICsgdGhpcy5fcmFuZ2VzW3JdLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiB1bmlvbihzMCwgczEpIHtcbiAgICBpZiAoISAoczAgaW5zdGFuY2VvZiBfQ29tcG91bmQpKSB7XG4gICAgICAgIGlmICghIChzMCBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgICAgIHMwID0gW3MwXTtcbiAgICAgICAgczAgPSBuZXcgX0NvbXBvdW5kKHMwKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHMxKVxuICAgICAgICBzMC5pbnNlcnRSYW5nZShzMSk7XG5cbiAgICByZXR1cm4gczA7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihzMCwgczEpIHtcbiAgICB2YXIgcjAgPSBzMC5yYW5nZXMoKTtcbiAgICB2YXIgcjEgPSBzMS5yYW5nZXMoKTtcbiAgICB2YXIgbDAgPSByMC5sZW5ndGgsIGwxID0gcjEubGVuZ3RoO1xuICAgIHZhciBpMCA9IDAsIGkxID0gMDtcbiAgICB2YXIgb3IgPSBbXTtcblxuICAgIHdoaWxlIChpMCA8IGwwICYmIGkxIDwgbDEpIHtcbiAgICAgICAgdmFyIHMwID0gcjBbaTBdLCBzMSA9IHIxW2kxXTtcbiAgICAgICAgdmFyIGxhcE1pbiA9IE1hdGgubWF4KHMwLm1pbigpLCBzMS5taW4oKSk7XG4gICAgICAgIHZhciBsYXBNYXggPSBNYXRoLm1pbihzMC5tYXgoKSwgczEubWF4KCkpO1xuICAgICAgICBpZiAobGFwTWF4ID49IGxhcE1pbikge1xuICAgICAgICAgICAgb3IucHVzaChuZXcgUmFuZ2UobGFwTWluLCBsYXBNYXgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczAubWF4KCkgPiBzMS5tYXgoKSkge1xuICAgICAgICAgICAgKytpMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsraTA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKG9yLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBGSVhNRVxuICAgIH0gZWxzZSBpZiAob3IubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9yWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbXBvdW5kKG9yKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNvdmVyYWdlKHMpIHtcbiAgICB2YXIgdG90ID0gMDtcbiAgICB2YXIgcmwgPSBzLnJhbmdlcygpO1xuICAgIGZvciAodmFyIHJpID0gMDsgcmkgPCBybC5sZW5ndGg7ICsrcmkpIHtcbiAgICAgICAgdmFyIHIgPSBybFtyaV07XG4gICAgICAgIHRvdCArPSAoci5tYXgoKSAtIHIubWluKCkgKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdDtcbn1cblxuXG5cbmZ1bmN0aW9uIHJhbmdlT3JkZXIoYSwgYilcbntcbiAgICBpZiAoYS5taW4oKSA8IGIubWluKCkpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYS5taW4oKSA+IGIubWluKCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhLm1heCgpIDwgYi5tYXgoKSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChiLm1heCgpID4gYS5tYXgoKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9yYW5nZU9yZGVyKGEsIGIpXG57XG4gICAgaWYgKGEuX21pbiA8IGIuX21pbikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChhLl9taW4gPiBiLl9taW4pIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhLl9tYXggPCBiLl9tYXgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYi5fbWF4ID4gYS5fbWF4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBSYW5nZTogUmFuZ2UsXG4gICAgICAgIHVuaW9uOiB1bmlvbixcbiAgICAgICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24sXG4gICAgICAgIGNvdmVyYWdlOiBjb3ZlcmFnZSxcbiAgICAgICAgcmFuZ2VPdmVyOiByYW5nZU9yZGVyLFxuICAgICAgICBfcmFuZ2VPcmRlcjogX3JhbmdlT3JkZXJcbiAgICB9XG59IiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMTRcbi8vXG4vLyBzdHlsZS5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIFN0eWxlRmlsdGVyKHR5cGUsIG1ldGhvZCwgbGFiZWwpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbn1cblxuU3R5bGVGaWx0ZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09IG8udHlwZSAmJiB0aGlzLm1ldGhvZCA9PSBvLm1ldGhvZCAmJiB0aGlzLmxhYmVsID09IG8ubGFiZWw7XG59XG5cblN0eWxlRmlsdGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmcyA9IFtdO1xuICAgIGlmICh0aGlzLnR5cGUpIFxuICAgICAgICBmcy5wdXNoKCd0eXBlPScgKyB0aGlzLnR5cGUpO1xuICAgIGlmICh0aGlzLm1ldGhvZClcbiAgICAgICAgZnMucHVzaCgnbWV0aG9kPScgKyB0aGlzLm1ldGhvZCk7XG4gICAgaWYgKHRoaXMubGFiZWwpXG4gICAgICAgIGZzLnB1c2goJ2xhYmVsPScgKyB0aGlzLmxhYmVsKTtcbiAgICByZXR1cm4gJ1N0eWxlRmlsdGVyPCcgKyBmcy5qb2luKCc7JykgKyAnPic7XG59XG5cbmZ1bmN0aW9uIFN0eWxlRmlsdGVyU2V0KGZpbHRlcnMpIHtcbiAgICB0aGlzLl9maWx0ZXJzID0ge307XG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZpbHRlcnMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZChmaWx0ZXJzW2ZpXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblN0eWxlRmlsdGVyU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICB2YXIgZnMgPSBmaWx0ZXIudG9TdHJpbmcoKTtcbiAgICBpZiAoIXRoaXMuX2ZpbHRlcnNbZnNdKSB7XG4gICAgICAgIHRoaXMuX2ZpbHRlcnNbZnNdID0gZmlsdGVyO1xuICAgICAgICB0aGlzLl9saXN0ID0gbnVsbDtcbiAgICB9XG59XG5cblN0eWxlRmlsdGVyU2V0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbihmaWx0ZXJTZXQpIHtcbiAgICB2YXIgbCA9IGZpbHRlclNldC5saXN0KCk7XG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGwubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHRoaXMuYWRkKGxbZmldKTtcbiAgICB9XG59XG5cblN0eWxlRmlsdGVyU2V0LnByb3RvdHlwZS5kb2VzTm90Q29udGFpbiA9IGZ1bmN0aW9uKGZpbHRlclNldCkge1xuICAgIHZhciBsID0gZmlsdGVyU2V0Lmxpc3QoKTtcbiAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgbC5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJzW2ZpLnRvU3RyaW5nKCldKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5TdHlsZUZpbHRlclNldC5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fbGlzdCkge1xuICAgICAgICB0aGlzLl9saXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5fZmlsdGVycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZpbHRlcnMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0LnB1c2godGhpcy5fZmlsdGVyc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xpc3Q7XG59XG5cblN0eWxlRmlsdGVyU2V0LnByb3RvdHlwZS50eXBlTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0eXBlcyA9IFtdO1xuICAgIHZhciBsaXN0ID0gdGhpcy5saXN0KCk7XG4gICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGxpc3QubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBsaXN0W2ZpXTtcbiAgICAgICAgdmFyIHR5cGUgPSBmaWx0ZXIudHlwZTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUgPT0gJ2RlZmF1bHQnKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0eXBlcy5pbmRleE9mKHR5cGUpIDwgMClcbiAgICAgICAgICAgIHR5cGVzLnB1c2godHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlcztcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBTdHlsZUZpbHRlcjogU3R5bGVGaWx0ZXIsXG4gICAgICAgIFN0eWxlRmlsdGVyU2V0OiBTdHlsZUZpbHRlclNldFxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gc3ZnLWV4cG9ydC5qc1xuLy9cblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbiAgICB2YXIgbWFrZUVsZW1lbnROUyA9IHV0aWxzLm1ha2VFbGVtZW50TlM7XG5cbiAgICB2YXIgVkVSU0lPTiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG4gICAgdmFyIHN2Z1NlcVRpZXIgPSByZXF1aXJlKCcuL3NlcXVlbmNlLWRyYXcnKS5zdmdTZXFUaWVyO1xuXG4gICAgdmFyIHN2Z3UgPSByZXF1aXJlKCcuL3N2Zy11dGlscycpO1xuICAgIHZhciBOU19TVkcgPSBzdmd1Lk5TX1NWRztcbiAgICB2YXIgTlNfWExJTksgPSBzdmd1Lk5TX1hMSU5LO1xuICAgIHZhciBTVkdQYXRoID0gc3ZndS5TVkdQYXRoO1xuXG4gICAgdmFyIG5mID0gcmVxdWlyZSgnLi9udW1mb3JtYXRzJyk7XG4gICAgdmFyIGZvcm1hdFF1YW50TGFiZWwgPSBuZi5mb3JtYXRRdWFudExhYmVsO1xufVxuXG5cbkJyb3dzZXIucHJvdG90eXBlLm1ha2VTVkcgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIG1pblRpZXJIZWlnaHQgPSBvcHRzLm1pblRpZXJIZWlnaHQgfHwgMjA7XG4gICAgdmFyIHBhZGRpbmcgPSAzO1xuXG4gICAgdmFyIGIgPSB0aGlzO1xuICAgIHZhciBzYXZlRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlRG9jdW1lbnQoTlNfU1ZHLCAnc3ZnJywgbnVsbCk7XG5cbiAgICB2YXIgc2F2ZVJvb3QgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnLCBudWxsLCB7XG4gICAgICAgIGZvbnRGYW1pbHk6ICdoZWx2ZXRpY2EnLFxuICAgICAgICBmb250U2l6ZTogJzhwdCdcbiAgICB9KTtcbiAgICBzYXZlRG9jLmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzYXZlUm9vdCk7XG5cbiAgICB2YXIgbWFyZ2luID0gMjAwO1xuXG4gICAgdmFyIGRhbGxpYW5jZUFuY2hvciA9IG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnYScsXG4gICAgICAgbWFrZUVsZW1lbnROUyhOU19TVkcsICd0ZXh0JywgJ0dyYXBoaWNzIGZyb20gRGFsbGlhbmNlICcgKyBWRVJTSU9OLCB7XG4gICAgICAgICAgIHg6IChiLmZlYXR1cmVQYW5lbFdpZHRoICsgbWFyZ2luICsgMjApLzIsXG4gICAgICAgICAgIHk6IDMwLFxuICAgICAgICAgICBzdHJva2VXaWR0aDogMCxcbiAgICAgICAgICAgZm9udFNpemU6ICcxMnB0Jyxcblx0ICAgICAgIHRleHRBbmNob3I6ICdtaWRkbGUnLFxuXHQgICAgICAgZmlsbDogJ2JsdWUnXG4gICAgICAgfSkpO1xuICAgIGRhbGxpYW5jZUFuY2hvci5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJywgTlNfWExJTkspO1xuICAgIGRhbGxpYW5jZUFuY2hvci5zZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnLCAnaHR0cDovL3d3dy5iaW9kYWxsaWFuY2Uub3JnLycpO1xuICBcbiAgICBzYXZlUm9vdC5hcHBlbmRDaGlsZChkYWxsaWFuY2VBbmNob3IpO1xuICAgIFxuICAgIHZhciBjbGlwUmVjdCA9IG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAncmVjdCcsIG51bGwsIHtcbiAgICBcdHg6IG1hcmdpbixcbiAgICBcdHk6IDUwLFxuICAgIFx0d2lkdGg6IGIuZmVhdHVyZVBhbmVsV2lkdGgsXG4gICAgXHRoZWlnaHQ6IDEwMDAwMFxuICAgIH0pO1xuICAgIHZhciBjbGlwID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdjbGlwUGF0aCcsIGNsaXBSZWN0LCB7aWQ6ICdmZWF0dXJlQ2xpcCd9KTtcbiAgICBzYXZlUm9vdC5hcHBlbmRDaGlsZChjbGlwKTtcblxuICAgIHZhciBwb3MgPSA3MDtcbiAgICB2YXIgdGllckhvbGRlciA9IG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnZycsIG51bGwsIHt9KTtcblxuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCBiLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICB2YXIgdGllciA9IGIudGllcnNbdGldO1xuICAgIFx0dmFyIHRpZXJTVkcgPSBtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnLCBudWxsLCB7Y2xpcFBhdGg6ICd1cmwoI2ZlYXR1cmVDbGlwKScsIGNsaXBSdWxlOiAnbm9uemVybyd9KTtcbiAgICBcdHZhciB0aWVyTGFiZWxzID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdnJyk7XG4gICAgXHR2YXIgdGllclRvcFBvcyA9IHBvcztcblxuICAgIFx0dmFyIHRpZXJCYWNrZ3JvdW5kID0gbWFrZUVsZW1lbnROUyhOU19TVkcsICdyZWN0JywgbnVsbCwge3g6IDAsIHk6IHRpZXJUb3BQb3MsIHdpZHRoOiAnMTAwMDAnLCBoZWlnaHQ6IDUwLCBmaWxsOiB0aWVyLmJhY2tncm91bmR9KTtcbiAgICBcdHRpZXJTVkcuYXBwZW5kQ2hpbGQodGllckJhY2tncm91bmQpO1xuXG4gICAgXHRpZiAodGllci5zZXF1ZW5jZVNvdXJjZSkge1xuICAgIFx0ICAgIHZhciBzZXFUcmFjayA9IHN2Z1NlcVRpZXIodGllciwgdGllci5jdXJyZW50U2VxdWVuY2UpO1xuICAgIFx0ICAgIFxuICAgIFx0ICAgIHRpZXJTVkcuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnROUyhOU19TVkcsICdnJywgc2VxVHJhY2ssIHt0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIChtYXJnaW4pICsgJywgJyArIHBvcyArICcpJ30pKTtcbiAgICBcdCAgICBwb3MgKz0gODA7XG4gICAgXHR9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aWVyLnN1YnRpZXJzKSB7XG4gICAgXHRcdCAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgIFx0XG4gICAgXHQgICAgdmFyIG9mZnNldCA9ICgodGllci5nbHlwaENhY2hlT3JpZ2luIC0gYi52aWV3U3RhcnQpICogYi5zY2FsZSk7XG4gICAgICAgICAgICB2YXIgaGFzUXVhbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIHN0aSA9IDA7IHN0aSA8IHRpZXIuc3VidGllcnMubGVuZ3RoOyArK3N0aSkge1xuICAgICAgICAgICAgICAgIHBvcyArPSBwYWRkaW5nO1xuICAgICAgICBcdFx0dmFyIHN1YnRpZXIgPSB0aWVyLnN1YnRpZXJzW3N0aV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBcdFx0dmFyIGdseXBoRWxlbWVudHMgPSBbXTtcbiAgICAgICAgXHRcdGZvciAodmFyIGdpID0gMDsgZ2kgPCBzdWJ0aWVyLmdseXBocy5sZW5ndGg7ICsrZ2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gc3VidGllci5nbHlwaHNbZ2ldO1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEVsZW1lbnRzLnB1c2goZ2x5cGgudG9TVkcoKSk7XG4gICAgICAgIFx0XHR9XG5cbiAgICBcdFx0ICAgIHRpZXJTVkcuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnROUyhOU19TVkcsICdnJywgZ2x5cGhFbGVtZW50cywge3RyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgKG1hcmdpbitvZmZzZXQpICsgJywgJyArIHBvcyArICcpJ30pKTtcblxuICAgICAgICBcdFx0aWYgKHN1YnRpZXIucXVhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzUXVhbnQgPSB0cnVlO1xuICAgICAgICBcdFx0ICAgIHZhciBxID0gc3VidGllci5xdWFudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBzdWJ0aWVyLmhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtVGljcyA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoID4gNDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRpY3MgPSAxICsgKChoLzIwKSB8IDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aWNTcGFjaW5nID0gaCAvIChudW1UaWNzIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aWNJbnRlcnZhbCA9IChxLm1heCAtIHEubWluKSAvIChudW1UaWNzIC0gMSk7XG5cbiAgICAgICAgXHRcdCAgICB2YXIgcGF0aCA9IG5ldyBTVkdQYXRoKCk7XG4gICAgICAgIFx0XHQgICAgcGF0aC5tb3ZlVG8obWFyZ2luICsgNSwgcG9zKTtcbiAgICAgICAgXHRcdCAgICBwYXRoLmxpbmVUbyhtYXJnaW4sIHBvcyk7XG4gICAgICAgIFx0XHQgICAgcGF0aC5saW5lVG8obWFyZ2luLCBwb3MgKyBzdWJ0aWVyLmhlaWdodCk7XG4gICAgICAgIFx0XHQgICAgcGF0aC5saW5lVG8obWFyZ2luICsgNSwgcG9zICsgc3VidGllci5oZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMTsgdCA8IG51bVRpY3MtMTsgKyt0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHkgPSB0KnRpY1NwYWNpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLm1vdmVUbyhtYXJnaW4sIHBvcyArIHR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubGluZVRvKG1hcmdpbiszLCBwb3MgKyB0eSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICBcdFx0ICAgIHRpZXJMYWJlbHMuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnROUyhOU19TVkcsICdwYXRoJywgbnVsbCwge2Q6IHBhdGgudG9QYXRoRGF0YSgpLCBmaWxsOiAnbm9uZScsIHN0cm9rZTogJ2JsYWNrJywgc3Ryb2tlV2lkdGg6ICcycHgnfSkpO1xuICAgICAgICBcdFx0ICAgIHRpZXJMYWJlbHMuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnROUyhOU19TVkcsICd0ZXh0JywgZm9ybWF0UXVhbnRMYWJlbChxLm1heCksIHt4OiBtYXJnaW4gLSAzLCB5OiBwb3MgKyA3LCB0ZXh0QW5jaG9yOiAnZW5kJ30pKTtcbiAgICAgICAgXHRcdCAgICB0aWVyTGFiZWxzLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAndGV4dCcsIGZvcm1hdFF1YW50TGFiZWwocS5taW4pLCB7eDogbWFyZ2luIC0gMywgeTogcG9zICsgIHN1YnRpZXIuaGVpZ2h0LCB0ZXh0QW5jaG9yOiAnZW5kJ30pKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgdCA9IDE7IHQgPCBudW1UaWNzLTE7ICsrdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5ID0gdCp0aWNTcGFjaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGllckxhYmVscy5hcHBlbmRDaGlsZChtYWtlRWxlbWVudE5TKE5TX1NWRywgJ3RleHQnLCBmb3JtYXRRdWFudExhYmVsKCgxLjAqcS5tYXgpIC0gKHQqdGljSW50ZXJ2YWwpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3g6IG1hcmdpbiAtIDMsIHk6IHBvcyArICB0eSArIDMsIHRleHRBbmNob3I6ICdlbmQnfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgIFx0XHR9XG5cbiAgICBcdFx0ICAgIHBvcyArPSBzdWJ0aWVyLmhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3MgLSB0aWVyVG9wUG9zIDwgbWluVGllckhlaWdodCkge1xuICAgICAgICAgICAgICAgIHBvcyA9IHRpZXJUb3BQb3MgKyBtaW5UaWVySGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgIFx0fVxuXG4gICAgICAgIHZhciBsYWJlbE5hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgdGllci5jb25maWcubmFtZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICBsYWJlbE5hbWUgPSB0aWVyLmNvbmZpZy5uYW1lO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsYWJlbE5hbWUgPSB0aWVyLmRhc1NvdXJjZS5uYW1lO1xuICAgIFx0dGllckxhYmVscy5hcHBlbmRDaGlsZChcbiAgICBcdCAgICBtYWtlRWxlbWVudE5TKFxuICAgIFx0XHROU19TVkcsICd0ZXh0JyxcbiAgICBcdFx0bGFiZWxOYW1lLFxuICAgIFx0XHR7eDogbWFyZ2luIC0gKGhhc1F1YW50ID8gMjAgOiAxMiksIHk6IChwb3MrdGllclRvcFBvcys4KS8yLCBmb250U2l6ZTogJzEwcHQnLCB0ZXh0QW5jaG9yOiAnZW5kJ30pKTtcblxuICAgIFx0XG4gICAgXHR0aWVyQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHBvcyAtIHRpZXJUb3BQb3MpO1xuICAgIFx0dGllckhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudE5TKE5TX1NWRywgJ2cnLCBbdGllclNWRywgdGllckxhYmVsc10pKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5oaWdobGlnaHRzKSB7XG4gICAgICAgIHZhciBoaWdobGlnaHRzID0gdGhpcy5oaWdobGlnaHRzIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgaGlnaGxpZ2h0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgIHZhciBoID0gaGlnaGxpZ2h0c1toaV07XG4gICAgICAgICAgICBpZiAoKGguY2hyID09IHRoaXMuY2hyIHx8IGguY2hyID09ICgnY2hyJyArIHRoaXMuY2hyKSkgJiYgaC5taW4gPCB0aGlzLnZpZXdFbmQgJiYgaC5tYXggPiB0aGlzLnZpZXdTdGFydCkge1xuICAgICAgICAgICAgICAgIHZhciB0bWluID0gKE1hdGgubWF4KGgubWluLCB0aGlzLnZpZXdTdGFydCkgLSB0aGlzLnZpZXdTdGFydCkgKiB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICAgIHZhciB0bWF4ID0gKE1hdGgubWluKGgubWF4LCB0aGlzLnZpZXdFbmQpIC0gdGhpcy52aWV3U3RhcnQpICogdGhpcy5zY2FsZTtcblxuICAgICAgICAgICAgICAgIHRpZXJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnROUyhOU19TVkcsICdyZWN0JywgbnVsbCwge3g6IG1hcmdpbiArIHRtaW4sIHk6IDcwLCB3aWR0aDogKHRtYXgtdG1pbiksIGhlaWdodDogcG9zLTcwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZTogJ25vbmUnLCBmaWxsOiB0aGlzLmRlZmF1bHRIaWdobGlnaHRGaWxsLCBmaWxsT3BhY2l0eTogdGhpcy5kZWZhdWx0SGlnaGxpZ2h0QWxwaGF9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcnVsZXJQb3MgPSAtMTsgXG4gICAgaWYgKG9wdHMucnVsZXIgPT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcnVsZXJQb3MgPSBtYXJnaW4gKyAoKHRoaXMudmlld0VuZCAtIHRoaXMudmlld1N0YXJ0KSp0aGlzLnNjYWxlKSAvIDI7XG4gICAgfSBlbHNlIGlmIChvcHRzLnJ1bGVyID09ICdsZWZ0Jykge1xuICAgICAgICBydWxlclBvcyA9IG1hcmdpbjtcbiAgICB9IGVsc2UgaWYgKG9wdHMucnVsZXIgPT0gJ3JpZ2h0Jykge1xuICAgICAgICBydWxlclBvcyA9IG1hcmdpbiArICgodGhpcy52aWV3RW5kIC0gdGhpcy52aWV3U3RhcnQpKnRoaXMuc2NhbGUpO1xuICAgIH1cbiAgICBpZiAocnVsZXJQb3MgPj0gMCkge1xuICAgICAgICB0aWVySG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50TlMoTlNfU1ZHLCAnbGluZScsIG51bGwsIHt4MTogcnVsZXJQb3MsIHkxOiA3MCwgeDI6IHJ1bGVyUG9zLCB5MjogcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U6ICdibHVlJ30pKTtcbiAgICB9XG5cbiAgICBzYXZlUm9vdC5hcHBlbmRDaGlsZCh0aWVySG9sZGVyKTtcbiAgICBzYXZlRG9jLmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgYi5mZWF0dXJlUGFuZWxXaWR0aCArIDIwICsgbWFyZ2luKTtcbiAgICBzYXZlRG9jLmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHBvcyArIDUwKTtcblxuICAgIHZhciBzdmdCbG9iID0gbmV3IEJsb2IoW25ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc2F2ZURvYyldLCB7dHlwZTogJ2ltYWdlL3N2Zyt4bWwnfSk7XG4gICAgcmV0dXJuIHN2Z0Jsb2I7XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDE0XG4vL1xuLy8gc3ZnLXV0aWxzLmpzXG4vL1xuXG52YXIgTlNfU1ZHID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbnZhciBOU19YTElOSyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxuZnVuY3Rpb24gU1ZHUGF0aCgpIHtcbiAgICB0aGlzLm9wcyA9IFtdO1xufVxuXG5TVkdQYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5vcHMucHVzaCgnTSAnICsgeCArICcgJyArIHkpO1xufVxuXG5TVkdQYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5vcHMucHVzaCgnTCAnICsgeCArICcgJyArIHkpO1xufVxuXG5TVkdQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9wcy5wdXNoKCdaJyk7XG59XG5cblNWR1BhdGgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcHMuam9pbignICcpO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIE5TX1NWRzogTlNfU1ZHLFxuICAgICAgICBOU19YTElOSzogTlNfWExJTkssXG4gICAgICAgIFNWR1BhdGg6IFNWR1BhdGhcbiAgICB9XG59IiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxM1xuLy9cbi8vIHRhYml4LXNvdXJjZS5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHNhID0gcmVxdWlyZSgnLi9zb3VyY2VhZGFwdGVycycpO1xuICAgIHZhciBkYWxsaWFuY2VfcmVnaXN0ZXJTb3VyY2VBZGFwdGVyRmFjdG9yeSA9IHNhLnJlZ2lzdGVyU291cmNlQWRhcHRlckZhY3Rvcnk7XG4gICAgdmFyIGRhbGxpYW5jZV9tYWtlUGFyc2VyID0gc2EubWFrZVBhcnNlcjtcbiAgICB2YXIgRmVhdHVyZVNvdXJjZUJhc2UgPSBzYS5GZWF0dXJlU291cmNlQmFzZTtcblxuICAgIHZhciBiaW4gPSByZXF1aXJlKCcuL2JpbicpO1xuICAgIHZhciBVUkxGZXRjaGFibGUgPSBiaW4uVVJMRmV0Y2hhYmxlO1xuICAgIHZhciBCbG9iRmV0Y2hhYmxlID0gYmluLkJsb2JGZXRjaGFibGU7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIEF3YWl0ZWQgPSB1dGlscy5Bd2FpdGVkO1xuXG4gICAgdmFyIGNvbm5lY3RUYWJpeCA9IHJlcXVpcmUoJy4vdGFiaXgnKS5jb25uZWN0VGFiaXg7XG59XG5cbmZ1bmN0aW9uIFRhYml4RmVhdHVyZVNvdXJjZShzb3VyY2UpIHtcbiAgICBGZWF0dXJlU291cmNlQmFzZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMucmVhZGluZXNzID0gJ0Nvbm5lY3RpbmcnO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuXG4gICAgdGhpcy50YWJpeEhvbGRlciA9IG5ldyBBd2FpdGVkKCk7XG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuXG4gICAgdmFyIHBhcnNlciA9IGRhbGxpYW5jZV9tYWtlUGFyc2VyKHNvdXJjZS5wYXlsb2FkKTtcbiAgICBpZiAoIXBhcnNlcikge1xuICAgICAgICB0aHJvdyAnVW5zdXBvcnRlZCB0YWJpeCBwYXlsb2FkICcgKyBzb3VyY2UucGF5bG9hZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSwgaW5kZXg7XG4gICAgaWYgKHRoaXMuc291cmNlLmJsb2IpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCbG9iRmV0Y2hhYmxlKHRoaXMuc291cmNlLmJsb2IpO1xuICAgICAgICBpbmRleCA9IG5ldyBCbG9iRmV0Y2hhYmxlKHRoaXMuc291cmNlLmluZGV4QmxvYik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IG5ldyBVUkxGZXRjaGFibGUodGhpcy5zb3VyY2UudXJpLCB7Y3JlZGVudGlhbHM6IHRoaXMuc291cmNlLmNyZWRlbnRpYWxzfSk7XG4gICAgICAgIGluZGV4ID0gbmV3IFVSTEZldGNoYWJsZSh0aGlzLnNvdXJjZS5pbmRleFVSSSB8fCAodGhpcy5zb3VyY2UudXJpICsgJy50YmknKSwge2NyZWRlbnRpYWxzOiB0aGlzLnNvdXJjZS5jcmVkZW50aWFsc30pO1xuICAgIH1cbiAgICBjb25uZWN0VGFiaXgoZGF0YSwgaW5kZXgsIGZ1bmN0aW9uKHRhYml4LCBlcnIpIHtcbiAgICAgICAgdGhpc0IudGFiaXhIb2xkZXIucHJvdmlkZSh0YWJpeCk7XG4gICAgICAgIHRhYml4LmZldGNoSGVhZGVyKGZ1bmN0aW9uKGxpbmVzLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uID0gcGFyc2VyLmNyZWF0ZVNlc3Npb24oZnVuY3Rpb24oKSB7IC8qIE51bGwgc2luayBiZWNhdXNlIHdlIHNob3VsZG4ndCBnZXQgcmVjb3JkcyAqLyB9KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgbGluZXMubGVuZ3RoOyArK2xpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24ucGFyc2UobGluZXNbbGldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vzc2lvbi5mbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpc0IucmVhZGluZXNzID0gbnVsbFxuICAgICAgICB0aGlzQi5ub3RpZnlSZWFkaW5lc3MoKTtcbiAgICB9KTtcbn1cblxuVGFiaXhGZWF0dXJlU291cmNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRmVhdHVyZVNvdXJjZUJhc2UucHJvdG90eXBlKTtcblxuVGFiaXhGZWF0dXJlU291cmNlLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNociwgbWluLCBtYXgsIHNjYWxlLCB0eXBlcywgcG9vbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIFxuICAgIHRoaXNCLmJ1c3krKztcbiAgICB0aGlzQi5ub3RpZnlBY3Rpdml0eSgpO1xuICAgIFxuICAgIHRoaXMudGFiaXhIb2xkZXIuYXdhaXQoZnVuY3Rpb24odGFiaXgpIHtcbiAgICAgICAgdGFiaXguZmV0Y2goY2hyLCBtaW4sIG1heCwgZnVuY3Rpb24ocmVjb3JkcywgZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXNCLmJ1c3ktLTtcbiAgICAgICAgICAgIHRoaXNCLm5vdGlmeUFjdGl2aXR5KCk7XG5cbiAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzQi5wYXJzZXIuY3JlYXRlU2Vzc2lvbihmdW5jdGlvbihmKSB7ZmVhdHVyZXMucHVzaChmKX0pO1xuICAgICAgICAgICAgZm9yICh2YXIgcmkgPSAwOyByaSA8IHJlY29yZHMubGVuZ3RoOyArK3JpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSBzZXNzaW9uLnBhcnNlKHJlY29yZHNbcmldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlc3Npb24uZmx1c2goKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGZlYXR1cmVzLCAxMDAwMDAwMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cblxuVGFiaXhGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXRTdHlsZVNoZWV0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5wYXJzZXIgJiYgdGhpcy5wYXJzZXIuZ2V0U3R5bGVTaGVldClcbiAgICAgICAgdGhpcy5wYXJzZXIuZ2V0U3R5bGVTaGVldChjYWxsYmFjaylcbn1cblxuVGFiaXhGZWF0dXJlU291cmNlLnByb3RvdHlwZS5nZXREZWZhdWx0RklQcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucGFyc2VyICYmIHRoaXMucGFyc2VyLmdldERlZmF1bHRGSVBzKVxuICAgICAgICB0aGlzLnBhcnNlci5nZXREZWZhdWx0RklQcyhjYWxsYmFjayk7XG59XG5cblxuZGFsbGlhbmNlX3JlZ2lzdGVyU291cmNlQWRhcHRlckZhY3RvcnkoJ3RhYml4JywgZnVuY3Rpb24oc291cmNlKSB7XG4gICAgcmV0dXJuIHtmZWF0dXJlczogbmV3IFRhYml4RmVhdHVyZVNvdXJjZShzb3VyY2UpfTtcbn0pOyIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTFcbi8vXG4vLyB0YWJpeC5qczogYmFzaWMgc3VwcG9ydCBmb3IgdGFiaXgtaW5kZXhlZCBmbGF0ZmlsZXNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgVEFCSVhfTUFHSUMgPSAweDAxNDk0MjU0O1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzcGFucyA9IHJlcXVpcmUoJy4vc3BhbnMnKTtcbiAgICB2YXIgUmFuZ2UgPSBzcGFucy5SYW5nZTtcbiAgICB2YXIgdW5pb24gPSBzcGFucy51bmlvbjtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gc3BhbnMuaW50ZXJzZWN0aW9uO1xuXG4gICAgdmFyIGJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG4gICAgdmFyIHJlYWRJbnQgPSBiaW4ucmVhZEludDtcbiAgICB2YXIgcmVhZFNob3J0ID0gYmluLnJlYWRTaG9ydDtcbiAgICB2YXIgcmVhZEJ5dGUgPSBiaW4ucmVhZEJ5dGU7XG4gICAgdmFyIHJlYWRJbnQ2NCA9IGJpbi5yZWFkSW50NjQ7XG4gICAgdmFyIHJlYWRGbG9hdCA9IGJpbi5yZWFkRmxvYXQ7XG5cbiAgICB2YXIgbGgzdXRpbHMgPSByZXF1aXJlKCcuL2xoM3V0aWxzJyk7XG4gICAgdmFyIHJlYWRWb2IgPSBsaDN1dGlscy5yZWFkVm9iO1xuICAgIHZhciB1bmJnemYgPSBsaDN1dGlscy51bmJnemY7XG4gICAgdmFyIHJlZzJiaW5zID0gbGgzdXRpbHMucmVnMmJpbnM7XG4gICAgdmFyIENodW5rID0gbGgzdXRpbHMuQ2h1bms7XG59XG5cbmZ1bmN0aW9uIFRhYml4RmlsZSgpIHtcbn1cblxuZnVuY3Rpb24gY29ubmVjdFRhYml4KGRhdGEsIHRiaSwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGFiaXggPSBuZXcgVGFiaXhGaWxlKCk7XG4gICAgdGFiaXguZGF0YSA9IGRhdGE7XG4gICAgdGFiaXgudGJpID0gdGJpO1xuXG4gICAgdGFiaXgudGJpLmZldGNoKGZ1bmN0aW9uKGhlYWRlcikgeyAgIC8vIERvIHdlIHJlYWxseSBuZWVkIHRvIGZldGNoIHRoZSB3aG9sZSB0aGluZz8gOi0oXG4gICAgICAgIGlmICghaGVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgXCJDb3VsZG4ndCBhY2Nlc3MgVGFiaXhcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5jaGVhZCA9IHVuYmd6ZihoZWFkZXIsIGhlYWRlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdmFyIHVuY2JhID0gbmV3IFVpbnQ4QXJyYXkodW5jaGVhZCk7XG4gICAgICAgIHZhciBtYWdpYyA9IHJlYWRJbnQodW5jYmEsIDApO1xuICAgICAgICBpZiAobWFnaWMgIT0gVEFCSVhfTUFHSUMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAnTm90IGEgdGFiaXggaW5kZXgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBucmVmID0gcmVhZEludCh1bmNiYSwgNCk7XG4gICAgICAgIHRhYml4LmZvcm1hdCA9IHJlYWRJbnQodW5jYmEsIDgpO1xuICAgICAgICB0YWJpeC5jb2xTZXEgPSByZWFkSW50KHVuY2JhLCAxMik7XG4gICAgICAgIHRhYml4LmNvbFN0YXJ0ID0gcmVhZEludCh1bmNiYSwgMTYpO1xuICAgICAgICB0YWJpeC5jb2xFbmQgPSByZWFkSW50KHVuY2JhLCAyMCk7XG4gICAgICAgIHRhYml4Lm1ldGEgPSByZWFkSW50KHVuY2JhLCAyNCk7XG4gICAgICAgIHRhYml4LnNraXAgPSByZWFkSW50KHVuY2JhLCAyOCk7XG4gICAgICAgIHZhciBuYW1lTGVuZ3RoID0gcmVhZEludCh1bmNiYSwgMzIpO1xuXG4gICAgICAgIHRhYml4LmluZGljZXMgPSBbXTtcblxuICAgICAgICB2YXIgcCA9IDM2O1xuICAgICAgICB0YWJpeC5jaHJUb0luZGV4ID0ge307XG4gICAgICAgIHRhYml4LmluZGV4VG9DaHIgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBucmVmOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJydcblxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2ggPSB1bmNiYVtwKytdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PSAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIG5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRhYml4LmNoclRvSW5kZXhbbmFtZV0gPSBpO1xuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignY2hyJykgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRhYml4LmNoclRvSW5kZXhbbmFtZS5zdWJzdHJpbmcoMyldID0gaTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFiaXguY2hyVG9JbmRleFsnY2hyJyArIG5hbWVdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYml4LmluZGV4VG9DaHIucHVzaChuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5CbG9ja0luZGV4ID0gMTAwMDAwMDAwMDtcbiAgICAgICAgZm9yICh2YXIgcmVmID0gMDsgcmVmIDwgbnJlZjsgKytyZWYpIHtcbiAgICAgICAgICAgIHZhciBibG9ja1N0YXJ0ID0gcDtcbiAgICAgICAgICAgIHZhciBuYmluID0gcmVhZEludCh1bmNiYSwgcCk7IHAgKz0gNDtcbiAgICAgICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgbmJpbjsgKytiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbiA9IHJlYWRJbnQodW5jYmEsIHApO1xuICAgICAgICAgICAgICAgIHZhciBuY2huayA9IHJlYWRJbnQodW5jYmEsIHArNCk7XG4gICAgICAgICAgICAgICAgcCArPSA4ICsgKG5jaG5rICogMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5pbnR2ID0gcmVhZEludCh1bmNiYSwgcCk7IHAgKz0gNDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHEgPSBwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuaW50djsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSByZWFkVm9iKHVuY2JhLCBxKTsgcSArPSA4O1xuICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaSA9IHYuYmxvY2s7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2Lm9mZnNldCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBiaSArPSA2NTUzNjtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYmkgPCBtaW5CbG9ja0luZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluQmxvY2tJbmRleCA9IGJpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwICs9IChuaW50diAqIDgpO1xuXG5cbiAgICAgICAgICAgIHZhciB1YiA9IHVuY2JhO1xuICAgICAgICAgICAgaWYgKG5iaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGFiaXguaW5kaWNlc1tyZWZdID0gbmV3IFVpbnQ4QXJyYXkodW5jaGVhZCwgYmxvY2tTdGFydCwgcCAtIGJsb2NrU3RhcnQpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgdGFiaXguaGVhZGVyTWF4ID0gbWluQmxvY2tJbmRleDtcblxuICAgICAgICBjYWxsYmFjayh0YWJpeCk7XG4gICAgfSwge3RpbWVvdXQ6IDUwMDB9KTtcbn1cblxuLy8gQ29weS1wYXN0ZSBmcm9tIEJhbUZpbGVcblxuVGFiaXhGaWxlLnByb3RvdHlwZS5ibG9ja3NGb3JSYW5nZSA9IGZ1bmN0aW9uKHJlZklkLCBtaW4sIG1heCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuaW5kaWNlc1tyZWZJZF07XG4gICAgaWYgKCFpbmRleCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIGludEJpbnNMID0gcmVnMmJpbnMobWluLCBtYXgpO1xuICAgIHZhciBpbnRCaW5zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRCaW5zTC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnRCaW5zW2ludEJpbnNMW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHZhciBsZWFmQ2h1bmtzID0gW10sIG90aGVyQ2h1bmtzID0gW107XG5cbiAgICB2YXIgbmJpbiA9IHJlYWRJbnQoaW5kZXgsIDApO1xuICAgIHZhciBwID0gNDtcbiAgICBmb3IgKHZhciBiID0gMDsgYiA8IG5iaW47ICsrYikge1xuICAgICAgICB2YXIgYmluID0gcmVhZEludChpbmRleCwgcCk7XG4gICAgICAgIHZhciBuY2huayA9IHJlYWRJbnQoaW5kZXgsIHArNCk7XG4gICAgICAgIHAgKz0gODtcbiAgICAgICAgaWYgKGludEJpbnNbYmluXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBuY2huazsgKytjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNzID0gcmVhZFZvYihpbmRleCwgcCk7XG4gICAgICAgICAgICAgICAgdmFyIGNlID0gcmVhZFZvYihpbmRleCwgcCArIDgpO1xuICAgICAgICAgICAgICAgIChiaW4gPCA0NjgxID8gb3RoZXJDaHVua3MgOiBsZWFmQ2h1bmtzKS5wdXNoKG5ldyBDaHVuayhjcywgY2UpKTtcbiAgICAgICAgICAgICAgICBwICs9IDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCArPSAgKG5jaG5rICogMTYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5pbnR2ID0gcmVhZEludChpbmRleCwgcCk7XG4gICAgdmFyIGxvd2VzdCA9IG51bGw7XG4gICAgdmFyIG1pbkxpbiA9IE1hdGgubWluKG1pbj4+MTQsIG5pbnR2IC0gMSksIG1heExpbiA9IE1hdGgubWluKG1heD4+MTQsIG5pbnR2IC0gMSk7XG4gICAgZm9yICh2YXIgaSA9IG1pbkxpbjsgaSA8PSBtYXhMaW47ICsraSkge1xuICAgICAgICB2YXIgbGIgPSAgcmVhZFZvYihpbmRleCwgcCArIDQgKyAoaSAqIDgpKTtcbiAgICAgICAgaWYgKCFsYikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb3dlc3QgfHwgbGIuYmxvY2sgPCBsb3dlc3QuYmxvY2sgfHwgbGIub2Zmc2V0IDwgbG93ZXN0Lm9mZnNldCkge1xuICAgICAgICAgICAgbG93ZXN0ID0gbGI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIHBydW5lZE90aGVyQ2h1bmtzID0gW107XG4gICAgaWYgKGxvd2VzdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJDaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjaG5rID0gb3RoZXJDaHVua3NbaV07XG4gICAgICAgICAgICBpZiAoY2huay5tYXh2LmJsb2NrID49IGxvd2VzdC5ibG9jayAmJiBjaG5rLm1heHYub2Zmc2V0ID49IGxvd2VzdC5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBwcnVuZWRPdGhlckNodW5rcy5wdXNoKGNobmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBcbiAgICBvdGhlckNodW5rcyA9IHBydW5lZE90aGVyQ2h1bmtzO1xuXG4gICAgdmFyIGludENodW5rcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3RoZXJDaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW50Q2h1bmtzLnB1c2gob3RoZXJDaHVua3NbaV0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlYWZDaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW50Q2h1bmtzLnB1c2gobGVhZkNodW5rc1tpXSk7XG4gICAgfVxuXG4gICAgaW50Q2h1bmtzLnNvcnQoZnVuY3Rpb24oYzAsIGMxKSB7XG4gICAgICAgIHZhciBkaWYgPSBjMC5taW52LmJsb2NrIC0gYzEubWludi5ibG9jaztcbiAgICAgICAgaWYgKGRpZiAhPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGMwLm1pbnYub2Zmc2V0IC0gYzEubWludi5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWVyZ2VkQ2h1bmtzID0gW107XG4gICAgaWYgKGludENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBjdXIgPSBpbnRDaHVua3NbMF07XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgaW50Q2h1bmtzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgbmMgPSBpbnRDaHVua3NbaV07XG4gICAgICAgICAgICBpZiAobmMubWludi5ibG9jayA9PSBjdXIubWF4di5ibG9jayAvKiAmJiBuYy5taW52Lm9mZnNldCA9PSBjdXIubWF4di5vZmZzZXQgKi8pIHsgLy8gbm8gcG9pbnQgc3BsaXR0aW5nIG1pZC1ibG9ja1xuICAgICAgICAgICAgICAgIGN1ciA9IG5ldyBDaHVuayhjdXIubWludiwgbmMubWF4dik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZENodW5rcy5wdXNoKGN1cik7XG4gICAgICAgICAgICAgICAgY3VyID0gbmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VkQ2h1bmtzLnB1c2goY3VyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2VkQ2h1bmtzO1xufVxuXG5UYWJpeEZpbGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuXG4gICAgdmFyIGNocklkID0gdGhpcy5jaHJUb0luZGV4W2Nocl07XG4gICAgaWYgKGNocklkID09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKFtdKTtcblxuICAgIHZhciBjYW5vbmljYWxDaHIgPSB0aGlzLmluZGV4VG9DaHJbY2hySWRdO1xuXG4gICAgdmFyIGNodW5rcztcbiAgICBpZiAoY2hySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaHVua3MgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaHVua3MgPSB0aGlzLmJsb2Nrc0ZvclJhbmdlKGNocklkLCBtaW4sIG1heCk7XG4gICAgICAgIGlmICghY2h1bmtzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnRXJyb3IgaW4gaW5kZXggZmV0Y2gnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZWNvcmRzID0gW107XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZGF0YTtcblxuICAgIGZ1bmN0aW9uIHRyYW1wKCkge1xuICAgICAgICBpZiAoaW5kZXggPj0gY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHJlY29yZHMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNodW5rc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgZmV0Y2hNaW4gPSBjLm1pbnYuYmxvY2s7XG4gICAgICAgICAgICB2YXIgZmV0Y2hNYXggPSBjLm1heHYuYmxvY2sgKyAoMTw8MTYpOyAvLyAqc2lnaCpcbiAgICAgICAgICAgIHRoaXNCLmRhdGEuc2xpY2UoZmV0Y2hNaW4sIGZldGNoTWF4IC0gZmV0Y2hNaW4pLmZldGNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gdW5iZ3pmKHIsIGMubWF4di5ibG9jayAtIGMubWludi5ibG9jayArIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFtcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgICAgIHRoaXNCLnJlYWRSZWNvcmRzKGJhLCBjaHVua3NbaW5kZXhdLm1pbnYub2Zmc2V0LCByZWNvcmRzLCBtaW4sIG1heCwgY2Fub25pY2FsQ2hyKTtcbiAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIHJldHVybiB0cmFtcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW1wKCk7XG59XG5cblRhYml4RmlsZS5wcm90b3R5cGUucmVhZFJlY29yZHMgPSBmdW5jdGlvbihiYSwgb2Zmc2V0LCBzaW5rLCBtaW4sIG1heCwgY2hyKSB7XG4gICBMSU5FX0xPT1A6XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGxpbmUgPSAnJztcbiAgICAgICAgd2hpbGUgKG9mZnNldCA8IGJhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoID0gYmFbb2Zmc2V0KytdO1xuICAgICAgICAgICAgaWYgKGNoID09IDEwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRva3MgPSBsaW5lLnNwbGl0KCdcXHQnKTtcblxuICAgICAgICAgICAgICAgIGlmICh0b2tzW3RoaXMuY29sU2VxIC0gMV0gPT0gY2hyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbWluID0gcGFyc2VJbnQodG9rc1t0aGlzLmNvbFN0YXJ0IC0gMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm1heCA9IGZtaW47XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbEVuZCA+IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBmbWF4ID0gcGFyc2VJbnQodG9rc1t0aGlzLmNvbEVuZCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZm9ybWF0ICYgMHgxMDAwMCkgKytmbWluO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbWluIDw9IG1heCAmJiBmbWF4ID49IG1pbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbmsucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWUgTElORV9MT09QO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5cblRhYml4RmlsZS5wcm90b3R5cGUuZmV0Y2hIZWFkZXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmV0Y2hQdHIgPSAwLCBwdHIgPSAwLCBsaW5lPScnO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuXG4gICAgc2VsZi5kYXRhLnNsaWNlKDAsIHNlbGYuaGVhZGVyTWF4KS5mZXRjaChmdW5jdGlvbihjaG5rKSB7XG4gICAgICAgIGlmICghY2huaykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIFwiRmV0Y2ggZmFpbGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KHVuYmd6ZihjaG5rLCBjaG5rLmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgdmFyIHB0ciA9IDAsIGxpbmUgPSAnJywgbGluZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKHB0ciA8IGJhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoID0gYmFbcHRyKytdXG4gICAgICAgICAgICBpZiAoY2ggPT0gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5jaGFyQ29kZUF0KDApID09IHNlbGYubWV0YSkge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGxpbmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobGluZXMpO1xuICAgIH0pO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNvbm5lY3RUYWJpeDogY29ubmVjdFRhYml4LFxuICAgICAgICBUQUJJWF9NQUdJQzogVEFCSVhfTUFHSUNcbiAgICB9O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxM1xuLy9cbi8vIHRodWIuanM6IHN1cHBvcnQgZm9yIHRyYWNrLWh1YiBzdHlsZSByZWdpc3RyaWVzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIHRleHRYSFIgPSB1dGlscy50ZXh0WEhSO1xuICAgIHZhciByZWxhdGl2ZVVSTCA9IHV0aWxzLnJlbGF0aXZlVVJMO1xuICAgIHZhciBzaGFsbG93Q29weSA9IHV0aWxzLnNoYWxsb3dDb3B5O1xuXG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIERBU1N0eWxlc2hlZXQgPSBkYXMuREFTU3R5bGVzaGVldDtcbiAgICB2YXIgREFTU3R5bGUgPSBkYXMuREFTU3R5bGU7XG59XG5cbnZhciBUSFVCX1NUQU5aQV9SRUdFWFAgPSAvXFxuXFxzKlxcbi87XG52YXIgVEhVQl9QQVJTRV9SRUdFWFAgID0gLyhcXHcrKSArKC4rKVxcbj8vO1xudmFyIFRIVUJfU1VCR1JPVVBfUkVHRVhQID0gL3N1Ykdyb3VwWzEtOV0vO1xuXG52YXIgVEhVQl9QRU5OQU5UX1BSRUZJWCA9ICdodHRwOi8vZ2Vub21lLnVjc2MuZWR1L2ltYWdlcy8nO1xuXG5mdW5jdGlvbiBUcmFja0h1Yih1cmwpIHtcbiAgICB0aGlzLmdlbm9tZXMgPSB7fTtcbiAgICB0aGlzLnVybCA9IHVybDtcbn1cblxuZnVuY3Rpb24gVHJhY2tIdWJUcmFjaygpIHtcbn1cblxuVHJhY2tIdWJUcmFjay5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaykge1xuICAgIGlmICh0aGlzW2tdKVxuICAgICAgICByZXR1cm4gdGhpc1trXTtcbiAgICBlbHNlIGlmICh0aGlzLl9wYXJlbnQpIFxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50LmdldChrKTtcbn1cblxuZnVuY3Rpb24gVHJhY2tIdWJEQihodWIpIHtcbiAgICB0aGlzLmh1YiA9IGh1Yjtcbn1cblxuVHJhY2tIdWJEQi5wcm90b3R5cGUuZ2V0VHJhY2tzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIGlmICh0aGlzLl90cmFja3MpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX3RyYWNrcyk7XG4gICAgfSBcbiAgICBcbiAgICB0ZXh0WEhSKHRoaXMuYWJzVVJMLCBmdW5jdGlvbih0cmFja0ZpbGUsIGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gdHJhY2tGaWxlID0gdHJhY2tGaWxlLnJlcGxhY2UoL1xcIy4qL2csICcnKTtcbiAgICAgICAgdHJhY2tGaWxlID0gdHJhY2tGaWxlLnJlcGxhY2UoJ1xcXFxcXG4nLCAnICcpO1xuXG4gICAgICAgIHZhciB0cmFja3MgPSBbXTtcbiAgICAgICAgdmFyIHRyYWNrc0J5SWQgPSB7fTtcbiAgICAgICAgdmFyIHN0YW56YXMgPSB0cmFja0ZpbGUuc3BsaXQoVEhVQl9TVEFOWkFfUkVHRVhQKTtcbiAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdGFuemFzLmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICB2YXIgdG9rcyA9IHN0YW56YXNbc10ucmVwbGFjZSgvXFwjLiovZywgJycpLnNwbGl0KFRIVUJfUEFSU0VfUkVHRVhQKTtcbiAgICAgICAgICAgIHZhciB0cmFjayA9IG5ldyBUcmFja0h1YlRyYWNrKCk7XG4gICAgICAgICAgICB0cmFjay5fZGIgPSB0aGlzQjtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdG9rcy5sZW5ndGggLSAyOyBsICs9IDMpIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IHRva3NbbCsxXSwgdiA9IHRva3NbbCsyXTtcbiAgICAgICAgICAgICAgICBpZiAoay5tYXRjaChUSFVCX1NVQkdST1VQX1JFR0VYUCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFjay5zdWJncm91cHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5zdWJncm91cHMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNndG9rcyA9IHYuc3BsaXQoL1xccy8pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2d0YWcgPSBzZ3Rva3NbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZ3JlY29yZCA9IHtuYW1lOiBzZ3Rva3NbMV0sIHRhZ3M6IFtdLCB0aXRsZXM6IFtdfTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2d0aSA9IDI7IHNndGkgPCBzZ3Rva3MubGVuZ3RoOyArK3NndGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBncnAgPSBzZ3Rva3Nbc2d0aV0uc3BsaXQoLz0vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNncmVjb3JkLnRhZ3MucHVzaChncnBbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2dyZWNvcmQudGl0bGVzLnB1c2goZ3JwWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmFjay5zdWJncm91cHNbc2d0YWddID0gc2dyZWNvcmQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrID09PSAnc3ViR3JvdXBzJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2d0b2tzID0gdi5zcGxpdCgvKFxcdyspPShcXHcrKS8pO1xuICAgICAgICAgICAgICAgICAgICB0cmFjay5zZ20gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2d0aSA9IDA7IHNndGkgPCBzZ3Rva3MubGVuZ3RoIC0gMjsgc2d0aSArPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5zZ21bc2d0b2tzW3NndGkrMV1dID0gc2d0b2tzW3NndGkgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrW3Rva3NbbCsxXV0gPSB0b2tzW2wrMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhY2sudHJhY2sgJiYgKHRyYWNrLnR5cGUgfHwgdHJhY2suY29udGFpbmVyIHx8IHRyYWNrLnZpZXcgfHwgdHJhY2suYmlnRGF0YVVybCkpIHtcbiAgICAgICAgICAgICAgICB0cmFja3MucHVzaCh0cmFjayk7XG4gICAgICAgICAgICAgICAgdHJhY2tzQnlJZFt0cmFjay50cmFja10gPSB0cmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3NraXBwaW5nICcsIHRyYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHRvcGxldmVscyA9IFtdO1xuICAgICAgICB2YXIgY29tcG9zaXRlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdHJhY2tzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICAgICAgdmFyIHRyYWNrID0gdHJhY2tzW3RpXTtcbiAgICAgICAgICAgIHZhciB0b3AgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRyYWNrLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwdG9rcyA9IHRyYWNrLnBhcmVudC5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0cmFja3NCeUlkW3B0b2tzWzBdXTtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLl9wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2godHJhY2spO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvdWxkbid0IGZpbmQgcGFyZW50IFwiICsgcHRva3NbMF0gKyAnKCcgKyB0cmFjay5wYXJlbnQgKyAnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNrLmNvbXBvc2l0ZVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRlcy5wdXNoKHRyYWNrKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9wKSB7XG4gICAgICAgICAgICAgICAgdG9wbGV2ZWxzLnB1c2godHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNvbXBvc2l0ZXMubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgICAgICB2YXIgY29tcCA9IGNvbXBvc2l0ZXNbY2ldO1xuICAgICAgICAgICAgaWYgKCFjb21wLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgcGFyZW50T2ZWaWV3cyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIga2kgPSAwOyBraSA8IGNvbXAuY2hpbGRyZW4ubGVuZ3RoOyArK2tpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSBjb21wLmNoaWxkcmVuW2tpXTtcbiAgICAgICAgICAgICAgICBpZiAoay52aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGsuc2hvcnRMYWJlbCA9IGNvbXAuc2hvcnRMYWJlbCArIFwiOiBcIiArIGsuc2hvcnRMYWJlbDtcbiAgICAgICAgICAgICAgICAgICAgdG9wbGV2ZWxzLnB1c2goayk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9mVmlld3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGFyZW50T2ZWaWV3cylcbiAgICAgICAgICAgICAgICB0b3BsZXZlbHMucHVzaChjb21wKTtcbiAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIHRoaXNCLl90cmFja3MgPSB0b3BsZXZlbHM7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzQi5fdHJhY2tzLCBudWxsKTtcbiAgICB9LCB7Y3JlZGVudGlhbHM6IHRoaXMuY3JlZGVudGlhbHMsIHNhbHQ6IHRydWV9KTtcbn1cblxuZnVuY3Rpb24gY29ubmVjdFRyYWNrSHViKGh1YlVSTCwgY2FsbGJhY2ssIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBvcHRzLnNhbHQgPSB0cnVlO1xuXG4gICAgdGV4dFhIUihodWJVUkwsIGZ1bmN0aW9uKGh1YkZpbGUsIGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tzID0gaHViRmlsZS5zcGxpdChUSFVCX1BBUlNFX1JFR0VYUCk7XG4gICAgICAgIHZhciBodWIgPSBuZXcgVHJhY2tIdWIoaHViVVJMKTtcbiAgICAgICAgaWYgKG9wdHMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIGh1Yi5jcmVkZW50aWFscyA9IG9wdHMuY3JlZGVudGlhbHM7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCB0b2tzLmxlbmd0aCAtIDI7IGwgKz0gMykge1xuICAgICAgICAgICAgaHViW3Rva3NbbCsxXV0gPSB0b2tzW2wrMl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoaHViLmdlbm9tZXNGaWxlKSB7XG4gICAgICAgICAgICB2YXIgZ2VuVVJMID0gcmVsYXRpdmVVUkwoaHViVVJMLCBodWIuZ2Vub21lc0ZpbGUpO1xuICAgICAgICAgICAgdGV4dFhIUihnZW5VUkwsIGZ1bmN0aW9uKGdlbkZpbGUsIGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN0YW56YXMgPSBnZW5GaWxlLnNwbGl0KFRIVUJfU1RBTlpBX1JFR0VYUCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBzdGFuemFzLmxlbmd0aDsgKytzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tzID0gc3Rhbnphc1tzXS5zcGxpdChUSFVCX1BBUlNFX1JFR0VYUCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncHJvcHMgPSBuZXcgVHJhY2tIdWJEQihodWIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3Byb3BzLmNyZWRlbnRpYWxzID0gb3B0cy5jcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdG9rcy5sZW5ndGggLSAyOyBsICs9IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdwcm9wc1t0b2tzW2wrMV1dID0gdG9rc1tsKzJdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdwcm9wcy50d29CaXRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncHJvcHMudHdvQml0UGF0aCA9IHJlbGF0aXZlVVJMKGdlblVSTCwgZ3Byb3BzLnR3b0JpdFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdwcm9wcy5nZW5vbWUgJiYgZ3Byb3BzLnRyYWNrRGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdwcm9wcy5hYnNVUkwgPSByZWxhdGl2ZVVSTChnZW5VUkwsIGdwcm9wcy50cmFja0RiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1Yi5nZW5vbWVzW2dwcm9wcy5nZW5vbWVdID0gZ3Byb3BzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaHViKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnTm8gZ2Vub21lc0ZpbGUnKTtcbiAgICAgICAgfVxuICAgIH0sIG9wdHMpO1xufVxuXG5cblRyYWNrSHViVHJhY2sucHJvdG90eXBlLnRvRGFsbGlhbmNlU291cmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZSA9IHtcbiAgICAgICAgbmFtZTogdGhpcy5zaG9ydExhYmVsLFxuICAgICAgICBkZXNjOiB0aGlzLmxvbmdMYWJlbFxuICAgIH07XG4gICAgaWYgKHRoaXMuX2RiLm1hcHBpbmcpIHtcbiAgICAgICAgc291cmNlLm1hcHBpbmcgPSB0aGlzLl9kYi5tYXBwaW5nO1xuICAgIH1cblxuICAgIHZhciBwZW5uYW50SWNvbiA9IHRoaXMuZ2V0KCdwZW5uYW50SWNvbicpO1xuICAgIGlmIChwZW5uYW50SWNvbikge1xuICAgICAgICB2YXIgcHRva3MgPSBwZW5uYW50SWNvbi5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBzb3VyY2UucGVubmFudCA9IFRIVUJfUEVOTkFOVF9QUkVGSVggKyBwdG9rc1swXTtcbiAgICB9XG5cbiAgICB2YXIgc2VhcmNoVHJpeCA9IHRoaXMuZ2V0KCdzZWFyY2hUcml4Jyk7XG4gICAgaWYgKHNlYXJjaFRyaXgpIHtcbiAgICAgICAgc291cmNlLnRyaXhVUkkgPSByZWxhdGl2ZVVSTCh0aGlzLl9kYi5hYnNVUkwsIHNlYXJjaFRyaXgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbnRhaW5lciA9PSAnbXVsdGlXaWcnKSB7XG4gICAgICAgIHNvdXJjZS5tZXJnZSA9ICdjb25jYXQnO1xuICAgICAgICBzb3VyY2Uub3ZlcmxheSA9IFtdO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuIHx8IFtdO1xuICAgICAgICBzb3VyY2Uuc3R5bGUgPSBbXTtcbiAgICAgICAgc291cmNlLm5vRG93bnNhbXBsZSA9IHRydWU7XG5cbiAgICAgICAgZm9yICh2YXIgY2kgPSAwOyBjaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytjaSkge1xuICAgICAgICAgICAgdmFyIGNoID0gY2hpbGRyZW5bY2ldO1xuICAgICAgICAgICAgdmFyIGNzID0gY2gudG9EYWxsaWFuY2VTb3VyY2UoKVxuICAgICAgICAgICAgc291cmNlLm92ZXJsYXkucHVzaChjcyk7XG5cbiAgICAgICAgICAgIGlmIChjcy5zdHlsZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBjcy5zdHlsZS5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gY3Muc3R5bGVbc2ldO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5tZXRob2QgPSBjaC5zaG9ydExhYmVsOyAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWdncmVnYXRlID09ICd0cmFuc3BhcmVudE92ZXJsYXknKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGUuc3R5bGUuQUxQSEEgPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZS5zdHlsZS5wdXNoKHN0eWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvdXJjZTsgICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKHAuX3BhcmVudCAmJiAhcC50eXBlKSB7XG4gICAgICAgICAgICAgICAgcCA9IHAuX3BhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUgPSBwLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdHlwZVRva3MgPSB0eXBlLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGlmICh0eXBlVG9rc1swXSA9PSAnYmlnQmVkJyAmJiB0aGlzLmJpZ0RhdGFVcmwpIHtcbiAgICAgICAgICAgIHZhciBiZWRUb2tlbnMgPSB0eXBlVG9rc1sxXXwwXG4gICAgICAgICAgICB2YXIgYmVkUGx1cyA9IHR5cGVUb2tzWzJdID09ICcrJztcblxuICAgICAgICAgICAgc291cmNlLmJ3Z1VSSSA9IHJlbGF0aXZlVVJMKHRoaXMuX2RiLmFic1VSTCwgdGhpcy5iaWdEYXRhVXJsKTtcbiAgICAgICAgICAgIHNvdXJjZS5zdHlsZSA9IHRoaXMuYmlnYmVkU3R5bGVzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGIuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UuY3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJlZFRva2VucyA+PSAxMiAmJiBiZWRQbHVzKVxuICAgICAgICAgICAgICAgIHNvdXJjZS5jb2xsYXBzZVN1cGVyR3JvdXBzID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZVRva3NbMF0gPT0gJ2JpZ1dpZycgJiYgdGhpcy5iaWdEYXRhVXJsKSB7XG4gICAgICAgICAgICBzb3VyY2UuYndnVVJJID0gcmVsYXRpdmVVUkwodGhpcy5fZGIuYWJzVVJMLCB0aGlzLmJpZ0RhdGFVcmwpO1xuICAgICAgICAgICAgc291cmNlLnN0eWxlID0gdGhpcy5iaWd3aWdTdHlsZXMoKTtcbiAgICAgICAgICAgIHNvdXJjZS5ub0Rvd25zYW1wbGUgPSB0cnVlOyAgICAgLy8gRklYTUUgc2VlbXMgbGlrZSBhIGJsdW50IGluc3RydW1lbnQuLi5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMueUxpbmVPbk9mZiAmJiB0aGlzLnlMaW5lT25PZmYgPT0gJ29uJykge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5xdWFudExlYXBUaHJlc2hvbGQgPSB0aGlzLnlMaW5lTWFyayAhPT0gdW5kZWZpbmVkID8gKDEuMCAqIHRoaXMueUxpbmVNYXJrKSA6IDAuMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuX2RiLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLmNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlVG9rc1swXSA9PSAnYmFtJyAgJiYgdGhpcy5iaWdEYXRhVXJsKSB7XG4gICAgICAgICAgICBzb3VyY2UuYmFtVVJJID0gcmVsYXRpdmVVUkwodGhpcy5fZGIuYWJzVVJMLCB0aGlzLmJpZ0RhdGFVcmwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RiLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLmNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZVRva3NbMF0gPT0gJ3ZjZlRhYml4JyAmJiB0aGlzLmJpZ0RhdGFVcmwpIHtcbiAgICAgICAgICAgIHNvdXJjZS51cmkgPSByZWxhdGl2ZVVSTCh0aGlzLl9kYi5hYnNVUkwsIHRoaXMuYmlnRGF0YVVybCk7XG4gICAgICAgICAgICBzb3VyY2UudGllcl90eXBlID0gJ3RhYml4JztcbiAgICAgICAgICAgIHNvdXJjZS5wYXlsb2FkID0gJ3ZjZic7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGIuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UuY3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdVbnN1cHBvcnRlZCAnICsgdGhpcy50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuVHJhY2tIdWJUcmFjay5wcm90b3R5cGUuYmlnd2lnU3R5bGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHZhciBwID0gdGhpcztcbiAgICAgICAgd2hpbGUgKHAuX3BhcmVudCAmJiAhcC50eXBlKSB7XG4gICAgICAgICAgICBwID0gcC5fcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHR5cGUgPSBwLnR5cGU7XG4gICAgfVxuICAgIGlmICghdHlwZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciB0eXBlVG9rcyA9IHR5cGUuc3BsaXQoL1xccysvKTtcblxuICAgIHZhciBtaW4sIG1heDtcbiAgICBpZiAodHlwZVRva3MubGVuZ3RoID49IDMpIHtcbiAgICAgICAgbWluID0gMS4wICogdHlwZVRva3NbMV07XG4gICAgICAgIG1heCA9IDEuMCAqIHR5cGVUb2tzWzJdO1xuICAgIH1cblxuICAgIHZhciBoZWlnaHQ7XG4gICAgaWYgKHRoaXMubWF4SGVpZ2h0UGl4ZWxzKSB7XG4gICAgICAgIHZhciBtaHBUb2tzID0gdGhpcy5tYXhIZWlnaHRQaXhlbHMuc3BsaXQoLzovKTtcbiAgICAgICAgaWYgKG1ocFRva3MubGVuZ3RoID09IDMpIHtcbiAgICAgICAgICAgIGhlaWdodCA9IG1ocFRva3NbMV0gfCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ21heEhlaWdodFBpeGVscyBzaG91bGQgYmUgb2YgdGhlIGZvcm0gbWF4OmRlZmF1bHQ6bWluJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdmFyIGd0eXBlID0gJ2JhcnMnO1xuICAgIGlmICh0aGlzLmdyYXBoVHlwZURlZmF1bHQpIHtcbiAgICAgICAgZ3R5cGUgPSB0aGlzLmdyYXBoVHlwZURlZmF1bHQ7XG4gICAgfVxuICAgIFxuICAgIHZhciBjb2xvciA9ICdibGFjayc7XG4gICAgdmFyIGFsdENvbG9yID0gbnVsbDtcbiAgICBpZiAodGhpcy5jb2xvcikge1xuICAgICAgICBjb2xvciA9ICdyZ2IoJyArIHRoaXMuY29sb3IgKyAnKSc7XG4gICAgfVxuICAgIGlmICh0aGlzLmFsdENvbG9yKSB7XG4gICAgICAgIGFsdENvbG9yID0gJ3JnYignICsgdGhpcy5hbHRDb2xvciArICcpJztcbiAgICB9XG4gICAgXG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuICAgIHZhciB3aWdTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgIGlmIChndHlwZSA9PSAncG9pbnRzJykge1xuICAgICAgICB3aWdTdHlsZS5nbHlwaCA9ICdQT0lOVCc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2lnU3R5bGUuZ2x5cGggPSAnSElTVE9HUkFNJztcbiAgICB9XG5cbiAgICBpZiAoYWx0Q29sb3IpIHtcbiAgICAgICAgd2lnU3R5bGUuQ09MT1IxID0gY29sb3I7XG4gICAgICAgIHdpZ1N0eWxlLkNPTE9SMiA9IGFsdENvbG9yO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSBjb2xvcjtcbiAgICB9XG4gICAgd2lnU3R5bGUuSEVJR0hUID0gaGVpZ2h0IHx8IDMwO1xuICAgIGlmIChtaW4gfHwgbWF4KSB7XG4gICAgICAgIHdpZ1N0eWxlLk1JTiA9IG1pbjtcbiAgICAgICAgd2lnU3R5bGUuTUFYID0gbWF4O1xuICAgIH1cbiAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgIHJldHVybiBzdHlsZXNoZWV0LnN0eWxlcztcbn1cblxuVHJhY2tIdWJUcmFjay5wcm90b3R5cGUuYmlnYmVkU3R5bGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1SZ2IgPSAoJycrdGhpcy5nZXQoJ2l0ZW1SZ2InKSkudG9Mb3dlckNhc2UoKSA9PSAnb24nO1xuICAgIHZhciB2aXNpYmlsaXR5ID0gdGhpcy5nZXQoJ3Zpc2liaWxpdHknKSB8fCAnZnVsbCc7XG4gICAgdmFyIGNvbG9yID0gdGhpcy5nZXQoJ2NvbG9yJyk7XG4gICAgaWYgKGNvbG9yKVxuICAgICAgICBjb2xvciA9ICdyZ2IoJyArIGNvbG9yICsgJyknO1xuICAgIGVsc2UgXG4gICAgICAgIGNvbG9yID0gJ2JsdWUnO1xuICAgIFxuICAgIHZhciBzdHlsZXNoZWV0ID0gbmV3IERBU1N0eWxlc2hlZXQoKTtcbiAgICB2YXIgd2lnU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICB3aWdTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgIHdpZ1N0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgIHdpZ1N0eWxlLkJHQ09MT1IgPSBjb2xvcjtcbiAgICB3aWdTdHlsZS5IRUlHSFQgPSAodmlzaWJpbGl0eSA9PSAnZnVsbCcgfHwgdmlzaWJpbGl0eSA9PSAncGFjaycpID8gMTIgOiA4O1xuICAgIHdpZ1N0eWxlLkJVTVAgPSAodmlzaWJpbGl0eSA9PSAnZnVsbCcgfHwgdmlzaWJpbGl0eSA9PSAncGFjaycpO1xuICAgIHdpZ1N0eWxlLkxBQkVMID0gKHZpc2liaWxpdHkgPT0gJ2Z1bGwnIHx8IHZpc2liaWxpdHkgPT0gJ3BhY2snKTtcbiAgICB3aWdTdHlsZS5aSU5ERVggPSAyMDtcbiAgICBpZiAoaXRlbVJnYilcbiAgICAgICAgd2lnU3R5bGUuQkdJVEVNID0gdHJ1ZTtcblxuICAgIHZhciBjYnMgPSB0aGlzLmdldCgnY29sb3JCeVN0cmFuZCcpO1xuICAgIGlmIChjYnMpIHtcbiAgICAgICAgdmFyIGNic1Rva3MgPSBjYnMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwbHVzID0gc2hhbGxvd0NvcHkod2lnU3R5bGUpO1xuICAgICAgICBwbHVzLkJHQ09MT1IgPSAncmdiKCcgKyBjYnNUb2tzWzBdICsgJyknO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2JpZ2JlZCcsIG9yaWVudGF0aW9uOiAnKyd9LCBudWxsLCBwbHVzKTtcblxuICAgICAgICB2YXIgbWludXMgPSBzaGFsbG93Q29weSh3aWdTdHlsZSk7XG4gICAgICAgIG1pbnVzLkJHQ09MT1IgPSAncmdiKCcgKyBjYnNUb2tzWzFdICsgJyknO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2JpZ2JlZCcsIG9yaWVudGF0aW9uOiAnLSd9LCBudWxsLCBtaW51cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdiaWdiZWQnfSwgbnVsbCwgd2lnU3R5bGUpO1xuICAgIH0gICBcbiAgICBcbiAgICB2YXIgdGxTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgIHRsU3R5bGUuZ2x5cGggPSAnQk9YJztcbiAgICB0bFN0eWxlLkZHQ09MT1IgPSAnYmxhY2snO1xuICAgIGlmIChpdGVtUmdiKVxuICAgICAgICB0bFN0eWxlLkJHSVRFTSA9IHRydWU7XG4gICAgdGxTdHlsZS5CR0NPTE9SID0gJ3JlZCdcbiAgICB0bFN0eWxlLkhFSUdIVCA9IDEwO1xuICAgIHRsU3R5bGUuQlVNUCA9IHRydWU7XG4gICAgdGxTdHlsZS5aSU5ERVggPSAyMDtcbiAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3RyYW5zbGF0aW9uJ30sIG51bGwsIHRsU3R5bGUpO1xuICAgIFxuICAgIHZhciB0c1N0eWxlID0gbmV3IERBU1N0eWxlKCk7XG4gICAgdHNTdHlsZS5nbHlwaCA9ICdCT1gnO1xuICAgIHRzU3R5bGUuRkdDT0xPUiA9ICdibGFjayc7XG4gICAgdHNTdHlsZS5CR0NPTE9SID0gJ3doaXRlJztcbiAgICB0c1N0eWxlLkhFSUdIVCA9IDEwO1xuICAgIHRzU3R5bGUuWklOREVYID0gMTA7XG4gICAgdHNTdHlsZS5CVU1QID0gdHJ1ZTtcbiAgICB0c1N0eWxlLkxBQkVMID0gdHJ1ZTtcbiAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ3RyYW5zY3JpcHQnfSwgbnVsbCwgdHNTdHlsZSk7XG5cbiAgICByZXR1cm4gc3R5bGVzaGVldC5zdHlsZXM7XG59XG5cbmZ1bmN0aW9uIFRIVUJfQ09NUEFSRShnLCBoKSB7XG4gICAgaWYgKGcucHJpb3JpdHkgJiYgaC5wcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gKDEuMCAqIGcucHJpb3JpdHkpIC0gKDEuMCAqIGgucHJpb3JpdHkpXG4gICAgfSBlbHNlIGlmIChnLnByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoaC5wcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGcuc2hvcnRMYWJlbC5sb2NhbGVDb21wYXJlKGguc2hvcnRMYWJlbCk7XG4gICAgfVxufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIGNvbm5lY3RUcmFja0h1YjogY29ubmVjdFRyYWNrSHViLFxuICAgICAgICBUSFVCX0NPTVBBUkU6IFRIVUJfQ09NUEFSRVxuICAgIH07XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gdGllci1hY3Rpb25zLmpzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgc2hhbGxvd0NvcHkgPSB1dGlscy5zaGFsbG93Q29weTtcbn1cblxuQnJvd3Nlci5wcm90b3R5cGUubWVyZ2VTZWxlY3RlZFRpZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICB2YXIgc3R5bGVzID0gW107XG5cbiAgICBmb3IgKHZhciBzdGkgPSAwOyBzdGkgPCB0aGlzLnNlbGVjdGVkVGllcnMubGVuZ3RoOyArK3N0aSkge1xuICAgICAgICB2YXIgdGllciA9IHRoaXMudGllcnNbdGhpcy5zZWxlY3RlZFRpZXJzW3N0aV1dO1xuXHQgICAgc291cmNlcy5wdXNoKHNoYWxsb3dDb3B5KHRpZXIuZGFzU291cmNlKSk7XG4gICAgICAgIHZhciBzcyA9IHRpZXIuc3R5bGVzaGVldC5zdHlsZXM7XG4gICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgIHZhciBzaCA9IHNzW3NpXTtcbiAgICAgICAgICAgIHZhciBuc2ggPSBzaGFsbG93Q29weShzaCk7XG4gICAgICAgICAgICBuc2gubWV0aG9kID0gdGllci5kYXNTb3VyY2UubmFtZS5yZXBsYWNlKC9bKCkrKj9dL2csICdcXFxcJCYnKTtcbiAgICAgICAgICAgIG5zaC5fbWV0aG9kUkUgPSBudWxsO1xuICAgICAgICAgICAgbnNoLnN0eWxlID0gc2hhbGxvd0NvcHkoc2guc3R5bGUpO1xuICAgICAgICAgICAgaWYgKG5zaC5zdHlsZS5aSU5ERVggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBuc2guc3R5bGUuWklOREVYID0gc3RpO1xuXG4gICAgICAgICAgICBpZiAodGllci5mb3JjZU1pbikge1xuICAgICAgICAgICAgICAgIG5zaC5zdHlsZS5NSU4gPSB0aWVyLmZvcmNlTWluO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRpZXIuZm9yY2VNYXgpIHtcbiAgICAgICAgICAgICAgICBuc2guc3R5bGUuTUFYID0gdGllci5mb3JjZU1heDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3R5bGVzLnB1c2gobnNoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLmFkZFRpZXIoXG5cdHtuYW1lOiAnTWVyZ2VkJyxcblx0IG1lcmdlOiAnY29uY2F0Jyxcblx0IG92ZXJsYXk6IHNvdXJjZXMsXG5cdCBub0Rvd25zYW1wbGU6IHRydWUsXG4gICAgIHN0eWxlOiBzdHlsZXN9KTtcblxuICAgIHRoaXMuc2V0U2VsZWN0ZWRUaWVyKHRoaXMudGllcnMubGVuZ3RoIC0gMSk7XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEzXG4vL1xuLy8gdGllci1lZGl0LmpzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcblxuICAgIHZhciBkYXMgPSByZXF1aXJlKCcuL2RhcycpO1xuICAgIHZhciBpc0Rhc0Jvb2xlYW5UcnVlID0gZGFzLmlzRGFzQm9vbGVhblRydWU7XG4gICAgdmFyIGlzRGFzQm9vbGVhbk5vdEZhbHNlID0gZGFzLmlzRGFzQm9vbGVhbk5vdEZhbHNlO1xuICAgIHZhciBjb3B5U3R5bGVzaGVldCA9IGRhcy5jb3B5U3R5bGVzaGVldDtcblxuICAgIHZhciBjb2xvciA9IHJlcXVpcmUoJy4vY29sb3InKTtcbiAgICB2YXIgZGFzQ29sb3VyRm9yTmFtZSA9IGNvbG9yLmRhc0NvbG91ckZvck5hbWU7XG5cbiAgICB2YXIgc291cmNlRGF0YVVSSSA9IHJlcXVpcmUoJy4vc291cmNlY29tcGFyZScpLnNvdXJjZURhdGFVUkk7XG59XG5cbnZhciBfX2RhbGxpYW5jZV9zbWFsbEdseXBocyA9IHtcbiAgICBET1Q6IHRydWUsIFxuICAgIEVYOiB0cnVlLCBcbiAgICBTVEFSOiB0cnVlLCBcbiAgICBTUVVBUkU6IHRydWUsIFxuICAgIENST1NTOiB0cnVlLCBcbiAgICBUUklBTkdMRTogdHJ1ZSwgXG4gICAgUExJTVNPTEw6IHRydWVcbn07XG5cbkJyb3dzZXIucHJvdG90eXBlLm9wZW5UaWVyUGFuZWwgPSBmdW5jdGlvbih0aWVyKSB7XG4gICAgdmFyIGIgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMudWlNb2RlID09PSAndGllcicgJiYgdGhpcy5tYW5pcHVsYXRpbmdUaWVyID09PSB0aWVyKSB7XG4gICAgICAgIHRoaXMuaGlkZVRvb2xQYW5lbCgpO1xuICAgICAgICB0aGlzLnNldFVpTW9kZSgnbm9uZScpO1xuICAgIH0gZWxzZSBpZiAoIXRpZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZXRTdHlsZUNvbG9ycyA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGUuQkdHUkFEKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKG51bUNvbG9ycyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlLmdseXBoID09ICdMSU5FUExPVCcgfHwgX19kYWxsaWFuY2Vfc21hbGxHbHlwaHNbc3R5bGUuZ2x5cGhdKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLkZHQ09MT1IgPSB0aWVyQ29sb3JGaWVsZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5CR0NPTE9SID0gdGllckNvbG9yRmllbGQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0eWxlLkNPTE9SMSA9IHN0eWxlLkNPTE9SMiA9IHN0eWxlLkNPTE9SMyA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlLkNPTE9SMSA9IHRpZXJDb2xvckZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgICAgIHN0eWxlLkNPTE9SMiA9IHRpZXJDb2xvckZpZWxkMi52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobnVtQ29sb3JzID4gMikge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5DT0xPUjMgPSB0aWVyQ29sb3JGaWVsZDMudmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuQ09MT1IzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZS5fZ3JhZGllbnQgPSBudWxsO1xuICAgICAgICAgICAgc3R5bGUuX3BsdXNDb2xvciA9IHRpZXJQbHVzQ29sb3JGaWVsZC52YWx1ZTtcbiAgICAgICAgICAgIHN0eWxlLl9taW51c0NvbG9yID0gdGllck1pbnVzQ29sb3JGaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtdXRhdGVTdHlsZXNoZWV0ID0gZnVuY3Rpb24odmlzaXRvcikge1xuICAgICAgICAgICAgdmFyIG5zcyA9IGNvcHlTdHlsZXNoZWV0KHRpZXIuc3R5bGVzaGVldCk7XG4gICAgICAgICAgICB2YXIgc3NTY2FsZSA9IHRpZXIuYnJvd3Nlci56b29tRm9yQ3VycmVudFNjYWxlKCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnNzLnN0eWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzaCA9IG5zcy5zdHlsZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNoLnpvb20gJiYgc2guem9vbSAhPSBzc1NjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZpc2l0b3Ioc2guc3R5bGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnNzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5nZUNvbG9yID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHRpZXIubWVyZ2VTdHlsZXNoZWV0KG11dGF0ZVN0eWxlc2hlZXQoc2V0U3R5bGVDb2xvcnMpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpbmdUaWVyID0gdGllcjtcblxuICAgICAgICB2YXIgdGllckZvcm0gPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge2NsYXNzTmFtZTogJ3RpZXItZWRpdCd9KTtcblxuICAgICAgICB2YXIgYWJvdXRCYW5uZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgXCJBYm91dCAnXCIgKyAodGllci5jb25maWcuTmFtZSB8fCB0aWVyLmRhc1NvdXJjZS5uYW1lKSArIFwiJ1wiLCBudWxsLFxuICAgICAgICAgICAgICAgIHtiYWNrZ3JvdW5kOiAnZ3JheScsIHBhZGRpbmdCb3R0b206ICc1cHgnLCBtYXJnaW5Cb3R0b206ICc1cHgnLCB0ZXh0QWxpZ246ICdjZW50ZXInfSk7XG4gICAgICAgIHRpZXJGb3JtLmFwcGVuZENoaWxkKGFib3V0QmFubmVyKTtcblxuICAgICAgICB2YXIgYWJvdXQgPSBtYWtlRWxlbWVudCgnZGl2JywgXG4gICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3AnLCB0aWVyLmRhc1NvdXJjZS5kZXNjKV1cbiAgICAgICAgKTtcbiAgICAgICAgdmFyIGFib3V0Tm90ZXMgPSBbXTtcbiAgICAgICAgdmFyIHNkdXJpID0gc291cmNlRGF0YVVSSSh0aWVyLmRhc1NvdXJjZSk7XG4gICAgICAgIGlmIChzZHVyaSAmJlxuICAgICAgICAgICAgKHNkdXJpLmluZGV4T2YoJ2h0dHA6Ly8nKSA9PSAwIHx8XG4gICAgICAgICAgICAgc2R1cmkuaW5kZXhPZignaHR0cHM6Ly8nKSA9PSAwIHx8XG4gICAgICAgICAgICAgc2R1cmkuaW5kZXhPZignLy8nKSA9PSAwKSAmJlxuICAgICAgICAgICAgc2R1cmkgIT09ICdodHRwczovL3d3dy5iaW9kYWxsaWFuY2Uub3JnL21hZ2ljL25vX3VyaScpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFib3V0Tm90ZXMucHVzaChtYWtlRWxlbWVudCgnbGknLCBtYWtlRWxlbWVudCgnYScsICcoRG93bmxvYWQgZGF0YSknLCB7aHJlZjogc2R1cml9KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRpZXIuZGFzU291cmNlLm1hcHBpbmcpIHtcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSB0aGlzLmNoYWluc1t0aWVyLmRhc1NvdXJjZS5tYXBwaW5nXS5jb29yZHM7XG4gICAgICAgICAgICBhYm91dE5vdGVzLnB1c2gobWFrZUVsZW1lbnQoJ2xpJywgICdNYXBwZWQgZnJvbSAnICsgY29vcmRzLmF1dGggKyBjb29yZHMudmVyc2lvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFib3V0Tm90ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYWJvdXQuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3VsJywgYWJvdXROb3RlcykpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aWVyRm9ybS5hcHBlbmRDaGlsZChhYm91dCk7XG5cbiAgICAgICAgdmFyIHNlbWFudGljQmFubmVyID0gbWFrZUVsZW1lbnQoJ3NwYW4nLCAnIChzdHlsZXMgZm9yIGN1cnJlbnQgem9vbSBsZXZlbCknLCBudWxsLCB7ZGlzcGxheTogJ25vbmUnfSk7XG4gICAgICAgIHZhciBlZGl0QmFubmVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIFsnRWRpdCcsIHNlbWFudGljQmFubmVyXSwgbnVsbCxcbiAgICAgICAgICAgICAge2JhY2tncm91bmQ6ICdncmF5JywgcGFkZGluZ0JvdHRvbTogJzVweCcsIG1hcmdpbkJvdHRvbTogJzVweCcsIHRleHRBbGlnbjogJ2NlbnRlcid9KTtcbiAgICAgICAgdGllckZvcm0uYXBwZW5kQ2hpbGQoZWRpdEJhbm5lcik7XG5cbiAgICAgICAgdmFyIHRpZXJOYW1lRmllbGQgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ3RleHQnfSk7XG4gICAgICAgIHZhciB0aWVyUGlubmVkVG9nZ2xlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdjaGVja2JveCcsIGRpc2FibGVkOiB0aGlzLmRpc2FibGVQaW5uaW5nfSk7XG5cbiAgICAgICAgdmFyIGdseXBoRmllbGQgPSBtYWtlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIGdseXBoRmllbGQuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsICdIaXN0b2dyYW0nLCB7dmFsdWU6ICdISVNUT0dSQU0nfSkpO1xuICAgICAgICBnbHlwaEZpZWxkLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnTGluZSBQbG90Jywge3ZhbHVlOiAnTElORVBMT1QnfSkpO1xuICAgICAgICBnbHlwaEZpZWxkLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnUmliYm9uJywge3ZhbHVlOiAnR1JBRElFTlQnfSkpO1xuICAgICAgICBnbHlwaEZpZWxkLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCAnU2NhdHRlcicsIHt2YWx1ZTogJ1NDQVRURVInfSkpO1xuXG4gICAgICAgIHZhciB0aWVyQ29sb3JGaWVsZCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCcsIHZhbHVlOiAnI2RkMDBkZCd9KTtcbiAgICAgICAgdmFyIHRpZXJDb2xvckZpZWxkMiA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCcsIHZhbHVlOiAnI2RkMDBkZCd9KTtcbiAgICAgICAgdmFyIHRpZXJDb2xvckZpZWxkMyA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCcsIHZhbHVlOiAnI2RkMDBkZCd9KTtcblxuICAgICAgICB2YXIgdGllclBsdXNDb2xvckZpZWxkID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcjZmZhMDdhJ30pO1xuICAgICAgICB2YXIgdGllck1pbnVzQ29sb3JGaWVsZCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAndGV4dCcsIHZhbHVlOiAnIzg3Y2VmYSd9KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGllckNvbG9yRmllbGQudHlwZSA9IHRpZXJDb2xvckZpZWxkMi50eXBlID0gdGllckNvbG9yRmllbGQzLnR5cGUgPSAnY29sb3InO1xuICAgICAgICAgICAgdGllclBsdXNDb2xvckZpZWxkLnR5cGUgPSB0aWVyTWludXNDb2xvckZpZWxkLnR5cGUgPSAnY29sb3InO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJRSB0aHJvd3MgaWYgYXR0ZW1wdCB0byBzZXQgdHlwZSB0byAnY29sb3InLlxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRpZXJDb2xvckZpZWxkcyA9IFt0aWVyQ29sb3JGaWVsZCwgdGllckNvbG9yRmllbGQyLCB0aWVyQ29sb3JGaWVsZDNdO1xuICAgICAgICB2YXIgY29sb3JMaXN0UGx1cyA9IG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXBsdXMtY2lyY2xlJ30pO1xuICAgICAgICB2YXIgY29sb3JMaXN0TWludXMgPSBtYWtlRWxlbWVudCgnaScsIG51bGwsIHtjbGFzc05hbWU6ICdmYSBmYS1taW51cy1jaXJjbGUnfSk7XG4gICAgICAgIHZhciBudW1Db2xvcnMgPSAxO1xuICAgICAgICB2YXIgY29sb3JMaXN0RWxlbWVudCA9IG1ha2VFbGVtZW50KCd0ZCcsIHRpZXJDb2xvckZpZWxkcyk7XG4gICAgICAgIHZhciBzZXROdW1Db2xvcnMgPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICBudW1Db2xvcnMgPSBuO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIFxuICAgICAgICAgICAgICAgIHRpZXJDb2xvckZpZWxkc1tpXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBuOyBpIDwgdGllckNvbG9yRmllbGRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHRpZXJDb2xvckZpZWxkc1tpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGNvbG9yTGlzdFBsdXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKG51bUNvbG9ycyA8IDMpIHtcbiAgICAgICAgICAgICAgICBzZXROdW1Db2xvcnMobnVtQ29sb3JzICsgMSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ29sb3IobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgY29sb3JMaXN0TWludXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKG51bUNvbG9ycyA+IDEpIHtcbiAgICAgICAgICAgICAgICBzZXROdW1Db2xvcnMobnVtQ29sb3JzIC0gMSk7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ29sb3IobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICB2YXIgdGllck1pbkZpZWxkID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICcwLjAnfSk7XG4gICAgICAgIHZhciB0aWVyTWF4RmllbGQgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ3RleHQnLCB2YWx1ZTogJzEwLjAnfSk7XG4gICAgICAgIHZhciB0aWVyTWluVG9nZ2xlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdjaGVja2JveCd9KTtcbiAgICAgICAgdmFyIHRpZXJNYXhUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94J30pO1xuXG4gICAgICAgIHZhciBxdWFudExlYXBUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94JywgY2hlY2tlZDogdGllci5xdWFudExlYXBUaHJlc2hvbGQgIT09IHVuZGVmaW5lZH0pO1xuICAgICAgICB2YXIgcXVhbnRMZWFwVGhyZXNoRmllbGQgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ3RleHQnLCB2YWx1ZTogdGllci5xdWFudExlYXBUaHJlc2hvbGQsIGRpc2FibGVkOiAhcXVhbnRMZWFwVG9nZ2xlLmNoZWNrZWR9KTtcblxuICAgICAgICB2YXIgdGllckhlaWdodEZpZWxkID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICd0ZXh0JywgdmFsdWU6ICc1MCd9KTtcblxuICAgICAgICB2YXIgYnVtcFRvZ2dsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnY2hlY2tib3gnfSk7XG4gICAgICAgIHZhciBidW1wTGltaXQgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ3RleHQnfSk7XG4gICAgICAgIHZhciBsYWJlbFRvZ2dsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnY2hlY2tib3gnfSk7XG5cbiAgICAgICAgdmFyIG1haW5TdHlsZSA9IG51bGw7XG4gICAgICAgIGlmICh0aWVyLnN0eWxlc2hlZXQuc3R5bGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBzID0gbWFpblN0eWxlID0gdGllci5zdHlsZXNoZWV0LnN0eWxlc1swXS5zdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWZyZXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRpZXIuY29uZmlnLm5hbWUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRpZXJOYW1lRmllbGQudmFsdWUgPSB0aWVyLmNvbmZpZy5uYW1lO1xuICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICB0aWVyTmFtZUZpZWxkLnZhbHVlID0gdGllci5kYXNTb3VyY2UubmFtZTtcblxuICAgICAgICAgICAgdGllclBpbm5lZFRvZ2dsZS5jaGVja2VkID0gdGllci5waW5uZWQ7XG5cbiAgICAgICAgICAgIGlmICh0aWVyLmZvcmNlSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGllckhlaWdodEZpZWxkLnZhbHVlID0gJycgKyB0aWVyLmZvcmNlSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYWluU3R5bGUgJiYgbWFpblN0eWxlLkhFSUdIVCkge1xuICAgICAgICAgICAgICAgIHRpZXJIZWlnaHRGaWVsZC52YWx1ZSA9ICcnICsgbWFpblN0eWxlLkhFSUdIVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aWVyLnF1YW50TGVhcFRocmVzaG9sZCA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHF1YW50TGVhcFRvZ2dsZS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBxdWFudExlYXBUaHJlc2hGaWVsZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZUZsb2F0KHF1YW50TGVhcFRocmVzaEZpZWxkLnZhbHVlKSAhPSB0aWVyLnF1YW50TGVhcFRocmVzaG9sZClcbiAgICAgICAgICAgICAgICAgICAgcXVhbnRMZWFwVGhyZXNoRmllbGQudmFsdWUgPSB0aWVyLnF1YW50TGVhcFRocmVzaG9sZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcXVhbnRMZWFwVG9nZ2xlLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBxdWFudExlYXBUaHJlc2hGaWVsZC5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGllci5zdWJ0aWVyTWF4ID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgYnVtcExpbWl0LnZhbHVlID0gJycgKyB0aWVyLnN1YnRpZXJNYXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1bXBMaW1pdC52YWx1ZSA9ICcnICsgKHRpZXIuZGFzU291cmNlLnN1YnRpZXJNYXggfHwgdGllci5icm93c2VyLmRlZmF1bHRTdWJ0aWVyTWF4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpZXIuc3R5bGVzaGVldC5zdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgaXNRdWFudGl0YXRpdmU9ZmFsc2UsIGlzU2ltcGxlUXVhbnRpdGF0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHNzU2NhbGUgPSB0aWVyLmJyb3dzZXIuem9vbUZvckN1cnJlbnRTY2FsZSgpO1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVTdHlsZUNvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aWVyLnN0eWxlc2hlZXQuc3R5bGVzLmxlbmd0aDsgKytzaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2ggPSB0aWVyLnN0eWxlc2hlZXQuc3R5bGVzW3NpXTsgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoc2guem9vbSAmJiBzaC56b29tICE9IHNzU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICsrYWN0aXZlU3R5bGVDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNzID0gdGllci5zdHlsZXNoZWV0LnN0eWxlc1tzaV0uc3R5bGU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gbWFpblN0eWxlID0gc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChzcy5nbHlwaCA9PSAnTElORVBMT1QnIHx8IHNzLmdseXBoID09ICdISVNUT0dSQU0nIHx8IHNzLmdseXBoID09ICdHUkFESUVOVCcgfHwgaXNEYXNCb29sZWFuVHJ1ZShzcy5TQ0FUVEVSKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1YW50aXRhdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gbWFpblN0eWxlID0gc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1F1YW50aXRhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZW1hbnRpY0Jhbm5lci5zdHlsZS5kaXNwbGF5ID0gKGFjdGl2ZVN0eWxlQ291bnQgPT0gdGllci5zdHlsZXNoZWV0LnN0eWxlcy5sZW5ndGgpID8gJ25vbmUnIDogJ2lubGluZSc7XG5cbiAgICAgICAgICAgICAgICBpc1NpbXBsZVF1YW50aXRhdGl2ZSA9IGlzUXVhbnRpdGF0aXZlICYmIGFjdGl2ZVN0eWxlQ291bnQgPT0gMTtcbiAgICAgICAgICAgICAgICB2YXIgaXNHcmFkaWVudCA9IHMuQ09MT1IyIHx8IHMuQkdHUkFEO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUXVhbnRpdGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pblJvdy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgICAgICAgICAgICAgIG1heFJvdy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgICAgICAgICAgICAgIGJ1bXBSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW5Sb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgbWF4Um93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIGJ1bXBSb3cuc3R5bGUuZGlzcGxheSA9ICd0YWJsZS1yb3cnO1xuICAgICAgICAgICAgICAgICAgICBidW1wVG9nZ2xlLmNoZWNrZWQgPSBpc0Rhc0Jvb2xlYW5UcnVlKG1haW5TdHlsZS5CVU1QKTtcbiAgICAgICAgICAgICAgICAgICAgYnVtcExpbWl0LmRpc2FibGVkID0gIWlzRGFzQm9vbGVhblRydWUobWFpblN0eWxlLkJVTVApO1xuICAgICAgICAgICAgICAgICAgICBsYWJlbFJvdy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsVG9nZ2xlLmNoZWNrZWQgPSBpc0Rhc0Jvb2xlYW5UcnVlKG1haW5TdHlsZS5MQUJFTCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2ltcGxlUXVhbnRpdGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlUm93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgICAgICAgICAgY29sb3JSb3cuc3R5bGUuZGlzcGxheSA9ICd0YWJsZS1yb3cnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlUm93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yUm93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbnVtQ29sb3JzID0gMTtcbiAgICAgICAgICAgICAgICBpZiAocy5DT0xPUjEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGllckNvbG9yRmllbGQudmFsdWUgPSBkYXNDb2xvdXJGb3JOYW1lKHMuQ09MT1IxKS50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5DT0xPUjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpZXJDb2xvckZpZWxkMi52YWx1ZSA9IGRhc0NvbG91ckZvck5hbWUocy5DT0xPUjIpLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocy5DT0xPUjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aWVyQ29sb3JGaWVsZDMudmFsdWUgPSBkYXNDb2xvdXJGb3JOYW1lKHMuQ09MT1IzKS50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUNvbG9ycyA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUNvbG9ycyA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5nbHlwaCA9PSAnTElORVBMT1QnIHx8IHMuZ2x5cGggPT0gJ0RPVCcgJiYgcy5GR0NPTE9SKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aWVyQ29sb3JGaWVsZC52YWx1ZSA9IGRhc0NvbG91ckZvck5hbWUocy5GR0NPTE9SKS50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHMuQkdDT0xPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGllckNvbG9yRmllbGQudmFsdWUgPSBkYXNDb2xvdXJGb3JOYW1lKHMuQkdDT0xPUikudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgc2V0TnVtQ29sb3JzKG51bUNvbG9ycyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocy5fcGx1c0NvbG9yKVxuICAgICAgICAgICAgICAgICAgICB0aWVyUGx1c0NvbG9yRmllbGQudmFsdWUgPSBkYXNDb2xvdXJGb3JOYW1lKHMuX3BsdXNDb2xvcikudG9IZXhTdHJpbmcoKSB8fCBzLl9wbHVzQ29sb3I7XG4gICAgICAgICAgICAgICAgaWYgKHMuX21pbnVzQ29sb3IpXG4gICAgICAgICAgICAgICAgICAgIHRpZXJNaW51c0NvbG9yRmllbGQudmFsdWUgPSBkYXNDb2xvdXJGb3JOYW1lKHMuX21pbnVzQ29sb3IpLnRvSGV4U3RyaW5nKCkgfHwgcy5fbWludXNDb2xvcjtcbiAgICAgICAgICAgICAgICBpZiAoaXNEYXNCb29sZWFuVHJ1ZShzLlNDQVRURVIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoRmllbGQudmFsdWUgPSAnU0NBVFRFUic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhGaWVsZC52YWx1ZSA9IHMuZ2x5cGg7XG4gICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgIHZhciBzZXRNaW5WYWx1ZSwgc2V0TWF4VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHMuTUlOICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KHMuTUlOKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTih4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE1pblZhbHVlID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aWVyLmZvcmNlTWluRHluYW1pYyAmJiAocy5NSU4gIT09IHVuZGVmaW5lZCB8fCB0aWVyLmZvcmNlTWluICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNaW5Ub2dnbGUuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNaW5GaWVsZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNaW5Ub2dnbGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aWVyTWluRmllbGQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzLk1BWCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChzLk1BWClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTih4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE1heFZhbHVlID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aWVyLmZvcmNlTWF4RHluYW1pYyAmJiAocy5NQVggIT09IHVuZGVmaW5lZCB8fCB0aWVyLmZvcmNlTWF4ICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNYXhUb2dnbGUuY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNYXhGaWVsZC5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNYXhUb2dnbGUuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aWVyTWF4RmllbGQuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0aWVyLmZvcmNlTWluICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRNaW5WYWx1ZSA9IHRpZXIuZm9yY2VNaW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aWVyLmZvcmNlTWF4ICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRNYXhWYWx1ZSA9IHRpZXIuZm9yY2VNYXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yoc2V0TWluVmFsdWUpID09ICdudW1iZXInICYmIHNldE1pblZhbHVlICE9IHBhcnNlRmxvYXQodGllck1pbkZpZWxkLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aWVyTWluRmllbGQudmFsdWUgPSBzZXRNaW5WYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZihzZXRNYXhWYWx1ZSkgPT0gJ251bWJlcicgJiYgc2V0TWF4VmFsdWUgIT0gcGFyc2VGbG9hdCh0aWVyTWF4RmllbGQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpZXJNYXhGaWVsZC52YWx1ZSA9IHNldE1heFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBzZXFTdHlsZSA9IGdldFNlcVN0eWxlKHRpZXIuc3R5bGVzaGVldCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcVN0eWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcU1pc21hdGNoUm93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgICAgICAgICAgc2VxTWlzbWF0Y2hUb2dnbGUuY2hlY2tlZCA9IChzZXFTdHlsZS5fX1NFUUNPTE9SID09PSAnbWlzbWF0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VxSW5zZXJ0Um93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgICAgICAgICAgc2VxSW5zZXJ0VG9nZ2xlLmNoZWNrZWQgPSAgaXNEYXNCb29sZWFuVHJ1ZShzZXFTdHlsZS5fX0lOU0VSVElPTlMpO1xuICAgICAgICAgICAgICAgICAgICBzZXFJZ25vcmVRdWFsc1Jvdy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgICAgICAgICAgICAgIHNlcUlnbm9yZVF1YWxzVG9nZ2xlLmNoZWNrZWQgPSAoc2VxU3R5bGUuX19kaXNhYmxlUXVhbHMgPT09IHVuZGVmaW5lZCB8fCBzZXFTdHlsZS5fX2Rpc2FibGVRdWFscyA9PT0gZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzZXFTdHlsZS5fX2Rpc2FibGVRdWFscyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxTWlzbWF0Y2hSb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgc2VxSW5zZXJ0Um93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgIHNlcUlnbm9yZVF1YWxzUm93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlcVN0eWxlICYmIHNlcU1pc21hdGNoVG9nZ2xlLmNoZWNrZWQgJiYgIWlzU2ltcGxlUXVhbnRpdGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdXNTdHJhbmRDb2xvclJvdy5zdHlsZS5kaXNwbGF5ID0gJ3RhYmxlLXJvdyc7XG4gICAgICAgICAgICAgICAgICAgIG1pbnVzU3RyYW5kQ29sb3JSb3cuc3R5bGUuZGlzcGxheSA9ICd0YWJsZS1yb3cnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBsdXNTdHJhbmRDb2xvclJvdy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBtaW51c1N0cmFuZENvbG9yUm93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNRdWFudGl0YXRpdmUgJiYgdGllci5icm93c2VyLnNvdXJjZUFkYXB0ZXJJc0NhcGFibGUodGllci5mZWF0dXJlU291cmNlLCAncXVhbnRMZWFwJykpXG4gICAgICAgICAgICAgICAgcXVhbnRMZWFwUm93LnN0eWxlLmRpc3BsYXkgPSAndGFibGUtcm93JztcbiAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICAgICAgcXVhbnRMZWFwUm93LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VxTWlzbWF0Y2hUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94J30pO1xuICAgICAgICB2YXIgc2VxTWlzbWF0Y2hSb3cgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdIaWdobGlnaHQgbWlzbWF0Y2hlcyAmIHN0cmFuZHMnKSxcbiAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBzZXFNaXNtYXRjaFRvZ2dsZSldKTtcbiAgICAgICAgc2VxTWlzbWF0Y2hUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBuc3MgPSBjb3B5U3R5bGVzaGVldCh0aWVyLnN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgdmFyIHNlcVN0eWxlID0gZ2V0U2VxU3R5bGUobnNzKTtcbiAgICAgICAgICAgIHNlcVN0eWxlLl9fU0VRQ09MT1IgPSBzZXFNaXNtYXRjaFRvZ2dsZS5jaGVja2VkID8gJ21pc21hdGNoJyA6ICdiYXNlJztcbiAgICAgICAgICAgIHRpZXIubWVyZ2VTdHlsZXNoZWV0KG5zcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBzZXFJbnNlcnRUb2dnbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2NoZWNrYm94J30pO1xuICAgICAgICB2YXIgc2VxSW5zZXJ0Um93ID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgIFttYWtlRWxlbWVudCgndGgnLCAnU2hvdyBpbnNlcnRpb25zJyksXG4gICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgc2VxSW5zZXJ0VG9nZ2xlKV0pO1xuICAgICAgICBzZXFJbnNlcnRUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBuc3MgPSBjb3B5U3R5bGVzaGVldCh0aWVyLnN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgdmFyIHNlcVN0eWxlID0gZ2V0U2VxU3R5bGUobnNzKTtcbiAgICAgICAgICAgIHNlcVN0eWxlLl9fSU5TRVJUSU9OUyA9IHNlcUluc2VydFRvZ2dsZS5jaGVja2VkID8gJ3llcycgOiAnbm8nO1xuICAgICAgICAgICAgdGllci5tZXJnZVN0eWxlc2hlZXQobnNzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHNlcUlnbm9yZVF1YWxzVG9nZ2xlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdjaGVja2JveCd9KTtcbiAgICAgICAgdmFyIHNlcUlnbm9yZVF1YWxzUm93ID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgIFttYWtlRWxlbWVudCgndGgnLCAnUmVmbGVjdCBiYXNlIHF1YWxpdHkgYXMgYmFzZSBjb2xvciB0cmFuc3BhcmVuY3knKSxcbiAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBzZXFJZ25vcmVRdWFsc1RvZ2dsZSldKTtcbiAgICAgICAgc2VxSWdub3JlUXVhbHNUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHZhciBuc3MgPSBjb3B5U3R5bGVzaGVldCh0aWVyLnN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgdmFyIHNlcVN0eWxlID0gZ2V0U2VxU3R5bGUobnNzKTtcbiAgICAgICAgICAgIHNlcVN0eWxlLl9fZGlzYWJsZVF1YWxzID0gIXNlcUlnbm9yZVF1YWxzVG9nZ2xlLmNoZWNrZWQ7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzZXFTdHlsZS5fX2Rpc2FibGVRdWFscyk7XG4gICAgICAgICAgICB0aWVyLm1lcmdlU3R5bGVzaGVldChuc3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc3R5bGVSb3cgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgICAgIFttYWtlRWxlbWVudCgndGgnLCAnU3R5bGUnKSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgZ2x5cGhGaWVsZCldKTtcbiAgICAgICAgdmFyIGNvbG9yUm93ID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgWydDb2xvdXIocyknLCBjb2xvckxpc3RQbHVzLCBjb2xvckxpc3RNaW51c10pLFxuICAgICAgICAgICAgICAgICBjb2xvckxpc3RFbGVtZW50XSk7XG4gICAgICAgIHZhciBwbHVzU3RyYW5kQ29sb3JSb3cgPSBtYWtlRWxlbWVudCgndHInLFxuICAgICAgICAgICAgICAgIFttYWtlRWxlbWVudCgndGgnLCAnUGx1cyBTdHJhbmQgQ29sb3InKSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgdGllclBsdXNDb2xvckZpZWxkKV0pO1xuICAgICAgICB2YXIgbWludXNTdHJhbmRDb2xvclJvdyA9IG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdNaW51cyBTdHJhbmQgQ29sb3InKSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgdGllck1pbnVzQ29sb3JGaWVsZCldKTtcbiAgICAgICAgdmFyIG1pblJvdyA9IG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdNaW4gdmFsdWUnKSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgW3RpZXJNaW5Ub2dnbGUsICcgJywgdGllck1pbkZpZWxkXSldKTtcbiAgICAgICAgdmFyIG1heFJvdyA9IG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdNYXggdmFsdWUnKSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgW3RpZXJNYXhUb2dnbGUsICcgJywgdGllck1heEZpZWxkXSldKTtcbiAgICAgICAgdmFyIHF1YW50TGVhcFJvdyA9IFxuICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdUaHJlc2hvbGQgbGVhcDonKSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgW3F1YW50TGVhcFRvZ2dsZSwgJyAnLCBxdWFudExlYXBUaHJlc2hGaWVsZF0pXSk7XG4gICAgICAgIHZhciBidW1wUm93ID0gbWFrZUVsZW1lbnQoJ3RyJyxcbiAgICAgICAgICAgICAgICBbbWFrZUVsZW1lbnQoJ3RoJywgJ0J1bXAgb3ZlcmxhcHMnKSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgW2J1bXBUb2dnbGUsICcgbGltaXQ6ICcsIGJ1bXBMaW1pdF0pXSk7XG4gICAgICAgIHZhciBsYWJlbFJvdyA9IG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdMYWJlbCBmZWF0dXJlcycpLFxuICAgICAgICAgICAgICAgICBtYWtlRWxlbWVudCgndGQnLCBsYWJlbFRvZ2dsZSldKTtcblxuXG4gICAgICAgIHZhciB0aWVyVGFibGUgPSBtYWtlRWxlbWVudCgndGFibGUnLFxuICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdOYW1lJywge30sIHt3aWR0aDogJzE1MHB4JywgdGV4dEFsaWduOiAncmlnaHQnfSksXG4gICAgICAgICAgICAgICAgIHRpZXJOYW1lRmllbGRdKSxcblxuICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdQaW4gdG8gdG9wJyksXG4gICAgICAgICAgICAgICAgIHRpZXJQaW5uZWRUb2dnbGVdKSxcblxuICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0cicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCd0aCcsICdIZWlnaHQnKSxcbiAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgdGllckhlaWdodEZpZWxkKV0pLFxuXG4gICAgICAgICAgICBzdHlsZVJvdyxcbiAgICAgICAgICAgIGNvbG9yUm93LFxuICAgICAgICAgICAgcGx1c1N0cmFuZENvbG9yUm93LFxuICAgICAgICAgICAgbWludXNTdHJhbmRDb2xvclJvdyxcbiAgICAgICAgICAgIG1pblJvdyxcbiAgICAgICAgICAgIG1heFJvdyxcbiAgICAgICAgICAgIHF1YW50TGVhcFJvdyxcbiAgICAgICAgICAgIGJ1bXBSb3csXG4gICAgICAgICAgICBsYWJlbFJvdyxcbiAgICAgICAgICAgIHNlcU1pc21hdGNoUm93LFxuICAgICAgICAgICAgc2VxSW5zZXJ0Um93LFxuICAgICAgICAgICAgc2VxSWdub3JlUXVhbHNSb3dcbiAgICAgICAgICAgICBdKTtcblxuXG4gICAgICAgIHJlZnJlc2goKTtcblxuICAgICAgICB0aWVyRm9ybS5hcHBlbmRDaGlsZCh0aWVyVGFibGUpO1xuXG4gICAgICAgIHZhciByZXNldEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdidXR0b24nLCAnUmVzZXQgdHJhY2snLCB7Y2xhc3NOYW1lOiAnYnRuJ30sIHttYXJnaW5MZWZ0OiAnYXV0bycsIG1hcmdpblJpZ2h0OiAnYXV0bycsIGRpc3BsYXk6ICdibG9jayd9KTtcbiAgICAgICAgcmVzZXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdGllci5zZXRDb25maWcoe30pO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIHRpZXJGb3JtLmFwcGVuZENoaWxkKHJlc2V0QnV0dG9uKTtcblxuICAgICAgICB0aWVyTmFtZUZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHRpZXIubWVyZ2VDb25maWcoe25hbWU6IHRpZXJOYW1lRmllbGQudmFsdWV9KTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIHRpZXJQaW5uZWRUb2dnbGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHRpZXIubWVyZ2VDb25maWcoe3Bpbm5lZDogdGllclBpbm5lZFRvZ2dsZS5jaGVja2VkfSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgdGllckNvbG9yRmllbGRzLmxlbmd0aDsgKytjaSkge1xuICAgICAgICAgICAgdGllckNvbG9yRmllbGRzW2NpXS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBjaGFuZ2VDb2xvciwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGllclBsdXNDb2xvckZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGNoYW5nZUNvbG9yLCBmYWxzZSk7XG4gICAgICAgIHRpZXJNaW51c0NvbG9yRmllbGQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgY2hhbmdlQ29sb3IsIGZhbHNlKTtcblxuICAgICAgICBnbHlwaEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgbnNzID0gbXV0YXRlU3R5bGVzaGVldChmdW5jdGlvbih0cykge1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaEZpZWxkLnZhbHVlID09PSAnU0NBVFRFUicpIHtcbiAgICAgICAgICAgICAgICAgICAgdHMuU0NBVFRFUiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRzLmdseXBoID0gJ0RPVCc7XG4gICAgICAgICAgICAgICAgICAgIHRzLlNJWkUgPSAnMyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHMuZ2x5cGggPSBnbHlwaEZpZWxkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cy5TQ0FUVEVSID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRTdHlsZUNvbG9ycyh0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpZXIubWVyZ2VTdHlsZXNoZWV0KG5zcyk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICB0aWVyTWluVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgY29uZiA9IHtmb3JjZU1pbkR5bmFtaWM6ICF0aWVyTWluVG9nZ2xlLmNoZWNrZWR9O1xuICAgICAgICAgICAgdGllck1pbkZpZWxkLmRpc2FibGVkID0gIXRpZXJNaW5Ub2dnbGUuY2hlY2tlZDtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdCh0aWVyTWluRmllbGQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRpZXJNaW5Ub2dnbGUuY2hlY2tlZCAmJiB0eXBlb2YoeCkgPT0gJ251bWJlcicgJiYgIWlzTmFOKHgpKVxuICAgICAgICAgICAgICAgIGNvbmYuZm9yY2VNaW4gPSBwYXJzZUZsb2F0KHgpO1xuICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyhjb25mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRpZXJNaW5GaWVsZC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQodGllck1pbkZpZWxkLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoeCkgPT0gJ251bWJlcicgJiYgIWlzTmFOKHgpKVxuICAgICAgICAgICAgICAgIHRpZXIubWVyZ2VDb25maWcoe2ZvcmNlTWluOiB4fSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICB0aWVyTWF4VG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgY29uZiA9IHtmb3JjZU1heER5bmFtaWM6ICF0aWVyTWF4VG9nZ2xlLmNoZWNrZWR9O1xuICAgICAgICAgICAgdGllck1heEZpZWxkLmRpc2FibGVkID0gIXRpZXJNYXhUb2dnbGUuY2hlY2tlZDtcbiAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdCh0aWVyTWF4RmllbGQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRpZXJNYXhUb2dnbGUuY2hlY2tlZCAmJiB0eXBlb2YoeCkgPT0gJ251bWJlcicgJiYgIWlzTmFOKHgpKVxuICAgICAgICAgICAgICAgIGNvbmYuZm9yY2VNYXggPSBwYXJzZUZsb2F0KHgpO1xuICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyhjb25mKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRpZXJNYXhGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQodGllck1heEZpZWxkLnZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YoeCkgPT0gJ251bWJlcicgJiYgIWlzTmFOKHgpKVxuICAgICAgICAgICAgICAgIHRpZXIubWVyZ2VDb25maWcoe2ZvcmNlTWF4OiB4fSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICB0aWVySGVpZ2h0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KHRpZXJIZWlnaHRGaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHgpID09ICdudW1iZXInICYmICFpc05hTih4KSlcbiAgICAgICAgICAgICAgICB0aWVyLm1lcmdlQ29uZmlnKHtoZWlnaHQ6IE1hdGgubWluKDUwMCwgeHwwKX0pO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZVF1YW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBxdWFudExlYXBUaHJlc2hGaWVsZC5kaXNhYmxlZCA9ICFxdWFudExlYXBUb2dnbGUuY2hlY2tlZDtcbiAgICAgICAgICAgIGlmIChxdWFudExlYXBUb2dnbGUuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChxdWFudExlYXBUaHJlc2hGaWVsZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZih4KSA9PSAnbnVtYmVyJyAmJiAhaXNOYU4oeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyh7cXVhbnRMZWFwVGhyZXNob2xkOiBwYXJzZUZsb2F0KHF1YW50TGVhcFRocmVzaEZpZWxkLnZhbHVlKX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyh7cXVhbnRMZWFwVGhyZXNob2xkOiBudWxsfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVhbnRMZWFwVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB1cGRhdGVRdWFudCgpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIHF1YW50TGVhcFRocmVzaEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIHVwZGF0ZVF1YW50KCk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBsYWJlbFRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdmFyIG5zcyA9IG11dGF0ZVN0eWxlc2hlZXQoZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5MQUJFTCA9IGxhYmVsVG9nZ2xlLmNoZWNrZWQgPyAneWVzJyA6ICdubyc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpZXIubWVyZ2VTdHlsZXNoZWV0KG5zcyk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgYnVtcFRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgdmFyIG5zcyA9IG11dGF0ZVN0eWxlc2hlZXQoZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5CVU1QID0gYnVtcFRvZ2dsZS5jaGVja2VkID8gJ3llcycgOiAnbm8nO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aWVyLm1lcmdlU3R5bGVzaGVldChuc3MpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIGJ1bXBMaW1pdC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHBhcnNlSW50KGJ1bXBMaW1pdC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mKHgpID09ICdudW1iZXInICYmIHggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGllci5tZXJnZUNvbmZpZyh7c3VidGllck1heDogeH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSk7XG5cblxuICAgICAgICB0aGlzLnNob3dUb29sUGFuZWwodGllckZvcm0pO1xuICAgICAgICB0aGlzLnNldFVpTW9kZSgndGllcicpO1xuXG4gICAgICAgIHRpZXIuYWRkVGllckxpc3RlbmVyKHJlZnJlc2gpO1xuXG4gICAgICAgIHZhciBjdXJyZW50U2NhbGUgPSB0aWVyLmJyb3dzZXIuc2NhbGU7XG4gICAgICAgIHRpZXIuYnJvd3Nlci5hZGRWaWV3TGlzdGVuZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGllci5icm93c2VyLnNjYWxlICE9IGN1cnJlbnRTY2FsZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTY2FsZSA9IHRpZXIuYnJvd3Nlci5zY2FsZTtcbiAgICAgICAgICAgICAgICByZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2VxU3R5bGUoc3R5bGVzaGVldCkge1xuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzdHlsZXNoZWV0LnN0eWxlcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgdmFyIHNzID0gc3R5bGVzaGVldC5zdHlsZXNbc2ldLnN0eWxlO1xuICAgICAgICBpZiAoc3MuZ2x5cGggPT09ICdfX1NFUVVFTkNFJykge1xuICAgICAgICAgICAgcmV0dXJuIHNzO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEwXG4vL1xuLy8gdGllci5qczogKHRyeSkgdG8gZW5jYXBzdWxhdGUgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYSBicm93c2VyIHRpZXIuXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIG1ha2VFbGVtZW50ID0gdXRpbHMubWFrZUVsZW1lbnQ7XG4gICAgdmFyIHJlbW92ZUNoaWxkcmVuID0gdXRpbHMucmVtb3ZlQ2hpbGRyZW47XG4gICAgdmFyIHNoYWxsb3dDb3B5ID0gdXRpbHMuc2hhbGxvd0NvcHk7XG4gICAgdmFyIHB1c2huZXcgPSB1dGlscy5wdXNobmV3O1xuICAgIHZhciBtaW5pSlNPTmlmeSA9IHV0aWxzLm1pbmlKU09OaWZ5O1xuICAgIHZhciBhcnJheUluZGV4T2YgPSB1dGlscy5hcnJheUluZGV4T2Y7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU3R5bGVzaGVldCA9IGRhcy5EQVNTdHlsZXNoZWV0O1xuICAgIHZhciBEQVNTdHlsZSA9IGRhcy5EQVNTdHlsZTtcblxuICAgIHZhciBzaGExID0gcmVxdWlyZSgnLi9zaGExJyk7XG4gICAgdmFyIGI2NF9zaGExID0gc2hhMS5iNjRfc2hhMTtcblxuICAgIHZhciBzdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGUnKTtcbiAgICB2YXIgU3R5bGVGaWx0ZXIgPSBzdHlsZS5TdHlsZUZpbHRlcjtcbiAgICB2YXIgU3R5bGVGaWx0ZXJTZXQgPSBzdHlsZS5TdHlsZUZpbHRlclNldDtcblxuICAgIHZhciBzYyA9IHJlcXVpcmUoJy4vc291cmNlY29tcGFyZScpO1xuICAgIHZhciBzb3VyY2VEYXRhVVJJID0gc2Muc291cmNlRGF0YVVSSTtcbn1cblxudmFyIF9fdGllcl9pZFNlZWQgPSAwO1xuXG5mdW5jdGlvbiBEYXNUaWVyKGJyb3dzZXIsIHNvdXJjZSwgY29uZmlnLCBiYWNrZ3JvdW5kKVxue1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMuaWQgPSAndGllcicgKyAoKytfX3RpZXJfaWRTZWVkKTtcbiAgICB0aGlzLmJyb3dzZXIgPSBicm93c2VyO1xuICAgIHRoaXMuZGFzU291cmNlID0gc2hhbGxvd0NvcHkoc291cmNlKTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBiYWNrZ3JvdW5kO1xuXG4gICAgdGhpcy52aWV3cG9ydCA9IG1ha2VFbGVtZW50KCdjYW52YXMnLCBudWxsLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3dpZHRoOiAnJyArICgodGhpcy5icm93c2VyLmZlYXR1cmVQYW5lbFdpZHRofDApICsgMjAwMCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjMwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICd2aWV3cG9ydF8xMl81J30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtwb3NpdGlvbjogJ2lubGluZS1ibG9jaycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcwcHgnLCBib3JkZXI6ICcwcHgnfSk7XG4gICAgdGhpcy52aWV3cG9ydEhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnLCB0aGlzLnZpZXdwb3J0LCB7Y2xhc3NOYW1lOiAndmlld3BvcnQtaG9sZGVyXzEyXzUnfSwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMHB4JywgbWFyZ2luOiAnMHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJzBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiAnLTEwMDBweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5IZWlnaHQ6ICcyMDBweCd9KTtcbiAgICB0aGlzLm92ZXJsYXkgPSBtYWtlRWxlbWVudCgnY2FudmFzJywgbnVsbCxcbiAgICAgICAgIHt3aWR0aDogKyAoKHRoaXMuYnJvd3Nlci5mZWF0dXJlUGFuZWxXaWR0aHwwKSksIFxuICAgICAgICAgIGhlaWdodDogXCIzMFwiLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ3ZpZXdwb3J0LW92ZXJsYXknfSk7XG5cbiAgICB0aGlzLm5vdGlmaWVyID0gbWFrZUVsZW1lbnQoJ2RpdicsICcnLCB7Y2xhc3NOYW1lOiAnbm90aWZpZXInfSk7XG4gICAgdGhpcy5ub3RpZmllckhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnLCB0aGlzLm5vdGlmaWVyLCB7Y2xhc3NOYW1lOiAnbm90aWZpZXItaG9sZGVyJ30pO1xuICAgIHRoaXMucXVhbnRPdmVybGF5ID0gbWFrZUVsZW1lbnQoXG4gICAgICAgICdjYW52YXMnLCBudWxsLCBcbiAgICAgICAge3dpZHRoOiAnNTAnLCBoZWlnaHQ6IFwiNTZcIixcbiAgICAgICAgIGNsYXNzTmFtZTogJ3F1YW50LW92ZXJsYXknfSk7XG5cbiAgICB0aGlzLnJlbW92ZUJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXRpbWVzJ30pO1xuICAgIHRoaXMuYnVtcEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLXBsdXMtY2lyY2xlJ30pO1xuICAgIHRoaXMubG9hZGVyQnV0dG9uID0gYnJvd3Nlci5tYWtlTG9hZGVyKDE2KTtcbiAgICB0aGlzLmxvYWRlckJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuaW5mb0VsZW1lbnQgPSBtYWtlRWxlbWVudCgnZGl2JywgdGhpcy5kYXNTb3VyY2UuZGVzYywge2NsYXNzTmFtZTogJ3RyYWNrLWxhYmVsLWluZm8nfSk7XG4gICAgdGhpcy5uYW1lQnV0dG9uID0gbWFrZUVsZW1lbnQoJ2RpdicsIFtdLCB7Y2xhc3NOYW1lOiAndGllci10YWInfSk7XG4gICAgdGhpcy5uYW1lQnV0dG9uLmFwcGVuZENoaWxkKHRoaXMucmVtb3ZlQnV0dG9uKTtcbiAgICBpZiAoc291cmNlLnBlbm5hbnQpIHtcbiAgICAgICAgdGhpcy5uYW1lQnV0dG9uLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdpbWcnLCBudWxsLCB7c3JjOiBzb3VyY2UucGVubmFudCwgd2lkdGg6ICcxNicsIGhlaWdodDogJzE2J30pKVxuICAgIH0gZWxzZSBpZiAoc291cmNlLm1hcHBpbmcpIHtcbiAgICAgICAgdmFyIHZlcnNpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5icm93c2VyLmNoYWluc1tzb3VyY2UubWFwcGluZ10pXG4gICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5icm93c2VyLmNoYWluc1tzb3VyY2UubWFwcGluZ10uY29vcmRzLnZlcnNpb247XG4gICAgICAgIGlmICh2ZXJzaW9uKVxuICAgICAgICAgICAgdGhpcy5uYW1lQnV0dG9uLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdzcGFuJywgJycgKyB2ZXJzaW9uLCBudWxsLCB7Zm9udFNpemU6ICc4cHQnLCBiYWNrZ3JvdW5kOiAnYmxhY2snLCBjb2xvcjogJ3doaXRlJywgcGFkZGluZ0xlZnQ6ICczcHgnLCBwYWRkaW5nUmlnaHQ6ICczcHgnLCBwYWRkaW5nVG9wOiAnMXB4JywgcGFkZGluZ0JvdHRvbTogJzFweCcsIG1hcmdpbkxlZnQ6ICcycHgnLCBib3JkZXJSYWRpdXM6ICcxMHB4J30pKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lRWxlbWVudCA9IG1ha2VFbGVtZW50KCdzcGFuJywgc291cmNlLm5hbWUpO1xuICAgIHRoaXMubmFtZUJ1dHRvbi5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnc3BhbicsIFt0aGlzLm5hbWVFbGVtZW50LCB0aGlzLmluZm9FbGVtZW50XSwge2NsYXNzTmFtZTogJ3RyYWNrLW5hbWUtaG9sZGVyJ30pKTtcbiAgICB0aGlzLm5hbWVCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy5idW1wQnV0dG9uKTtcbiAgICB0aGlzLm5hbWVCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy5sb2FkZXJCdXR0b24pO1xuXG4gICAgdGhpcy5sYWJlbCA9IG1ha2VFbGVtZW50KCdzcGFuJyxcbiAgICAgICBbdGhpcy5uYW1lQnV0dG9uXSxcbiAgICAgICB7Y2xhc3NOYW1lOiAnYnRuLWdyb3VwIHRyYWNrLWxhYmVsJ30pO1xuXG4gICAgdmFyIGNsYXNzZXMgPSAndGllcicgKyAoc291cmNlLmNsYXNzTmFtZSA/ICcgJyArIHNvdXJjZS5jbGFzc05hbWUgOiAnJyk7XG4gICAgdGhpcy5yb3cgPSBtYWtlRWxlbWVudCgnZGl2JywgW3RoaXMudmlld3BvcnRIb2xkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3ZlcmxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWFudE92ZXJsYXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtjbGFzc05hbWU6IGNsYXNzZXN9KTtcblxuICAgIGlmICghYmFja2dyb3VuZCkge1xuICAgICAgICB0aGlzLnJvdy5zdHlsZS5iYWNrZ3JvdW5kID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGlmICghYnJvd3Nlci5ub0RlZmF1bHRMYWJlbHMpXG4gICAgICAgIHRoaXMucm93LmFwcGVuZENoaWxkKHRoaXMubGFiZWwpO1xuICAgIHRoaXMucm93LmFwcGVuZENoaWxkKHRoaXMubm90aWZpZXJIb2xkZXIpO1xuICAgIFxuICAgIHRoaXMubGF5b3V0SGVpZ2h0ID0gMjU7XG4gICAgdGhpcy5idW1wZWQgPSB0cnVlO1xuICAgIHRoaXMuc3R5bGVJZFNlZWQgPSAwO1xuICAgIGlmIChzb3VyY2UucXVhbnRMZWFwVGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMucXVhbnRMZWFwVGhyZXNob2xkID0gc291cmNlLnF1YW50TGVhcFRocmVzaG9sZDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMpIHtcbiAgICAgICAgdGhpcy5idW1wZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXRXYXNEb25lID0gZmFsc2U7XG5cbiAgICBpZiAoc291cmNlLmZlYXR1cmVJbmZvUGx1Z2luKSB7XG4gICAgICAgIHRoaXMuYWRkRmVhdHVyZUluZm9QbHVnaW4oc291cmNlLmZlYXR1cmVJbmZvUGx1Z2luKTtcbiAgICB9XG5cbiAgICB0aGlzLmluaXRTb3VyY2VzKCk7XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIGlmICh0aGlzLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5mZWF0dXJlU291cmNlLmdldERlZmF1bHRGSVBzICYmICFzb3VyY2Uubm9Tb3VyY2VGZWF0dXJlSW5mbykge1xuICAgICAgICB0aGlzLmZlYXR1cmVTb3VyY2UuZ2V0RGVmYXVsdEZJUHMoZnVuY3Rpb24oZmlwKSB7XG4gICAgICAgICAgICBpZiAoZmlwKVxuICAgICAgICAgICAgICAgIHRoaXNCLmFkZEZlYXR1cmVJbmZvUGx1Z2luKGZpcCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZlYXR1cmVTb3VyY2UgJiYgdGhpcy5mZWF0dXJlU291cmNlLmFkZFJlYWRpbmVzc0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMucmVhZGluZXNzTGlzdGVuZXIgPSBmdW5jdGlvbihyZWFkeSkge1xuICAgICAgICAgICAgdGhpc0Iubm90aWZ5KHJlYWR5LCAtMSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmVhdHVyZVNvdXJjZS5hZGRSZWFkaW5lc3NMaXN0ZW5lcih0aGlzLnJlYWRpbmVzc0xpc3RlbmVyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5mZWF0dXJlU291cmNlICYmIHRoaXMuZmVhdHVyZVNvdXJjZS5hZGRBY3Rpdml0eUxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZpdHlMaXN0ZW5lciA9IGZ1bmN0aW9uKGJ1c3kpIHtcbiAgICAgICAgICAgIGlmIChidXN5ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXNCLmxvYWRlckJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNCLmxvYWRlckJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc0IuYnJvd3Nlci5waW5nQWN0aXZpdHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mZWF0dXJlU291cmNlLmFkZEFjdGl2aXR5TGlzdGVuZXIodGhpcy5hY3Rpdml0eUxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuZmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnMgPSBbXTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmZlYXR1cmVTb3VyY2UucmVtb3ZlUmVhZGluZXNzTGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlU291cmNlLnJlbW92ZVJlYWRpbmVzc0xpc3RlbmVyKHRoaXMucmVhZGluZXNzTGlzdGVuZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5mZWF0dXJlU291cmNlLnJlbW92ZUFjdGl2aXR5TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlU291cmNlLnJlbW92ZUFjdGl2aXR5TGlzdGVuZXIodGhpcy5hY3Rpdml0eUxpc3RlbmVyKTtcbiAgICB9XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnNldEJhY2tncm91bmQgPSBmdW5jdGlvbihiKSB7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gYjtcbiAgICB0aGlzLnZpZXdwb3J0SG9sZGVyLnN0eWxlLmJhY2tncm91bmQgPSBiO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5hZGRGZWF0dXJlSW5mb1BsdWdpbiA9IGZ1bmN0aW9uKHApIHtcbiAgICBpZiAoIXRoaXMuZmVhdHVyZUluZm9QbHVnaW5zKSBcbiAgICAgICAgdGhpcy5mZWF0dXJlSW5mb1BsdWdpbnMgPSBbXTtcbiAgICB0aGlzLmZlYXR1cmVJbmZvUGx1Z2lucy5wdXNoKHApO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRpZXIgPSB0aGlzO1xuXG4gICAgaWYgKHRpZXIuZGFzU291cmNlLnN0eWxlKSB7XG4gICAgICAgIHRoaXMuc2V0U3R5bGVzaGVldCh7c3R5bGVzOiB0aWVyLmRhc1NvdXJjZS5zdHlsZX0pO1xuICAgICAgICB0aGlzLmJyb3dzZXIucmVmcmVzaFRpZXIodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGllci5zdGF0dXMgPSAnRmV0Y2hpbmcgc3R5bGVzaGVldCc7XG4gICAgICAgIHRpZXIuZmV0Y2hTdHlsZXNoZWV0KGZ1bmN0aW9uKHNzLCBlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgfHwgIXNzKSB7XG4gICAgICAgICAgICAgICAgdGllci5lcnJvciA9ICdObyBzdHlsZXNoZWV0JztcbiAgICAgICAgICAgICAgICB2YXIgc3MgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuICAgICAgICAgICAgICAgIHZhciBkZWZTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICAgICAgICAgIGRlZlN0eWxlLmdseXBoID0gJ0JPWCc7XG4gICAgICAgICAgICAgICAgZGVmU3R5bGUuQkdDT0xPUiA9ICdibHVlJztcbiAgICAgICAgICAgICAgICBkZWZTdHlsZS5GR0NPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgICAgICAgICBzcy5wdXNoU3R5bGUoe3R5cGU6ICdkZWZhdWx0J30sIG51bGwsIGRlZlN0eWxlKTtcbiAgICAgICAgICAgICAgICB0aWVyLnNldFN0eWxlc2hlZXQoc3MpO1xuICAgICAgICAgICAgICAgIHRpZXIuYnJvd3Nlci5yZWZyZXNoVGllcih0aWVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGllci5zZXRTdHlsZXNoZWV0KHNzKTtcbiAgICAgICAgICAgICAgICBpZiAoc3MuZ2VuZUhpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGllci5kYXNTb3VyY2UuY29sbGFwc2VTdXBlckdyb3VwcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRpZXIuYnVtcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRpZXIudXBkYXRlTGFiZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGllci5fdXBkYXRlRnJvbUNvbmZpZygpO1xuICAgICAgICAgICAgICAgIHRpZXIuYnJvd3Nlci5yZWZyZXNoVGllcih0aWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5zZXRTdHlsZXNoZWV0ID0gZnVuY3Rpb24oc3MpIHtcbiAgICB0aGlzLmJhc2VTdHlsZXNoZWV0ID0gc2hhbGxvd0NvcHkoc3MpO1xuICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCB0aGlzLmJhc2VTdHlsZXNoZWV0LnN0eWxlcy5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgdmFyIHNoID0gdGhpcy5iYXNlU3R5bGVzaGVldC5zdHlsZXNbc2ldID0gc2hhbGxvd0NvcHkodGhpcy5iYXNlU3R5bGVzaGVldC5zdHlsZXNbc2ldKTtcbiAgICAgICAgc2guX21ldGhvZFJFID0gc2guX2xhYmVsUkUgPSBzaC5fdHlwZVJFID0gbnVsbDtcbiAgICAgICAgc2guc3R5bGUgPSBzaGFsbG93Q29weShzaC5zdHlsZSk7XG4gICAgICAgIHNoLnN0eWxlLmlkID0gJ3N0eWxlJyArICgrK3RoaXMuc3R5bGVJZFNlZWQpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VTdHlsZXNoZWV0VmFsaWRpdHkgPSBiNjRfc2hhMShtaW5pSlNPTmlmeSh0aGlzLmJhc2VTdHlsZXNoZWV0KSk7XG4gICAgdGhpcy5fdXBkYXRlRnJvbUNvbmZpZygpO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZWF0dXJlU291cmNlO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5nZXREZXNpcmVkVHlwZXMgPSBmdW5jdGlvbihzY2FsZSkge1xuICAgIHZhciBzZnMgPSB0aGlzLmdldEFjdGl2ZVN0eWxlRmlsdGVycyhzY2FsZSk7XG4gICAgaWYgKHNmcylcbiAgICAgICAgcmV0dXJuIHNmcy50eXBlTGlzdCgpO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5nZXRBY3RpdmVTdHlsZUZpbHRlcnMgPSBmdW5jdGlvbihzY2FsZSkge1xuICAgIHZhciBzc1NjYWxlID0gdGhpcy5icm93c2VyLnpvb21Gb3JDdXJyZW50U2NhbGUoKTtcblxuICAgIGlmICh0aGlzLnN0eWxlc2hlZXQpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IG5ldyBTdHlsZUZpbHRlclNldCgpO1xuICAgICAgICB2YXIgc3MgPSB0aGlzLnN0eWxlc2hlZXQuc3R5bGVzO1xuICAgICAgICBmb3IgKHZhciBzaSA9IDA7IHNpIDwgc3MubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICB2YXIgc2ggPSBzc1tzaV07XG4gICAgICAgICAgICBpZiAoIXNoLnpvb20gfHwgc2guem9vbSA9PSBzc1NjYWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLmFkZChuZXcgU3R5bGVGaWx0ZXIoc2gudHlwZSwgc2gubWV0aG9kLCBzaC5sYWJlbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5uZWVkc1NlcXVlbmNlID0gZnVuY3Rpb24oc2NhbGUgKSB7XG4gICAgaWYgKHRoaXMuc2VxdWVuY2VTb3VyY2UgJiYgc2NhbGUgPCA1KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoKHRoaXMuZGFzU291cmNlLmJhbVVSSSB8fCB0aGlzLmRhc1NvdXJjZS5iYW1CbG9iIHx8IHRoaXMuZGFzU291cmNlLmJ3Z1VSSSB8fCB0aGlzLmRhc1NvdXJjZS5id2dCbG9iKVxuICAgICAgICAgICAgICAgICAmJiBzY2FsZSA8IDIwKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUudmlld0ZlYXR1cmVzID0gZnVuY3Rpb24oY2hyLCBjb3ZlcmFnZSwgc2NhbGUsIGZlYXR1cmVzLCBzZXF1ZW5jZSkge1xuICAgIHRoaXMuY3VycmVudEZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgICB0aGlzLm5vdGlmeUZlYXR1cmVzTG9hZGVkKCk7XG4gICAgXG4gICAgdGhpcy5rbm93bkNociA9IGNocjtcbiAgICB0aGlzLmtub3duQ292ZXJhZ2UgPSBjb3ZlcmFnZTtcblxuICAgIGlmICh0aGlzLnN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX25vdGlmaWVyVG9TdGF0dXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLmRyYXcoKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuY3VycmVudEZlYXR1cmVzO1xuICAgIHZhciBzZXEgPSB0aGlzLmN1cnJlbnRTZXF1ZW5jZTtcbiAgICBpZiAodGhpcy5zZXF1ZW5jZVNvdXJjZSkge1xuICAgICAgICBkcmF3U2VxVGllcih0aGlzLCBzZXEpOyBcbiAgICB9IGVsc2Uge1xuICAgICAgICBkcmF3RmVhdHVyZVRpZXIodGhpcyk7XG4gICAgfVxuICAgIHRoaXMucGFpbnQoKTtcbiAgICB0aGlzLm9yaWdpbkhheHggPSAwO1xuICAgIHRoaXMuYnJvd3Nlci5hcnJhbmdlVGllcnMoKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUuZmluZE5leHRGZWF0dXJlID0gZnVuY3Rpb24oY2hyLCBwb3MsIGRpciwgZmVkZ2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMucXVhbnRMZWFwVGhyZXNob2xkKSB7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYnJvd3Nlci52aWV3RW5kIC0gdGhpcy5icm93c2VyLnZpZXdTdGFydCArIDE7XG4gICAgICAgIHBvcyA9IChwb3MgKyAgKCh3aWR0aCAqIGRpcikgLyAyKSl8MFxuICAgICAgICB0aGlzLmZlYXR1cmVTb3VyY2UucXVhbnRGaW5kTmV4dEZlYXR1cmUoY2hyLCBwb3MsIGRpciwgdGhpcy5xdWFudExlYXBUaHJlc2hvbGQsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5rbm93bkNvdmVyYWdlICYmIHBvcyA+PSB0aGlzLmtub3duQ292ZXJhZ2UubWluKCkgJiYgcG9zIDw9IHRoaXMua25vd25Db3ZlcmFnZS5tYXgoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEZlYXR1cmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJlc3RGZWF0dXJlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBmaSA9IDA7IGZpIDwgdGhpcy5jdXJyZW50RmVhdHVyZXMubGVuZ3RoOyArK2ZpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmID0gdGhpcy5jdXJyZW50RmVhdHVyZXNbZmldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWYubWluIHx8ICFmLm1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGYucGFyZW50cyAmJiBmLnBhcmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWRnZSA9PSAxICYmIGYubWF4ID49IHBvcyAmJiBmLm1pbiA8IHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVzdEZlYXR1cmUgfHwgZi5taW4gPiBiZXN0RmVhdHVyZS5taW4gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGYubWluID09IGJlc3RGZWF0dXJlLm1pbiAmJiBmLm1heCA8IGJlc3RGZWF0dXJlLm1heCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZlYXR1cmUgPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZi5tYXggPCBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3RGZWF0dXJlIHx8IGYubWF4ID4gYmVzdEZlYXR1cmUubWF4IHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZi5tYXggPT0gYmVzdEZlYXR1cmUubWF4ICYmIGYubWluIDwgYmVzdEZlYXR1cmUubWluKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZi5taW4gPT0gYmVzdEZlYXR1cmUubW1pbiAmJiBiZXN0RmVhdHVyZS5tYXggPj0gcG9zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0RmVhdHVyZSA9IGY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWRnZSA9PSAxICYmIGYubWluIDw9IHBvcyAmJiBmLm1heCA+IHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYmVzdEZlYXR1cmUgfHwgZi5tYXggPCBiZXN0RmVhdHVyZS5tYXggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGYubWF4ID09IGJlc3RGZWF0dXJlLm1heCAmJiBmLm1pbiA+IGJlc3RGZWF0dXJlLm1pbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZlYXR1cmUgPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZi5taW4gPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJlc3RGZWF0dXJlIHx8IGYubWluIDwgYmVzdEZlYXR1cmUubWluIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmLm1pbiA9PSBiZXN0RmVhdHVyZS5taW4gJiYgZi5tYXggPiBiZXN0RmVhdHVyZS5tYXgpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmLm1heCA9PSBiZXN0RmVhdHVyZS5tYXggJiYgYmVzdEZlYXR1cmUubWluIDw9IHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZlYXR1cmUgPSBmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmVzdEZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGJlc3RGZWF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gdGhpcy5icm93c2VyLmtub3duU3BhY2UubWluO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuYnJvd3Nlci5rbm93blNwYWNlLm1heDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyeVNvdXJjZUZORihjaHIsIHBvcywgZGlyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS50cnlTb3VyY2VGTkYgPSBmdW5jdGlvbihjaHIsIHBvcywgZGlyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmZlYXR1cmVTb3VyY2UuZmluZE5leHRGZWF0dXJlKGNociwgcG9zLCBkaXIsIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlKVxuICAgICAgICAgICAgY2FsbGJhY2soZmVhdHVyZSk7XG5cbiAgICAgICAgdmFyIHNzID0gc2VsZi5icm93c2VyLmdldFNlcXVlbmNlU291cmNlKCk7XG4gICAgICAgIGlmICghc3MpIC8vIFdlJ3JlIHByb2JhYmx5IGluIHRyb3VibGUsIGJ1dCByZXR1cm4gYW55d2F5LlxuICAgICAgICAgICAgY2FsbGJhY2soZmVhdHVyZSlcblxuICAgICAgICBzcy5nZXRTZXFJbmZvKGZlYXR1cmUuc2VnbWVudCwgZnVuY3Rpb24oc2kpIHtcbiAgICAgICAgICAgIGlmIChzaSlcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhmZWF0dXJlKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZWxmLnRyeVNvdXJjZUZORihmZWF0dXJlLnNlZ21lbnQsIGRpciA+IDAgPyAxMDAwMDAwMDAwMCA6IDAsIGRpciwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuXG5EYXNUaWVyLnByb3RvdHlwZS51cGRhdGVMYWJlbCA9IGZ1bmN0aW9uKCkge1xuICAgdGhpcy5idW1wQnV0dG9uLmNsYXNzTmFtZSA9IHRoaXMuYnVtcGVkID8gJ2ZhIGZhLW1pbnVzLWNpcmNsZScgOiAnZmEgZmEtcGx1cy1jaXJjbGUnO1xuICAgaWYgKHRoaXMuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMpIHtcbiAgICAgICAgdGhpcy5idW1wQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ1bXBCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnVwZGF0ZUhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY3VycmVudEhlaWdodCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGF5b3V0SGVpZ2h0LCB0aGlzLmxhYmVsLmNsaWVudEhlaWdodCArIDIpLCB0aGlzLmJyb3dzZXIubWluVGllckhlaWdodCk7XG4gICAgdGhpcy5yb3cuc3R5bGUuaGVpZ2h0ID0gJycgKyB0aGlzLmN1cnJlbnRIZWlnaHQgKyAncHgnO1xuICAgIHRoaXMuYnJvd3Nlci51cGRhdGVIZWlnaHQoKTtcbiB9XG5cblxuRGFzVGllci5wcm90b3R5cGUuZHJhd092ZXJsYXkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IHRoaXM7XG4gICAgdmFyIGIgPSB0aGlzLmJyb3dzZXI7XG4gICAgdmFyIHJldGluYSA9IGIucmV0aW5hICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMTtcbiAgICBcbiAgICB0Lm92ZXJsYXkuaGVpZ2h0ID0gdC52aWV3cG9ydC5oZWlnaHQ7XG4gICAgdC5vdmVybGF5LndpZHRoID0gcmV0aW5hID8gYi5mZWF0dXJlUGFuZWxXaWR0aCAqIDIgOiBiLmZlYXR1cmVQYW5lbFdpZHRoO1xuXG4gICAgdmFyIGcgPSB0Lm92ZXJsYXkuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAocmV0aW5hKSB7XG4gICAgICAgIGcuc2NhbGUoMiwgMik7XG4gICAgfVxuICAgIFxuICAgIHZhciBvcmlnaW4gPSBiLnZpZXdTdGFydDtcbiAgICB2YXIgdmlzU3RhcnQgPSBiLnZpZXdTdGFydDtcbiAgICB2YXIgdmlzRW5kID0gYi52aWV3RW5kO1xuXG4gICAgaWYgKHRoaXMub3ZlcmxheUxhYmVsQ2FudmFzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSAoKHRoaXMuZ2x5cGhDYWNoZU9yaWdpbiAtIHRoaXMuYnJvd3Nlci52aWV3U3RhcnQpKnRoaXMuYnJvd3Nlci5zY2FsZSk7XG4gICAgICAgIGcuc2F2ZSgpO1xuICAgICAgICBnLnRyYW5zbGF0ZShvZmZzZXQsIDApO1xuICAgICAgICB2YXIgZHJhd1N0YXJ0ID0gLW9mZnNldCArIDI7XG4gICAgICAgIGlmICh0aGlzLmRhc1NvdXJjZS50aWVyR3JvdXApXG4gICAgICAgICAgICBkcmF3U3RhcnQgKz0gMTU7XG4gICAgICAgIHRoaXMub3ZlcmxheUxhYmVsQ2FudmFzLmRyYXcoZywgZHJhd1N0YXJ0LCBiLmZlYXR1cmVQYW5lbFdpZHRoLW9mZnNldCk7XG4gICAgICAgIGcucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGhpID0gMDsgaGkgPCBiLmhpZ2hsaWdodHMubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgIHZhciBoID0gYi5oaWdobGlnaHRzW2hpXTtcbiAgICAgICAgaWYgKCgoaC5jaHIgPT09IGIuY2hyKSB8fCAoaC5jaHIgPT09ICgnY2hyJyArIGIuY2hyKSkpICYmIGgubWluIDwgdmlzRW5kICYmIGgubWF4ID4gdmlzU3RhcnQpIHtcbiAgICAgICAgICAgIGcuZ2xvYmFsQWxwaGEgPSBiLmRlZmF1bHRIaWdobGlnaHRBbHBoYTtcbiAgICAgICAgICAgIGcuZmlsbFN0eWxlID0gYi5kZWZhdWx0SGlnaGxpZ2h0RmlsbDtcbiAgICAgICAgICAgIGcuZmlsbFJlY3QoKGgubWluIC0gb3JpZ2luKSAqIGIuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgIChoLm1heCAtIGgubWluKSAqIGIuc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgIHQub3ZlcmxheS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgfSBcblxuICAgIC8vIHQub29yaWdpbiA9IGIudmlld1N0YXJ0O1xuICAgIHQub3ZlcmxheS5zdHlsZS53aWR0aCA9IGIuZmVhdHVyZVBhbmVsV2lkdGg7XG4gICAgdC5vdmVybGF5LnN0eWxlLmhlaWdodCA9IHQudmlld3BvcnQuc3R5bGUuaGVpZ2h0O1xuICAgIHQub3ZlcmxheS5zdHlsZS5sZWZ0ID0gJzBweCc7XG59XG5cblxuRGFzVGllci5wcm90b3R5cGUudXBkYXRlU3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuX25vdGlmaWVyVG9TdGF0dXMoKTtcbiAgICAgICAgdmFyIHNkID0gc291cmNlRGF0YVVSSSh0aGlzLmRhc1NvdXJjZSk7XG4gICAgICAgIGlmICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonICYmIHNvdXJjZURhdGFVUkkodGhpcy5kYXNTb3VyY2UpLmluZGV4T2YoJ2h0dHA6JykgPT0gMCAmJiAhdGhpcy5jaGVja2VkSFRUUCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja2VkSFRUUCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJyb3dzZXIuY2FuRmV0Y2hQbGFpbkhUVFAoKS50aGVuKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGNhbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi53YXJuSFRUUCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9ub3RpZmllclRvU3RhdHVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IG51bGxcbiAgICAgICAgICAgIHRoaXMuX25vdGlmaWVyVG9TdGF0dXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuRGFzVGllci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24obWVzc2FnZSwgdGltZW91dCkge1xuICAgIGlmICh0eXBlb2YodGltZW91dCkgIT09ICdudW1iZXInKVxuICAgICAgICB0aW1lb3V0ID0gMjAwMDtcblxuICAgIGlmICh0aGlzLm5vdGlmaWVyRmFkZVRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm90aWZpZXJGYWRlVGltZW91dCk7XG4gICAgICAgIHRoaXMubm90aWZpZXJGYWRlVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fbm90aWZpZXJPbihtZXNzYWdlKTtcbiAgICAgICAgaWYgKHRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5ub3RpZmllckZhZGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzQi5fbm90aWZpZXJUb1N0YXR1cygpO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ub3RpZmllclRvU3RhdHVzKCk7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5fbm90aWZpZXJPbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHdhcm5IVFRQKSB7XG4gICAgcmVtb3ZlQ2hpbGRyZW4odGhpcy5ub3RpZmllcik7XG4gICAgaWYgKHdhcm5IVFRQKSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBtYWtlRWxlbWVudChcbiAgICAgICAgICAgICAgICAnc3BhbicsXG4gICAgICAgICAgICAgICAgW21ha2VFbGVtZW50KCdhJywgJ1tIVFRQIFdhcm5pbmddICcsIHtocmVmOiB0aGlzLmJyb3dzZXIuaHR0cFdhcm5pbmdVUkwsIHRhcmdldDogXCJfYmxhbmtcIn0pLFxuICAgICAgICAgICAgICAgICBtZXNzYWdlXVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmaWVyLnN0eWxlLm9wYWNpdHkgPSAwLjg7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLl9ub3RpZmllck9mZiA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubm90aWZpZXIuc3R5bGUub3BhY2l0eSA9IDA7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLl9ub3RpZmllclRvU3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuX25vdGlmaWVyT24odGhpcy5zdGF0dXMsIHRoaXMud2FybkhUVFApXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbm90aWZpZXJPZmYoKTtcbiAgICB9XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnNldENvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIHRoaXMuX3VwZGF0ZUZyb21Db25maWcoKTtcbiAgICB0aGlzLm5vdGlmeVRpZXJMaXN0ZW5lcnMoKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUubWVyZ2VTdHlsZXNoZWV0ID0gZnVuY3Rpb24obmV3U3R5bGUpIHtcbiAgICB0aGlzLm1lcmdlQ29uZmlnKHtcbiAgICAgICAgc3R5bGVzaGVldDogbmV3U3R5bGUsIFxuICAgICAgICBzdHlsZXNoZWV0VmFsaWRpdHk6IHRoaXMuYmFzZVN0eWxlc2hlZXRWYWxpZGl0eVxuICAgIH0pO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5tZXJnZUNvbmZpZyA9IGZ1bmN0aW9uKG5ld0NvbmZpZykge1xuICAgIGZvciAodmFyIGsgaW4gbmV3Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnW2tdID0gbmV3Q29uZmlnW2tdO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVGcm9tQ29uZmlnKCk7XG4gICAgdGhpcy5ub3RpZnlUaWVyTGlzdGVuZXJzKCk7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLl91cGRhdGVGcm9tQ29uZmlnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5lZWRzUmVmcmVzaCA9IGZhbHNlO1xuICAgIHZhciBuZWVkc1Jlb3JkZXIgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWcubmFtZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHRoaXMubmFtZUVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5uYW1lRWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMuZGFzU291cmNlLm5hbWU7XG5cbiAgICB2YXIgd2FudGVkSGVpZ2h0ID0gdGhpcy5jb25maWcuaGVpZ2h0IHx8IHRoaXMuZGFzU291cmNlLmZvcmNlSGVpZ2h0O1xuICAgIGlmICh3YW50ZWRIZWlnaHQgIT0gdGhpcy5mb3JjZUhlaWdodCkge1xuICAgICAgICB0aGlzLmZvcmNlSGVpZ2h0ID0gd2FudGVkSGVpZ2h0O1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZvcmNlTWluRHluYW1pYyAhPSB0aGlzLmNvbmZpZy5mb3JjZU1pbkR5bmFtaWMpIHtcbiAgICAgICAgdGhpcy5mb3JjZU1pbkR5bmFtaWMgPSB0aGlzLmNvbmZpZy5mb3JjZU1pbkR5bmFtaWM7XG4gICAgICAgIG5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGZvcmNlTWluID0gdGhpcy5jb25maWcuZm9yY2VNaW4gIT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcuZm9yY2VNaW4gOiB0aGlzLmRhc1NvdXJjZS5mb3JjZU1pbjtcbiAgICBpZiAodGhpcy5mb3JjZU1pbiAhPSBmb3JjZU1pbikge1xuICAgICAgICB0aGlzLmZvcmNlTWluID0gZm9yY2VNaW47XG4gICAgICAgIG5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZm9yY2VNYXhEeW5hbWljICE9IHRoaXMuY29uZmlnLmZvcmNlTWF4RHluYW1pYykge1xuICAgICAgICB0aGlzLmZvcmNlTWF4RHluYW1pYyA9IHRoaXMuY29uZmlnLmZvcmNlTWF4RHluYW1pYztcbiAgICAgICAgbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGZvcmNlTWF4ID0gdGhpcy5jb25maWcuZm9yY2VNYXggIT0gdW5kZWZpbmVkID8gdGhpcy5jb25maWcuZm9yY2VNYXggOiB0aGlzLmRhc1NvdXJjZS5mb3JjZU1heDtcbiAgICBpZiAodGhpcy5mb3JjZU1heCAhPSBmb3JjZU1heCkge1xuICAgICAgICB0aGlzLmZvcmNlTWF4ID0gZm9yY2VNYXg7XG4gICAgICAgIG5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHF1YW50TGVhcFRocmVzaG9sZCA9IG51bGw7XG4gICAgaWYgKHRoaXMuY29uZmlnLnF1YW50TGVhcFRocmVzaG9sZCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBxdWFudExlYXBUaHJlc2hvbGQgPSB0aGlzLmNvbmZpZy5xdWFudExlYXBUaHJlc2hvbGQ7XG4gICAgZWxzZSBpZiAodGhpcy5kYXNTb3VyY2UucXVhbnRMZWFwVGhyZXNob2xkICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHF1YW50TGVhcFRocmVzaG9sZCA9IHRoaXMuZGFzU291cmNlLnF1YW50TGVhcFRocmVzaG9sZDtcbiAgICBpZiAocXVhbnRMZWFwVGhyZXNob2xkICE9IHRoaXMucXVhbnRMZWFwVGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMucXVhbnRMZWFwVGhyZXNob2xkID0gcXVhbnRMZWFwVGhyZXNob2xkO1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBQb3NzaWJsZSBGSVhNRSAtLSBhcmUgdGhlcmUgY2FzZXMgd2hlcmUgc3R5bGUgSURzIG5lZWQgdG8gYmUgcmVhc3NpZ25lZD9cbiAgICB2YXIgc3R5bGVzaGVldCA9IG51bGw7XG4gICAgaWYgKHRoaXMuY29uZmlnLnN0eWxlc2hlZXRWYWxpZGl0eSA9PSB0aGlzLmJhc2VTdHlsZXNoZWV0VmFsaWRpdHkpXG4gICAgICAgIHN0eWxlc2hlZXQgPSB0aGlzLmNvbmZpZy5zdHlsZXNoZWV0O1xuICAgIHN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0IHx8IHRoaXMuYmFzZVN0eWxlc2hlZXQ7XG4gICAgaWYgKHRoaXMuc3R5bGVzaGVldCAhPT0gc3R5bGVzaGVldCkge1xuICAgICAgICB0aGlzLnN0eWxlc2hlZXQgPSBzdHlsZXNoZWV0O1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciB3YW50ZWRQaW5uZWQgPSB0aGlzLmNvbmZpZy5waW5uZWQgIT09IHVuZGVmaW5lZCA/IHRoaXMuY29uZmlnLnBpbm5lZCA6IHRoaXMuZGFzU291cmNlLnBpbm5lZDtcbiAgICBpZiAod2FudGVkUGlubmVkICE9PSB0aGlzLnBpbm5lZCkge1xuICAgICAgICB0aGlzLnBpbm5lZCA9IHdhbnRlZFBpbm5lZDtcbiAgICAgICAgbmVlZHNSZW9yZGVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgd2FudGVkU3VidGllck1heCA9ICh0eXBlb2YodGhpcy5jb25maWcuc3VidGllck1heCA9PT0gJ251bWJlcicpID8gXG4gICAgICAgIHRoaXMuY29uZmlnLnN1YnRpZXJNYXggOiB0aGlzLmRhc1NvdXJjZS5zdWJ0aWVyTWF4IHx8IHRoaXMuYnJvd3Nlci5kZWZhdWx0U3VidGllck1heCk7XG4gICAgaWYgKHdhbnRlZFN1YnRpZXJNYXggIT0gdGhpcy5zdWJ0aWVyTWF4KSB7XG4gICAgICAgIHRoaXMuc3VidGllck1heCA9IHdhbnRlZFN1YnRpZXJNYXg7XG4gICAgICAgIG5lZWRzUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHdhbnRlZEJ1bXBlZDtcbiAgICBpZiAodGhpcy5jb25maWcuYnVtcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FudGVkQnVtcGVkID0gdGhpcy5jb25maWcuYnVtcGVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kYXNTb3VyY2UuYnVtcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2FudGVkQnVtcGVkID0gdGhpcy5kYXNTb3VyY2UuYnVtcGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHdhbnRlZEJ1bXBlZCA9IHRoaXMuZGFzU291cmNlLmNvbGxhcHNlU3VwZXJHcm91cHMgPyBmYWxzZSA6IHRydWU7XG4gICAgfVxuICAgIGlmICh3YW50ZWRCdW1wZWQgIT09IHRoaXMuYnVtcGVkKSB7XG4gICAgICAgIHRoaXMuYnVtcGVkID0gd2FudGVkQnVtcGVkO1xuICAgICAgICBuZWVkc1JlZnJlc2ggPSB0cnVlO1xuICAgICAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVmcmVzaClcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlZHJhdygpO1xuXG4gICAgaWYgKG5lZWRzUmVvcmRlcilcbiAgICAgICAgdGhpcy5icm93c2VyLnJlb3JkZXJUaWVycygpO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5zY2hlZHVsZVJlZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50RmVhdHVyZXMpXG4gICAgICAgIHJldHVybjtcbiAgICBcbiAgICB2YXIgdGllciA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMucmVkcmF3VGltZW91dCkge1xuICAgICAgICB0aGlzLnJlZHJhd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGllci5kcmF3KCk7XG4gICAgICAgICAgICB0aWVyLnJlZHJhd1RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCAxMCk7XG4gICAgfVxufVxuRGFzVGllci5wcm90b3R5cGUuY2xlYXJUaWVyTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMubGlzdGVuZXJzID0gW107XG59XG5cblxuRGFzVGllci5wcm90b3R5cGUuYWRkVGllckxpc3RlbmVyID0gZnVuY3Rpb24obCkge1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobCk7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLnJlbW92ZVRpZXJMaXN0ZW5lciA9IGZ1bmN0aW9uKGwpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMubGlzdGVuZXJzLCBsKTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5ub3RpZnlUaWVyTGlzdGVuZXJzID0gZnVuY3Rpb24oY2hhbmdlKSB7XG4gICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbbGldKGNoYW5nZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnJvd3Nlci5ub3RpZnlUaWVyKCk7XG59XG5cbkRhc1RpZXIucHJvdG90eXBlLmNsZWFyRmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5mZWF0dXJlc0xvYWRlZExpc3RlbmVycyA9IFtdO1xufVxuXG5EYXNUaWVyLnByb3RvdHlwZS5hZGRGZWF0dXJlc0xvYWRlZExpc3RlbmVyID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIHRoaXMuZmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnMucHVzaChoYW5kbGVyKTtcbn1cblxuRGFzVGllci5wcm90b3R5cGUucmVtb3ZlRmVhdHVyZXNMb2FkZWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICB2YXIgaWR4ID0gYXJyYXlJbmRleE9mKHRoaXMuZmVhdHVyZXNMb2FkZWRMaXN0ZW5lcnMsIGhhbmRsZXIpO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICB0aGlzLmZlYXR1cmVzTG9hZGVkTGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cbn1cblxuXG5EYXNUaWVyLnByb3RvdHlwZS5ub3RpZnlGZWF0dXJlc0xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCB0aGlzLmZlYXR1cmVzTG9hZGVkTGlzdGVuZXJzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlc0xvYWRlZExpc3RlbmVyc1tsaV0uY2FsbCh0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgRGFzVGllcjogRGFzVGllclxuICAgIH07XG5cbiAgICAvLyBJbXBvcnRlZCBmb3Igc2lkZSBlZmZlY3RzXG4gICAgdmFyIGZkID0gcmVxdWlyZSgnLi9mZWF0dXJlLWRyYXcnKTtcbiAgICB2YXIgZHJhd0ZlYXR1cmVUaWVyID0gZmQuZHJhd0ZlYXR1cmVUaWVyO1xuICAgIHZhciBzZCA9IHJlcXVpcmUoJy4vc2VxdWVuY2UtZHJhdycpO1xuICAgIHZhciBkcmF3U2VxVGllciA9IHNkLmRyYXdTZXFUaWVyO1xuICAgIC8vIHJlcXVpcmUoJy4vc291cmNlYWRhcHRlcnMnKTsgIC8qIERvbmUgaW4gY2Jyb3dzZXIgaW5zdGVhZCAqL1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIHRyYWNrLWFkZGVyLmpzXG4vL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaWYgKHR5cGVvZihyZXF1aXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgYnJvd3NlciA9IHJlcXVpcmUoJy4vY2Jyb3dzZXInKTtcbiAgICB2YXIgQnJvd3NlciA9IGJyb3dzZXIuQnJvd3NlcjtcblxuICAgIHZhciBzYyA9IHJlcXVpcmUoJy4vc291cmNlY29tcGFyZScpO1xuICAgIHZhciBzb3VyY2VzQXJlRXF1YWwgPSBzYy5zb3VyY2VzQXJlRXF1YWw7XG5cbiAgICB2YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG4gICAgdmFyIG1ha2VFbGVtZW50ID0gdXRpbHMubWFrZUVsZW1lbnQ7XG4gICAgdmFyIHJlbW92ZUNoaWxkcmVuID0gdXRpbHMucmVtb3ZlQ2hpbGRyZW47XG4gICAgdmFyIE9ic2VydmVkID0gdXRpbHMuT2JzZXJ2ZWQ7XG5cbiAgICB2YXIgdGh1YiA9IHJlcXVpcmUoJy4vdGh1YicpO1xuICAgIHZhciBUSFVCX0NPTVBBUkUgPSB0aHViLlRIVUJfQ09NUEFSRTtcbiAgICB2YXIgY29ubmVjdFRyYWNrSHViID0gdGh1Yi5jb25uZWN0VHJhY2tIdWI7XG5cbiAgICB2YXIgZG9tdWkgPSByZXF1aXJlKCcuL2RvbXVpJyk7XG4gICAgdmFyIG1ha2VUcmVlVGFibGVTZWN0aW9uID0gZG9tdWkubWFrZVRyZWVUYWJsZVNlY3Rpb247XG5cbiAgICB2YXIgcHJvYmVSZXNvdXJjZSA9IHJlcXVpcmUoJy4vcHJvYmUnKS5wcm9iZVJlc291cmNlO1xuXG5cbiAgICAvLyBNb3N0IG9mIHRoaXMgY291bGQgZGlzYXBwZWFyIGlmIHdlIGxlYXZlIGFsbCBwcm9iaW5nIHRvIHRoZSBwcm9iZSBtb2R1bGUuLi5cbiAgICB2YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbiAgICB2YXIgVVJMRmV0Y2hhYmxlID0gYmluLlVSTEZldGNoYWJsZTtcbiAgICB2YXIgQmxvYkZldGNoYWJsZSA9IGJpbi5CbG9iRmV0Y2hhYmxlO1xuICAgIHZhciByZWFkSW50ID0gYmluLnJlYWRJbnQ7XG5cbiAgICB2YXIgbGgzdXRpbHMgPSByZXF1aXJlKCcuL2xoM3V0aWxzJyk7XG4gICAgdmFyIHVuYmd6ZiA9IGxoM3V0aWxzLnVuYmd6ZjtcblxuICAgIHZhciBiYW0gPSByZXF1aXJlKCcuL2JhbScpO1xuICAgIHZhciBCQU1fTUFHSUMgPSBiYW0uQkFNX01BR0lDO1xuICAgIHZhciBCQUlfTUFHSUMgPSBiYW0uQkFJX01BR0lDO1xuXG4gICAgdmFyIHRiaSA9IHJlcXVpcmUoJy4vdGFiaXgnKTtcbiAgICB2YXIgVEFCSVhfTUFHSUMgPSB0YmkuVEFCSVhfTUFHSUM7XG5cbiAgICB2YXIgZGFzID0gcmVxdWlyZSgnLi9kYXMnKTtcbiAgICB2YXIgREFTU291cmNlID0gZGFzLkRBU1NvdXJjZTtcbiAgICB2YXIgREFTU2VnbWVudCA9IGRhcy5EQVNTZWdtZW50O1xuICAgIHZhciBEQVNSZWdpc3RyeSA9IGRhcy5EQVNSZWdpc3RyeTtcbiAgICB2YXIgY29vcmRzTWF0Y2ggPSBkYXMuY29vcmRzTWF0Y2g7XG5cbiAgICB2YXIgRW5jb2RlRmV0Y2hhYmxlID0gcmVxdWlyZSgnLi9lbmNvZGUnKS5FbmNvZGVGZXRjaGFibGU7XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLmN1cnJlbnRseUFjdGl2ZSA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0aGlzLnRpZXJzLmxlbmd0aDsgKyt0aSkge1xuICAgICAgICBpZiAoc291cmNlc0FyZUVxdWFsKHRoaXMudGllcnNbdGldLmRhc1NvdXJjZSwgc291cmNlKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpZXJzW3RpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5Ccm93c2VyLnByb3RvdHlwZS5tYWtlQnV0dG9uID0gZnVuY3Rpb24obmFtZSwgdG9vbHRpcCkge1xuICAgIHZhciByZWdCdXR0b24gPSBtYWtlRWxlbWVudCgnYScsIG5hbWUsIHtocmVmOiAnIyd9KTtcbiAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICB0aGlzLm1ha2VUb29sdGlwKHJlZ0J1dHRvbiwgdG9vbHRpcCk7XG4gICAgfVxuICAgIHJldHVybiBtYWtlRWxlbWVudCgnbGknLCByZWdCdXR0b24pO1xufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUJ1dHRvbihhZGRNb2RlQnV0dG9ucywgd2hpY2gpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFkZE1vZGVCdXR0b25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBiID0gYWRkTW9kZUJ1dHRvbnNbaV07XG4gICAgICAgIGlmIChiID09PSB3aGljaCkge1xuICAgICAgICAgICAgYi5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkJyb3dzZXIucHJvdG90eXBlLnNob3dUcmFja0FkZGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICBpZiAodGhpcy51aU1vZGUgPT09ICdhZGQnKSB7XG4gICAgICAgIHRoaXMuaGlkZVRvb2xQYW5lbCgpO1xuICAgICAgICB0aGlzLnNldFVpTW9kZSgnbm9uZScpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRoaXNCID0gdGhpcztcblxuICAgIHZhciBwb3B1cCA9IG1ha2VFbGVtZW50KCdkaXYnLCBudWxsLCB7Y2xhc3NOYW1lOiAnZGFsbGlhbmNlJ30gLCB7d2lkdGg6ICcxMDAlJywgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIGJveFNpemluZzogJ2JvcmRlci1ib3gnLCBNb3pCb3hTaXppbmc6ICdib3JkZXItYm94JywgdmVydGljYWxBbGlnbjogJ3RvcCcsIHBhZGRpbmdSaWdodDogJzE1cHgnfSk7XG5cbiAgICB2YXIgYWRkTW9kZUJ1dHRvbnMgPSBbXTtcbiAgICB2YXIgbWFrZVN0YWIsIG1ha2VTdGFiT2JzZXJ2ZXI7XG5cblxuICAgIGlmICghdGhpcy5ub1JlZ2lzdHJ5VGFicykge1xuICAgICAgICB2YXIgcmVnQnV0dG9uID0gdGhpcy5tYWtlQnV0dG9uKCdSZWdpc3RyeScsICdCcm93c2UgY29tcGF0aWJsZSBkYXRhc291cmNlcyBmcm9tIHRoZSBEQVMgcmVnaXN0cnknKTtcbiAgICAgICAgYWRkTW9kZUJ1dHRvbnMucHVzaChyZWdCdXR0b24pO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgbSBpbiB0aGlzLm1hcHBhYmxlU291cmNlcykge1xuICAgICAgICAgICAgdmFyIG1mICA9IGZ1bmN0aW9uKG1tKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcEJ1dHRvbiA9IHRoaXNCLm1ha2VCdXR0b24odGhpc0IuY2hhaW5zW21tXS5zcmNUYWcsICdCcm93c2UgZGF0YXNvdXJjZXMgbWFwcGVkIGZyb20gJyArIHRoaXNCLmNoYWluc1ttbV0uc3JjVGFnKTtcbiAgICAgICAgICAgICAgICBhZGRNb2RlQnV0dG9ucy5wdXNoKG1hcEJ1dHRvbik7XG4gICAgICAgICAgICAgICAgbWFwQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBtYXBCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICBtYWtlU3RhYih0aGlzQi5tYXBwYWJsZVNvdXJjZXNbbW1dLCBtbSk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfTsgbWYobSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBlZERlZmF1bHRzID0ge307XG4gICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHRoaXMuZGVmYXVsdFNvdXJjZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5kZWZhdWx0U291cmNlc1tzaV07XG4gICAgICAgIHZhciBnID0gcy5ncm91cCB8fCAnRGVmYXVsdHMnO1xuICAgICAgICBpZiAoZ3JvdXBlZERlZmF1bHRzW2ddKSB7XG4gICAgICAgICAgICBncm91cGVkRGVmYXVsdHNbZ10ucHVzaChzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwZWREZWZhdWx0c1tnXSA9IFtzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcblxuICAgIHZhciBtYWtlSHViQnV0dG9uID0gZnVuY3Rpb24odGRiKSB7XG4gICAgICAgIHZhciBodWIgPSB0ZGIuaHViO1xuICAgICAgICB2YXIgaHViTWVudUJ1dHRvbiA9IG1ha2VFbGVtZW50KCdpJywgbnVsbCwge2NsYXNzTmFtZTogJ2ZhIGZhLWxpc3QtYWx0J30sIHtjdXJzb3I6ICdjb250ZXh0LW1lbnUnfSk7XG4gICAgICAgIHZhciBsYWJlbCA9IGh1Yi5hbHRMYWJlbCB8fCBodWIuc2hvcnRMYWJlbCB8fCAnVW5rbm93bic7XG4gICAgICAgIGlmICh0ZGIubWFwcGluZylcbiAgICAgICAgICAgIGxhYmVsID0gbGFiZWwgKyAnICgnICsgdGRiLmdlbm9tZSArICcpJztcbiAgICAgICAgdmFyIGhiQ29udGVudCA9IG1ha2VFbGVtZW50KCdzcGFuJywgW2xhYmVsLCAnICcsIGh1Yk1lbnVCdXR0b25dKTtcbiAgICAgICAgdmFyIGh1YkJ1dHRvbiA9IHRoaXNCLm1ha2VCdXR0b24oaGJDb250ZW50LCBodWIubG9uZ0xhYmVsKTtcbiAgICAgICAgaHViQnV0dG9uLmh1YiA9IHRkYjtcbiAgICAgICAgYWRkTW9kZUJ1dHRvbnMucHVzaChodWJCdXR0b24pO1xuICAgICAgICBcbiAgICAgICAgaHViQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYWN0aXZhdGVCdXR0b24oYWRkTW9kZUJ1dHRvbnMsIGh1YkJ1dHRvbik7XG4gICAgICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgICAgIHZhciBsb2FkZXIgPSB0aGlzQi5tYWtlTG9hZGVyKDI0KTtcbiAgICAgICAgICAgIGxvYWRlci5zdHlsZS5tYXJnaW5MZWZ0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgbG9hZGVyLnN0eWxlLm1hcmdpblJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgbG9hZGVyLnN0eWxlLm1hcmdpblRvcCA9ICcxMDBweCc7XG4gICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdkaXYnLCBsb2FkZXIsIG51bGwsIHt0ZXh0QWxpZ246ICdjZW50ZXInfSkpO1xuXG4gICAgICAgICAgICByZWZyZXNoQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGNhbkJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgICAgICB0ZGIuZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBtYWtlSHViU3RhYih0cmFja3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBodWJNZW51QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmVtb3ZlSHViSXRlbSA9IG1ha2VFbGVtZW50KCdsaScsIG1ha2VFbGVtZW50KCdhJywgJ1JlbW92ZSBodWInKSk7XG4gICAgICAgICAgICB2YXIgYWxsT25JdGVtID0gbWFrZUVsZW1lbnQoJ2xpJywgIG1ha2VFbGVtZW50KCdhJywgJ0VuYWJsZSBhbGwnKSk7XG4gICAgICAgICAgICB2YXIgYWxsT2ZmSXRlbSA9IG1ha2VFbGVtZW50KCdsaScsICBtYWtlRWxlbWVudCgnYScsICdEaXNhYmxlIGFsbCcpKTtcbiAgICAgICAgICAgIHZhciBodWJNZW51ID0gbWFrZUVsZW1lbnQoJ3VsJywgW3JlbW92ZUh1Ykl0ZW0sIGFsbE9uSXRlbSwgYWxsT2ZmSXRlbV0sIHtjbGFzc05hbWU6ICdkcm9wZG93bi1tZW51J30sIHtkaXNwbGF5OiAnYmxvY2snfSk7XG5cbiAgICAgICAgICAgIHZhciBteCA9ICBldi5jbGllbnRYLCBteSA9IGV2LmNsaWVudFk7XG4gICAgICAgICAgICBteCArPSAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgbXkgKz0gIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG5cbiAgICAgICAgICAgIGh1Yk1lbnUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgaHViTWVudS5zdHlsZS50b3AgPSAnJyArIChteSsxMCkgKyAncHgnO1xuICAgICAgICAgICAgaHViTWVudS5zdHlsZS5sZWZ0ID0gJycgKyAobXgtMzApICsgJ3B4JztcbiAgICAgICAgICAgIHRoaXNCLmhQb3B1cEhvbGRlci5hcHBlbmRDaGlsZChodWJNZW51KTtcblxuICAgICAgICAgICAgdmFyIGNsaWNrQ2F0Y2hlciA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NjJyk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrQ2F0Y2hlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpc0IuaFBvcHVwSG9sZGVyLnJlbW92ZUNoaWxkKGh1Yk1lbnUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGlja0NhdGNoZXIsIHRydWUpO1xuXG4gICAgICAgICAgICByZW1vdmVIdWJJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpc0IuaHViT2JqZWN0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNCLmh1Yk9iamVjdHNbaGldLmFic1VSTCA9PSB0ZGIuYWJzVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5odWJPYmplY3RzLnNwbGljZShoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpc0IuaHVicy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhjID0gdGhpc0IuaHVic1toaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGMgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgaGMgPSB7dXJsOiBoY307XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYy51cmwgPT0gdGRiLmh1Yi51cmwgJiYgIWhjLmdlbm9tZSB8fCBoYy5nZW5vbWUgPT0gdGRiLmdlbm9tZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IuaHVicy5zcGxpY2UoaGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXNCLm5vdGlmeVRpZXIoKTtcblxuICAgICAgICAgICAgICAgIG1vZGVCdXR0b25Ib2xkZXIucmVtb3ZlQ2hpbGQoaHViQnV0dG9uKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0ZUJ1dHRvbihhZGRNb2RlQnV0dG9ucywgYWRkSHViQnV0dG9uKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hUb0h1YkNvbm5lY3RNb2RlKCk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG5cblxuICAgICAgICAgICAgYWxsT25JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICB0ZGIuZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0cmFja3MubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHMgPSB0cmFja3NbdGldLnRvRGFsbGlhbmNlU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXNCLmN1cnJlbnRseUFjdGl2ZShkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgICBhbGxPZmZJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICB0ZGIuZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHRpID0gMDsgdGkgPCB0cmFja3MubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHMgPSB0cmFja3NbdGldLnRvRGFsbGlhbmNlU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpc0IuY3VycmVudGx5QWN0aXZlKGRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnJlbW92ZVRpZXIoZHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gaHViQnV0dG9uO1xuICAgIH1cblxuICAgIHZhciBmaXJzdERlZkJ1dHRvbiA9IG51bGw7XG4gICAgdmFyIGZpcnN0RGVmU291cmNlcyA9IG51bGw7XG4gICAgZm9yICh2YXIgZyBpbiBncm91cGVkRGVmYXVsdHMpIHtcbiAgICAgICAgKGZ1bmN0aW9uKGcsIGRzKSB7XG4gICAgICAgICAgICB2YXIgZGVmQnV0dG9uID0gdGhpc0IubWFrZUJ1dHRvbihnLCAnQnJvd3NlIHRoZSBkZWZhdWx0IHNldCBvZiBkYXRhIGZvciB0aGlzIGJyb3dzZXInKTtcbiAgICAgICAgICAgIGRlZkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYWN0aXZhdGVCdXR0b24oYWRkTW9kZUJ1dHRvbnMsIGRlZkJ1dHRvbik7XG4gICAgICAgICAgICAgICAgbWFrZVN0YWIobmV3IE9ic2VydmVkKGRzKSk7XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICBhZGRNb2RlQnV0dG9ucy5wdXNoKGRlZkJ1dHRvbik7XG5cbiAgICAgICAgICAgIGlmICghZmlyc3REZWZCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBmaXJzdERlZkJ1dHRvbiA9IGRlZkJ1dHRvbjtcbiAgICAgICAgICAgICAgICBmaXJzdERlZlNvdXJjZXMgPSBkcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoZywgZ3JvdXBlZERlZmF1bHRzW2ddKTtcbiAgICB9ICAgXG4gICAgdmFyIGN1c3RCdXR0b24gPSB0aGlzLm1ha2VCdXR0b24oJ0RBUycsICdBZGQgYXJiaXRyYXJ5IERBUyBkYXRhJyk7XG4gICAgYWRkTW9kZUJ1dHRvbnMucHVzaChjdXN0QnV0dG9uKTtcbiAgICB2YXIgYmluQnV0dG9uID0gdGhpcy5tYWtlQnV0dG9uKCdCaW5hcnknLCAnQWRkIGRhdGEgaW4gYmlnd2lnIG9yIGJpZ2JlZCBmb3JtYXQnKTtcbiAgICBhZGRNb2RlQnV0dG9ucy5wdXNoKGJpbkJ1dHRvbik7XG5cblxuICAgIGZvciAodmFyIGhpID0gMDsgaGkgPCB0aGlzLmh1Yk9iamVjdHMubGVuZ3RoOyArK2hpKSB7XG4gICAgICAgIHZhciBodWIgPSB0aGlzLmh1Yk9iamVjdHNbaGldO1xuICAgICAgICBtYWtlSHViQnV0dG9uKGh1Yik7XG4gICAgfVxuXG4gICAgdmFyIGFkZEh1YkJ1dHRvbiA9IHRoaXMubWFrZUJ1dHRvbignKycsICdDb25uZWN0IHRvIGEgbmV3IHRyYWNrLWh1YicpO1xuICAgIGFkZE1vZGVCdXR0b25zLnB1c2goYWRkSHViQnV0dG9uKTtcblxuXG4gICAgdmFyIG1vZGVCdXR0b25Ib2xkZXIgPSBtYWtlRWxlbWVudCgndWwnLCBhZGRNb2RlQnV0dG9ucywge2NsYXNzTmFtZTogJ25hdiBuYXYtdGFicyd9LCB7bWFyZ2luQm90dG9tOiAnMHB4J30pO1xuICAgIHBvcHVwLmFwcGVuZENoaWxkKG1vZGVCdXR0b25Ib2xkZXIpO1xuICAgIFxuICAgIHZhciBjdXN0VVJMLCBjdXN0TmFtZSwgY3VzdENTLCBjdXN0UXVhbnQsIGN1c3RGaWxlLCBjdXN0VXNlciwgY3VzdFBhc3M7XG4gICAgdmFyIGN1c3RvbU1vZGUgPSBmYWxzZTtcbiAgICB2YXIgZGF0YVRvRmluYWxpemUgPSBudWxsO1xuXG4gICAgdmFyIGFzZm9ybSA9IG1ha2VFbGVtZW50KCdmb3JtJywgbnVsbCwge30sIHtkaXNwbGF5OiAnaW5saW5lLWJsb2NrJywgd2lkdGg6ICcxMDAlJ30pO1xuICAgIGFzZm9ybS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBkb0FkZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIHRydWUpOyBcbiAgICB2YXIgc3RhYkhvbGRlciA9IG1ha2VFbGVtZW50KCdkaXYnKTtcbiAgICBzdGFiSG9sZGVyLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICBzdGFiSG9sZGVyLnN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCc7XG4gICAgLy8gc3RhYkhvbGRlci5zdHlsZS5oZWlnaHQgPSAnNTAwcHgnO1xuICAgIGFzZm9ybS5hcHBlbmRDaGlsZChzdGFiSG9sZGVyKTtcblxuICAgIHZhciBfX21hcHBpbmc7XG4gICAgdmFyIF9fc291cmNlSG9sZGVyO1xuXG5cbiAgICBtYWtlU3RhYiA9IGZ1bmN0aW9uKG1zb3VyY2VzLCBtYXBwaW5nKSB7XG4gICAgICAgIHJlZnJlc2hCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYWRkQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGNhbkJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBpZiAoX19zb3VyY2VIb2xkZXIpIHtcbiAgICAgICAgICAgIF9fc291cmNlSG9sZGVyLnJlbW92ZUxpc3RlbmVyKG1ha2VTdGFiT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIF9fbWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgIF9fc291cmNlSG9sZGVyID0gbXNvdXJjZXM7XG4gICAgICAgIF9fc291cmNlSG9sZGVyLmFkZExpc3RlbmVyQW5kRmlyZShtYWtlU3RhYk9ic2VydmVyKTtcbiAgICB9XG5cbiAgICBtYWtlU3RhYk9ic2VydmVyID0gZnVuY3Rpb24obXNvdXJjZXMpIHtcbiAgICAgICAgY3VzdG9tTW9kZSA9IGZhbHNlO1xuICAgICAgICB2YXIgYnV0dG9ucyA9IFtdO1xuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgaWYgKCFtc291cmNlcykge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdEYWxsaWFuY2Ugd2FzIHVuYWJsZSB0byByZXRyaWV2ZSBkYXRhIHNvdXJjZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBEQVMgcmVnaXN0cnksIHBsZWFzZSB0cnkgYWdhaW4gbGF0ZXInKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzdGFiQm9keSA9IG1ha2VFbGVtZW50KCd0Ym9keScsIG51bGwsIHtjbGFzc05hbWU6ICd0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWNvbmRlbnNlZCd9LCB7d2lkdGg6ICcxMDAlJ30pO1xuICAgICAgICB2YXIgc3RhYiA9IG1ha2VFbGVtZW50KCd0YWJsZScsIHN0YWJCb2R5LCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSwge3dpZHRoOiAnMTAwJScsIHRhYmxlTGF5b3V0OiAnZml4ZWQnfSk7IFxuICAgICAgICB2YXIgaWR4ID0gMDtcblxuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBzb3VyY2VzLnB1c2gobXNvdXJjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzb3VyY2VzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEubmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKS5sb2NhbGVDb21wYXJlKGIubmFtZS50b0xvd2VyQ2FzZSgpLnRyaW0oKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgICAgICB2YXIgciA9IG1ha2VFbGVtZW50KCd0cicpO1xuXG4gICAgICAgICAgICB2YXIgYmQgPSBtYWtlRWxlbWVudCgndGQnLCBudWxsLCB7fSwge3dpZHRoOiAnMzBweCd9KTtcbiAgICAgICAgICAgIGJkLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UucHJvcHMgfHwgc291cmNlLnByb3BzLmNvcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IG1ha2VFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgIGIudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgICAgICAgICAgYi5kYWxsaWFuY2Vfc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgIGlmIChfX21hcHBpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5kYWxsaWFuY2VfbWFwcGluZyA9IF9fbWFwcGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYi5jaGVja2VkID0gdGhpc0IuY3VycmVudGx5QWN0aXZlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgYmQuYXBwZW5kQ2hpbGQoYik7XG4gICAgICAgICAgICAgICAgYnV0dG9ucy5wdXNoKGIpO1xuICAgICAgICAgICAgICAgIGIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2LnRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGV2LnRhcmdldC5kYWxsaWFuY2Vfc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnJlbW92ZVRpZXIoZXYudGFyZ2V0LmRhbGxpYW5jZV9zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJkLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCchJykpO1xuICAgICAgICAgICAgICAgIHRoaXNCLm1ha2VUb29sdGlwKGJkLCBtYWtlRWxlbWVudCgnc3BhbicsIFtcIlRoaXMgZGF0YSBzb3VyY2UgaXNuJ3QgYWNjZXNzaWJsZSBiZWNhdXNlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBcIiwgbWFrZUVsZW1lbnQoJ2EnLCBcIkNPUlNcIiwge2hyZWY6ICdodHRwOi8vd3d3LnczLm9yZy9UUi9jb3JzLyd9KSwgXCIuXCJdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByLmFwcGVuZENoaWxkKGJkKTtcbiAgICAgICAgICAgIHZhciBsZCA9IG1ha2VFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgbGQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc291cmNlLm5hbWUpKTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuZGVzYyAmJiBzb3VyY2UuZGVzYy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpc0IubWFrZVRvb2x0aXAobGQsIHNvdXJjZS5kZXNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIuYXBwZW5kQ2hpbGQobGQpO1xuICAgICAgICAgICAgc3RhYkJvZHkuYXBwZW5kQ2hpbGQocik7XG4gICAgICAgICAgICArK2lkeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZXRDaGVja3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGJpID0gMDsgYmkgPCBidXR0b25zLmxlbmd0aDsgKytiaSkge1xuICAgICAgICAgICAgICAgIHZhciBiID0gYnV0dG9uc1tiaV07XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzQi5jdXJyZW50bHlBY3RpdmUoYi5kYWxsaWFuY2Vfc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgICAgICBiLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGIuY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzZXRDaGVja3MoKTtcbiAgICAgICAgdGhpc0IuYWRkVGllckxpc3RlbmVyKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgIHNldENoZWNrcygpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKHN0YWIpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBtYWtlSHViU3RhYih0cmFja3MpIHtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgY2FuQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgY3VzdG9tTW9kZSA9IGZhbHNlO1xuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgXG4gICAgICAgIHZhciB0dGFiID0gbWFrZUVsZW1lbnQoJ2RpdicsIG51bGwsIHt9LCB7d2lkdGg6ICcxMDAlJ30pO1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHRyYWNrc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNvdXJjZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zaG9ydExhYmVsLnRvTG93ZXJDYXNlKCkudHJpbSgpLmxvY2FsZUNvbXBhcmUoYi5zaG9ydExhYmVsLnRvTG93ZXJDYXNlKCkudHJpbSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgICAgICB2YXIgdG9wcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IHNvdXJjZXMubGVuZ3RoOyArK3RpKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2sgPSBzb3VyY2VzW3RpXTtcbiAgICAgICAgICAgIGlmICh0cmFjay5jaGlsZHJlbiAmJiB0cmFjay5jaGlsZHJlbi5sZW5ndGggPiAwICYmIHRyYWNrLmNvbnRhaW5lciAhPSAnbXVsdGlXaWcnKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzLnB1c2godHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b3BzLnB1c2godHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzaG9ydExhYmVsOiAnT3RoZXJzJyxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogLTEwMDAwMDAwMCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogdG9wc30pO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JvdXBzLnNvcnQoVEhVQl9DT01QQVJFKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBidXR0b25zID0gW107XG4gICAgICAgIGZvciAodmFyIGdpID0gMDsgZ2kgPCBncm91cHMubGVuZ3RoOyArK2dpKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbZ2ldO1xuICAgICAgICAgICAgdmFyIGRnID0gZ3JvdXA7XG4gICAgICAgICAgICBpZiAoIWRnLmRpbWVuc2lvbnMgJiYgZGcuX3BhcmVudCAmJiBkZy5fcGFyZW50LmRpbWVuc2lvbnMpXG4gICAgICAgICAgICAgICAgZGcgPSBkZy5fcGFyZW50O1xuXG4gICAgICAgICAgICB2YXIgZHByb3BzID0ge31cbiAgICAgICAgICAgIGlmIChkZy5kaW1lbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR0b2tzID0gZGcuZGltZW5zaW9ucy5zcGxpdCgvKFxcdyspPShcXHcrKS8pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR0aSA9IDA7IGR0aSA8IGR0b2tzLmxlbmd0aCAtIDI7IGR0aSArPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRwcm9wc1tkdG9rc1tkdGkgKyAxXV0gPSBkdG9rc1tkdGkgKyAyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkcHJvcHMuZGltWCAmJiBkcHJvcHMuZGltWSkge1xuICAgICAgICAgICAgICAgIHZhciBkaW1YID0gZHByb3BzLmRpbVgsIGRpbVkgPSBkcHJvcHMuZGltWTtcbiAgICAgICAgICAgICAgICB2YXIgc2dYID0gZGcuc3ViZ3JvdXBzW2RpbVhdO1xuICAgICAgICAgICAgICAgIHZhciBzZ1kgPSBkZy5zdWJncm91cHNbZGltWV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIHRya3MgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaSA9IDA7IGNpIDwgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyArK2NpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuW2NpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZYID0gY2hpbGQuc2dtW2RpbVhdLCB2WSA9IGNoaWxkLnNnbVtkaW1ZXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmtzW3ZYXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRya3NbdlhdID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRya3NbdlhdW3ZZXSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBtYXRyaXggPSBtYWtlRWxlbWVudCgndGFibGUnLCBudWxsLCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSwge3RhYmxlTGF5b3V0OiAnZml4ZWQnfSk7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZGVyID0gbWFrZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgndGgnLCBudWxsLCB7fSwge3dpZHRoOiAnMTUwcHgnLCBoZWlnaHQ6ICcxMDBweCd9KSk7ICAgLy8gYmxhbmsgY29ybmVyIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgc2kgPSAwOyBzaSA8IHNnWC50aXRsZXMubGVuZ3RoOyArK3NpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IG1ha2VFbGVtZW50KCd0aCcsIG1ha2VFbGVtZW50KCdkaXYnLCBzZ1gudGl0bGVzW3NpXSwge30sIHt0cmFuc2Zvcm06ICdyb3RhdGUoLTYwZGVnKScsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46ICcwJSAxMDAlJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmtpdFRyYW5zZm9ybTogJ3JvdGF0ZSgtNjBkZWcpIHRyYW5zbGF0ZSgyMHB4LDEwcHgpJywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmtpdFRyYW5zZm9ybU9yaWdpbjogJzAlIDEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0J30pLCB7fSwge3dpZHRoOiAnMzVweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdib3R0b20nfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci5hcHBlbmRDaGlsZChoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXRyaXguYXBwZW5kQ2hpbGQoaGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbWJvZHkgPSBtYWtlRWxlbWVudCgndGJvZHknLCBudWxsLCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSlcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5aSA9IDA7IHlpIDwgc2dZLnRpdGxlcy5sZW5ndGg7ICsreWkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZZID0gc2dZLnRhZ3NbeWldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93ID0gbWFrZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgndGgnLCBzZ1kudGl0bGVzW3lpXSksIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhpID0gMDsgeGkgPCBzZ1gudGl0bGVzLmxlbmd0aDsgKyt4aSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZYID0gc2dYLnRhZ3NbeGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSBtYWtlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmtzW3ZYXSAmJiB0cmtzW3ZYXVt2WV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2sgPSB0cmtzW3ZYXVt2WV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRzID0gdHJhY2sudG9EYWxsaWFuY2VTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG1ha2VFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiZCA9IG1ha2VFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJkLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiID0gbWFrZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLmRhbGxpYW5jZV9zb3VyY2UgPSBkcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX19tYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuZGFsbGlhbmNlX21hcHBpbmcgPSBfX21hcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaChiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LnRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGV2LnRhcmdldC5kYWxsaWFuY2Vfc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLnJlbW92ZVRpZXIoZXYudGFyZ2V0LmRhbGxpYW5jZV9zb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChjZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgbWJvZHkuYXBwZW5kQ2hpbGQocm93KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWF0cml4LmFwcGVuZENoaWxkKG1ib2R5KTtcbiAgICAgICAgICAgICAgICB0dGFiLmFwcGVuZENoaWxkKG1ha2VUcmVlVGFibGVTZWN0aW9uKGdyb3VwLnNob3J0TGFiZWwsIG1hdHJpeCwgZ2k9PTApKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGFiQm9keSA9IG1ha2VFbGVtZW50KCd0Ym9keScsIG51bGwsIHtjbGFzc05hbWU6ICd0YWJsZSB0YWJsZS1zdHJpcGVkIHRhYmxlLWNvbmRlbnNlZCd9KTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhYiA9IG1ha2VFbGVtZW50KCd0YWJsZScsIHN0YWJCb2R5LCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSwge3dpZHRoOiAnMTAwJScsIHRhYmxlTGF5b3V0OiAnZml4ZWQnfSk7IFxuICAgICAgICAgICAgICAgIHZhciBpZHggPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZ3JvdXAuY2hpbGRyZW4uc29ydChUSFVCX0NPTVBBUkUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gZ3JvdXAuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcyA9IHRyYWNrLnRvRGFsbGlhbmNlU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IG1ha2VFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmQgPSBtYWtlRWxlbWVudCgndGQnLCBudWxsLCB7fSwge3dpZHRoOiAnMzBweCd9KTtcbiAgICAgICAgICAgICAgICAgICAgYmQuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG1ha2VFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICBiLnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgICAgICAgICAgICBiLmRhbGxpYW5jZV9zb3VyY2UgPSBkcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9fbWFwcGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5kYWxsaWFuY2VfbWFwcGluZyA9IF9fbWFwcGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goYik7XG4gICAgICAgICAgICAgICAgICAgIGJkLmFwcGVuZENoaWxkKGIpO1xuICAgICAgICAgICAgICAgICAgICBiLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXYudGFyZ2V0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGV2LnRhcmdldC5kYWxsaWFuY2Vfc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0IucmVtb3ZlVGllcihldi50YXJnZXQuZGFsbGlhbmNlX3NvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHIuYXBwZW5kQ2hpbGQoYmQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGQgPSBtYWtlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgbGQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodHJhY2suc2hvcnRMYWJlbCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2subG9uZ0xhYmVsICYmIHRyYWNrLmxvbmdMYWJlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5tYWtlVG9vbHRpcChsZCwgdHJhY2subG9uZ0xhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByLmFwcGVuZENoaWxkKGxkKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYkJvZHkuYXBwZW5kQ2hpbGQocik7XG4gICAgICAgICAgICAgICAgICAgICsraWR4O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChncm91cHMubGVuZ3RoID4gMSB8fCBncm91cC5zaG9ydExhYmVsICE9PSAnT3RoZXJzJykge1xuICAgICAgICAgICAgICAgICAgICB0dGFiLmFwcGVuZENoaWxkKG1ha2VUcmVlVGFibGVTZWN0aW9uKGdyb3VwLnNob3J0TGFiZWwsIHN0YWIsIGdpPT0wKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHRhYi5hcHBlbmRDaGlsZChzdGFiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2V0Q2hlY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYnV0dG9ucy5sZW5ndGg7ICsrYmkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IGJ1dHRvbnNbYmldO1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpc0IuY3VycmVudGx5QWN0aXZlKGIuZGFsbGlhbmNlX3NvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgYi5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYi5kaXNhYmxlZCA9IHQuc2VxdWVuY2VTb3VyY2UgIT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiLmNoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0Q2hlY2tzKCk7XG4gICAgICAgIHRoaXNCLmFkZFRpZXJMaXN0ZW5lcihmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICBzZXRDaGVja3MoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKHR0YWIpO1xuICAgIH1cblxuICAgIGlmIChyZWdCdXR0b24pIHtcbiAgICAgICAgcmVnQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgYWN0aXZhdGVCdXR0b24oYWRkTW9kZUJ1dHRvbnMsIHJlZ0J1dHRvbik7XG4gICAgICAgICAgICBtYWtlU3RhYih0aGlzQi5hdmFpbGFibGVTb3VyY2VzKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiBcbiAgICBiaW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldikge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgc3dpdGNoVG9CaW5Nb2RlKCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIGFkZEh1YkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzd2l0Y2hUb0h1YkNvbm5lY3RNb2RlKCk7XG4gICAgfSwgZmFsc2UpO1xuXG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hUb0Jpbk1vZGUoKSB7XG4gICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBiaW5CdXR0b24pO1xuICAgICAgICBjdXN0b21Nb2RlID0gJ2Jpbic7XG5cbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgdmFyIHBhZ2VIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge30sIHtwYWRkaW5nTGVmdDogJzEwcHgnLCBwYWRkaW5nUmlnaHQ6ICcxMHB4J30pO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdoMycsICdBZGQgY3VzdG9tIFVSTC1iYXNlZCBkYXRhJykpO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgWydZb3UgY2FuIGFkZCBpbmRleGVkIGJpbmFyeSBkYXRhIGhvc3RlZCBvbiBhbiB3ZWIgc2VydmVyIHRoYXQgc3VwcG9ydHMgQ09SUyAoJywgbWFrZUVsZW1lbnQoJ2EnLCAnZnVsbCBkZXRhaWxzJywge2hyZWY6ICdodHRwOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvYmluLmh0bWwnfSksICcpLiAgQ3VycmVudGx5IHN1cHBvcnRlZCBmb3JtYXRzIGFyZSBiaWd3aWcsIGJpZ2JlZCwgYW5kIGluZGV4ZWQgQkFNLiddKSk7XG5cbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnYnInKSk7XG4gICAgICAgIHBhZ2VIb2xkZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1VSTDogJykpO1xuICAgICAgICBjdXN0VVJMID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgJycsIHtzaXplOiA4MCwgdmFsdWU6ICdodHRwOi8vd3d3LmJpb2RhbGxpYW5jZS5vcmcvZGF0YXNldHMvZW5zR2VuZS5iYid9LCB7d2lkdGg6ICcxMDAlJ30pO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKGN1c3RVUkwpO1xuICAgICAgICBcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnYnInKSk7XG4gICAgICAgIHBhZ2VIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2InLCAnLSBvciAtJykpO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdicicpKTtcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnRmlsZTogJykpO1xuICAgICAgICBjdXN0RmlsZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsIG51bGwsIHt0eXBlOiAnZmlsZScsIG11bHRpcGxlOiAnbXVsdGlwbGUnfSk7XG4gICAgICAgIHBhZ2VIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdEZpbGUpO1xuICAgICAgICBcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdDbGlja2luZyB0aGUgXCJBZGRcIiBidXR0b24gYmVsb3cgd2lsbCBpbml0aWF0ZSBhIHNlcmllcyBvZiB0ZXN0IHF1ZXJpZXMuJykpO1xuXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQocGFnZUhvbGRlcik7XG4gICAgICAgIGN1c3RVUkwuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hUb0h1YkNvbm5lY3RNb2RlKCkge1xuICAgICAgICBhY3RpdmF0ZUJ1dHRvbihhZGRNb2RlQnV0dG9ucywgYWRkSHViQnV0dG9uKTtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBjdXN0b21Nb2RlID0gJ2h1Yi1jb25uZWN0JztcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oc3RhYkhvbGRlcik7XG5cbiAgICAgICAgdmFyIHBhZ2VIb2xkZXIgPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge30sIHtwYWRkaW5nTGVmdDogJzEwcHgnLCBwYWRkaW5nUmlnaHQ6ICcxMHB4J30pO1xuICAgICAgICBwYWdlSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdoMycsICdDb25uZWN0IHRvIGEgdHJhY2sgaHViLicpKTtcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFsnRW50ZXIgdGhlIHRvcC1sZXZlbCBVUkwgKHVzdWFsbHkgcG9pbnRzIHRvIGEgZmlsZSBjYWxsZWQgXCJodWIudHh0XCIpIG9mIGEgVUNTQy1zdHlsZSB0cmFjayBodWInXSkpO1xuICAgICAgICBcbiAgICAgICAgY3VzdFVSTCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7c2l6ZTogMTIwLCB2YWx1ZTogJ2h0dHA6Ly93d3cuYmlvZGFsbGlhbmNlLm9yZy9kYXRhc2V0cy90ZXN0aHViL2h1Yi50eHQnfSwge3dpZHRoOiAnMTAwJSd9KTtcbiAgICAgICAgcGFnZUhvbGRlci5hcHBlbmRDaGlsZChjdXN0VVJMKTtcbiAgICAgICAgXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQocGFnZUhvbGRlcik7XG4gICAgICAgIFxuICAgICAgICBjdXN0VVJMLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgY3VzdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBzd2l0Y2hUb0N1c3RvbU1vZGUoKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICBmdW5jdGlvbiBzd2l0Y2hUb0N1c3RvbU1vZGUoKSB7XG4gICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBjdXN0QnV0dG9uKTtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICBjdXN0b21Nb2RlID0gJ2Rhcyc7XG5cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oc3RhYkhvbGRlcik7XG5cbiAgICAgICAgdmFyIGN1c3RvbUZvcm0gPSBtYWtlRWxlbWVudCgnZGl2JywgbnVsbCwge30sICB7cGFkZGluZ0xlZnQ6ICcxMHB4JywgcGFkZGluZ1JpZ2h0OiAnMTBweCd9KTtcbiAgICAgICAgY3VzdG9tRm9ybS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnaDMnLCAnQWRkIGN1c3RvbSBEQVMgZGF0YScpKTtcbiAgICAgICAgY3VzdG9tRm9ybS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdUaGlzIGludGVyZmFjZSBpcyBpbnRlbmRlZCBmb3IgYWRkaW5nIGN1c3RvbSBvciBsYWItc3BlY2lmaWMgZGF0YS4gIFB1YmxpYyBkYXRhIGNhbiBiZSBhZGRlZCBtb3JlIGVhc2lseSB2aWEgdGhlIHJlZ2lzdHJ5IGludGVyZmFjZS4nKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIGN1c3RvbUZvcm0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1VSTDogJykpO1xuICAgICAgICBjdXN0b21Gb3JtLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdicicpKTtcbiAgICAgICAgY3VzdFVSTCA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7c2l6ZTogODAsIHZhbHVlOiAnaHR0cDovL3d3dy5kZXJraG9sbS5uZXQ6ODA4MC9kYXMvbWVkaXBzZXFfcmVhZHMvJ30sIHt3aWR0aDogJzEwMCUnfSk7XG4gICAgICAgIGN1c3RvbUZvcm0uYXBwZW5kQ2hpbGQoY3VzdFVSTCk7XG5cbiAgICAgICAgY3VzdG9tRm9ybS5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdDbGlja2luZyB0aGUgXCJBZGRcIiBidXR0b24gYmVsb3cgd2lsbCBpbml0aWF0ZSBhIHNlcmllcyBvZiB0ZXN0IHF1ZXJpZXMuICBJZiB0aGUgc291cmNlIGlzIHBhc3N3b3JkLXByb3RlY3RlZCwgeW91IG1heSBiZSBwcm9tcHRlZCB0byBlbnRlciBjcmVkZW50aWFscy4nKSk7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdG9tRm9ybSk7XG5cbiAgICAgICAgY3VzdFVSTC5mb2N1cygpO1xuICAgIH1cblxuXG5cbiAgICB2YXIgYWRkQnV0dG9uID0gbWFrZUVsZW1lbnQoJ2J1dHRvbicsICdBZGQnLCB7Y2xhc3NOYW1lOiAnYnRuIGJ0bi1wcmltYXJ5J30pO1xuICAgIGFkZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkb0FkZCgpO1xuICAgIH0sIGZhbHNlKTtcblxuICAgIGZ1bmN0aW9uIGRvQWRkKCkge1xuICAgICAgICBpZiAoY3VzdG9tTW9kZSkge1xuICAgICAgICAgICAgaWYgKGN1c3RvbU1vZGUgPT09ICdkYXMnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cmkgPSBjdXN0VVJMLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIS9eLis6XFwvXFwvLy5leGVjKGN1cmkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cmkgPSAnaHR0cDovLycgKyBjdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmRzID0gbmV3IERBU1NvdXJjZSh7bmFtZTogJ3RlbXBvcmFyeScsIHVyaTogY3VyaX0pO1xuICAgICAgICAgICAgICAgIHRyeUFkZERBUyhuZHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Nb2RlID09PSAnYmluJykge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTGlzdCA9IGN1c3RGaWxlLmZpbGVzO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZpbGVMaXN0ICYmIGZpbGVMaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5QWRkTXVsdGlwbGUoZmlsZUxpc3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJpID0gY3VzdFVSTC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghL14uKzpcXC9cXC8vLmV4ZWMoY3VyaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cmkgPSAnaHR0cDovLycgKyBjdXJpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSB7dXJpOiBjdXJpfTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxjdXJpID0gY3VyaS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGN1cmkuaW5kZXhPZihcImh0dHBzOi8vd3d3LmVuY29kZXByb2plY3Qub3JnL1wiKSA9PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBsY3VyaS5pbmRleE9mKFwiQEBkb3dubG9hZFwiKSA+PSAwKSBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLnRyYW5zcG9ydCA9ICdlbmNvZGUnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeUFkZEJpbihzb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tTW9kZSA9PT0gJ3Jlc2V0Jykge1xuICAgICAgICAgICAgICAgIHN3aXRjaFRvQ3VzdG9tTW9kZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Nb2RlID09PSAncmVzZXQtYmluJykge1xuICAgICAgICAgICAgICAgIHN3aXRjaFRvQmluTW9kZSgpOyBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tTW9kZSA9PT0gJ3Jlc2V0LWh1YicpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hUb0h1YkNvbm5lY3RNb2RlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbU1vZGUgPT09ICdwcm9tcHQtYmFpJykge1xuICAgICAgICAgICAgICAgIHZhciBmaWxlTGlzdCA9IGN1c3RGaWxlLmZpbGVzO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlTGlzdCAmJiBmaWxlTGlzdC5sZW5ndGggPiAwICYmIGZpbGVMaXN0WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb0ZpbmFsaXplLmJhaUJsb2IgPSBmaWxlTGlzdFswXTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVCQU0oZGF0YVRvRmluYWxpemUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21wdEZvckJBSShkYXRhVG9GaW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Nb2RlID09PSAncHJvbXB0LXRiaScpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUxpc3QgPSBjdXN0RmlsZS5maWxlcztcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUxpc3QgJiYgZmlsZUxpc3QubGVuZ3RoID4gMCAmJiBmaWxlTGlzdFswXSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhVG9GaW5hbGl6ZS5pbmRleEJsb2IgPSBmaWxlTGlzdFswXTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVUYWJpeFZDRihkYXRhVG9GaW5hbGl6ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0Rm9yVGFiaXgoZGF0YVRvRmluYWxpemUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VzdG9tTW9kZSA9PT0gJ2ZpbmFsaXplJyB8fCBjdXN0b21Nb2RlID09PSAnZmluYWxpemUtYmluJykge1xuICAgICAgICAgICAgICAgIGRhdGFUb0ZpbmFsaXplLm5hbWUgPSBjdXN0TmFtZS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGN1c3RDUy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobSAhPSAnX19kZWZhdWx0X18nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb0ZpbmFsaXplLm1hcHBpbmcgPSBtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFUb0ZpbmFsaXplLm1hcHBpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXN0UXVhbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRvRmluYWxpemUubWF4YmlucyA9IGN1c3RRdWFudC5jaGVja2VkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjdXN0VXNlci52YWx1ZS5sZW5ndGggPiAxICYmIGN1c3RQYXNzLnZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRvRmluYWxpemUueFVzZXIgPSBjdXN0VXNlci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVRvRmluYWxpemUueFBhc3MgPSBjdXN0UGFzcy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzQi5hZGRUaWVyKGRhdGFUb0ZpbmFsaXplKTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXN0b21Nb2RlID09ICdmaW5hbGl6ZS1iaW4nKVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2hUb0Jpbk1vZGUoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaFRvQ3VzdG9tTW9kZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Nb2RlID09PSAnaHViLWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cmkgPSBjdXN0VVJMLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoIS9eLis6XFwvXFwvLy5leGVjKGN1cmkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cmkgPSAnaHR0cDovLycgKyBjdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cnlBZGRIdWIoY3VyaSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbU1vZGUgPT09ICdtdWx0aXBsZScpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBtaSA9IDA7IG1pIDwgbXVsdGlwbGVTZXQubGVuZ3RoOyArK21pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gbXVsdGlwbGVTZXRbbWldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5oaWRkZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocy50aWVyX3R5cGUgPT0gJ2JhbScgJiYgIXMuaW5kZXhCbG9iICYmICFzLmluZGV4VXJpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnRpZXJfdHlwZSA9PSAndGFiaXgnICYmICFzLmluZGV4QmxvYiAmJiAhcy5pbmRleFVyaSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZHMgPSBtYWtlU291cmNlQ29uZmlnKHMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZHMubm9QZXJzaXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmFkZFRpZXIobmRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN3aXRjaFRvQmluTW9kZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc0IucmVtb3ZlQWxsUG9wdXBzKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gdHJ5QWRkSHViKGN1cmksIG9wdHMsIHJldHJ5KSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBmb3IgKHZhciBoaSA9IDA7IGhpIDwgdGhpc0IuaHViT2JqZWN0cy5sZW5ndGg7ICsraGkpIHtcbiAgICAgICAgICAgIHZhciBoID0gdGhpc0IuaHViT2JqZWN0c1toaV07XG4gICAgICAgICAgICBpZiAoaC5odWIudXJsID09IGN1cmkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBiaSA9IDA7IGJpIDwgYWRkTW9kZUJ1dHRvbnMubGVuZ3RoOyArK2JpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRNb2RlQnV0dG9uc1tiaV0uaHViID09IGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBhZGRNb2RlQnV0dG9uc1tiaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGguZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWFrZUh1YlN0YWIodHJhY2tzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29ubmVjdFRyYWNrSHViKGN1cmksIGZ1bmN0aW9uKGh1YiwgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5QWRkSHViKGN1cmksIHtjcmVkZW50aWFsczogdHJ1ZX0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdoMicsICdFcnJvciBjb25uZWN0aW5nIHRvIHRyYWNrIGh1YicpKVxuICAgICAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3AnLCBlcnIpKTtcbiAgICAgICAgICAgICAgICBjdXN0b21Nb2RlID0gJ3Jlc2V0LWh1Yic7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVzdEh1YiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGJlc3RIdWJCdXR0b24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGdlbm9tZSBpbiBodWIuZ2Vub21lcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwcGluZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBva2F5ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbm9tZSA9PSB0aGlzQi5jb29yZFN5c3RlbS51Y3NjTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2theSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbWlkIGluIHRoaXNCLmNoYWlucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtID0gdGhpc0IuY2hhaW5zW21pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdlbm9tZSA9PSBtLmNvb3Jkcy51Y3NjTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nID0gbWlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBva2F5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9rYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYyA9IHt1cmw6IGN1cmksIGdlbm9tZTogZ2Vub21lfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLmNyZWRlbnRpYWxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhjLmNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBwaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGMubWFwcGluZyA9IG1hcHBpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHViLmdlbm9tZXNbZ2Vub21lXS5tYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNCLmh1YnMucHVzaChoYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzQi5odWJPYmplY3RzLnB1c2goaHViLmdlbm9tZXNbZ2Vub21lXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBodWJCdXR0b24gPSBtYWtlSHViQnV0dG9uKGh1Yi5nZW5vbWVzW2dlbm9tZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZUJ1dHRvbkhvbGRlci5hcHBlbmRDaGlsZChodWJCdXR0b24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcHBpbmcgfHwgIWJlc3RIdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0SHViID0gaHViLmdlbm9tZXNbZ2Vub21lXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0SHViQnV0dG9uID0gaHViQnV0dG9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGJlc3RIdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc0Iubm90aWZ5VGllcigpO1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmF0ZUJ1dHRvbihhZGRNb2RlQnV0dG9ucywgYmVzdEh1YkJ1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RIdWIuZ2V0VHJhY2tzKGZ1bmN0aW9uKHRyYWNrcywgZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlSHViU3RhYih0cmFja3MpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnaDInLCAnTm8gZGF0YSBmb3IgdGhpcyBnZW5vbWUnKSlcbiAgICAgICAgICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdUaGlzIFVSTCBhcHBlYXJzIHRvIGJlIGEgdmFsaWQgdHJhY2staHViLCBidXQgaXQgZG9lc25cXCd0IGNvbnRhaW4gYW55IGRhdGEgZm9yIHRoZSBjb29yZGluYXRlIHN5c3RlbSBvZiB0aGlzIGJyb3dzZXInKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3AnLCAnY29vcmRTeXN0ZW0udWNzY05hbWUgPSAnICsgdGhpc0IuY29vcmRTeXN0ZW0udWNzY05hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tTW9kZSA9ICdyZXNldC1odWInO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBvcHRzKTtcbiAgICB9XG5cbiAgICB2YXIgdHJ5QWRkREFTID0gZnVuY3Rpb24obmRzLCByZXRyeSkge1xuICAgICAgICB2YXIga25vd25TcGFjZSA9IHRoaXNCLmtub3duU3BhY2U7XG4gICAgICAgIGlmICgha25vd25TcGFjZSkge1xuICAgICAgICAgICAgYWxlcnQoXCJDYW4ndCBjb25maXJtIHRyYWNrLWFkZGl0aW9uIHRvIGFuIHVuaW5pdCBicm93c2VyLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHNtID0gTWF0aC5tYXgoa25vd25TcGFjZS5taW4sIChrbm93blNwYWNlLm1pbiArIGtub3duU3BhY2UubWF4IC0gMTAwKSAvIDIpfDA7XG4gICAgICAgIHZhciB0ZXN0U2VnbWVudCA9IG5ldyBEQVNTZWdtZW50KGtub3duU3BhY2UuY2hyLCB0c20sIE1hdGgubWluKHRzbSArIDk5LCBrbm93blNwYWNlLm1heCkpO1xuICAgICAgICBuZHMuZmVhdHVyZXModGVzdFNlZ21lbnQsIHt9LCBmdW5jdGlvbihmZWF0dXJlcywgc3RhdHVzKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICBuZHMuY3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0cnlBZGREQVMobmRzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnaDInLCAnQ3VzdG9tIGRhdGEgbm90IGZvdW5kJykpO1xuICAgICAgICAgICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgJ0RBUyB1cmk6ICcgKyBuZHMudXJpICsgJyBpcyBub3QgYW5zd2VyaW5nIGZlYXR1cmVzIHJlcXVlc3RzJykpO1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21Nb2RlID0gJ3Jlc2V0JztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVFeHRyYWN0UGF0dGVybiA9IG5ldyBSZWdFeHAoJy8oW14vXSspLz8kJyk7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbmFtZUV4dHJhY3RQYXR0ZXJuLmV4ZWMobmRzLnVyaSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5kcy5uYW1lID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5QWRkREFTeFNvdXJjZXMobmRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRyeUFkZERBU3hTb3VyY2VzKG5kcywgcmV0cnkpIHtcbiAgICAgICAgdmFyIHVyaSA9IG5kcy51cmk7XG4gICAgICAgIGlmIChyZXRyeSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gLyguKylcXC9bXlxcL10rXFwvPy8uZXhlYyh1cmkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdXJpID0gbWF0Y2hbMV0gKyAnL3NvdXJjZXMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNxZmFpbCgpIHtcbiAgICAgICAgICAgIGlmICghcmV0cnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5QWRkREFTeFNvdXJjZXMobmRzLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZERhc0NvbXBsZXRpb25QYWdlKG5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbmV3IERBU1JlZ2lzdHJ5KHVyaSwge2NyZWRlbnRpYWxzOiBuZHMuY3JlZGVudGlhbHN9KS5zb3VyY2VzKFxuICAgICAgICAgICAgZnVuY3Rpb24oc291cmNlcykge1xuICAgICAgICAgICAgICAgIGlmICghc291cmNlcyB8fCBzb3VyY2VzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzcWZhaWwoKTtcbiAgICAgICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAgICAgdmFyIGZzID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmcyA9IHNvdXJjZXNbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlc1tpXS51cmkgPT09IG5kcy51cmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcyA9IHNvdXJjZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzRGV0ZXJtaW5lZCA9IGZhbHNlLCBxdWFudERldGVybWluZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmRzLm5hbWUgPSBmcy5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBuZHMuZGVzYyA9IGZzLmRlc2M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcy5tYXhiaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZHMubWF4YmlucyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZHMubWF4YmlucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcy5jYXBhYmlsaXRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5kcy5jYXBhYmlsaXRpZXMgPSBmcy5jYXBhYmlsaXRpZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcXVhbnREZXRlcm1pbmVkID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZzLmNvb3JkcyAmJiBmcy5jb29yZHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yZHMgPSBmcy5jb29yZHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29vcmRzTWF0Y2goY29vcmRzLCB0aGlzQi5jb29yZFN5c3RlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHNEZXRlcm1pbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpc0IuY2hhaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzQi5jaGFpbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3Jkc01hdGNoKGNvb3JkcywgdGhpc0IuY2hhaW5zW2tdLmNvb3JkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5kcy5tYXBwaW5nID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkc0RldGVybWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkRGFzQ29tcGxldGlvblBhZ2UobmRzLCBjb29yZHNEZXRlcm1pbmVkLCBxdWFudERldGVybWluZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcWZhaWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgbWFrZVNvdXJjZUNvbmZpZyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgdmFyIG5kcyA9IHtuYW1lOiBzLm5hbWV9O1xuICAgICAgICBpZiAocy5jcmVkZW50aWFscylcbiAgICAgICAgICAgIG5kcy5jcmVkZW50aWFscyA9IHMuY3JlZGVudGlhbHM7XG4gICAgICAgIFxuICAgICAgICBpZiAocy5tYXBwaW5nICYmIHMubWFwcGluZyAhPSAnX19kZWZhdWx0X18nKVxuICAgICAgICAgICAgbmRzLm1hcHBpbmcgPSBzLm1hcHBpbmc7XG5cbiAgICAgICAgaWYgKHMudHJhbnNwb3J0KVxuICAgICAgICAgICAgbmRzLnRyYW5zcG9ydCA9IHMudHJhbnNwb3J0O1xuXG4gICAgICAgIGlmIChzLnRpZXJfdHlwZSA9PSAnYndnJykge1xuICAgICAgICAgICAgaWYgKHMuYmxvYilcbiAgICAgICAgICAgICAgICBuZHMuYndnQmxvYiA9IHMuYmxvYjtcbiAgICAgICAgICAgIGVsc2UgaWYgKHMudXJpKVxuICAgICAgICAgICAgICAgIG5kcy5id2dVUkkgPSBzLnVyaTtcbiAgICAgICAgICAgIHJldHVybiBuZHM7XG4gICAgICAgIH0gZWxzZSBpZiAocy50aWVyX3R5cGUgPT0gJ2JhbScpIHtcbiAgICAgICAgICAgIGlmIChzLmJsb2IpIHtcbiAgICAgICAgICAgICAgICBuZHMuYmFtQmxvYiA9IHMuYmxvYjtcbiAgICAgICAgICAgICAgICBuZHMuYmFpQmxvYiA9IHMuaW5kZXhCbG9iO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZHMuYmFtVVJJID0gcy51cmk7XG4gICAgICAgICAgICAgICAgbmRzLmJhaVVSSSA9IHMuaW5kZXhVcmk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmRzO1xuICAgICAgICB9IGVsc2UgaWYgKHMudGllcl90eXBlID09ICd0YWJpeCcpIHtcbiAgICAgICAgICAgIG5kcy50aWVyX3R5cGUgPSAndGFiaXgnO1xuICAgICAgICAgICAgbmRzLnBheWxvYWQgPSBzLnBheWxvYWQ7XG4gICAgICAgICAgICBpZiAocy5ibG9iKSB7XG4gICAgICAgICAgICAgICAgbmRzLmJsb2IgPSBzLmJsb2I7XG4gICAgICAgICAgICAgICAgbmRzLmluZGV4QmxvYiA9IHMuaW5kZXhCbG9iO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZHMudXJpID0gcy51cmk7XG4gICAgICAgICAgICAgICAgbmRzLmluZGV4VXJpID0gcy5pbmRleFVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZHM7XG4gICAgICAgIH0gZWxzZSBpZiAocy50aWVyX3R5cGUgPT0gJ21lbXN0b3JlJykge1xuICAgICAgICAgICAgbmRzLnRpZXJfdHlwZSA9ICdtZW1zdG9yZSc7XG4gICAgICAgICAgICBuZHMucGF5bG9hZCA9IHMucGF5bG9hZDtcbiAgICAgICAgICAgIGlmIChzLmJsb2IpXG4gICAgICAgICAgICAgICAgbmRzLmJsb2IgPSBzLmJsb2I7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbmRzLnVyaSA9IHMudXJpO1xuICAgICAgICAgICAgcmV0dXJuIG5kcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cnlBZGRCaW4gPSBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgcHJvYmVSZXNvdXJjZShzb3VyY2UsIGZ1bmN0aW9uKHNvdXJjZSwgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oc3RhYkhvbGRlcik7XG4gICAgICAgICAgICAgICAgdmFyIHRhYkVycm9yID0gbWFrZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHRhYkVycm9yLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdoMicsIFwiQ291bGRuJ3QgYWNjZXNzIGN1c3RvbSBkYXRhXCIpKTtcbiAgICAgICAgICAgICAgICB0YWJFcnJvci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICcnICsgZXJyKSk7XG4gICAgICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZCh0YWJFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc291cmNlKTtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiBzb3VyY2UudXJpLmluZGV4T2YoJ2h0dHA6JykgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzQi5jYW5GZXRjaFBsYWluSFRUUCgpLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihjYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJFcnJvci5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCdwJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCdzdHJvbmcnLCAnSFRUUCB3YXJuaW5nOiAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAneW91IG1heSBub3QgYmUgYWJsZSB0byBhY2Nlc3MgSFRUUCByZXNvdXJjZXMgZnJvbSBhbiBpbnN0YW5jZSBvZiBCaW9kYWxsaWFuY2Ugd2hpY2ggeW91IGFyZSBhY2Nlc3NpbmcgdmlhIEhUVFBTLicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ2EnLCAnW01vcmUgaW5mb10nLCB7aHJlZjogdGhpc0IuaHR0cFdhcm5pbmdVUkwsIHRhcmdldDogXCJfYmxhbmtcIn0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VzdG9tTW9kZSA9ICdyZXNldC1iaW4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgbmRzID0gbWFrZVNvdXJjZUNvbmZpZyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UudGllcl90eXBlID09ICdiYW0nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZUJBTShuZHMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnRpZXJfdHlwZSA9PSAndGFiaXgnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZVRhYml4VkNGKG5kcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZERhc0NvbXBsZXRpb25QYWdlKG5kcywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb21wdEZvckJBSShuZHMpIHtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuKHN0YWJIb2xkZXIpO1xuICAgICAgICBjdXN0b21Nb2RlID0gJ3Byb21wdC1iYWknXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2gyJywgJ1NlbGVjdCBhbiBpbmRleCBmaWxlJykpO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgJ0RhbGxpYW5jZSByZXF1aXJlcyBhIEJBTSBpbmRleCAoLmJhaSkgZmlsZSB3aGVuIGRpc3BsYXlpbmcgQkFNIGRhdGEuICBUaGVzZSBub3JtYWxseSBhY2NvbXBhbnkgQkFNIGZpbGVzLiAgRm9yIHNlY3VyaXR5IHJlYXNvbnMsIHdlYiBhcHBsaWNhdGlvbnMgbGlrZSBEYWxsaWFuY2UgY2FuIG9ubHkgYWNjZXNzIGxvY2FsIGZpbGVzIHdoaWNoIHlvdSBoYXZlIGV4cGxpY2l0eSBzZWxlY3RlZC4gIFBsZWFzZSB1c2UgdGhlIGZpbGUgY2hvb3NlciBiZWxvdyB0byBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIEJBSSBmaWxlJykpO1xuXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ0luZGV4IGZpbGU6ICcpKTtcbiAgICAgICAgY3VzdEZpbGUgPSBtYWtlRWxlbWVudCgnaW5wdXQnLCBudWxsLCB7dHlwZTogJ2ZpbGUnfSk7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdEZpbGUpO1xuICAgICAgICBkYXRhVG9GaW5hbGl6ZSA9IG5kcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcm9tcHRGb3JUYWJpeChuZHMpIHtcbiAgICAgICAgcmVmcmVzaEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBhZGRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuICAgICAgICBjYW5CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgIHJlbW92ZUNoaWxkcmVuKHN0YWJIb2xkZXIpO1xuICAgICAgICBjdXN0b21Nb2RlID0gJ3Byb21wdC10YmknXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2gyJywgJ1NlbGVjdCBhbiBpbmRleCBmaWxlJykpO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgJ0RhbGxpYW5jZSByZXF1aXJlcyBhIFRhYml4IGluZGV4ICgudGJpKSBmaWxlIHdoZW4gZGlzcGxheWluZyBWQ0YgZGF0YS4gIEZvciBzZWN1cml0eSByZWFzb25zLCB3ZWIgYXBwbGljYXRpb25zIGxpa2UgRGFsbGlhbmNlIGNhbiBvbmx5IGFjY2VzcyBsb2NhbCBmaWxlcyB3aGljaCB5b3UgaGF2ZSBleHBsaWNpdHkgc2VsZWN0ZWQuICBQbGVhc2UgdXNlIHRoZSBmaWxlIGNob29zZXIgYmVsb3cgdG8gc2VsZWN0IHRoZSBhcHByb3ByaWF0ZSBCQUkgZmlsZScpKTtcblxuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdJbmRleCBmaWxlOiAnKSk7XG4gICAgICAgIGN1c3RGaWxlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdmaWxlJ30pO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKGN1c3RGaWxlKTtcbiAgICAgICAgZGF0YVRvRmluYWxpemUgPSBuZHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVCQU0obmRzKSB7XG4gICAgICAgIHZhciBpbmRleEY7XG4gICAgICAgIGlmIChuZHMuYmFpQmxvYikgXG4gICAgICAgICAgICBpbmRleEYgPSBuZXcgQmxvYkZldGNoYWJsZShuZHMuYmFpQmxvYik7XG4gICAgICAgIGVsc2UgaWYgKG5kcy50cmFuc3BvcnQgPT0gJ2VuY29kZScpXG4gICAgICAgICAgICBpbmRleEYgPSBuZXcgRW5jb2RlRmV0Y2hhYmxlKG5kcy5iYW1VUkkgKyAnLmJhaScpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBpbmRleEYgPSBuZXcgVVJMRmV0Y2hhYmxlKG5kcy5iYW1VUkkgKyAnLmJhaScsIHtjcmVkZW50aWFsczogbmRzLmNyZWRlbnRpYWxzfSk7XG5cbiAgICAgICAgaW5kZXhGLnNsaWNlKDAsIDI1NikuZmV0Y2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgIHZhciBoYXNCQUkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hZ2ljMiA9IHJlYWRJbnQoYmEsIDApO1xuICAgICAgICAgICAgICAgICAgICBoYXNCQUkgPSAobWFnaWMyID09IEJBSV9NQUdJQyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNCQUkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZERhc0NvbXBsZXRpb25QYWdlKG5kcywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluRm9ybWF0RXJyb3JQYWdlKCdZb3UgaGF2ZSBzZWxlY3RlZCBhIHZhbGlkIEJBTSBmaWxlLCBidXQgYSBjb3JyZXNwb25kaW5nIGluZGV4ICguYmFpKSBmaWxlIHdhcyBub3QgZm91bmQuICBQbGVhc2UgaW5kZXggeW91ciBCQU0gKHNhbXRvb2xzIGluZGV4KSBhbmQgcGxhY2UgdGhlIEJBSSBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGxldGVUYWJpeFZDRihuZHMpIHtcbiAgICAgICAgdmFyIGluZGV4RjtcbiAgICAgICAgaWYgKG5kcy5pbmRleEJsb2IpIHtcbiAgICAgICAgICAgIGluZGV4RiA9IG5ldyBCbG9iRmV0Y2hhYmxlKG5kcy5pbmRleEJsb2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhGID0gbmV3IFVSTEZldGNoYWJsZShuZHMudXJpICsgJy50YmknKTtcbiAgICAgICAgfVxuICAgICAgICBpbmRleEYuc2xpY2UoMCwgMTw8MTYpLmZldGNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIHZhciBoYXNUYWJpeCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmEgPSBuZXcgVWludDhBcnJheShyKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFbMF0gPT0gMzEgfHwgYmFbMV0gPT0gMTM5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmMgPSB1bmJnemYocik7XG4gICAgICAgICAgICAgICAgICAgIGJhID0gbmV3IFVpbnQ4QXJyYXkodW5jKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG0yID0gcmVhZEludChiYSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc1RhYml4ID0gKG0yID09IFRBQklYX01BR0lDKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVGFiaXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkRGFzQ29tcGxldGlvblBhZ2UobmRzLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmluRm9ybWF0RXJyb3JQYWdlKCdZb3UgaGF2ZSBzZWxlY3RlZCBhIHZhbGlkIFZDRiBmaWxlLCBidXQgYSBjb3JyZXNwb25kaW5nIGluZGV4ICgudGJpKSBmaWxlIHdhcyBub3QgZm91bmQuICBQbGVhc2UgaW5kZXggeW91ciBWQ0YgKFwidGFiaXggLXAgdmNmIC1mIG15ZmlsZS52Y2YuZ3pcIikgYW5kIHBsYWNlIHRoZSAudGJpIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJpbkZvcm1hdEVycm9yUGFnZShtZXNzYWdlKSB7XG4gICAgICAgIHJlZnJlc2hCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgYWRkQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgY2FuQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcblxuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0N1c3RvbSBkYXRhIGZvcm1hdCBub3QgcmVjb2duaXplZCc7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2gyJywgJ0Vycm9yIGFkZGluZyBjdXN0b20gZGF0YScpKTtcbiAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIG1lc3NhZ2UpKTtcbiAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdDdXJyZW50bHkgc3VwcG9ydGVkIGZvcm1hdHMgYXJlIGJpZ0JlZCwgYmlnV2lnLCBhbmQgQkFNLicpKTtcbiAgICAgICAgY3VzdG9tTW9kZSA9ICdyZXNldC1iaW4nO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgICAgICAgICAgICAgICAgICAgXG4gICAgdmFyIGFkZERhc0NvbXBsZXRpb25QYWdlID0gZnVuY3Rpb24obmRzLCBjb29yZHNEZXRlcm1pbmVkLCBxdWFudERldGVybWluZWQsIHF1YW50SXJyZWxldmFudCkge1xuICAgICAgICByZWZyZXNoQnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGFkZEJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIGNhbkJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG5cbiAgICAgICAgcmVtb3ZlQ2hpbGRyZW4oc3RhYkhvbGRlcik7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2gyJywgJ0FkZCBjdXN0b20gZGF0YTogc3RlcCAyJykpO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdMYWJlbDogJykpO1xuICAgICAgICBjdXN0TmFtZSA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnLCB7dmFsdWU6IG5kcy5uYW1lfSk7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdE5hbWUpO1xuXG5cbiAgICAgICAgLy8gc3RhYkhvbGRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnVXNlcjogJykpO1xuICAgICAgICBjdXN0VXNlciA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnKTtcbiAgICAgICAgLy8gc3RhYkhvbGRlci5hcHBlbmRDaGlsZChjdXN0VXNlcik7XG4gICAgICAgIC8vc3RhYkhvbGRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnUGFzczogJykpO1xuICAgICAgICBjdXN0UGFzcyA9IG1ha2VFbGVtZW50KCdpbnB1dCcsICcnKTtcbiAgICAgICAgLy8gc3RhYkhvbGRlci5hcHBlbmRDaGlsZChjdXN0UGFzcyk7XG4gICAgICAgIFxuXG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdicicpKTtcbiAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgnaDQnLCAnQ29vcmRpbmF0ZSBzeXN0ZW06ICcpKTtcbiAgICAgICAgY3VzdENTID0gbWFrZUVsZW1lbnQoJ3NlbGVjdCcsIG51bGwpO1xuICAgICAgICBjdXN0Q1MuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsIHRoaXNCLm5hbWVGb3JDb29yZFN5c3RlbSh0aGlzQi5jb29yZFN5c3RlbSksIHt2YWx1ZTogJ19fZGVmYXVsdF9fJ30pKTtcbiAgICAgICAgaWYgKHRoaXNCLmNoYWlucykge1xuICAgICAgICAgICAgZm9yICh2YXIgY3NrIGluIHRoaXNCLmNoYWlucykge1xuICAgICAgICAgICAgICAgIHZhciBjcyA9IHRoaXNCLmNoYWluc1tjc2tdLmNvb3JkcztcbiAgICAgICAgICAgICAgICBjdXN0Q1MuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsIHRoaXNCLm5hbWVGb3JDb29yZFN5c3RlbShjcyksIHt2YWx1ZTogY3NrfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1c3RDUy52YWx1ZSA9IG5kcy5tYXBwaW5nIHx8ICdfX2RlZmF1bHRfXyc7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdENTKTtcblxuICAgICAgICBpZiAoY29vcmRzRGV0ZXJtaW5lZCkge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFwiKEJhc2VkIG9uIHNlcnZlciByZXNwb25zZSwgcHJvYmFibHkgZG9lc24ndCBuZWVkIGNoYW5naW5nLilcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFttYWtlRWxlbWVudCgnYicsICdXYXJuaW5nOiAnKSwgXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZhbHVlIGZyb20gc2VydmVyIHJlc3BvbnNlcy4gIFBsZWFzZSBjaGVjayBjYXJlZnVsbHkuXCJdKSk7XG4gICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgXCJJZiB5b3UgZG9uJ3Qgc2VlIHRoZSBtYXBwaW5nIHlvdSdyZSBsb29raW5nIGZvciwgcGxlYXNlIGNvbnRhY3QgdGhvbWFzQGJpb2RhbGxpYW5jZS5vcmdcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFxdWFudElycmVsZXZhbnQpIHtcbiAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1F1YW50aXRhdGl2ZTogJykpO1xuICAgICAgICAgICAgY3VzdFF1YW50ID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdjaGVja2JveCcsIGNoZWNrZWQ6IHRydWV9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmRzLm1heGJpbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY3VzdFF1YW50LmNoZWNrZWQgPSBuZHMubWF4YmlucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoY3VzdFF1YW50KTtcbiAgICAgICAgICAgIGlmIChxdWFudERldGVybWluZWQpIHtcbiAgICAgICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdwJywgXCIoQmFzZWQgb24gc2VydmVyIHJlc3BvbnNlLCBwcm9iYWJseSBkb2Vzbid0IG5lZWQgY2hhbmdpbmcuKVwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3AnLCBbbWFrZUVsZW1lbnQoJ2InLCBcIldhcm5pbmc6IFwiKSwgXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIGNvcnJlY3QgdmFsdWUuICBJZiBpbiBkb3VidCwgbGVhdmUgY2hlY2tlZC5cIl0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZHMuYndnQmxvYikge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsIFttYWtlRWxlbWVudCgnYicsICdXYXJuaW5nOiAnKSwgJ2RhdGEgYWRkZWQgZnJvbSBsb2NhbCBmaWxlLiAgRHVlIHRvIHRoZSBicm93c2VyIHNlY3VyaXR5IG1vZGVsLCB0aGUgdHJhY2sgd2lsbCBkaXNhcHBlYXIgaWYgeW91IHJlbG9hZCBEYWxsaWFuY2UuJ10pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1c3ROYW1lLmZvY3VzKCk7XG5cbiAgICAgICAgaWYgKGN1c3RvbU1vZGUgPT09ICdiaW4nIHx8IGN1c3RvbU1vZGUgPT09ICdwcm9tcHQtYmFpJyB8fCBjdXN0b21Nb2RlID09PSAncHJvbXB0LXRiaScpXG4gICAgICAgICAgICBjdXN0b21Nb2RlID0gJ2ZpbmFsaXplLWJpbic7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGN1c3RvbU1vZGUgPSAnZmluYWxpemUnO1xuICAgICAgICBkYXRhVG9GaW5hbGl6ZSA9IG5kcztcbiAgICB9XG5cbiAgICB2YXIgbXVsdGlwbGVTZXQgPSBudWxsO1xuICAgIHZhciB0cnlBZGRNdWx0aXBsZSA9IGZ1bmN0aW9uKGZpbGVMaXN0KSB7XG4gICAgICAgIHZhciBuZXdTb3VyY2VzID0gbXVsdGlwbGVTZXQgPSBbXTtcbiAgICAgICAgY3VzdG9tTW9kZSA9ICdtdWx0aXBsZSc7XG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBmaWxlTGlzdC5sZW5ndGg7ICsrZmkpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmlsZUxpc3RbZmldO1xuICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICBuZXdTb3VyY2VzLnB1c2goe2Jsb2I6IGZ9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGZpID0gMDsgZmkgPCBuZXdTb3VyY2VzLmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgcHJvYmVNdWx0aXBsZShuZXdTb3VyY2VzW2ZpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTXVsdGlwbGVTdGF0dXMoKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvYmVNdWx0aXBsZSA9IGZ1bmN0aW9uKG5zKSB7XG4gICAgICAgIHByb2JlUmVzb3VyY2UobnMsIGZ1bmN0aW9uKHNvdXJjZSwgZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLmVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdXNlZEluZGljZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBiYW1zID0ge30sIHRhYml4ZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBtdWx0aXBsZVNldC5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG11bHRpcGxlU2V0W3NpXTtcbiAgICAgICAgICAgICAgICBpZiAocy50aWVyX3R5cGUgPT0gJ2JhbScgJiYgIXMuaW5kZXhCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhbXNbcy5ibG9iLm5hbWVdID0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMudGllcl90eXBlID09ICd0YWJpeCcgJiYgIXMuaW5kZXhCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYml4ZXNbcy5ibG9iLm5hbWVdID0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBtdWx0aXBsZVNldC5sZW5ndGg7ICsrc2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IG11bHRpcGxlU2V0W3NpXTtcbiAgICAgICAgICAgICAgICBpZiAocy50aWVyX3R5cGUgPT09ICdiYWknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYWlQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnKC4rKVxcXFwuYmFpJCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBiYWlQYXR0ZXJuLmV4ZWMocy5ibG9iLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgYmFtc1ttYXRjaFsxXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbXNbbWF0Y2hbMV1dLmluZGV4QmxvYiA9IHMuYmxvYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRJbmRpY2VzLnB1c2goc2kpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzLnRpZXJfdHlwZSA9PT0gJ3RhYml4LWluZGV4Jykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGJpUGF0dGVybiA9IG5ldyBSZWdFeHAoJyguKylcXFxcLnRiaSQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdGJpUGF0dGVybi5leGVjKHMuYmxvYi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoICYmIHRhYml4ZXNbbWF0Y2hbMV1dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWJpeGVzW21hdGNoWzFdXS5pbmRleEJsb2IgPSBzLmJsb2I7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkSW5kaWNlcy5wdXNoKHNpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgYmkgPSB1c2VkSW5kaWNlcy5sZW5ndGggLSAxOyBiaSA+PSAwOyAtLWJpKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlwbGVTZXQuc3BsaWNlKHVzZWRJbmRpY2VzW2JpXSwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZU11bHRpcGxlU3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB1cGRhdGVNdWx0aXBsZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZW1vdmVDaGlsZHJlbihzdGFiSG9sZGVyKTtcbiAgICAgICAgdmFyIG5lZWRzSW5kZXggPSBmYWxzZTtcbiAgICAgICAgdmFyIG11bHRUYWJsZSA9IG1ha2VFbGVtZW50KCd0YWJsZScsIG11bHRpcGxlU2V0XG4gICAgICAgICAgLmZpbHRlcihmdW5jdGlvbihzKSB7cmV0dXJuICFzLmhpZGRlbn0pXG4gICAgICAgICAgLm1hcChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gbWFrZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ3RkJywgcy5uYW1lIHx8IHMuYmxvYi5uYW1lKSk7XG4gICAgICAgICAgICB2YXIgdHlwZUNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAocy5lcnJvcikge1xuICAgICAgICAgICAgICAgIHR5cGVDb250ZW50ID0gbWFrZUVsZW1lbnQoJ3NwYW4nLCAnRXJyb3InLCBudWxsLCB7Y29sb3I6ICdyZWQnfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHMudGllcl90eXBlKSB7XG4gICAgICAgICAgICAgICAgdHlwZUNvbnRlbnQgPSBzLnBheWxvYWQgfHwgcy50aWVyX3R5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR5cGVDb250ZW50ID0gdGhpc0IubWFrZUxvYWRlcigxNik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjY3M7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSAndW5rbm93bic7XG4gICAgICAgICAgICBpZiAocy50aWVyX3R5cGUgPT0gJ2J3ZycgfHwgcy50aWVyX3R5cGUgPT0gJ21lbXN0b3JlJykge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gJ29rYXknO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzLnRpZXJfdHlwZSA9PSAnYmFtJykge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gcy5pbmRleEJsb2IgPyAnb2theScgOiAnbmVlZHMtaW5kZXgnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzLnRpZXJfdHlwZSA9PSAndGFiaXgnKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUgPSBzLmluZGV4QmxvYiA/ICdva2F5JyA6ICduZWVkcy1pbmRleCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PSAnb2theScpIHtcbiAgICAgICAgICAgICAgICBjY3MgPSBtYWtlRWxlbWVudCgnc2VsZWN0JywgbnVsbCwgbnVsbCwge3dpZHRoOiAnMTUwcHgnfSk7XG4gICAgICAgICAgICAgICAgY2NzLmFwcGVuZENoaWxkKG1ha2VFbGVtZW50KCdvcHRpb24nLCB0aGlzQi5uYW1lRm9yQ29vcmRTeXN0ZW0odGhpc0IuY29vcmRTeXN0ZW0pLCB7dmFsdWU6ICdfX2RlZmF1bHRfXyd9KSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNCLmNoYWlucykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBjc2sgaW4gdGhpc0IuY2hhaW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3MgPSB0aGlzQi5jaGFpbnNbY3NrXS5jb29yZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjY3MuYXBwZW5kQ2hpbGQobWFrZUVsZW1lbnQoJ29wdGlvbicsIHRoaXNCLm5hbWVGb3JDb29yZFN5c3RlbShjcyksIHt2YWx1ZTogY3NrfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNjcy52YWx1ZSA9IHMubWFwcGluZyB8fCAnX19kZWZhdWx0X18nO1xuXG4gICAgICAgICAgICAgICAgY2NzLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHMubWFwcGluZyA9IGNjcy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cocyk7XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PSAnbmVlZHMtaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgY2NzID0gbWFrZUVsZW1lbnQoJ3NwYW4nLCAnTmVlZHMgaW5kZXgnLCB7fSwge2NvbG9yOiAncmVkJ30pO1xuICAgICAgICAgICAgICAgIG5lZWRzSW5kZXggPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWFrZUVsZW1lbnQoJ3RyJywgW21ha2VFbGVtZW50KCd0ZCcsIHMubmFtZSB8fCBzLmJsb2IubmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VFbGVtZW50KCd0ZCcsIHR5cGVDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUVsZW1lbnQoJ3RkJywgY2NzKV0pO1xuXG4gICAgICAgIH0pLCB7Y2xhc3NOYW1lOiAndGFibGUgdGFibGUtc3RyaXBlZCB0YWJsZS1jb25kZW5zZWQnfSk7XG4gICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQobXVsdFRhYmxlKTtcblxuICAgICAgICBpZiAobmVlZHNJbmRleCkge1xuICAgICAgICAgICAgc3RhYkhvbGRlci5hcHBlbmRDaGlsZChtYWtlRWxlbWVudCgncCcsICdTb21lIG9mIHRoZXNlIGZpbGVzIGFyZSBtaXNzaW5nIHJlcXVpcmVkIGluZGV4ICguYmFpIG9yIC50YmkpIGZpbGVzLiAgRm9yIHNlY3VyaXR5IHJlYXNvbnMsIHdlYiBhcHBsaWNhdGlvbnMgbGlrZSBEYWxsaWFuY2UgY2FuIG9ubHkgYWNjZXNzIGxvY2FsIGZpbGVzIHdoaWNoIHlvdSBoYXZlIGV4cGxpY2l0eSBzZWxlY3RlZC4gIFBsZWFzZSB1c2UgdGhlIGZpbGUgY2hvb3NlciBiZWxvdyB0byBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIGluZGV4IGZpbGUnKSk7XG4gICAgICAgICAgICBzdGFiSG9sZGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdJbmRleCBmaWxlKHMpOiAnKSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhGaWxlID0gbWFrZUVsZW1lbnQoJ2lucHV0JywgbnVsbCwge3R5cGU6ICdmaWxlJywgbXVsdGlwbGU6ICdtdWx0aXBsZSd9KTtcbiAgICAgICAgICAgIHN0YWJIb2xkZXIuYXBwZW5kQ2hpbGQoaW5kZXhGaWxlKTtcbiAgICAgICAgICAgIGluZGV4RmlsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmaWxlc2V0IGNoYW5nZWQnKTtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZUxpc3QgPSBpbmRleEZpbGUuZmlsZXMgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZmkgPSAwOyBmaSA8IGZpbGVMaXN0Lmxlbmd0aDsgKytmaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGZpbGVMaXN0W2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBucyA9IHtibG9iOiBmLCBoaWRkZW46IHRydWV9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVTZXQucHVzaChucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9iZU11bHRpcGxlKG5zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYW5CdXR0b24gPSBtYWtlRWxlbWVudCgnYnV0dG9uJywgJ0NhbmNlbCcsIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgY2FuQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChjdXN0b21Nb2RlID09PSAnZmluYWxpemUtYmluJylcbiAgICAgICAgICAgIHN3aXRjaFRvQmluTW9kZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzd2l0Y2hUb0N1c3RvbU1vZGUoKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgcmVmcmVzaEJ1dHRvbiA9IG1ha2VFbGVtZW50KCdidXR0b24nLCAnUmVmcmVzaCcsIHtjbGFzc05hbWU6ICdidG4nfSk7XG4gICAgcmVmcmVzaEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpOyBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzQi5xdWVyeVJlZ2lzdHJ5KF9fbWFwcGluZyk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHRoaXMubWFrZVRvb2x0aXAocmVmcmVzaEJ1dHRvbiwgJ0NsaWNrIHRvIHJlLWZldGNoIGRhdGEgZnJvbSB0aGUgREFTIHJlZ2lzdHJ5Jyk7XG5cbiAgICB2YXIgYnV0dG9uSG9sZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIFthZGRCdXR0b24sICcgJywgY2FuQnV0dG9uLCAnICcsIHJlZnJlc2hCdXR0b25dKTtcbiAgICBidXR0b25Ib2xkZXIuc3R5bGUubWFyZ2luID0gJzEwcHgnO1xuICAgIGFzZm9ybS5hcHBlbmRDaGlsZChidXR0b25Ib2xkZXIpO1xuXG4gICAgcG9wdXAuYXBwZW5kQ2hpbGQoYXNmb3JtKTtcbiAgICBtYWtlU3RhYih0aGlzQi5hdmFpbGFibGVTb3VyY2VzKTtcblxuICAgIHRoaXMuc2hvd1Rvb2xQYW5lbChwb3B1cCk7XG4gICAgdGhpcy5zZXRVaU1vZGUoJ2FkZCcpO1xuXG4gICAgaWYgKGZpcnN0RGVmQnV0dG9uKSB7XG4gICAgICAgIGFjdGl2YXRlQnV0dG9uKGFkZE1vZGVCdXR0b25zLCBmaXJzdERlZkJ1dHRvbik7XG4gICAgICAgIG1ha2VTdGFiKG5ldyBPYnNlcnZlZChmaXJzdERlZlNvdXJjZXMpKTtcbiAgICB9XG59XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBEYWxsaWFuY2UgR2Vub21lIEV4cGxvcmVyXG4vLyAoYykgVGhvbWFzIERvd24gMjAwNi0yMDEwXG4vL1xuLy8gdHJpeC5qczogVUNTQy1zdHlsZSBmcmVlIHRleHQgaW5kaWNlc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIGNvbm5lY3RUcml4KGl4LCBpeHgsIGNhbGxiYWNrKSB7XG4gICAgaXh4LmZldGNoQXNUZXh0KGZ1bmN0aW9uKGl4eERhdGEpIHtcbiAgICAgICAgaWYgKCFpeHhEYXRhKSBcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBcIkNvdWxkbid0IGZldGNoIGluZGV4LWluZGV4XCIpO1xuXG4gICAgICAgIHZhciB0b2tzID0gaXh4RGF0YS5zcGxpdCgvKC4rKShbMC05QS1GXXsxMH0pXFxuLyk7XG5cbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgdmFyIG9mZnNldHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgdGkgPSAxOyB0aSA8IHRva3MubGVuZ3RoOyB0aSArPSAzKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2godG9rc1t0aV0pO1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlSW50KHRva3NbdGkrMV0sIDE2KSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IFRyaXhJbmRleChrZXlzLCBvZmZzZXRzLCBpeCkpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBUcml4SW5kZXgoa2V5cywgb2Zmc2V0cywgaXgpIHtcbiAgICB0aGlzLmtleXMgPSBrZXlzO1xuICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7XG4gICAgdGhpcy5peCA9IGl4O1xufVxuXG5Ucml4SW5kZXgucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uKHF1ZXJ5LCBjYWxsYmFjaykge1xuICAgIHZhciBpeHNsaWNlO1xuXG4gICAgdmFyIHF0YWcgPSAocXVlcnkgKyAnICAgICAnKS5zdWJzdHJpbmcoMCw1KS50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChxdGFnLmxvY2FsZUNvbXBhcmUodGhpcy5rZXlzW2ldKSA8IDApIHtcbiAgICAgICAgICAgIGl4c2xpY2UgPSB0aGlzLml4LnNsaWNlKHRoaXMub2Zmc2V0c1tpIC0gMV0sIHRoaXMub2Zmc2V0c1tpXSAtIHRoaXMub2Zmc2V0c1tpIC0gMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWl4c2xpY2UpIHtcbiAgICAgICAgaXhzbGljZSA9IHRoaXMuaXguc2xpY2UodGhpcy5vZmZzZXRzW3RoaXMub2Zmc2V0cy5sZW5ndGggLSAxXSk7XG4gICAgfVxuXG4gICAgaXhzbGljZS5mZXRjaEFzVGV4dChmdW5jdGlvbihpc3QpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gaXN0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yICh2YXIgbGkgPSAwOyBsaSA8IGxpbmVzLmxlbmd0aDsgKytsaSkge1xuICAgICAgICAgICAgaWYgKGxpbmVzW2xpXS5pbmRleE9mKHF1ZXJ5LnRvTG93ZXJDYXNlKCkgKyAnICcpID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobGluZXNbbGldLnNwbGl0KCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTtcbiAgICB9KTtcbn1cblxuaWYgKHR5cGVvZihtb2R1bGUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBjb25uZWN0VHJpeDogY29ubmVjdFRyaXhcbiAgICB9O1xufSIsIi8qIC0qLSBtb2RlOiBqYXZhc2NyaXB0OyBjLWJhc2ljLW9mZnNldDogNDsgaW5kZW50LXRhYnMtbW9kZTogbmlsIC0qLSAqL1xuXG4vLyBcbi8vIERhbGxpYW5jZSBHZW5vbWUgRXhwbG9yZXJcbi8vIChjKSBUaG9tYXMgRG93biAyMDA2LTIwMTBcbi8vXG4vLyB0d29CaXQuanM6IHBhY2tlZC1iaW5hcnkgcmVmZXJlbmNlIHNlcXVlbmNlc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGJpbiA9IHJlcXVpcmUoJy4vYmluJyk7XG4gICAgdmFyIHJlYWRJbnQgPSBiaW4ucmVhZEludDtcbiAgICB2YXIgcmVhZEludEJFID0gYmluLnJlYWRJbnRCRTtcblxuICAgIHZhciBzcGFucyA9IHJlcXVpcmUoJy4vc3BhbnMnKTtcbiAgICB2YXIgUmFuZ2UgPSBzcGFucy5SYW5nZTtcbiAgICB2YXIgdW5pb24gPSBzcGFucy51bmlvbjtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gc3BhbnMuaW50ZXJzZWN0aW9uO1xufVxuXG52YXIgVFdPQklUX01BR0lDID0gMHgxYTQxMjc0MztcbnZhciBUV09CSVRfTUFHSUNfQkUgPSAweDQzMjc0MTFhO1xuXG5mdW5jdGlvbiBUd29CaXRGaWxlKCkge1xufVxuXG5mdW5jdGlvbiBtYWtlVHdvQml0KGZldGNoYWJsZSwgY250KSB7XG4gICAgdmFyIHRiID0gbmV3IFR3b0JpdEZpbGUoKTtcbiAgICB0Yi5kYXRhID0gZmV0Y2hhYmxlO1xuICAgIHZhciBoZWFkZXJCbG9ja1NpemUgPSAxMjUwMDtcblxuICAgIHRiLmRhdGEuc2xpY2UoMCwgaGVhZGVyQmxvY2tTaXplKS5mZXRjaChmdW5jdGlvbihyKSB7XG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgcmV0dXJuIGNudChudWxsLCBcIkNvdWxkbid0IGFjY2VzcyBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KHIpO1xuICAgICAgICB2YXIgbWFnaWMgPSByZWFkSW50KGJhLCAwKTtcbiAgICAgICAgaWYgKG1hZ2ljID09IFRXT0JJVF9NQUdJQykge1xuICAgICAgICAgICAgdGIucmVhZEludCA9IHJlYWRJbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAobWFnaWMgPT0gVFdPQklUX01BR0lDX0JFKSB7XG4gICAgICAgICAgICB0Yi5yZWFkSW50ID0gcmVhZEludEJFO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNudChudWxsLCBcIk5vdCBhIC4yYml0IGZpbGUsIG1hZ2ljPTB4XCIgKyBtYWdpYy50b1N0cmluZygxNikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnNpb24gPSB0Yi5yZWFkSW50KGJhLCA0KTtcbiAgICAgICAgaWYgKHZlcnNpb24gIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNudChudWxsLCAnVW5zdXBwb3J0ZWQgdmVyc2lvbiAnICsgdmVyc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0Yi5zZXFDb3VudCA9IHRiLnJlYWRJbnQoYmEsIDgpO1xuICAgICAgICB0Yi5zZXFEaWN0ID0ge307XG5cbiAgICAgICAgdmFyIHAgPSAxNiwgaT0wO1xuICAgICAgICB2YXIgbyA9IDA7ICAvLyBPZmZzZXQgb2YgdGhlIGN1cnJlbnQgYmxvY2sgaWYgd2UgbmVlZCB0byBmZXRjaCBtdWx0aXBsZSBoZWFkZXIgYmxvY2tzLlxuXG4gICAgICAgIHZhciBwYXJzZVNlcUluZm8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgdGIuc2VxQ291bnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnMgPSBiYVtwXTtcbiAgICAgICAgICAgICAgICBpZiAocCArIG5zICsgNiA+PSBiYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRiLmRhdGEuc2xpY2UobyArIHAsIGhlYWRlckJsb2NrU2l6ZSkuZmV0Y2goZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG8gKz0gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmEgPSBuZXcgVWludDhBcnJheShyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU2VxSW5mbygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICArK3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IG5zOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShiYVtwKytdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdGIucmVhZEludChiYSwgcCk7XG4gICAgICAgICAgICAgICAgICAgIHAgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGIuc2VxRGljdFtuYW1lXSA9IG5ldyBUd29CaXRTZXEodGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY250KHRiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlU2VxSW5mbygpO1xuICAgICAgICBcbiAgICB9KTtcbn1cblxuVHdvQml0RmlsZS5wcm90b3R5cGUuZ2V0U2VxID0gZnVuY3Rpb24oY2hyKSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuc2VxRGljdFtjaHJdO1xuICAgIGlmICghc2VxKSB7XG4gICAgICAgIHNlcSA9IHRoaXMuc2VxRGljdFsnY2hyJyArIGNocl07XG4gICAgfVxuICAgIHJldHVybiBzZXE7XG59XG5cblR3b0JpdEZpbGUucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24oY2hyLCBtaW4sIG1heCwgY250KSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuZ2V0U2VxKGNocik7XG4gICAgaWYgKCFzZXEpIHtcbiAgICAgICAgcmV0dXJuIGNudChudWxsLCBcIkNvdWxkbid0IGZpbmQgXCIgKyBjaHIpO1xuICAgIH0gZWxzZSBpZiAobWF4IDw9IG1pbikge1xuICAgICAgICByZXR1cm4gY250KCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXEuZmV0Y2gobWluLCBtYXgsIGNudCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBUd29CaXRTZXEodGJmLCBvZmZzZXQpIHtcbiAgICB0aGlzLnRiZiA9IHRiZjtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbn1cblxuVHdvQml0U2VxLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oY250KSB7XG4gICAgaWYgKHRoaXMuc2VxT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBjbnQoKTtcbiAgICB9XG5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXNCLnRiZi5kYXRhLnNsaWNlKHRoaXNCLm9mZnNldCwgOCkuZmV0Y2goZnVuY3Rpb24ocjEpIHtcbiAgICAgICAgaWYgKCFyMSkge1xuICAgICAgICAgICAgcmV0dXJuIGNudCgnRmV0Y2ggZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhID0gbmV3IFVpbnQ4QXJyYXkocjEpO1xuICAgICAgICB0aGlzQi5fbGVuZ3RoID0gdGhpc0IudGJmLnJlYWRJbnQoYmEsIDApO1xuICAgICAgICB0aGlzQi5uQmxvY2tDbnQgPSB0aGlzQi50YmYucmVhZEludChiYSwgNCk7XG4gICAgICAgIHRoaXNCLnRiZi5kYXRhLnNsaWNlKHRoaXNCLm9mZnNldCArIDgsIHRoaXNCLm5CbG9ja0NudCo4ICsgNCkuZmV0Y2goZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgICAgIGlmICghcjIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY250KCdGZXRjaCBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYSA9IG5ldyBVaW50OEFycmF5KHIyKTtcbiAgICAgICAgICAgIHZhciBuYnMgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCB0aGlzQi5uQmxvY2tDbnQ7ICsrYikge1xuICAgICAgICAgICAgICAgIHZhciBuYk1pbiA9IHRoaXNCLnRiZi5yZWFkSW50KGJhLCBiICogNCk7XG4gICAgICAgICAgICAgICAgdmFyIG5iTGVuID0gdGhpc0IudGJmLnJlYWRJbnQoYmEsIChiICsgdGhpc0IubkJsb2NrQ250KSAqIDQpO1xuICAgICAgICAgICAgICAgIHZhciBuYiA9IG5ldyBSYW5nZShuYk1pbiwgbmJNaW4gKyBuYkxlbiAtIDEpO1xuICAgICAgICAgICAgICAgIGlmICghbmJzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5icyA9IG5iO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5icyA9IHVuaW9uKG5icywgbmIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNCLm5CbG9ja3MgPSBuYnM7XG4gICAgICAgICAgICB0aGlzQi5tQmxvY2tDbnQgPSB0aGlzQi50YmYucmVhZEludChiYSwgdGhpc0IubkJsb2NrQ250KjgpO1xuICAgICAgICAgICAgdGhpc0Iuc2VxTGVuZ3RoID0gKCh0aGlzQi5fbGVuZ3RoICsgMykvNCl8MDtcbiAgICAgICAgICAgIHRoaXNCLnNlcU9mZnNldCA9IHRoaXNCLm9mZnNldCArIDE2ICsgKCh0aGlzQi5uQmxvY2tDbnQgKyB0aGlzQi5tQmxvY2tDbnQpICogOCk7XG4gICAgICAgICAgICByZXR1cm4gY250KCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG52YXIgVFdPQklUX1RBQkxFID0gWydUJywgJ0MnLCAnQScsICdHJ107XG5cblR3b0JpdFNlcS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihtaW4sIG1heCwgY250KSB7XG4gICAgLS1taW47IC0tbWF4OyAgICAgICAvLyBTd2l0Y2ggdG8gemVyby1iYXNlZC5cbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuaW5pdChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjbnQobnVsbCwgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZldGNoTWluID0gbWluID4+IDI7XG4gICAgICAgIHZhciBmZXRjaE1heCA9IG1heCArIDMgPj4gMjtcbiAgICAgICAgaWYgKGZldGNoTWluIDwgMCB8fCBmZXRjaE1heCA+IHRoaXNCLnNlcUxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGNudCgnQ29vcmRpbmF0ZXMgb3V0IG9mIGJvdW5kczogJyArIG1pbiArICc6JyArIG1heCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzQi50YmYuZGF0YS5zbGljZSh0aGlzQi5zZXFPZmZzZXQgKyBmZXRjaE1pbiwgZmV0Y2hNYXggLSBmZXRjaE1pbikuc2FsdGVkKCkuZmV0Y2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKHIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbnQoJ1NlcUZldGNoIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNlcURhdGEgPSBuZXcgVWludDhBcnJheShyKTtcblxuICAgICAgICAgICAgdmFyIG5TcGFucyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXNCLm5CbG9ja3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW50ciA9IGludGVyc2VjdGlvbihuZXcgUmFuZ2UobWluLCBtYXgpLCB0aGlzQi5uQmxvY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW50cikge1xuICAgICAgICAgICAgICAgICAgICBuU3BhbnMgPSBpbnRyLnJhbmdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNlcXN0ciA9ICcnO1xuICAgICAgICAgICAgdmFyIHB0ciA9IG1pbjtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbGxTZXEoZnNtKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHB0ciA8PSBmc20pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJiID0gKHB0ciA+PiAyKSAtIGZldGNoTWluO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmkgPSBwdHIgJiAweDM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBidiA9IHNlcURhdGFbYmJdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAoYnYgPj4gNikgJiAweDM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmkgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IChidiA+PiA0KSAmIDB4MztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuaSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuID0gKGJ2ID4+IDIpICYgMHgzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IChidikgJiAweDM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2Vxc3RyICs9IFRXT0JJVF9UQUJMRVtuXTtcbiAgICAgICAgICAgICAgICAgICAgKytwdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IG5TcGFucy5sZW5ndGg7ICsrYikge1xuICAgICAgICAgICAgICAgIHZhciBuYiA9IG5TcGFuc1tiXTtcbiAgICAgICAgICAgICAgICBpZiAocHRyID4gbmIubWluKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ04gbWlzbWF0Y2guLi4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHRyIDwgbmIubWluKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbFNlcShuYi5taW4oKSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAocHRyIDw9IG5iLm1heCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcXN0ciArPSAnTic7XG4gICAgICAgICAgICAgICAgICAgICsrcHRyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwdHIgPD0gbWF4KSB7XG4gICAgICAgICAgICAgICAgZmlsbFNlcShtYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNudChzZXFzdHIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuVHdvQml0U2VxLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbihjbnQpIHtcbiAgICB2YXIgdGhpc0IgPSB0aGlzO1xuICAgIHRoaXMuaW5pdChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjbnQobnVsbCwgZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNudCh0aGlzQi5fbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIG1ha2VUd29CaXQ6IG1ha2VUd29CaXRcbiAgICB9O1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIHV0aWxzLmpzOiBvZGRzLCBzb2RzLCBhbmQgZW5kcy5cbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBzaGExID0gcmVxdWlyZSgnLi9zaGExJyk7XG4gICAgdmFyIGI2NF9zaGExID0gc2hhMS5iNjRfc2hhMTtcbn1cblxudmFyIE5VTV9SRUdFWFAgPSBuZXcgUmVnRXhwKCdbMC05XSsnKTtcblxuZnVuY3Rpb24gc3RyaW5nVG9OdW1iZXJzQXJyYXkoc3RyKSB7XG4gICAgdmFyIG51bXMgPSBuZXcgQXJyYXkoKTtcbiAgICB2YXIgbTtcbiAgICB3aGlsZSAobSA9IE5VTV9SRUdFWFAuZXhlYyhzdHIpKSB7XG4gICAgICAgIG51bXMucHVzaChtWzBdKTtcbiAgICAgICAgc3RyPXN0ci5zdWJzdHJpbmcobS5pbmRleCArIChtWzBdLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtcztcbn1cblxudmFyIFNUUklDVF9OVU1fUkVHRVhQID0gbmV3IFJlZ0V4cCgnXlswLTldKyQnKTtcblxuZnVuY3Rpb24gc3RyaW5nVG9JbnQoc3RyKSB7XG4gICAgc3RyID0gc3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnLCcsICdnJyksICcnKTtcbiAgICBpZiAoIVNUUklDVF9OVU1fUkVHRVhQLnRlc3Qoc3RyKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnwwO1xufVxuXG5mdW5jdGlvbiBwdXNobmV3KGEsIHYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGFbaV0gPT0gdikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGEucHVzaCh2KTtcbn1cblxuZnVuY3Rpb24gcHVzaG8ob2JqLCBrLCB2KSB7XG4gICAgaWYgKG9ialtrXSkge1xuICAgICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba10gPSBbdl07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwdXNobmV3byhvYmosIGssIHYpIHtcbiAgICB2YXIgYSA9IG9ialtrXTtcbiAgICBpZiAoYSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHsgICAgLy8gaW5kZXhPZiByZXF1aXJlcyBKUzE2IDotKC5cbiAgICAgICAgICAgIGlmIChhW2ldID09IHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrXSA9IFt2XTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gcGljayhhLCBiLCBjLCBkKVxue1xuICAgIGlmIChhKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH0gZWxzZSBpZiAoYikge1xuICAgICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfSBlbHNlIGlmIChkKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHVzaG5ldyhsLCBvKVxue1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobFtpXSA9PSBvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgbC5wdXNoKG8pO1xufVxuXG5cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mKGEsIHgpIHtcbiAgICBpZiAoIWEpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYVtpXSA9PT0geCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBhcnJheVJlbW92ZShhLCB4KSB7XG4gICAgdmFyIGkgPSBhcnJheUluZGV4T2YoYSwgeCk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBhLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLy9cbi8vIERPTSB1dGlsaXRpZXNcbi8vXG5cblxuZnVuY3Rpb24gbWFrZUVsZW1lbnQodGFnLCBjaGlsZHJlbiwgYXR0cmlicywgc3R5bGVzKVxue1xuICAgIHZhciBlbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghIChjaGlsZHJlbiBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoYykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycgKyBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxlLmFwcGVuZENoaWxkKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChhdHRyaWJzKSB7XG4gICAgICAgIGZvciAodmFyIGwgaW4gYXR0cmlicykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBlbGVbbF0gPSBhdHRyaWJzW2xdO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvciBzZXR0aW5nICcgKyBsKTtcbiAgICAgICAgICAgICAgICB0aHJvdyhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgIGZvciAodmFyIGwgaW4gc3R5bGVzKSB7XG4gICAgICAgICAgICBlbGUuc3R5bGVbbF0gPSBzdHlsZXNbbF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZTtcbn1cblxuZnVuY3Rpb24gbWFrZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZywgY2hpbGRyZW4sIGF0dHJpYnMpXG57XG4gICAgdmFyIGVsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2UsIHRhZyk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGlmICghIChjaGlsZHJlbiBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBbY2hpbGRyZW5dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBjID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGMgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGUuYXBwZW5kQ2hpbGQoYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2V0QXR0cnMoZWxlLCBhdHRyaWJzKTtcbiAgICByZXR1cm4gZWxlO1xufVxuXG52YXIgYXR0cl9uYW1lX2NhY2hlID0ge307XG5cbmZ1bmN0aW9uIHNldEF0dHIobm9kZSwga2V5LCB2YWx1ZSlcbntcbiAgICB2YXIgYXR0ciA9IGF0dHJfbmFtZV9jYWNoZVtrZXldO1xuICAgIGlmICghYXR0cikge1xuICAgICAgICB2YXIgX2F0dHIgPSAnJztcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBrZXkubGVuZ3RoOyArK2MpIHtcbiAgICAgICAgICAgIHZhciBjYyA9IGtleS5zdWJzdHJpbmcoYywgYysxKTtcbiAgICAgICAgICAgIHZhciBsY2MgPSBjYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGxjYyAhPSBjYykge1xuICAgICAgICAgICAgICAgIF9hdHRyID0gX2F0dHIgKyAnLScgKyBsY2M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9hdHRyID0gX2F0dHIgKyBjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRyX25hbWVfY2FjaGVba2V5XSA9IF9hdHRyO1xuICAgICAgICBhdHRyID0gX2F0dHI7XG4gICAgfVxuICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gc2V0QXR0cnMobm9kZSwgYXR0cmlicylcbntcbiAgICBpZiAoYXR0cmlicykge1xuICAgICAgICBmb3IgKHZhciBsIGluIGF0dHJpYnMpIHtcbiAgICAgICAgICAgIHNldEF0dHIobm9kZSwgbCwgYXR0cmlic1tsXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZHJlbihub2RlKVxue1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbn1cblxuXG5cbi8vXG4vLyBXQVJOSU5HOiBub3QgZm9yIGdlbmVyYWwgdXNlIVxuLy9cblxuZnVuY3Rpb24gbWluaUpTT05pZnkobywgZXhjKSB7XG4gICAgaWYgKHR5cGVvZiBvID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gICAgfSBlbHNlIGlmIChvID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIG8gKyBcIidcIjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBcIlwiICsgbztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvID09ICdib29sZWFuJykge1xuICAgICAgICByZXR1cm4gXCJcIiArIG87XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcyA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBzID0gKHMgPT0gbnVsbCA/ICcnIDogKHMgKyAnLCAnKSkgKyBtaW5pSlNPTmlmeShvW2ldLCBleGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdbJyArIChzP3M6JycpICsgJ10nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhjID0gZXhjIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y1trXSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGsgIT0gdW5kZWZpbmVkICYmIHR5cGVvZihvW2tdKSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSAocyA9PSBudWxsID8gJycgOiAocyArICcsICcpKSArIGsgKyAnOiAnICsgbWluaUpTT05pZnkob1trXSwgZXhjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ3snICsgKHM/czonJykgKyAnfSc7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBvKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDb3B5KG8pIHtcbiAgICB2YXIgbiA9IHt9O1xuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgICBuW2tdID0gb1trXTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIE9ic2VydmVkKHgpIHtcbiAgICB0aGlzLnZhbHVlID0geDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xufVxuXG5PYnNlcnZlZC5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbihmKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMucHVzaChmKTtcbn1cblxuT2JzZXJ2ZWQucHJvdG90eXBlLmFkZExpc3RlbmVyQW5kRmlyZSA9IGZ1bmN0aW9uKGYpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGYpO1xuICAgIGYodGhpcy52YWx1ZSk7XG59XG5cbk9ic2VydmVkLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGYpIHtcbiAgICBhcnJheVJlbW92ZSh0aGlzLmxpc3RlbmVycywgZik7XG59XG5cbk9ic2VydmVkLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn1cblxuT2JzZXJ2ZWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgpIHtcbiAgICB0aGlzLnZhbHVlID0geDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2ldKHgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gQXdhaXRlZCgpIHtcbiAgICB0aGlzLnF1ZXVlID0gW107XG59XG5cbkF3YWl0ZWQucHJvdG90eXBlLnByb3ZpZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHRoaXMucmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgXCJSZXNvdXJjZSBoYXMgYWxyZWFkeSBiZWVuIHByb3ZpZGVkLlwiO1xuICAgIH1cblxuICAgIHRoaXMucmVzID0geDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5xdWV1ZVtpXSh4KTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZSA9IG51bGw7ICAgLy8gYXZvaWQgbGVha2luZyBjbG9zdXJlcy5cbn1cblxuQXdhaXRlZC5wcm90b3R5cGUuYXdhaXQgPSBmdW5jdGlvbihmKSB7XG4gICAgaWYgKHRoaXMucmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZih0aGlzLnJlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZik7XG4gICAgfVxufVxuXG52YXIgX19kYWxsaWFuY2Vfc2FsdFNlZWQgPSAwO1xuXG5mdW5jdGlvbiBzYWx0VVJMKHVybCkge1xuICAgIHJldHVybiB1cmwgKyAnP3NhbHQ9JyArIGI2NF9zaGExKCcnICsgRGF0ZS5ub3coKSArICcsJyArICgrK19fZGFsbGlhbmNlX3NhbHRTZWVkKSk7XG59XG5cbmZ1bmN0aW9uIHRleHRYSFIodXJsLCBjYWxsYmFjaywgb3B0cykge1xuICAgIGlmIChvcHRzICYmIG9wdHMuc2FsdCkgXG4gICAgICAgIHVybCA9IHNhbHRVUkwodXJsKTtcblxuICAgIHRyeSB7XG4gICAgICAgIHZhciB0aW1lb3V0O1xuICAgICAgICBpZiAob3B0cy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RpbWluZyBvdXQgJyArIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgJ1RpbWVvdXQnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9wdHMudGltZW91dFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIFx0ICAgIGlmIChyZXEucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQpXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICBcdCAgICAgICAgaWYgKHJlcS5zdGF0dXMgPCAyMDAgfHwgcmVxLnN0YXR1cyA+PSAzMDApIHtcbiAgICBcdFx0ICAgIGNhbGxiYWNrKG51bGwsICdFcnJvciBjb2RlICcgKyByZXEuc3RhdHVzKTtcbiAgICBcdCAgICAgICAgfSBlbHNlIHtcbiAgICBcdFx0ICAgIGNhbGxiYWNrKHJlcS5yZXNwb25zZVRleHQpO1xuICAgIFx0ICAgICAgICB9XG4gICAgXHQgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcmVxLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7XG4gICAgICAgIHJlcS5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG5cbiAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmVxLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVxLnNlbmQoJycpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgJ0V4Y2VwdGlvbiAnICsgZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWxhdGl2ZVVSTChiYXNlLCByZWwpIHtcbiAgICAvLyBGSVhNRSBxdWl0ZSBuYWl2ZSAtLSBnb29kIGVub3VnaCBmb3IgdHJhY2todWJzP1xuXG4gICAgaWYgKHJlbC5pbmRleE9mKCdodHRwOicpID09IDAgfHwgcmVsLmluZGV4T2YoJ2h0dHBzOicpID09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlbDtcbiAgICB9XG5cbiAgICB2YXIgbGkgPSBiYXNlLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgaWYgKGxpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGJhc2Uuc3Vic3RyKDAsIGxpICsgMSkgKyByZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlbDtcbiAgICB9XG59XG5cbnZhciBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OID0ge1xuICAgICdUVFQnOiAnRicsXG4gICAgJ1RUQyc6ICdGJyxcbiAgICAnVFRBJzogJ0wnLFxuICAgICdUVEcnOiAnTCcsXG4gICAgJ0NUVCc6ICdMJyxcbiAgICAnQ1RDJzogJ0wnLFxuICAgICdDVEEnOiAnTCcsXG4gICAgJ0NURyc6ICdMJyxcbiAgICAnQVRUJzogJ0knLFxuICAgICdBVEMnOiAnSScsXG4gICAgJ0FUQSc6ICdJJyxcbiAgICAnQVRHJzogJ00nLFxuICAgICdHVFQnOiAnVicsXG4gICAgJ0dUQyc6ICdWJyxcbiAgICAnR1RBJzogJ1YnLFxuICAgICdHVEcnOiAnVicsXG4gICAgJ1RDVCc6ICdTJyxcbiAgICAnVENDJzogJ1MnLFxuICAgICdUQ0EnOiAnUycsXG4gICAgJ1RDRyc6ICdTJyxcbiAgICAnQ0NUJzogJ1AnLFxuICAgICdDQ0MnOiAnUCcsXG4gICAgJ0NDQSc6ICdQJyxcbiAgICAnQ0NHJzogJ1AnLFxuICAgICdBQ1QnOiAnVCcsXG4gICAgJ0FDQyc6ICdUJyxcbiAgICAnQUNBJzogJ1QnLFxuICAgICdBQ0cnOiAnVCcsXG4gICAgJ0dDVCc6ICdBJyxcbiAgICAnR0NDJzogJ0EnLFxuICAgICdHQ0EnOiAnQScsXG4gICAgJ0dDRyc6ICdBJyxcbiAgICAnVEFUJzogJ1knLFxuICAgICdUQUMnOiAnWScsXG4gICAgJ1RBQSc6ICcqJywgIC8vIHN0b3BcbiAgICAnVEFHJzogJyonLCAgLy8gc3RvcFxuICAgICdDQVQnOiAnSCcsXG4gICAgJ0NBQyc6ICdIJyxcbiAgICAnQ0FBJzogJ1EnLFxuICAgICdDQUcnOiAnUScsXG4gICAgJ0FBVCc6ICdOJyxcbiAgICAnQUFDJzogJ04nLFxuICAgICdBQUEnOiAnSycsXG4gICAgJ0FBRyc6ICdLJyxcbiAgICAnR0FUJzogJ0QnLFxuICAgICdHQUMnOiAnRCcsXG4gICAgJ0dBQSc6ICdFJyxcbiAgICAnR0FHJzogJ0UnLFxuICAgICdUR1QnOiAnQycsXG4gICAgJ1RHQyc6ICdDJyxcbiAgICAnVEdBJzogJyonLCAgLy8gc3RvcFxuICAgICdUR0cnOiAnVycsXG4gICAgJ0NHVCc6ICdSJyxcbiAgICAnQ0dDJzogJ1InLFxuICAgICdDR0EnOiAnUicsXG4gICAgJ0NHRyc6ICdSJyxcbiAgICAnQUdUJzogJ1MnLFxuICAgICdBR0MnOiAnUycsXG4gICAgJ0FHQSc6ICdSJyxcbiAgICAnQUdHJzogJ1InLFxuICAgICdHR1QnOiAnRycsXG4gICAgJ0dHQyc6ICdHJyxcbiAgICAnR0dBJzogJ0cnLFxuICAgICdHR0cnOiAnRydcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVVybFRvUGFnZShyZWwpIHtcbiAgICByZXR1cm4gbWFrZUVsZW1lbnQoJ2EnLCBudWxsLCB7aHJlZjogcmVsfSkuaHJlZjtcbn1cblxuLy9cbi8vIE1pc3NpbmcgQVBJc1xuLy8gXG5cbmlmICghKCd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlKSkge1xuICAgIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC9eXFxzKy8sICcnKS5yZXBsYWNlKC9cXHMrJC8sICcnKTtcbiAgICB9O1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICAgIHRleHRYSFI6IHRleHRYSFIsXG4gICAgICAgIHJlbGF0aXZlVVJMOiByZWxhdGl2ZVVSTCxcbiAgICAgICAgcmVzb2x2ZVVybFRvUGFnZTogcmVzb2x2ZVVybFRvUGFnZSxcbiAgICAgICAgc2hhbGxvd0NvcHk6IHNoYWxsb3dDb3B5LFxuICAgICAgICBwdXNobzogcHVzaG8sXG4gICAgICAgIHB1c2huZXc6IHB1c2huZXcsXG4gICAgICAgIHB1c2huZXdvOiBwdXNobmV3byxcbiAgICAgICAgYXJyYXlJbmRleE9mOiBhcnJheUluZGV4T2YsXG4gICAgICAgIHBpY2s6IHBpY2ssXG5cbiAgICAgICAgbWFrZUVsZW1lbnQ6IG1ha2VFbGVtZW50LFxuICAgICAgICBtYWtlRWxlbWVudE5TOiBtYWtlRWxlbWVudE5TLFxuICAgICAgICByZW1vdmVDaGlsZHJlbjogcmVtb3ZlQ2hpbGRyZW4sXG5cbiAgICAgICAgbWluaUpTT05pZnk6IG1pbmlKU09OaWZ5LFxuXG4gICAgICAgIE9ic2VydmVkOiBPYnNlcnZlZCxcbiAgICAgICAgQXdhaXRlZDogQXdhaXRlZCxcblxuICAgICAgICBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OOiBBTUlOT19BQ0lEX1RSQU5TTEFUSU9OXG4gICAgfVxufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIHZjZi5qc1xuLy9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YocmVxdWlyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHNhID0gcmVxdWlyZSgnLi9zb3VyY2VhZGFwdGVycycpO1xuICAgIHZhciBkYWxsaWFuY2VfcmVnaXN0ZXJQYXJzZXJGYWN0b3J5ID0gc2EucmVnaXN0ZXJQYXJzZXJGYWN0b3J5O1xuXG4gICAgdmFyIGRhcyA9IHJlcXVpcmUoJy4vZGFzJyk7XG4gICAgdmFyIERBU1N0eWxlc2hlZXQgPSBkYXMuREFTU3R5bGVzaGVldDtcbiAgICB2YXIgREFTU3R5bGUgPSBkYXMuREFTU3R5bGU7XG4gICAgdmFyIERBU0ZlYXR1cmUgPSBkYXMuREFTRmVhdHVyZTtcbiAgICB2YXIgREFTR3JvdXAgPSBkYXMuREFTR3JvdXA7XG59XG5cbmZ1bmN0aW9uIFZDRlBhcnNlcigpIHtcbiAgICB0aGlzLmluZm8gPSBbXTtcbn1cblxudmFyIFZDRl9JTkZPX1JFID0gLyhbXjs9XSspKD0oW147XSspKT87Py87XG52YXIgVkNGX0lORk9fSEVBREVSID0gLyMjSU5GTz08KFtePl0rKT4vO1xudmFyIFZDRl9JTkZPX0hFQURFUl9UT0sgPSAvKFteLD1dKyk9KFteLF0rfFwiW15cIl0rXCIpLD8vXG5cblZDRlBhcnNlci5wcm90b3R5cGUuY3JlYXRlU2Vzc2lvbiA9IGZ1bmN0aW9uKHNpbmspIHtcbiAgICByZXR1cm4gbmV3IFZDRlBhcnNlU2Vzc2lvbih0aGlzLCBzaW5rKTtcbn1cblxuZnVuY3Rpb24gVkNGUGFyc2VTZXNzaW9uKHBhcnNlciwgc2luaykge1xuICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgIHRoaXMuc2luayAgPSBzaW5rO1xufVxuXG5WQ0ZQYXJzZVNlc3Npb24ucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24obGluZSkge1xuICAgIGlmIChsaW5lLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGxpbmVbMF0gPT0gJyMnKSB7XG4gICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDEgJiYgbGluZVsxXSA9PSAnIycpIHtcbiAgICAgICAgICAgIHZhciBtID0gVkNGX0lORk9fSEVBREVSLmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tzID0gbVsxXS5zcGxpdChWQ0ZfSU5GT19IRUFERVJfVE9LKTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBudWxsLCBkZXNjID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB0aSA9IDA7IHRpIDwgdG9rcy5sZW5ndGggLSAxOyB0aSArPSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSB0b2tzW3RpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRva3NbdGkgKyAyXS5yZXBsYWNlKC9cIi9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ0lEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT0gJ0Rlc2NyaXB0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzYyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBkZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VyLmluZm8ucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIHtpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZGVzYzogZGVzY31cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdG9rcyA9IGxpbmUuc3BsaXQoJ1xcdCcpO1xuICAgIHZhciBmID0gbmV3IERBU0ZlYXR1cmUoKTtcbiAgICBmLnNlZ21lbnQgPSB0b2tzWzBdO1xuICAgIGYuaWQgPSB0b2tzWzJdXG4gICAgZi5yZWZBbGxlbGUgPSB0b2tzWzNdO1xuICAgIGYuYWx0QWxsZWxlcyA9IHRva3NbNF0uc3BsaXQoJywnKTtcbiAgICBmLm1pbiA9IHBhcnNlSW50KHRva3NbMV0pO1xuICAgIGYubWF4ID0gZi5taW4gKyBmLnJlZkFsbGVsZS5sZW5ndGggLSAxO1xuXG4gICAgdmFyIGluZm9Ub2tzID0gdG9rc1s3XS5zcGxpdChWQ0ZfSU5GT19SRSk7XG4gICAgZi5pbmZvID0ge307XG4gICAgZm9yICh2YXIgdGkgPSAwOyB0aSA8IGluZm9Ub2tzLmxlbmd0aDsgdGkgKz0gNCkge1xuICAgICAgICBmLmluZm9baW5mb1Rva3NbdGkgKyAxXV0gPSBpbmZvVG9rc1t0aSArIDNdO1xuICAgIH1cblxuXG4gICAgdmFyIGFsdCA9IGYuYWx0QWxsZWxlc1swXTtcbiAgICB2YXIgcmVmID0gZi5yZWZBbGxlbGU7XG4gICAgaWYgKGFsdC5sZW5ndGggPiByZWYubGVuZ3RoKSB7XG4gICAgICAgIGYudHlwZSA9IFwiaW5zZXJ0aW9uXCI7XG4gICAgICAgIGlmIChhbHQuaW5kZXhPZihyZWYpID09IDApIHtcbiAgICAgICAgICAgIGYuaW5zZXJ0aW9uID0gYWx0LnN1YnN0cihyZWYubGVuZ3RoKTtcbiAgICAgICAgICAgIGYubWluICs9IHJlZi5sZW5ndGg7XG4gICAgICAgICAgICBmLm1heCA9IGYubWluIC0gMTsgLy8gRWZmZWN0aXZlbHkgXCJiZXR3ZWVuXCIgYmFzZXMuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmLmluc2VydGlvbiA9IGFsdDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0Lmxlbmd0aCA8IHJlZi5sZW5ndGgpIHtcbiAgICAgICAgZi50eXBlID0gXCJkZWxldGlvblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGYudHlwZSA9ICdzdWJzdGl0dXRpb24nO1xuICAgIH1cblxuICAgIHRoaXMuc2luayhmKTtcbn1cblxuVkNGUGFyc2VTZXNzaW9uLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge307XG5cblZDRlBhcnNlci5wcm90b3R5cGUuZ2V0U3R5bGVTaGVldCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgREFTU3R5bGVzaGVldCgpO1xuXG4gICAge1xuICAgICAgICB2YXIgdmFyU3R5bGUgPSBuZXcgREFTU3R5bGUoKTtcbiAgICAgICAgdmFyU3R5bGUuZ2x5cGggPSAnX19JTlNFUlRJT04nO1xuICAgICAgICB2YXJTdHlsZS5CVU1QID0gJ3llcyc7XG4gICAgICAgIHZhclN0eWxlLkxBQkVMID0gJ25vJztcbiAgICAgICAgdmFyU3R5bGUuRkdDT0xPUiA9ICdyZ2IoNTAsODAsMjU1KSc7XG4gICAgICAgIHZhclN0eWxlLkJHQ09MT1IgPSAnIzg4ODg4OCc7XG4gICAgICAgIHZhclN0eWxlLlNUUk9LRUNPTE9SID0gJ2JsYWNrJztcbiAgICAgICAgc3R5bGVzaGVldC5wdXNoU3R5bGUoe3R5cGU6ICdpbnNlcnRpb24nfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdQTElNU09MTCc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ3JnYigyNTUsIDYwLCA2MCknO1xuICAgICAgICB2YXJTdHlsZS5CR0NPTE9SID0gJyM4ODg4ODgnO1xuICAgICAgICB2YXJTdHlsZS5TVFJPS0VDT0xPUiA9ICdibGFjayc7XG4gICAgICAgIHN0eWxlc2hlZXQucHVzaFN0eWxlKHt0eXBlOiAnZGVsZXRpb24nfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cbiAgICB7XG4gICAgICAgIHZhciB2YXJTdHlsZSA9IG5ldyBEQVNTdHlsZSgpO1xuICAgICAgICB2YXJTdHlsZS5nbHlwaCA9ICdQTElNU09MTCc7XG4gICAgICAgIHZhclN0eWxlLkJVTVAgPSAneWVzJztcbiAgICAgICAgdmFyU3R5bGUuTEFCRUwgPSAnbm8nO1xuICAgICAgICB2YXJTdHlsZS5GR0NPTE9SID0gJ3JnYig1MCw4MCwyNTUpJztcbiAgICAgICAgdmFyU3R5bGUuQkdDT0xPUiA9ICcjODg4ODg4JztcbiAgICAgICAgdmFyU3R5bGUuU1RST0tFQ09MT1IgPSAnYmxhY2snO1xuICAgICAgICBzdHlsZXNoZWV0LnB1c2hTdHlsZSh7dHlwZTogJ2RlZmF1bHQnfSwgbnVsbCwgdmFyU3R5bGUpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayhzdHlsZXNoZWV0KTtcbn1cblxuVkNGUGFyc2VyLnByb3RvdHlwZS5nZXREZWZhdWx0RklQcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmaXAgPSBmdW5jdGlvbihmZWF0dXJlLCBmZWF0dXJlSW5mbykge1xuICAgICAgICBmZWF0dXJlSW5mby5hZGQoXCJSZWYuIGFsbGVsZVwiLCBmZWF0dXJlLnJlZkFsbGVsZSk7XG4gICAgICAgIGZlYXR1cmVJbmZvLmFkZChcIkFsdC4gYWxsZWxlc1wiLCBmZWF0dXJlLmFsdEFsbGVsZXMuam9pbignLCcpKTtcblxuICAgICAgICBpZiAoZmVhdHVyZS5pbmZvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgc2VsZi5pbmZvLmxlbmd0aDsgKytpaSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gc2VsZi5pbmZvW2lpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gZmVhdHVyZS5pbmZvW2luZm8uaWRdO1xuICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlSW5mby5hZGQoaW5mby5kZXNjLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY2FsbGJhY2soZmlwKTtcbn1cblxuZGFsbGlhbmNlX3JlZ2lzdGVyUGFyc2VyRmFjdG9yeSgndmNmJywgZnVuY3Rpb24oKSB7cmV0dXJuIG5ldyBWQ0ZQYXJzZXIoKX0pO1xuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxMFxuLy9cbi8vIHZlcnNpb24uanNcbi8vXG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgVkVSU0lPTiA9IHtcbiAgICBDT05GSUc6IDUsXG4gICAgTUFKT1I6ICAwLFxuICAgIE1JTk9SOiAgMTMsXG4gICAgTUlDUk86ICA3LFxuICAgIEJSQU5DSDogJydcbn07XG5cblZFUlNJT04udG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdnMgPSAnJyArIHRoaXMuTUFKT1IgKyAnLicgKyB0aGlzLk1JTk9SICsgJy4nICsgdGhpcy5NSUNSTztcbiAgICBpZiAodGhpcy5QQVRDSCkge1xuICAgICAgICB2cyA9IHZzICsgdGhpcy5QQVRDSDtcbiAgICB9XG4gICAgaWYgKHRoaXMuQlJBTkNIICYmIHRoaXMuQlJBTkNIICE9ICcnKSB7XG4gICAgICAgIHZzID0gdnMgKyAnLScgKyB0aGlzLkJSQU5DSDtcbiAgICB9XG4gICAgcmV0dXJuIHZzO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWRVJTSU9OO1xufVxuIiwiLyogLSotIG1vZGU6IGphdmFzY3JpcHQ7IGMtYmFzaWMtb2Zmc2V0OiA0OyBpbmRlbnQtdGFicy1tb2RlOiBuaWwgLSotICovXG5cbi8vIFxuLy8gRGFsbGlhbmNlIEdlbm9tZSBFeHBsb3JlclxuLy8gKGMpIFRob21hcyBEb3duIDIwMDYtMjAxNFxuLy9cbi8vIHpvb21zbGlkZXIuanM6IGN1c3RvbSBzbGlkZXIgY29tcG9uZW50XG4vL1xuXG5cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mKHJlcXVpcmUpICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbiAgICB2YXIgbWFrZUVsZW1lbnQgPSB1dGlscy5tYWtlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gbWFrZVpvb21TbGlkZXIoKSB7XG4gICAgdmFyIHRyYWNrID0gbWFrZUVsZW1lbnQoJ2hyJywgbnVsbCwge2NsYXNzTmFtZTogJ3NsaWRlci10cmFjayd9KTtcbiAgICB2YXIgdGh1bWIgPSBtYWtlRWxlbWVudCgnaHInLCBudWxsLCB7Y2xhc3NOYW1lOiAnc2xpZGVyLXRodW1iIGFjdGl2ZSd9KTtcbiAgICB2YXIgdGh1bWIyID0gbWFrZUVsZW1lbnQoJ2hyJywgbnVsbCwge2NsYXNzTmFtZTogJ3NsaWRlci10aHVtYid9KTtcbiAgICB2YXIgc2xpZGVyID0gbWFrZUVsZW1lbnQoJ2RpdicsIFt0cmFjaywgdGh1bWIsIHRodW1iMl0sIHtjbGFzc05hbWU6ICdzbGlkZXInfSk7XG4gICAgdmFyIG1pblBvcyA9IDAsIG1heFBvcyA9IDIwMDtcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gMjAwO1xuICAgIHZhciBwb3MgPSA1MCwgcG9zMiA9IDEwMDtcbiAgICB2YXIgbGFiZWxzID0gW107XG5cbiAgICBzbGlkZXIucmVtb3ZlTGFiZWxzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGxpID0gMDsgbGkgPCBsYWJlbHMubGVuZ3RoOyArK2xpKSB7XG4gICAgICAgICAgICBzbGlkZXIucmVtb3ZlQ2hpbGQobGFiZWxzW2xpXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFiZWxzID0gW107XG4gICAgfVxuXG4gICAgc2xpZGVyLmFkZExhYmVsID0gZnVuY3Rpb24odmFsLCB0eHQpIHtcbiAgICAgICAgdmFyIHBvcyA9IChtaW5Qb3MgKyAoKHZhbCAtIG1pbikgKiAobWF4UG9zIC0gbWluUG9zKSkvKG1heC1taW4pKXwwO1xuICAgICAgICB2YXIgbGFiZWwgPSBtYWtlRWxlbWVudCgnZGl2JywgdHh0LCB7Y2xhc3NOYW1lOiAnc2xpZGVyLWxhYmVsJ30sIHtcbiAgICAgICAgICAgIGxlZnQ6ICcnICsgKChtaW5Qb3MgKyAoKHZhbCAtIG1pbikgKiAobWF4UG9zIC0gbWluUG9zKSkvKG1heC1taW4pKXwwKSArICdweCdcbiAgICAgICAgfSk7XG4gICAgICAgIHNsaWRlci5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIGxhYmVscy5wdXNoKGxhYmVsKTtcbiAgICB9XG5cbiAgICB2YXIgb25DaGFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xuICAgIG9uQ2hhbmdlLmluaXRFdmVudCgnY2hhbmdlJywgdHJ1ZSwgZmFsc2UpO1xuXG4gICAgZnVuY3Rpb24gc2V0UG9zKG5wKSB7XG4gICAgICAgIG5wID0gTWF0aC5taW4obnAsIG1heFBvcyk7XG4gICAgICAgIG5wID0gTWF0aC5tYXgobnAsIG1pblBvcyk7XG4gICAgICAgIHBvcyA9IG5wO1xuICAgICAgICB0aHVtYi5zdHlsZS5sZWZ0ID0gJycgKyBwb3MgKyAncHgnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFBvczIobnApIHtcbiAgICAgICAgbnAgPSBNYXRoLm1pbihucCwgbWF4UG9zKTtcbiAgICAgICAgbnAgPSBNYXRoLm1heChucCwgbWluUG9zKTtcbiAgICAgICAgcG9zMiA9IG5wO1xuICAgICAgICB0aHVtYjIuc3R5bGUubGVmdCA9ICcnICsgcG9zMiArICdweCc7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNsaWRlciwgJ3ZhbHVlJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgIHtyZXR1cm4gbWluICsgKCgocG9zLW1pblBvcykgKiAobWF4LW1pbikpIC8gKG1heFBvcyAtIG1pblBvcykpO30sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciBucCA9IG1pblBvcyArICgodi1taW4pICogKG1heFBvcy1taW5Qb3MpKS8obWF4LW1pbik7XG4gICAgICAgICAgc2V0UG9zKG5wKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNsaWRlciwgJ3ZhbHVlMicsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpICB7cmV0dXJuIG1pbiArICgoKHBvczItbWluUG9zKSAqIChtYXgtbWluKSkgLyAobWF4UG9zIC0gbWluUG9zKSk7fSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIG5wID0gbWluUG9zICsgKCh2LW1pbikgKiAobWF4UG9zLW1pblBvcykpLyhtYXgtbWluKTtcbiAgICAgICAgICBzZXRQb3MyKG5wKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNsaWRlciwgJ2FjdGl2ZScsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtyZXR1cm4gdGh1bWIuY2xhc3NMaXN0LmNvbnRhaW5zKCdhY3RpdmUnKSA/IDEgOiAyfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICBpZiAoeCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGh1bWIuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgdGh1bWIyLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHVtYjIuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgdGh1bWIuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzbGlkZXIsICdtaW4nLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiBtaW59LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7bWluID0gdn1cbiAgICB9KTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzbGlkZXIsICdtYXgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge3JldHVybiBtYXh9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7bWF4ID0gdn1cbiAgICB9KTtcblxuICAgIHZhciBvZmZzZXQ7XG4gICAgdmFyIHdoaWNoO1xuXG4gICAgdmFyIHRodW1iTW91c2VEb3duID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgd2hpY2ggPSB0aGlzID09IHRodW1iID8gMSA6IDI7XG4gICAgICAgIGlmICh3aGljaCAhPSBzbGlkZXIuYWN0aXZlKSB7XG4gICAgICAgICAgICBzbGlkZXIuYWN0aXZlID0gd2hpY2g7XG4gICAgICAgICAgICBzbGlkZXIuZGlzcGF0Y2hFdmVudChvbkNoYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aHVtYkRyYWdIYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGh1bWJEcmFnRW5kSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICBvZmZzZXQgPSBldi5jbGllbnRYIC0gKHdoaWNoID09IDEgPyBwb3MgOiBwb3MyKTtcbiAgICB9O1xuXG4gICAgdGh1bWIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGh1bWJNb3VzZURvd24sIGZhbHNlKTtcbiAgICB0aHVtYjIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGh1bWJNb3VzZURvd24sIGZhbHNlKTtcblxuICAgIHZhciB0aHVtYkRyYWdIYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKHdoaWNoID09IDEpXG4gICAgICAgICAgICBzZXRQb3MoZXYuY2xpZW50WCAtIG9mZnNldCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHNldFBvczIoZXYuY2xpZW50WCAtIG9mZnNldCk7XG4gICAgICAgIHNsaWRlci5kaXNwYXRjaEV2ZW50KG9uQ2hhbmdlKTtcbiAgICB9O1xuXG4gICAgdmFyIHRodW1iRHJhZ0VuZEhhbmRsZXIgPSBmdW5jdGlvbihldikge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGh1bWJEcmFnSGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRodW1iRHJhZ0VuZEhhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2xpZGVyO1xufVxuXG5pZiAodHlwZW9mKG1vZHVsZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtYWtlWm9vbVNsaWRlcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIFByb21pc2UgPSByZXF1aXJlKFwiLi9wcm9taXNlL3Byb21pc2VcIikuUHJvbWlzZTtcbnZhciBwb2x5ZmlsbCA9IHJlcXVpcmUoXCIuL3Byb21pc2UvcG9seWZpbGxcIikucG9seWZpbGw7XG5leHBvcnRzLlByb21pc2UgPSBQcm9taXNlO1xuZXhwb3J0cy5wb2x5ZmlsbCA9IHBvbHlmaWxsOyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIHRvU3RyaW5nICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZShcIi4vdXRpbHNcIikuaXNBcnJheTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZShcIi4vdXRpbHNcIikuaXNGdW5jdGlvbjtcblxuLyoqXG4gIFJldHVybnMgYSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gYWxsIHRoZSBnaXZlbiBwcm9taXNlcyBoYXZlIGJlZW5cbiAgZnVsZmlsbGVkLCBvciByZWplY3RlZCBpZiBhbnkgb2YgdGhlbSBiZWNvbWUgcmVqZWN0ZWQuIFRoZSByZXR1cm4gcHJvbWlzZVxuICBpcyBmdWxmaWxsZWQgd2l0aCBhbiBhcnJheSB0aGF0IGdpdmVzIGFsbCB0aGUgdmFsdWVzIGluIHRoZSBvcmRlciB0aGV5IHdlcmVcbiAgcGFzc2VkIGluIHRoZSBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50LlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgcHJvbWlzZTEgPSBSU1ZQLnJlc29sdmUoMSk7XG4gIHZhciBwcm9taXNlMiA9IFJTVlAucmVzb2x2ZSgyKTtcbiAgdmFyIHByb21pc2UzID0gUlNWUC5yZXNvbHZlKDMpO1xuICB2YXIgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBSU1ZQLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYFJTVlAuYWxsYCBhcmUgcmVqZWN0ZWQsIHRoZSBmaXJzdCBwcm9taXNlXG4gIHRoYXQgaXMgcmVqZWN0ZWQgd2lsbCBiZSBnaXZlbiBhcyBhbiBhcmd1bWVudCB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZXMnc1xuICByZWplY3Rpb24gaGFuZGxlci4gRm9yIGV4YW1wbGU6XG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIHZhciBwcm9taXNlMSA9IFJTVlAucmVzb2x2ZSgxKTtcbiAgdmFyIHByb21pc2UyID0gUlNWUC5yZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIHZhciBwcm9taXNlMyA9IFJTVlAucmVqZWN0KG5ldyBFcnJvcihcIjNcIikpO1xuICB2YXIgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBSU1ZQLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gQ29kZSBoZXJlIG5ldmVyIHJ1bnMgYmVjYXVzZSB0aGVyZSBhcmUgcmVqZWN0ZWQgcHJvbWlzZXMhXG4gIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgLy8gZXJyb3IubWVzc2FnZSA9PT0gXCIyXCJcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgYWxsXG4gIEBmb3IgUlNWUFxuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlc1xuICBAcGFyYW0ge1N0cmluZ30gbGFiZWxcbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiovXG5mdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIFByb21pc2UgPSB0aGlzO1xuXG4gIGlmICghaXNBcnJheShwcm9taXNlcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIGFsbC4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLCByZW1haW5pbmcgPSBwcm9taXNlcy5sZW5ndGgsXG4gICAgcHJvbWlzZTtcblxuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKGluZGV4KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZUFsbChpbmRleCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlQWxsKGluZGV4LCB2YWx1ZSkge1xuICAgICAgcmVzdWx0c1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlc1tpXTtcblxuICAgICAgaWYgKHByb21pc2UgJiYgaXNGdW5jdGlvbihwcm9taXNlLnRoZW4pKSB7XG4gICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlcihpKSwgcmVqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmVBbGwoaSwgcHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5hbGwgPSBhbGw7IiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG5cInVzZSBzdHJpY3RcIjtcbnZhciBicm93c2VyR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBsb2NhbCA9ICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgPyBnbG9iYWwgOiAodGhpcyA9PT0gdW5kZWZpbmVkPyB3aW5kb3c6dGhpcyk7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgbG9jYWwuc2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuZnVuY3Rpb24gZmx1c2goKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHVwbGUgPSBxdWV1ZVtpXTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0dXBsZVswXSwgYXJnID0gdHVwbGVbMV07XG4gICAgY2FsbGJhY2soYXJnKTtcbiAgfVxuICBxdWV1ZSA9IFtdO1xufVxuXG52YXIgc2NoZWR1bGVGbHVzaDtcblxuLy8gRGVjaWRlIHdoYXQgYXN5bmMgbWV0aG9kIHRvIHVzZSB0byB0cmlnZ2VyaW5nIHByb2Nlc3Npbmcgb2YgcXVldWVkIGNhbGxiYWNrczpcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gIHNjaGVkdWxlRmx1c2ggPSB1c2VOZXh0VGljaygpO1xufSBlbHNlIGlmIChCcm93c2VyTXV0YXRpb25PYnNlcnZlcikge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTXV0YXRpb25PYnNlcnZlcigpO1xufSBlbHNlIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZVNldFRpbWVvdXQoKTtcbn1cblxuZnVuY3Rpb24gYXNhcChjYWxsYmFjaywgYXJnKSB7XG4gIHZhciBsZW5ndGggPSBxdWV1ZS5wdXNoKFtjYWxsYmFjaywgYXJnXSk7XG4gIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAvLyBJZiBsZW5ndGggaXMgMSwgdGhhdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gYXN5bmMgZmx1c2guXG4gICAgLy8gSWYgYWRkaXRpb25hbCBjYWxsYmFja3MgYXJlIHF1ZXVlZCBiZWZvcmUgdGhlIHF1ZXVlIGlzIGZsdXNoZWQsIHRoZXlcbiAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgc2NoZWR1bGVGbHVzaCgpO1xuICB9XG59XG5cbmV4cG9ydHMuYXNhcCA9IGFzYXA7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIjFZaVo1U1wiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAgYFJTVlAuUHJvbWlzZS5jYXN0YCByZXR1cm5zIHRoZSBzYW1lIHByb21pc2UgaWYgdGhhdCBwcm9taXNlIHNoYXJlcyBhIGNvbnN0cnVjdG9yXG4gIHdpdGggdGhlIHByb21pc2UgYmVpbmcgY2FzdGVkLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgcHJvbWlzZSA9IFJTVlAucmVzb2x2ZSgxKTtcbiAgdmFyIGNhc3RlZCA9IFJTVlAuUHJvbWlzZS5jYXN0KHByb21pc2UpO1xuXG4gIGNvbnNvbGUubG9nKHByb21pc2UgPT09IGNhc3RlZCk7IC8vIHRydWVcbiAgYGBgXG5cbiAgSW4gdGhlIGNhc2Ugb2YgYSBwcm9taXNlIHdob3NlIGNvbnN0cnVjdG9yIGRvZXMgbm90IG1hdGNoLCBpdCBpcyBhc3NpbWlsYXRlZC5cbiAgVGhlIHJlc3VsdGluZyBwcm9taXNlIHdpbGwgZnVsZmlsbCBvciByZWplY3QgYmFzZWQgb24gdGhlIG91dGNvbWUgb2YgdGhlXG4gIHByb21pc2UgYmVpbmcgY2FzdGVkLlxuXG4gIEluIHRoZSBjYXNlIG9mIGEgbm9uLXByb21pc2UsIGEgcHJvbWlzZSB3aGljaCB3aWxsIGZ1bGZpbGwgd2l0aCB0aGF0IHZhbHVlIGlzXG4gIHJldHVybmVkLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgdmFsdWUgPSAxOyAvLyBjb3VsZCBiZSBhIG51bWJlciwgYm9vbGVhbiwgc3RyaW5nLCB1bmRlZmluZWQuLi5cbiAgdmFyIGNhc3RlZCA9IFJTVlAuUHJvbWlzZS5jYXN0KHZhbHVlKTtcblxuICBjb25zb2xlLmxvZyh2YWx1ZSA9PT0gY2FzdGVkKTsgLy8gZmFsc2VcbiAgY29uc29sZS5sb2coY2FzdGVkIGluc3RhbmNlb2YgUlNWUC5Qcm9taXNlKSAvLyB0cnVlXG5cbiAgY2FzdGVkLnRoZW4oZnVuY3Rpb24odmFsKSB7XG4gICAgdmFsID09PSB2YWx1ZSAvLyA9PiB0cnVlXG4gIH0pO1xuICBgYGBcblxuICBgUlNWUC5Qcm9taXNlLmNhc3RgIGlzIHNpbWlsYXIgdG8gYFJTVlAucmVzb2x2ZWAsIGJ1dCBgUlNWUC5Qcm9taXNlLmNhc3RgIGRpZmZlcnMgaW4gdGhlXG4gIGZvbGxvd2luZyB3YXlzOlxuICAqIGBSU1ZQLlByb21pc2UuY2FzdGAgc2VydmVzIGFzIGEgbWVtb3J5LWVmZmljaWVudCB3YXkgb2YgZ2V0dGluZyBhIHByb21pc2UsIHdoZW4geW91XG4gIGhhdmUgc29tZXRoaW5nIHRoYXQgY291bGQgZWl0aGVyIGJlIGEgcHJvbWlzZSBvciBhIHZhbHVlLiBSU1ZQLnJlc29sdmVcbiAgd2lsbCBoYXZlIHRoZSBzYW1lIGVmZmVjdCBidXQgd2lsbCBjcmVhdGUgYSBuZXcgcHJvbWlzZSB3cmFwcGVyIGlmIHRoZVxuICBhcmd1bWVudCBpcyBhIHByb21pc2UuXG4gICogYFJTVlAuUHJvbWlzZS5jYXN0YCBpcyBhIHdheSBvZiBjYXN0aW5nIGluY29taW5nIHRoZW5hYmxlcyBvciBwcm9taXNlIHN1YmNsYXNzZXMgdG9cbiAgcHJvbWlzZXMgb2YgdGhlIGV4YWN0IGNsYXNzIHNwZWNpZmllZCwgc28gdGhhdCB0aGUgcmVzdWx0aW5nIG9iamVjdCdzIGB0aGVuYCBpc1xuICBlbnN1cmVkIHRvIGhhdmUgdGhlIGJlaGF2aW9yIG9mIHRoZSBjb25zdHJ1Y3RvciB5b3UgYXJlIGNhbGxpbmcgY2FzdCBvbiAoaS5lLiwgUlNWUC5Qcm9taXNlKS5cblxuICBAbWV0aG9kIGNhc3RcbiAgQGZvciBSU1ZQXG4gIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgdG8gYmUgY2FzdGVkXG4gIEByZXR1cm4ge1Byb21pc2V9IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgcHJvcGVydGllcyBvZiBgcHJvbWlzZXNgXG4gIGhhdmUgYmVlbiBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiovXG5cblxuZnVuY3Rpb24gY2FzdChvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgaWYgKG9iamVjdCAmJiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QuY29uc3RydWN0b3IgPT09IHRoaXMpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIFByb21pc2UgPSB0aGlzO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZShvYmplY3QpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5jYXN0ID0gY2FzdDsiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBjb25maWcgPSB7XG4gIGluc3RydW1lbnQ6IGZhbHNlXG59O1xuXG5mdW5jdGlvbiBjb25maWd1cmUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBjb25maWdbbmFtZV0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29uZmlnW25hbWVdO1xuICB9XG59XG5cbmV4cG9ydHMuY29uZmlnID0gY29uZmlnO1xuZXhwb3J0cy5jb25maWd1cmUgPSBjb25maWd1cmU7IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXCJ1c2Ugc3RyaWN0XCI7XG4vKmdsb2JhbCBzZWxmKi9cbnZhciBSU1ZQUHJvbWlzZSA9IHJlcXVpcmUoXCIuL3Byb21pc2VcIikuUHJvbWlzZTtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZShcIi4vdXRpbHNcIikuaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIHZhciBsb2NhbDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQpIHtcbiAgICBsb2NhbCA9IHdpbmRvdztcbiAgfSBlbHNlIHtcbiAgICBsb2NhbCA9IHNlbGY7XG4gIH1cblxuICB2YXIgZXM2UHJvbWlzZVN1cHBvcnQgPSBcbiAgICBcIlByb21pc2VcIiBpbiBsb2NhbCAmJlxuICAgIC8vIFNvbWUgb2YgdGhlc2UgbWV0aG9kcyBhcmUgbWlzc2luZyBmcm9tXG4gICAgLy8gRmlyZWZveC9DaHJvbWUgZXhwZXJpbWVudGFsIGltcGxlbWVudGF0aW9uc1xuICAgIFwiY2FzdFwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICBcInJlc29sdmVcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgXCJyZWplY3RcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgXCJhbGxcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgXCJyYWNlXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgIC8vIE9sZGVyIHZlcnNpb24gb2YgdGhlIHNwZWMgaGFkIGEgcmVzb2x2ZXIgb2JqZWN0XG4gICAgLy8gYXMgdGhlIGFyZyByYXRoZXIgdGhhbiBhIGZ1bmN0aW9uXG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc29sdmU7XG4gICAgICBuZXcgbG9jYWwuUHJvbWlzZShmdW5jdGlvbihyKSB7IHJlc29sdmUgPSByOyB9KTtcbiAgICAgIHJldHVybiBpc0Z1bmN0aW9uKHJlc29sdmUpO1xuICAgIH0oKSk7XG5cbiAgaWYgKCFlczZQcm9taXNlU3VwcG9ydCkge1xuICAgIGxvY2FsLlByb21pc2UgPSBSU1ZQUHJvbWlzZTtcbiAgfVxufVxuXG5leHBvcnRzLnBvbHlmaWxsID0gcG9seWZpbGw7XG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIlwidXNlIHN0cmljdFwiO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKS5jb25maWc7XG52YXIgY29uZmlndXJlID0gcmVxdWlyZShcIi4vY29uZmlnXCIpLmNvbmZpZ3VyZTtcbnZhciBvYmplY3RPckZ1bmN0aW9uID0gcmVxdWlyZShcIi4vdXRpbHNcIikub2JqZWN0T3JGdW5jdGlvbjtcbnZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZShcIi4vdXRpbHNcIikuaXNGdW5jdGlvbjtcbnZhciBub3cgPSByZXF1aXJlKFwiLi91dGlsc1wiKS5ub3c7XG52YXIgY2FzdCA9IHJlcXVpcmUoXCIuL2Nhc3RcIikuY2FzdDtcbnZhciBhbGwgPSByZXF1aXJlKFwiLi9hbGxcIikuYWxsO1xudmFyIHJhY2UgPSByZXF1aXJlKFwiLi9yYWNlXCIpLnJhY2U7XG52YXIgc3RhdGljUmVzb2x2ZSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVcIikucmVzb2x2ZTtcbnZhciBzdGF0aWNSZWplY3QgPSByZXF1aXJlKFwiLi9yZWplY3RcIikucmVqZWN0O1xudmFyIGFzYXAgPSByZXF1aXJlKFwiLi9hc2FwXCIpLmFzYXA7XG5cbnZhciBjb3VudGVyID0gMDtcblxuY29uZmlnLmFzeW5jID0gYXNhcDsgLy8gZGVmYXVsdCBhc3luYyBpcyBhc2FwO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihyZXNvbHZlcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO1xuICB9XG5cbiAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICBpbnZva2VSZXNvbHZlcihyZXNvbHZlciwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIGludm9rZVJlc29sdmVyKHJlc29sdmVyLCBwcm9taXNlKSB7XG4gIGZ1bmN0aW9uIHJlc29sdmVQcm9taXNlKHZhbHVlKSB7XG4gICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICByZXNvbHZlcihyZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJlamVjdFByb21pc2UoZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlLCBlcnJvciwgc3VjY2VlZGVkLCBmYWlsZWQ7XG5cbiAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhbHVlID0gY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgZXJyb3IgPSBlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgICBzdWNjZWVkZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKGhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IEZVTEZJTExFRCkge1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9IGVsc2UgaWYgKHNldHRsZWQgPT09IFJFSkVDVEVEKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHZhbHVlKTtcbiAgfVxufVxuXG52YXIgUEVORElORyAgID0gdm9pZCAwO1xudmFyIFNFQUxFRCAgICA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCAgPSAyO1xuXG5mdW5jdGlvbiBzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IHN1YnNjcmliZXJzLmxlbmd0aDtcblxuICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIHN1YnNjcmliZXJzW2xlbmd0aCArIEZVTEZJTExFRF0gPSBvbkZ1bGZpbGxtZW50O1xuICBzdWJzY3JpYmVyc1tsZW5ndGggKyBSRUpFQ1RFRF0gID0gb25SZWplY3Rpb247XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2gocHJvbWlzZSwgc2V0dGxlZCkge1xuICB2YXIgY2hpbGQsIGNhbGxiYWNrLCBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzLCBkZXRhaWwgPSBwcm9taXNlLl9kZXRhaWw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMykge1xuICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgY2FsbGJhY2sgPSBzdWJzY3JpYmVyc1tpICsgc2V0dGxlZF07XG5cbiAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gIH1cblxuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IG51bGw7XG59XG5cblByb21pc2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUHJvbWlzZSxcblxuICBfc3RhdGU6IHVuZGVmaW5lZCxcbiAgX2RldGFpbDogdW5kZWZpbmVkLFxuICBfc3Vic2NyaWJlcnM6IHVuZGVmaW5lZCxcblxuICB0aGVuOiBmdW5jdGlvbihvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcblxuICAgIHZhciB0aGVuUHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uKCkge30pO1xuXG4gICAgaWYgKHRoaXMuX3N0YXRlKSB7XG4gICAgICB2YXIgY2FsbGJhY2tzID0gYXJndW1lbnRzO1xuICAgICAgY29uZmlnLmFzeW5jKGZ1bmN0aW9uIGludm9rZVByb21pc2VDYWxsYmFjaygpIHtcbiAgICAgICAgaW52b2tlQ2FsbGJhY2socHJvbWlzZS5fc3RhdGUsIHRoZW5Qcm9taXNlLCBjYWxsYmFja3NbcHJvbWlzZS5fc3RhdGUgLSAxXSwgcHJvbWlzZS5fZGV0YWlsKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJzY3JpYmUodGhpcywgdGhlblByb21pc2UsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhlblByb21pc2U7XG4gIH0sXG5cbiAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfVxufTtcblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5Qcm9taXNlLmNhc3QgPSBjYXN0O1xuUHJvbWlzZS5yYWNlID0gcmFjZTtcblByb21pc2UucmVzb2x2ZSA9IHN0YXRpY1Jlc29sdmU7XG5Qcm9taXNlLnJlamVjdCA9IHN0YXRpY1JlamVjdDtcblxuZnVuY3Rpb24gaGFuZGxlVGhlbmFibGUocHJvbWlzZSwgdmFsdWUpIHtcbiAgdmFyIHRoZW4gPSBudWxsLFxuICByZXNvbHZlZDtcblxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS5cIik7XG4gICAgfVxuXG4gICAgaWYgKG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB0aGVuID0gdmFsdWUudGhlbjtcblxuICAgICAgaWYgKGlzRnVuY3Rpb24odGhlbikpIHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodmFsdWUgIT09IHZhbCkge1xuICAgICAgICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWwpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmdWxmaWxsKHByb21pc2UsIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG5cbiAgICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChyZXNvbHZlZCkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoIWhhbmRsZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKSkge1xuICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7IHJldHVybjsgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFNFQUxFRDtcbiAgcHJvbWlzZS5fZGV0YWlsID0gdmFsdWU7XG5cbiAgY29uZmlnLmFzeW5jKHB1Ymxpc2hGdWxmaWxsbWVudCwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHJlamVjdChwcm9taXNlLCByZWFzb24pIHtcbiAgaWYgKHByb21pc2UuX3N0YXRlICE9PSBQRU5ESU5HKSB7IHJldHVybjsgfVxuICBwcm9taXNlLl9zdGF0ZSA9IFNFQUxFRDtcbiAgcHJvbWlzZS5fZGV0YWlsID0gcmVhc29uO1xuXG4gIGNvbmZpZy5hc3luYyhwdWJsaXNoUmVqZWN0aW9uLCBwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gcHVibGlzaEZ1bGZpbGxtZW50KHByb21pc2UpIHtcbiAgcHVibGlzaChwcm9taXNlLCBwcm9taXNlLl9zdGF0ZSA9IEZVTEZJTExFRCk7XG59XG5cbmZ1bmN0aW9uIHB1Ymxpc2hSZWplY3Rpb24ocHJvbWlzZSkge1xuICBwdWJsaXNoKHByb21pc2UsIHByb21pc2UuX3N0YXRlID0gUkVKRUNURUQpO1xufVxuXG5leHBvcnRzLlByb21pc2UgPSBQcm9taXNlOyIsIlwidXNlIHN0cmljdFwiO1xuLyogZ2xvYmFsIHRvU3RyaW5nICovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpLmlzQXJyYXk7XG5cbi8qKlxuICBgUlNWUC5yYWNlYCBhbGxvd3MgeW91IHRvIHdhdGNoIGEgc2VyaWVzIG9mIHByb21pc2VzIGFuZCBhY3QgYXMgc29vbiBhcyB0aGVcbiAgZmlyc3QgcHJvbWlzZSBnaXZlbiB0byB0aGUgYHByb21pc2VzYCBhcmd1bWVudCBmdWxmaWxscyBvciByZWplY3RzLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICB2YXIgcHJvbWlzZTEgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZShcInByb21pc2UgMVwiKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICB2YXIgcHJvbWlzZTIgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZShcInByb21pc2UgMlwiKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBSU1ZQLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09IFwicHJvbWlzZSAyXCIgYmVjYXVzZSBpdCB3YXMgcmVzb2x2ZWQgYmVmb3JlIHByb21pc2UxXG4gICAgLy8gd2FzIHJlc29sdmVkLlxuICB9KTtcbiAgYGBgXG5cbiAgYFJTVlAucmFjZWAgaXMgZGV0ZXJtaW5pc3RpYyBpbiB0aGF0IG9ubHkgdGhlIHN0YXRlIG9mIHRoZSBmaXJzdCBjb21wbGV0ZWRcbiAgcHJvbWlzZSBtYXR0ZXJzLiBGb3IgZXhhbXBsZSwgZXZlbiBpZiBvdGhlciBwcm9taXNlcyBnaXZlbiB0byB0aGUgYHByb21pc2VzYFxuICBhcnJheSBhcmd1bWVudCBhcmUgcmVzb2x2ZWQsIGJ1dCB0aGUgZmlyc3QgY29tcGxldGVkIHByb21pc2UgaGFzIGJlY29tZVxuICByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZCBwcm9taXNlXG4gIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgdmFyIHByb21pc2UxID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlc29sdmUoXCJwcm9taXNlIDFcIik7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2UyID0gbmV3IFJTVlAuUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJwcm9taXNlIDJcIikpO1xuICAgIH0sIDEwMCk7XG4gIH0pO1xuXG4gIFJTVlAucmFjZShbcHJvbWlzZTEsIHByb21pc2UyXSkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSBcInByb21pc2UyXCIgYmVjYXVzZSBwcm9taXNlIDIgYmVjYW1lIHJlamVjdGVkIGJlZm9yZVxuICAgIC8vIHByb21pc2UgMSBiZWNhbWUgZnVsZmlsbGVkXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQGZvciBSU1ZQXG4gIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGFycmF5IG9mIHByb21pc2VzIHRvIG9ic2VydmVcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgZGVzY3JpYmluZyB0aGUgcHJvbWlzZSByZXR1cm5lZC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCBiZWNvbWVzIGZ1bGZpbGxlZCB3aXRoIHRoZSB2YWx1ZSB0aGUgZmlyc3RcbiAgY29tcGxldGVkIHByb21pc2VzIGlzIHJlc29sdmVkIHdpdGggaWYgdGhlIGZpcnN0IGNvbXBsZXRlZCBwcm9taXNlIHdhc1xuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIHdpdGggdGhlIHJlYXNvbiB0aGF0IHRoZSBmaXJzdCBjb21wbGV0ZWQgcHJvbWlzZVxuICB3YXMgcmVqZWN0ZWQgd2l0aC5cbiovXG5mdW5jdGlvbiByYWNlKHByb21pc2VzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBQcm9taXNlID0gdGhpcztcblxuICBpZiAoIWlzQXJyYXkocHJvbWlzZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLicpO1xuICB9XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdLCBwcm9taXNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9taXNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2VzW2ldO1xuXG4gICAgICBpZiAocHJvbWlzZSAmJiB0eXBlb2YgcHJvbWlzZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzb2x2ZShwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLnJhY2UgPSByYWNlOyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gIGBSU1ZQLnJlamVjdGAgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSByZWplY3RlZCB3aXRoIHRoZSBwYXNzZWRcbiAgYHJlYXNvbmAuIGBSU1ZQLnJlamVjdGAgaXMgZXNzZW50aWFsbHkgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgdmFyIHByb21pc2UgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVqZWN0KG5ldyBFcnJvcignV0hPT1BTJykpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgdmFyIHByb21pc2UgPSBSU1ZQLnJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIENvZGUgaGVyZSBkb2Vzbid0IHJ1biBiZWNhdXNlIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIVxuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAnV0hPT1BTJ1xuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZWplY3RcbiAgQGZvciBSU1ZQXG4gIEBwYXJhbSB7QW55fSByZWFzb24gdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlamVjdGVkIHdpdGguXG4gIEBwYXJhbSB7U3RyaW5nfSBsYWJlbCBvcHRpb25hbCBzdHJpbmcgZm9yIGlkZW50aWZ5aW5nIHRoZSByZXR1cm5lZCBwcm9taXNlLlxuICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIHJlamVjdGVkIHdpdGggdGhlIGdpdmVuXG4gIGByZWFzb25gLlxuKi9cbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIFByb21pc2UgPSB0aGlzO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufVxuXG5leHBvcnRzLnJlamVjdCA9IHJlamVjdDsiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICBgUlNWUC5yZXNvbHZlYCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmVjb21lIGZ1bGZpbGxlZCB3aXRoIHRoZSBwYXNzZWRcbiAgYHZhbHVlYC4gYFJTVlAucmVzb2x2ZWAgaXMgZXNzZW50aWFsbHkgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgdmFyIHByb21pc2UgPSBuZXcgUlNWUC5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgcmVzb2x2ZSgxKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgSW5zdGVhZCBvZiB3cml0aW5nIHRoZSBhYm92ZSwgeW91ciBjb2RlIG5vdyBzaW1wbHkgYmVjb21lcyB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgdmFyIHByb21pc2UgPSBSU1ZQLnJlc29sdmUoMSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyB2YWx1ZSA9PT0gMVxuICB9KTtcbiAgYGBgXG5cbiAgQG1ldGhvZCByZXNvbHZlXG4gIEBmb3IgUlNWUFxuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgaWRlbnRpZnlpbmcgdGhlIHJldHVybmVkIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgZnVsZmlsbGVkIHdpdGggdGhlIGdpdmVuXG4gIGB2YWx1ZWBcbiovXG5mdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBQcm9taXNlID0gdGhpcztcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5yZXNvbHZlID0gcmVzb2x2ZTsiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICByZXR1cm4gaXNGdW5jdGlvbih4KSB8fCAodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNBcnJheSh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn1cblxuLy8gRGF0ZS5ub3cgaXMgbm90IGF2YWlsYWJsZSBpbiBicm93c2VycyA8IElFOVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRGF0ZS9ub3cjQ29tcGF0aWJpbGl0eVxudmFyIG5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7IH07XG5cblxuZXhwb3J0cy5vYmplY3RPckZ1bmN0aW9uID0gb2JqZWN0T3JGdW5jdGlvbjtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuZXhwb3J0cy5ub3cgPSBub3c7IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIvKiAtKi0gbW9kZTogamF2YXNjcmlwdDsgYy1iYXNpYy1vZmZzZXQ6IDQ7IGluZGVudC10YWJzLW1vZGU6IG5pbCAtKi0gKi9cblxuLy8gXG4vLyBKYXZhc2NyaXB0IFpMaWJcbi8vIEJ5IFRob21hcyBEb3duIDIwMTAtMjAxMVxuLy9cbi8vIEJhc2VkIHZlcnkgaGVhdmlseSBvbiBwb3J0aW9ucyBvZiBqemxpYiAoYnkgeW1ua0BqY3JhZnQuY29tKSwgd2hvIGluXG4vLyB0dXJuIGNyZWRpdHMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlciBmb3IgdGhlIG9yaWdpbmFsIHpsaWIgY29kZS5cbi8vXG4vLyBpbmZsYXRlLmpzOiBaTGliIGluZmxhdGUgY29kZVxuLy9cblxuLy9cbi8vIFNoYXJlZCBjb25zdGFudHNcbi8vXG5cbnZhciBNQVhfV0JJVFM9MTU7IC8vIDMySyBMWjc3IHdpbmRvd1xudmFyIERFRl9XQklUUz1NQVhfV0JJVFM7XG52YXIgTUFYX01FTV9MRVZFTD05O1xudmFyIE1BTlk9MTQ0MDtcbnZhciBCTUFYID0gMTU7XG5cbi8vIHByZXNldCBkaWN0aW9uYXJ5IGZsYWcgaW4gemxpYiBoZWFkZXJcbnZhciBQUkVTRVRfRElDVD0weDIwO1xuXG52YXIgWl9OT19GTFVTSD0wO1xudmFyIFpfUEFSVElBTF9GTFVTSD0xO1xudmFyIFpfU1lOQ19GTFVTSD0yO1xudmFyIFpfRlVMTF9GTFVTSD0zO1xudmFyIFpfRklOSVNIPTQ7XG5cbnZhciBaX0RFRkxBVEVEPTg7XG5cbnZhciBaX09LPTA7XG52YXIgWl9TVFJFQU1fRU5EPTE7XG52YXIgWl9ORUVEX0RJQ1Q9MjtcbnZhciBaX0VSUk5PPS0xO1xudmFyIFpfU1RSRUFNX0VSUk9SPS0yO1xudmFyIFpfREFUQV9FUlJPUj0tMztcbnZhciBaX01FTV9FUlJPUj0tNDtcbnZhciBaX0JVRl9FUlJPUj0tNTtcbnZhciBaX1ZFUlNJT05fRVJST1I9LTY7XG5cbnZhciBNRVRIT0Q9MDsgICAvLyB3YWl0aW5nIGZvciBtZXRob2QgYnl0ZVxudmFyIEZMQUc9MTsgICAgIC8vIHdhaXRpbmcgZm9yIGZsYWcgYnl0ZVxudmFyIERJQ1Q0PTI7ICAgIC8vIGZvdXIgZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QzPTM7ICAgIC8vIHRocmVlIGRpY3Rpb25hcnkgY2hlY2sgYnl0ZXMgdG8gZ29cbnZhciBESUNUMj00OyAgICAvLyB0d28gZGljdGlvbmFyeSBjaGVjayBieXRlcyB0byBnb1xudmFyIERJQ1QxPTU7ICAgIC8vIG9uZSBkaWN0aW9uYXJ5IGNoZWNrIGJ5dGUgdG8gZ29cbnZhciBESUNUMD02OyAgICAvLyB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeVxudmFyIEJMT0NLUz03OyAgIC8vIGRlY29tcHJlc3NpbmcgYmxvY2tzXG52YXIgQ0hFQ0s0PTg7ICAgLy8gZm91ciBjaGVjayBieXRlcyB0byBnb1xudmFyIENIRUNLMz05OyAgIC8vIHRocmVlIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0syPTEwOyAgLy8gdHdvIGNoZWNrIGJ5dGVzIHRvIGdvXG52YXIgQ0hFQ0sxPTExOyAgLy8gb25lIGNoZWNrIGJ5dGUgdG8gZ29cbnZhciBET05FPTEyOyAgICAvLyBmaW5pc2hlZCBjaGVjaywgZG9uZVxudmFyIEJBRD0xMzsgICAgIC8vIGdvdCBhbiBlcnJvci0tc3RheSBoZXJlXG5cbnZhciBpbmZsYXRlX21hc2sgPSBbMHgwMDAwMDAwMCwgMHgwMDAwMDAwMSwgMHgwMDAwMDAwMywgMHgwMDAwMDAwNywgMHgwMDAwMDAwZiwgMHgwMDAwMDAxZiwgMHgwMDAwMDAzZiwgMHgwMDAwMDA3ZiwgMHgwMDAwMDBmZiwgMHgwMDAwMDFmZiwgMHgwMDAwMDNmZiwgMHgwMDAwMDdmZiwgMHgwMDAwMGZmZiwgMHgwMDAwMWZmZiwgMHgwMDAwM2ZmZiwgMHgwMDAwN2ZmZiwgMHgwMDAwZmZmZl07XG5cbnZhciBJQl9UWVBFPTA7ICAvLyBnZXQgdHlwZSBiaXRzICgzLCBpbmNsdWRpbmcgZW5kIGJpdClcbnZhciBJQl9MRU5TPTE7ICAvLyBnZXQgbGVuZ3RocyBmb3Igc3RvcmVkXG52YXIgSUJfU1RPUkVEPTI7Ly8gcHJvY2Vzc2luZyBzdG9yZWQgYmxvY2tcbnZhciBJQl9UQUJMRT0zOyAvLyBnZXQgdGFibGUgbGVuZ3Roc1xudmFyIElCX0JUUkVFPTQ7IC8vIGdldCBiaXQgbGVuZ3RocyB0cmVlIGZvciBhIGR5bmFtaWMgYmxvY2tcbnZhciBJQl9EVFJFRT01OyAvLyBnZXQgbGVuZ3RoLCBkaXN0YW5jZSB0cmVlcyBmb3IgYSBkeW5hbWljIGJsb2NrXG52YXIgSUJfQ09ERVM9NjsgLy8gcHJvY2Vzc2luZyBmaXhlZCBvciBkeW5hbWljIGJsb2NrXG52YXIgSUJfRFJZPTc7ICAgLy8gb3V0cHV0IHJlbWFpbmluZyB3aW5kb3cgYnl0ZXNcbnZhciBJQl9ET05FPTg7ICAvLyBmaW5pc2hlZCBsYXN0IGJsb2NrLCBkb25lXG52YXIgSUJfQkFEPTk7ICAgLy8gb3QgYSBkYXRhIGVycm9yLS1zdHVjayBoZXJlXG5cbnZhciBmaXhlZF9ibCA9IDk7XG52YXIgZml4ZWRfYmQgPSA1O1xuXG52YXIgZml4ZWRfdGwgPSBbXG4gICAgOTYsNywyNTYsIDAsOCw4MCwgMCw4LDE2LCA4NCw4LDExNSxcbiAgICA4Miw3LDMxLCAwLDgsMTEyLCAwLDgsNDgsIDAsOSwxOTIsXG4gICAgODAsNywxMCwgMCw4LDk2LCAwLDgsMzIsIDAsOSwxNjAsXG4gICAgMCw4LDAsIDAsOCwxMjgsIDAsOCw2NCwgMCw5LDIyNCxcbiAgICA4MCw3LDYsIDAsOCw4OCwgMCw4LDI0LCAwLDksMTQ0LFxuICAgIDgzLDcsNTksIDAsOCwxMjAsIDAsOCw1NiwgMCw5LDIwOCxcbiAgICA4MSw3LDE3LCAwLDgsMTA0LCAwLDgsNDAsIDAsOSwxNzYsXG4gICAgMCw4LDgsIDAsOCwxMzYsIDAsOCw3MiwgMCw5LDI0MCxcbiAgICA4MCw3LDQsIDAsOCw4NCwgMCw4LDIwLCA4NSw4LDIyNyxcbiAgICA4Myw3LDQzLCAwLDgsMTE2LCAwLDgsNTIsIDAsOSwyMDAsXG4gICAgODEsNywxMywgMCw4LDEwMCwgMCw4LDM2LCAwLDksMTY4LFxuICAgIDAsOCw0LCAwLDgsMTMyLCAwLDgsNjgsIDAsOSwyMzIsXG4gICAgODAsNyw4LCAwLDgsOTIsIDAsOCwyOCwgMCw5LDE1MixcbiAgICA4NCw3LDgzLCAwLDgsMTI0LCAwLDgsNjAsIDAsOSwyMTYsXG4gICAgODIsNywyMywgMCw4LDEwOCwgMCw4LDQ0LCAwLDksMTg0LFxuICAgIDAsOCwxMiwgMCw4LDE0MCwgMCw4LDc2LCAwLDksMjQ4LFxuICAgIDgwLDcsMywgMCw4LDgyLCAwLDgsMTgsIDg1LDgsMTYzLFxuICAgIDgzLDcsMzUsIDAsOCwxMTQsIDAsOCw1MCwgMCw5LDE5NixcbiAgICA4MSw3LDExLCAwLDgsOTgsIDAsOCwzNCwgMCw5LDE2NCxcbiAgICAwLDgsMiwgMCw4LDEzMCwgMCw4LDY2LCAwLDksMjI4LFxuICAgIDgwLDcsNywgMCw4LDkwLCAwLDgsMjYsIDAsOSwxNDgsXG4gICAgODQsNyw2NywgMCw4LDEyMiwgMCw4LDU4LCAwLDksMjEyLFxuICAgIDgyLDcsMTksIDAsOCwxMDYsIDAsOCw0MiwgMCw5LDE4MCxcbiAgICAwLDgsMTAsIDAsOCwxMzgsIDAsOCw3NCwgMCw5LDI0NCxcbiAgICA4MCw3LDUsIDAsOCw4NiwgMCw4LDIyLCAxOTIsOCwwLFxuICAgIDgzLDcsNTEsIDAsOCwxMTgsIDAsOCw1NCwgMCw5LDIwNCxcbiAgICA4MSw3LDE1LCAwLDgsMTAyLCAwLDgsMzgsIDAsOSwxNzIsXG4gICAgMCw4LDYsIDAsOCwxMzQsIDAsOCw3MCwgMCw5LDIzNixcbiAgICA4MCw3LDksIDAsOCw5NCwgMCw4LDMwLCAwLDksMTU2LFxuICAgIDg0LDcsOTksIDAsOCwxMjYsIDAsOCw2MiwgMCw5LDIyMCxcbiAgICA4Miw3LDI3LCAwLDgsMTEwLCAwLDgsNDYsIDAsOSwxODgsXG4gICAgMCw4LDE0LCAwLDgsMTQyLCAwLDgsNzgsIDAsOSwyNTIsXG4gICAgOTYsNywyNTYsIDAsOCw4MSwgMCw4LDE3LCA4NSw4LDEzMSxcbiAgICA4Miw3LDMxLCAwLDgsMTEzLCAwLDgsNDksIDAsOSwxOTQsXG4gICAgODAsNywxMCwgMCw4LDk3LCAwLDgsMzMsIDAsOSwxNjIsXG4gICAgMCw4LDEsIDAsOCwxMjksIDAsOCw2NSwgMCw5LDIyNixcbiAgICA4MCw3LDYsIDAsOCw4OSwgMCw4LDI1LCAwLDksMTQ2LFxuICAgIDgzLDcsNTksIDAsOCwxMjEsIDAsOCw1NywgMCw5LDIxMCxcbiAgICA4MSw3LDE3LCAwLDgsMTA1LCAwLDgsNDEsIDAsOSwxNzgsXG4gICAgMCw4LDksIDAsOCwxMzcsIDAsOCw3MywgMCw5LDI0MixcbiAgICA4MCw3LDQsIDAsOCw4NSwgMCw4LDIxLCA4MCw4LDI1OCxcbiAgICA4Myw3LDQzLCAwLDgsMTE3LCAwLDgsNTMsIDAsOSwyMDIsXG4gICAgODEsNywxMywgMCw4LDEwMSwgMCw4LDM3LCAwLDksMTcwLFxuICAgIDAsOCw1LCAwLDgsMTMzLCAwLDgsNjksIDAsOSwyMzQsXG4gICAgODAsNyw4LCAwLDgsOTMsIDAsOCwyOSwgMCw5LDE1NCxcbiAgICA4NCw3LDgzLCAwLDgsMTI1LCAwLDgsNjEsIDAsOSwyMTgsXG4gICAgODIsNywyMywgMCw4LDEwOSwgMCw4LDQ1LCAwLDksMTg2LFxuICAgIDAsOCwxMywgMCw4LDE0MSwgMCw4LDc3LCAwLDksMjUwLFxuICAgIDgwLDcsMywgMCw4LDgzLCAwLDgsMTksIDg1LDgsMTk1LFxuICAgIDgzLDcsMzUsIDAsOCwxMTUsIDAsOCw1MSwgMCw5LDE5OCxcbiAgICA4MSw3LDExLCAwLDgsOTksIDAsOCwzNSwgMCw5LDE2NixcbiAgICAwLDgsMywgMCw4LDEzMSwgMCw4LDY3LCAwLDksMjMwLFxuICAgIDgwLDcsNywgMCw4LDkxLCAwLDgsMjcsIDAsOSwxNTAsXG4gICAgODQsNyw2NywgMCw4LDEyMywgMCw4LDU5LCAwLDksMjE0LFxuICAgIDgyLDcsMTksIDAsOCwxMDcsIDAsOCw0MywgMCw5LDE4MixcbiAgICAwLDgsMTEsIDAsOCwxMzksIDAsOCw3NSwgMCw5LDI0NixcbiAgICA4MCw3LDUsIDAsOCw4NywgMCw4LDIzLCAxOTIsOCwwLFxuICAgIDgzLDcsNTEsIDAsOCwxMTksIDAsOCw1NSwgMCw5LDIwNixcbiAgICA4MSw3LDE1LCAwLDgsMTAzLCAwLDgsMzksIDAsOSwxNzQsXG4gICAgMCw4LDcsIDAsOCwxMzUsIDAsOCw3MSwgMCw5LDIzOCxcbiAgICA4MCw3LDksIDAsOCw5NSwgMCw4LDMxLCAwLDksMTU4LFxuICAgIDg0LDcsOTksIDAsOCwxMjcsIDAsOCw2MywgMCw5LDIyMixcbiAgICA4Miw3LDI3LCAwLDgsMTExLCAwLDgsNDcsIDAsOSwxOTAsXG4gICAgMCw4LDE1LCAwLDgsMTQzLCAwLDgsNzksIDAsOSwyNTQsXG4gICAgOTYsNywyNTYsIDAsOCw4MCwgMCw4LDE2LCA4NCw4LDExNSxcbiAgICA4Miw3LDMxLCAwLDgsMTEyLCAwLDgsNDgsIDAsOSwxOTMsXG5cbiAgICA4MCw3LDEwLCAwLDgsOTYsIDAsOCwzMiwgMCw5LDE2MSxcbiAgICAwLDgsMCwgMCw4LDEyOCwgMCw4LDY0LCAwLDksMjI1LFxuICAgIDgwLDcsNiwgMCw4LDg4LCAwLDgsMjQsIDAsOSwxNDUsXG4gICAgODMsNyw1OSwgMCw4LDEyMCwgMCw4LDU2LCAwLDksMjA5LFxuICAgIDgxLDcsMTcsIDAsOCwxMDQsIDAsOCw0MCwgMCw5LDE3NyxcbiAgICAwLDgsOCwgMCw4LDEzNiwgMCw4LDcyLCAwLDksMjQxLFxuICAgIDgwLDcsNCwgMCw4LDg0LCAwLDgsMjAsIDg1LDgsMjI3LFxuICAgIDgzLDcsNDMsIDAsOCwxMTYsIDAsOCw1MiwgMCw5LDIwMSxcbiAgICA4MSw3LDEzLCAwLDgsMTAwLCAwLDgsMzYsIDAsOSwxNjksXG4gICAgMCw4LDQsIDAsOCwxMzIsIDAsOCw2OCwgMCw5LDIzMyxcbiAgICA4MCw3LDgsIDAsOCw5MiwgMCw4LDI4LCAwLDksMTUzLFxuICAgIDg0LDcsODMsIDAsOCwxMjQsIDAsOCw2MCwgMCw5LDIxNyxcbiAgICA4Miw3LDIzLCAwLDgsMTA4LCAwLDgsNDQsIDAsOSwxODUsXG4gICAgMCw4LDEyLCAwLDgsMTQwLCAwLDgsNzYsIDAsOSwyNDksXG4gICAgODAsNywzLCAwLDgsODIsIDAsOCwxOCwgODUsOCwxNjMsXG4gICAgODMsNywzNSwgMCw4LDExNCwgMCw4LDUwLCAwLDksMTk3LFxuICAgIDgxLDcsMTEsIDAsOCw5OCwgMCw4LDM0LCAwLDksMTY1LFxuICAgIDAsOCwyLCAwLDgsMTMwLCAwLDgsNjYsIDAsOSwyMjksXG4gICAgODAsNyw3LCAwLDgsOTAsIDAsOCwyNiwgMCw5LDE0OSxcbiAgICA4NCw3LDY3LCAwLDgsMTIyLCAwLDgsNTgsIDAsOSwyMTMsXG4gICAgODIsNywxOSwgMCw4LDEwNiwgMCw4LDQyLCAwLDksMTgxLFxuICAgIDAsOCwxMCwgMCw4LDEzOCwgMCw4LDc0LCAwLDksMjQ1LFxuICAgIDgwLDcsNSwgMCw4LDg2LCAwLDgsMjIsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOCwgMCw4LDU0LCAwLDksMjA1LFxuICAgIDgxLDcsMTUsIDAsOCwxMDIsIDAsOCwzOCwgMCw5LDE3MyxcbiAgICAwLDgsNiwgMCw4LDEzNCwgMCw4LDcwLCAwLDksMjM3LFxuICAgIDgwLDcsOSwgMCw4LDk0LCAwLDgsMzAsIDAsOSwxNTcsXG4gICAgODQsNyw5OSwgMCw4LDEyNiwgMCw4LDYyLCAwLDksMjIxLFxuICAgIDgyLDcsMjcsIDAsOCwxMTAsIDAsOCw0NiwgMCw5LDE4OSxcbiAgICAwLDgsMTQsIDAsOCwxNDIsIDAsOCw3OCwgMCw5LDI1MyxcbiAgICA5Niw3LDI1NiwgMCw4LDgxLCAwLDgsMTcsIDg1LDgsMTMxLFxuICAgIDgyLDcsMzEsIDAsOCwxMTMsIDAsOCw0OSwgMCw5LDE5NSxcbiAgICA4MCw3LDEwLCAwLDgsOTcsIDAsOCwzMywgMCw5LDE2MyxcbiAgICAwLDgsMSwgMCw4LDEyOSwgMCw4LDY1LCAwLDksMjI3LFxuICAgIDgwLDcsNiwgMCw4LDg5LCAwLDgsMjUsIDAsOSwxNDcsXG4gICAgODMsNyw1OSwgMCw4LDEyMSwgMCw4LDU3LCAwLDksMjExLFxuICAgIDgxLDcsMTcsIDAsOCwxMDUsIDAsOCw0MSwgMCw5LDE3OSxcbiAgICAwLDgsOSwgMCw4LDEzNywgMCw4LDczLCAwLDksMjQzLFxuICAgIDgwLDcsNCwgMCw4LDg1LCAwLDgsMjEsIDgwLDgsMjU4LFxuICAgIDgzLDcsNDMsIDAsOCwxMTcsIDAsOCw1MywgMCw5LDIwMyxcbiAgICA4MSw3LDEzLCAwLDgsMTAxLCAwLDgsMzcsIDAsOSwxNzEsXG4gICAgMCw4LDUsIDAsOCwxMzMsIDAsOCw2OSwgMCw5LDIzNSxcbiAgICA4MCw3LDgsIDAsOCw5MywgMCw4LDI5LCAwLDksMTU1LFxuICAgIDg0LDcsODMsIDAsOCwxMjUsIDAsOCw2MSwgMCw5LDIxOSxcbiAgICA4Miw3LDIzLCAwLDgsMTA5LCAwLDgsNDUsIDAsOSwxODcsXG4gICAgMCw4LDEzLCAwLDgsMTQxLCAwLDgsNzcsIDAsOSwyNTEsXG4gICAgODAsNywzLCAwLDgsODMsIDAsOCwxOSwgODUsOCwxOTUsXG4gICAgODMsNywzNSwgMCw4LDExNSwgMCw4LDUxLCAwLDksMTk5LFxuICAgIDgxLDcsMTEsIDAsOCw5OSwgMCw4LDM1LCAwLDksMTY3LFxuICAgIDAsOCwzLCAwLDgsMTMxLCAwLDgsNjcsIDAsOSwyMzEsXG4gICAgODAsNyw3LCAwLDgsOTEsIDAsOCwyNywgMCw5LDE1MSxcbiAgICA4NCw3LDY3LCAwLDgsMTIzLCAwLDgsNTksIDAsOSwyMTUsXG4gICAgODIsNywxOSwgMCw4LDEwNywgMCw4LDQzLCAwLDksMTgzLFxuICAgIDAsOCwxMSwgMCw4LDEzOSwgMCw4LDc1LCAwLDksMjQ3LFxuICAgIDgwLDcsNSwgMCw4LDg3LCAwLDgsMjMsIDE5Miw4LDAsXG4gICAgODMsNyw1MSwgMCw4LDExOSwgMCw4LDU1LCAwLDksMjA3LFxuICAgIDgxLDcsMTUsIDAsOCwxMDMsIDAsOCwzOSwgMCw5LDE3NSxcbiAgICAwLDgsNywgMCw4LDEzNSwgMCw4LDcxLCAwLDksMjM5LFxuICAgIDgwLDcsOSwgMCw4LDk1LCAwLDgsMzEsIDAsOSwxNTksXG4gICAgODQsNyw5OSwgMCw4LDEyNywgMCw4LDYzLCAwLDksMjIzLFxuICAgIDgyLDcsMjcsIDAsOCwxMTEsIDAsOCw0NywgMCw5LDE5MSxcbiAgICAwLDgsMTUsIDAsOCwxNDMsIDAsOCw3OSwgMCw5LDI1NVxuXTtcbnZhciBmaXhlZF90ZCA9IFtcbiAgICA4MCw1LDEsIDg3LDUsMjU3LCA4Myw1LDE3LCA5MSw1LDQwOTcsXG4gICAgODEsNSw1LCA4OSw1LDEwMjUsIDg1LDUsNjUsIDkzLDUsMTYzODUsXG4gICAgODAsNSwzLCA4OCw1LDUxMywgODQsNSwzMywgOTIsNSw4MTkzLFxuICAgIDgyLDUsOSwgOTAsNSwyMDQ5LCA4Niw1LDEyOSwgMTkyLDUsMjQ1NzcsXG4gICAgODAsNSwyLCA4Nyw1LDM4NSwgODMsNSwyNSwgOTEsNSw2MTQ1LFxuICAgIDgxLDUsNywgODksNSwxNTM3LCA4NSw1LDk3LCA5Myw1LDI0NTc3LFxuICAgIDgwLDUsNCwgODgsNSw3NjksIDg0LDUsNDksIDkyLDUsMTIyODksXG4gICAgODIsNSwxMywgOTAsNSwzMDczLCA4Niw1LDE5MywgMTkyLDUsMjQ1Nzdcbl07XG5cbiAgLy8gVGFibGVzIGZvciBkZWZsYXRlIGZyb20gUEtaSVAncyBhcHBub3RlLnR4dC5cbiAgdmFyIGNwbGVucyA9IFsgLy8gQ29weSBsZW5ndGhzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XG4gICAgICAgIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gICAgICAgIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG4gIF07XG5cbiAgLy8gc2VlIG5vdGUgIzEzIGFib3ZlIGFib3V0IDI1OFxuICB2YXIgY3BsZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBsaXRlcmFsIGNvZGVzIDI1Ny4uMjg1XG4gICAgICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDEsIDEsIDEsIDIsIDIsIDIsIDIsXG4gICAgICAgIDMsIDMsIDMsIDMsIDQsIDQsIDQsIDQsIDUsIDUsIDUsIDUsIDAsIDExMiwgMTEyICAvLyAxMTI9PWludmFsaWRcbiAgXTtcblxuIHZhciBjcGRpc3QgPSBbIC8vIENvcHkgb2Zmc2V0cyBmb3IgZGlzdGFuY2UgY29kZXMgMC4uMjlcbiAgICAgICAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAgICAgICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gICAgICAgIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzdcbiAgXTtcblxuICB2YXIgY3BkZXh0ID0gWyAvLyBFeHRyYSBiaXRzIGZvciBkaXN0YW5jZSBjb2Rlc1xuICAgICAgICAwLCAwLCAwLCAwLCAxLCAxLCAyLCAyLCAzLCAzLCA0LCA0LCA1LCA1LCA2LCA2LFxuICAgICAgICA3LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTAsIDExLCAxMSxcbiAgICAgICAgMTIsIDEyLCAxMywgMTNdO1xuXG4vL1xuLy8gWlN0cmVhbS5qYXZhXG4vL1xuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xufVxuXG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVJbml0ID0gZnVuY3Rpb24odywgbm93cmFwKSB7XG4gICAgaWYgKCF3KSB7XG5cdHcgPSBERUZfV0JJVFM7XG4gICAgfVxuICAgIGlmIChub3dyYXApIHtcblx0bm93cmFwID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXN0YXRlID0gbmV3IEluZmxhdGUoKTtcbiAgICByZXR1cm4gdGhpcy5pc3RhdGUuaW5mbGF0ZUluaXQodGhpcywgbm93cmFwPy13OncpO1xufVxuXG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlID0gZnVuY3Rpb24oZikge1xuICAgIGlmKHRoaXMuaXN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIHRoaXMuaXN0YXRlLmluZmxhdGUodGhpcywgZik7XG59XG5cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVFbmQgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuaXN0YXRlPT1udWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgdmFyIHJldD1pc3RhdGUuaW5mbGF0ZUVuZCh0aGlzKTtcbiAgICB0aGlzLmlzdGF0ZSA9IG51bGw7XG4gICAgcmV0dXJuIHJldDtcbn1cblpTdHJlYW0ucHJvdG90eXBlLmluZmxhdGVTeW5jID0gZnVuY3Rpb24oKXtcbiAgICAvLyBpZihpc3RhdGUgPT0gbnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiBpc3RhdGUuaW5mbGF0ZVN5bmModGhpcyk7XG59XG5aU3RyZWFtLnByb3RvdHlwZS5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpe1xuICAgIC8vIGlmKGlzdGF0ZSA9PSBudWxsKSByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGlzdGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTtcbn1cblxuLypcblxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCl7XG4gICAgcmV0dXJuIGRlZmxhdGVJbml0KGxldmVsLCBNQVhfV0JJVFMpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZUluaXQoaW50IGxldmVsLCBib29sZWFuIG5vd3JhcCl7XG4gICAgcmV0dXJuIGRlZmxhdGVJbml0KGxldmVsLCBNQVhfV0JJVFMsIG5vd3JhcCk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlSW5pdChpbnQgbGV2ZWwsIGludCBiaXRzKXtcbiAgICByZXR1cm4gZGVmbGF0ZUluaXQobGV2ZWwsIGJpdHMsIGZhbHNlKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVJbml0KGludCBsZXZlbCwgaW50IGJpdHMsIGJvb2xlYW4gbm93cmFwKXtcbiAgICBkc3RhdGU9bmV3IERlZmxhdGUoKTtcbiAgICByZXR1cm4gZHN0YXRlLmRlZmxhdGVJbml0KHRoaXMsIGxldmVsLCBub3dyYXA/LWJpdHM6Yml0cyk7XG4gIH1cbiAgcHVibGljIGludCBkZWZsYXRlKGludCBmbHVzaCl7XG4gICAgaWYoZHN0YXRlPT1udWxsKXtcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICB9XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlKHRoaXMsIGZsdXNoKTtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVFbmQoKXtcbiAgICBpZihkc3RhdGU9PW51bGwpIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICBpbnQgcmV0PWRzdGF0ZS5kZWZsYXRlRW5kKCk7XG4gICAgZHN0YXRlPW51bGw7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBwdWJsaWMgaW50IGRlZmxhdGVQYXJhbXMoaW50IGxldmVsLCBpbnQgc3RyYXRlZ3kpe1xuICAgIGlmKGRzdGF0ZT09bnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiBkc3RhdGUuZGVmbGF0ZVBhcmFtcyh0aGlzLCBsZXZlbCwgc3RyYXRlZ3kpO1xuICB9XG4gIHB1YmxpYyBpbnQgZGVmbGF0ZVNldERpY3Rpb25hcnkgKGJ5dGVbXSBkaWN0aW9uYXJ5LCBpbnQgZGljdExlbmd0aCl7XG4gICAgaWYoZHN0YXRlID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgcmV0dXJuIGRzdGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKTtcbiAgfVxuXG4qL1xuXG4vKlxuICAvLyBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gIC8vIHRocm91Z2ggdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXRcbiAgLy8gdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfb3V0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICAvLyAoU2VlIGFsc28gcmVhZF9idWYoKSkuXG4gIHZvaWQgZmx1c2hfcGVuZGluZygpe1xuICAgIGludCBsZW49ZHN0YXRlLnBlbmRpbmc7XG5cbiAgICBpZihsZW4+YXZhaWxfb3V0KSBsZW49YXZhaWxfb3V0O1xuICAgIGlmKGxlbj09MCkgcmV0dXJuO1xuXG4gICAgaWYoZHN0YXRlLnBlbmRpbmdfYnVmLmxlbmd0aDw9ZHN0YXRlLnBlbmRpbmdfb3V0IHx8XG4gICAgICAgbmV4dF9vdXQubGVuZ3RoPD1uZXh0X291dF9pbmRleCB8fFxuICAgICAgIGRzdGF0ZS5wZW5kaW5nX2J1Zi5sZW5ndGg8KGRzdGF0ZS5wZW5kaW5nX291dCtsZW4pIHx8XG4gICAgICAgbmV4dF9vdXQubGVuZ3RoPChuZXh0X291dF9pbmRleCtsZW4pKXtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihkc3RhdGUucGVuZGluZ19idWYubGVuZ3RoK1wiLCBcIitkc3RhdGUucGVuZGluZ19vdXQrXG5cdFx0XHQgXCIsIFwiK25leHRfb3V0Lmxlbmd0aCtcIiwgXCIrbmV4dF9vdXRfaW5kZXgrXCIsIFwiK2xlbik7XG4gICAgICBTeXN0ZW0ub3V0LnByaW50bG4oXCJhdmFpbF9vdXQ9XCIrYXZhaWxfb3V0KTtcbiAgICB9XG5cbiAgICBTeXN0ZW0uYXJyYXljb3B5KGRzdGF0ZS5wZW5kaW5nX2J1ZiwgZHN0YXRlLnBlbmRpbmdfb3V0LFxuXHRcdCAgICAgbmV4dF9vdXQsIG5leHRfb3V0X2luZGV4LCBsZW4pO1xuXG4gICAgbmV4dF9vdXRfaW5kZXgrPWxlbjtcbiAgICBkc3RhdGUucGVuZGluZ19vdXQrPWxlbjtcbiAgICB0b3RhbF9vdXQrPWxlbjtcbiAgICBhdmFpbF9vdXQtPWxlbjtcbiAgICBkc3RhdGUucGVuZGluZy09bGVuO1xuICAgIGlmKGRzdGF0ZS5wZW5kaW5nPT0wKXtcbiAgICAgIGRzdGF0ZS5wZW5kaW5nX291dD0wO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAgLy8gYW5kIHRvdGFsIG51bWJlciBvZiBieXRlcyByZWFkLiAgQWxsIGRlZmxhdGUoKSBpbnB1dCBnb2VzIHRocm91Z2hcbiAgLy8gdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAgLy8gYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm5leHRfaW4gYnVmZmVyIGFuZCBjb3B5aW5nIGZyb20gaXQuXG4gIC8vIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICBpbnQgcmVhZF9idWYoYnl0ZVtdIGJ1ZiwgaW50IHN0YXJ0LCBpbnQgc2l6ZSkge1xuICAgIGludCBsZW49YXZhaWxfaW47XG5cbiAgICBpZihsZW4+c2l6ZSkgbGVuPXNpemU7XG4gICAgaWYobGVuPT0wKSByZXR1cm4gMDtcblxuICAgIGF2YWlsX2luLT1sZW47XG5cbiAgICBpZihkc3RhdGUubm9oZWFkZXI9PTApIHtcbiAgICAgIGFkbGVyPV9hZGxlci5hZGxlcjMyKGFkbGVyLCBuZXh0X2luLCBuZXh0X2luX2luZGV4LCBsZW4pO1xuICAgIH1cbiAgICBTeXN0ZW0uYXJyYXljb3B5KG5leHRfaW4sIG5leHRfaW5faW5kZXgsIGJ1Ziwgc3RhcnQsIGxlbik7XG4gICAgbmV4dF9pbl9pbmRleCAgKz0gbGVuO1xuICAgIHRvdGFsX2luICs9IGxlbjtcbiAgICByZXR1cm4gbGVuO1xuICB9XG5cbiAgcHVibGljIHZvaWQgZnJlZSgpe1xuICAgIG5leHRfaW49bnVsbDtcbiAgICBuZXh0X291dD1udWxsO1xuICAgIG1zZz1udWxsO1xuICAgIF9hZGxlcj1udWxsO1xuICB9XG59XG4qL1xuXG5cbi8vXG4vLyBJbmZsYXRlLmphdmFcbi8vXG5cbmZ1bmN0aW9uIEluZmxhdGUoKSB7XG4gICAgdGhpcy53YXMgPSBbMF07XG59XG5cbkluZmxhdGUucHJvdG90eXBlLmluZmxhdGVSZXNldCA9IGZ1bmN0aW9uKHopIHtcbiAgICBpZih6ID09IG51bGwgfHwgei5pc3RhdGUgPT0gbnVsbCkgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIFxuICAgIHoudG90YWxfaW4gPSB6LnRvdGFsX291dCA9IDA7XG4gICAgei5tc2cgPSBudWxsO1xuICAgIHouaXN0YXRlLm1vZGUgPSB6LmlzdGF0ZS5ub3dyYXAhPTAgPyBCTE9DS1MgOiBNRVRIT0Q7XG4gICAgei5pc3RhdGUuYmxvY2tzLnJlc2V0KHosIG51bGwpO1xuICAgIHJldHVybiBaX09LO1xufVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlRW5kID0gZnVuY3Rpb24oeil7XG4gICAgaWYodGhpcy5ibG9ja3MgIT0gbnVsbClcbiAgICAgIHRoaXMuYmxvY2tzLmZyZWUoeik7XG4gICAgdGhpcy5ibG9ja3M9bnVsbDtcbiAgICByZXR1cm4gWl9PSztcbn1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZUluaXQgPSBmdW5jdGlvbih6LCB3KXtcbiAgICB6Lm1zZyA9IG51bGw7XG4gICAgdGhpcy5ibG9ja3MgPSBudWxsO1xuXG4gICAgLy8gaGFuZGxlIHVuZG9jdW1lbnRlZCBub3dyYXAgb3B0aW9uIChubyB6bGliIGhlYWRlciBvciBjaGVjaylcbiAgICBub3dyYXAgPSAwO1xuICAgIGlmKHcgPCAwKXtcbiAgICAgIHcgPSAtIHc7XG4gICAgICBub3dyYXAgPSAxO1xuICAgIH1cblxuICAgIC8vIHNldCB3aW5kb3cgc2l6ZVxuICAgIGlmKHc8OCB8fHc+MTUpe1xuICAgICAgdGhpcy5pbmZsYXRlRW5kKHopO1xuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgICB0aGlzLndiaXRzPXc7XG5cbiAgICB6LmlzdGF0ZS5ibG9ja3M9bmV3IEluZkJsb2Nrcyh6LCBcblx0XHRcdFx0ICB6LmlzdGF0ZS5ub3dyYXAhPTAgPyBudWxsIDogdGhpcyxcblx0XHRcdFx0ICAxPDx3KTtcblxuICAgIC8vIHJlc2V0IHN0YXRlXG4gICAgdGhpcy5pbmZsYXRlUmVzZXQoeik7XG4gICAgcmV0dXJuIFpfT0s7XG4gIH1cblxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZSA9IGZ1bmN0aW9uKHosIGYpe1xuICAgIHZhciByLCBiO1xuXG4gICAgaWYoeiA9PSBudWxsIHx8IHouaXN0YXRlID09IG51bGwgfHwgei5uZXh0X2luID09IG51bGwpXG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgZiA9IGYgPT0gWl9GSU5JU0ggPyBaX0JVRl9FUlJPUiA6IFpfT0s7XG4gICAgciA9IFpfQlVGX0VSUk9SO1xuICAgIHdoaWxlICh0cnVlKXtcbiAgICAgIHN3aXRjaCAoei5pc3RhdGUubW9kZSl7XG4gICAgICBjYXNlIE1FVEhPRDpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgaWYoKCh6LmlzdGF0ZS5tZXRob2QgPSB6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdKSYweGYpIT1aX0RFRkxBVEVEKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnPVwidW5rbm93biBjb21wcmVzc2lvbiBtZXRob2RcIjtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSA1OyAgICAgICAvLyBjYW4ndCB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZigoei5pc3RhdGUubWV0aG9kPj40KSs4PnouaXN0YXRlLndiaXRzKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnPVwiaW52YWxpZCB3aW5kb3cgc2l6ZVwiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RkxBRztcbiAgICAgIGNhc2UgRkxBRzpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgYiA9ICh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdKSYweGZmO1xuXG4gICAgICAgIGlmKCgoKHouaXN0YXRlLm1ldGhvZCA8PCA4KStiKSAlIDMxKSE9MCl7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZyA9IFwiaW5jb3JyZWN0IGhlYWRlciBjaGVja1wiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoKGImUFJFU0VUX0RJQ1QpPT0wKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHouaXN0YXRlLm1vZGUgPSBESUNUNDtcbiAgICAgIGNhc2UgRElDVDQ6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQ9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDwyNCkmMHhmZjAwMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZT1ESUNUMztcbiAgICAgIGNhc2UgRElDVDM6XG5cbiAgICAgICAgaWYoei5hdmFpbF9pbj09MClyZXR1cm4gcjtyPWY7XG5cbiAgICAgICAgei5hdmFpbF9pbi0tOyB6LnRvdGFsX2luKys7XG4gICAgICAgIHouaXN0YXRlLm5lZWQrPSgoei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTw8MTYpJjB4ZmYwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPURJQ1QyO1xuICAgICAgY2FzZSBESUNUMjpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZCs9KCh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpPDw4KSYweGZmMDA7XG4gICAgICAgIHouaXN0YXRlLm1vZGU9RElDVDE7XG4gICAgICBjYXNlIERJQ1QxOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkICs9ICh6Lm5leHRfaW5bei5uZXh0X2luX2luZGV4KytdJjB4ZmYpO1xuICAgICAgICB6LmFkbGVyID0gei5pc3RhdGUubmVlZDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IERJQ1QwO1xuICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICBjYXNlIERJQ1QwOlxuICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICB6Lm1zZyA9IFwibmVlZCBkaWN0aW9uYXJ5XCI7XG4gICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDA7ICAgICAgIC8vIGNhbiB0cnkgaW5mbGF0ZVN5bmNcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgICAgY2FzZSBCTE9DS1M6XG5cbiAgICAgICAgciA9IHouaXN0YXRlLmJsb2Nrcy5wcm9jKHosIHIpO1xuICAgICAgICBpZihyID09IFpfREFUQV9FUlJPUil7XG4gICAgICAgICAgei5pc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwOyAgICAgLy8gY2FuIHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmKHIgPT0gWl9PSyl7XG4gICAgICAgICAgciA9IGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYociAhPSBaX1NUUkVBTV9FTkQpe1xuICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBmO1xuICAgICAgICB6LmlzdGF0ZS5ibG9ja3MucmVzZXQoeiwgei5pc3RhdGUud2FzKTtcbiAgICAgICAgaWYoei5pc3RhdGUubm93cmFwIT0wKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlPURPTkU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgei5pc3RhdGUubW9kZT1DSEVDSzQ7XG4gICAgICBjYXNlIENIRUNLNDpcblxuICAgICAgICBpZih6LmF2YWlsX2luPT0wKXJldHVybiByO3I9ZjtcblxuICAgICAgICB6LmF2YWlsX2luLS07IHoudG90YWxfaW4rKztcbiAgICAgICAgei5pc3RhdGUubmVlZD0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDI0KSYweGZmMDAwMDAwO1xuICAgICAgICB6LmlzdGF0ZS5tb2RlPUNIRUNLMztcbiAgICAgIGNhc2UgQ0hFQ0szOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDE2KSYweGZmMDAwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IENIRUNLMjtcbiAgICAgIGNhc2UgQ0hFQ0syOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oKHoubmV4dF9pblt6Lm5leHRfaW5faW5kZXgrK10mMHhmZik8PDgpJjB4ZmYwMDtcbiAgICAgICAgei5pc3RhdGUubW9kZSA9IENIRUNLMTtcbiAgICAgIGNhc2UgQ0hFQ0sxOlxuXG4gICAgICAgIGlmKHouYXZhaWxfaW49PTApcmV0dXJuIHI7cj1mO1xuXG4gICAgICAgIHouYXZhaWxfaW4tLTsgei50b3RhbF9pbisrO1xuICAgICAgICB6LmlzdGF0ZS5uZWVkKz0oei5uZXh0X2luW3oubmV4dF9pbl9pbmRleCsrXSYweGZmKTtcblxuICAgICAgICBpZigoKHouaXN0YXRlLndhc1swXSkpICE9ICgoei5pc3RhdGUubmVlZCkpKXtcbiAgICAgICAgICB6LmlzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIHoubXNnID0gXCJpbmNvcnJlY3QgZGF0YSBjaGVja1wiO1xuICAgICAgICAgIHouaXN0YXRlLm1hcmtlciA9IDU7ICAgICAgIC8vIGNhbid0IHRyeSBpbmZsYXRlU3luY1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgei5pc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FTkQ7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGZ1bmN0aW9uKHosICBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4PTA7XG4gICAgdmFyIGxlbmd0aCA9IGRpY3RMZW5ndGg7XG4gICAgaWYoej09bnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsfHwgei5pc3RhdGUubW9kZSAhPSBESUNUMClcbiAgICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcblxuICAgIGlmKHouX2FkbGVyLmFkbGVyMzIoMSwgZGljdGlvbmFyeSwgMCwgZGljdExlbmd0aCkhPXouYWRsZXIpe1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG5cbiAgICB6LmFkbGVyID0gei5fYWRsZXIuYWRsZXIzMigwLCBudWxsLCAwLCAwKTtcblxuICAgIGlmKGxlbmd0aCA+PSAoMTw8ei5pc3RhdGUud2JpdHMpKXtcbiAgICAgIGxlbmd0aCA9ICgxPDx6LmlzdGF0ZS53Yml0cyktMTtcbiAgICAgIGluZGV4PWRpY3RMZW5ndGggLSBsZW5ndGg7XG4gICAgfVxuICAgIHouaXN0YXRlLmJsb2Nrcy5zZXRfZGljdGlvbmFyeShkaWN0aW9uYXJ5LCBpbmRleCwgbGVuZ3RoKTtcbiAgICB6LmlzdGF0ZS5tb2RlID0gQkxPQ0tTO1xuICAgIHJldHVybiBaX09LO1xuICB9XG5cbi8vICBzdGF0aWMgcHJpdmF0ZSBieXRlW10gbWFyayA9IHsoYnl0ZSkwLCAoYnl0ZSkwLCAoYnl0ZSkweGZmLCAoYnl0ZSkweGZmfTtcbnZhciBtYXJrID0gWzAsIDAsIDI1NSwgMjU1XVxuXG5JbmZsYXRlLnByb3RvdHlwZS5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uKHope1xuICAgIHZhciBuOyAgICAgICAvLyBudW1iZXIgb2YgYnl0ZXMgdG8gbG9vayBhdFxuICAgIHZhciBwOyAgICAgICAvLyBwb2ludGVyIHRvIGJ5dGVzXG4gICAgdmFyIG07ICAgICAgIC8vIG51bWJlciBvZiBtYXJrZXIgYnl0ZXMgZm91bmQgaW4gYSByb3dcbiAgICB2YXIgciwgdzsgICAvLyB0ZW1wb3JhcmllcyB0byBzYXZlIHRvdGFsX2luIGFuZCB0b3RhbF9vdXRcblxuICAgIC8vIHNldCB1cFxuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIGlmKHouaXN0YXRlLm1vZGUgIT0gQkFEKXtcbiAgICAgIHouaXN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICB6LmlzdGF0ZS5tYXJrZXIgPSAwO1xuICAgIH1cbiAgICBpZigobj16LmF2YWlsX2luKT09MClcbiAgICAgIHJldHVybiBaX0JVRl9FUlJPUjtcbiAgICBwPXoubmV4dF9pbl9pbmRleDtcbiAgICBtPXouaXN0YXRlLm1hcmtlcjtcblxuICAgIC8vIHNlYXJjaFxuICAgIHdoaWxlIChuIT0wICYmIG0gPCA0KXtcbiAgICAgIGlmKHoubmV4dF9pbltwXSA9PSBtYXJrW21dKXtcbiAgICAgICAgbSsrO1xuICAgICAgfVxuICAgICAgZWxzZSBpZih6Lm5leHRfaW5bcF0hPTApe1xuICAgICAgICBtID0gMDtcbiAgICAgIH1cbiAgICAgIGVsc2V7XG4gICAgICAgIG0gPSA0IC0gbTtcbiAgICAgIH1cbiAgICAgIHArKzsgbi0tO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmVcbiAgICB6LnRvdGFsX2luICs9IHAtei5uZXh0X2luX2luZGV4O1xuICAgIHoubmV4dF9pbl9pbmRleCA9IHA7XG4gICAgei5hdmFpbF9pbiA9IG47XG4gICAgei5pc3RhdGUubWFya2VyID0gbTtcblxuICAgIC8vIHJldHVybiBubyBqb3kgb3Igc2V0IHVwIHRvIHJlc3RhcnQgb24gYSBuZXcgYmxvY2tcbiAgICBpZihtICE9IDQpe1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gICAgcj16LnRvdGFsX2luOyAgdz16LnRvdGFsX291dDtcbiAgICB0aGlzLmluZmxhdGVSZXNldCh6KTtcbiAgICB6LnRvdGFsX2luPXI7ICB6LnRvdGFsX291dCA9IHc7XG4gICAgei5pc3RhdGUubW9kZSA9IEJMT0NLUztcbiAgICByZXR1cm4gWl9PSztcbn1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxuICAvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYnkgb25lIFBQUFxuICAvLyBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFuIGFkZGl0aW9uYWwgc2FmZXR5IGNoZWNrLiBQUFAgdXNlcyBaX1NZTkNfRkxVU0hcbiAgLy8gYnV0IHJlbW92ZXMgdGhlIGxlbmd0aCBieXRlcyBvZiB0aGUgcmVzdWx0aW5nIGVtcHR5IHN0b3JlZCBibG9jay4gV2hlblxuICAvLyBkZWNvbXByZXNzaW5nLCBQUFAgY2hlY2tzIHRoYXQgYXQgdGhlIGVuZCBvZiBpbnB1dCBwYWNrZXQsIGluZmxhdGUgaXNcbiAgLy8gd2FpdGluZyBmb3IgdGhlc2UgbGVuZ3RoIGJ5dGVzLlxuSW5mbGF0ZS5wcm90b3R5cGUuaW5mbGF0ZVN5bmNQb2ludCA9IGZ1bmN0aW9uKHope1xuICAgIGlmKHogPT0gbnVsbCB8fCB6LmlzdGF0ZSA9PSBudWxsIHx8IHouaXN0YXRlLmJsb2NrcyA9PSBudWxsKVxuICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIHJldHVybiB6LmlzdGF0ZS5ibG9ja3Muc3luY19wb2ludCgpO1xufVxuXG5cbi8vXG4vLyBJbmZCbG9ja3MuamF2YVxuLy9cblxudmFyIElORkJMT0NLU19CT1JERVIgPSBbMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNV07XG5cbmZ1bmN0aW9uIEluZkJsb2Nrcyh6LCBjaGVja2ZuLCB3KSB7XG4gICAgdGhpcy5odWZ0cz1uZXcgSW50MzJBcnJheShNQU5ZKjMpO1xuICAgIHRoaXMud2luZG93PW5ldyBVaW50OEFycmF5KHcpO1xuICAgIHRoaXMuZW5kPXc7XG4gICAgdGhpcy5jaGVja2ZuID0gY2hlY2tmbjtcbiAgICB0aGlzLm1vZGUgPSBJQl9UWVBFO1xuICAgIHRoaXMucmVzZXQoeiwgbnVsbCk7XG5cbiAgICB0aGlzLmxlZnQgPSAwOyAgICAgICAgICAgIC8vIGlmIFNUT1JFRCwgYnl0ZXMgbGVmdCB0byBjb3B5IFxuXG4gICAgdGhpcy50YWJsZSA9IDA7ICAgICAgICAgICAvLyB0YWJsZSBsZW5ndGhzICgxNCBiaXRzKSBcbiAgICB0aGlzLmluZGV4ID0gMDsgICAgICAgICAgIC8vIGluZGV4IGludG8gYmxlbnMgKG9yIGJvcmRlcikgXG4gICAgdGhpcy5ibGVucyA9IG51bGw7ICAgICAgICAgLy8gYml0IGxlbmd0aHMgb2YgY29kZXMgXG4gICAgdGhpcy5iYj1uZXcgSW50MzJBcnJheSgxKTsgLy8gYml0IGxlbmd0aCB0cmVlIGRlcHRoIFxuICAgIHRoaXMudGI9bmV3IEludDMyQXJyYXkoMSk7IC8vIGJpdCBsZW5ndGggZGVjb2RpbmcgdHJlZSBcblxuICAgIHRoaXMuY29kZXMgPSBuZXcgSW5mQ29kZXMoKTtcblxuICAgIHRoaXMubGFzdCA9IDA7ICAgICAgICAgICAgLy8gdHJ1ZSBpZiB0aGlzIGJsb2NrIGlzIHRoZSBsYXN0IGJsb2NrIFxuXG4gIC8vIG1vZGUgaW5kZXBlbmRlbnQgaW5mb3JtYXRpb24gXG4gICAgdGhpcy5iaXRrID0gMDsgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXIgXG4gICAgdGhpcy5iaXRiID0gMDsgICAgICAgICAgICAvLyBiaXQgYnVmZmVyIFxuICAgIHRoaXMucmVhZCA9IDA7ICAgICAgICAgICAgLy8gd2luZG93IHJlYWQgcG9pbnRlciBcbiAgICB0aGlzLndyaXRlID0gMDsgICAgICAgICAgIC8vIHdpbmRvdyB3cml0ZSBwb2ludGVyIFxuICAgIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAvLyBjaGVjayBvbiBvdXRwdXQgXG5cbiAgICB0aGlzLmluZnRyZWU9bmV3IEluZlRyZWUoKTtcbn1cblxuXG5cblxuSW5mQmxvY2tzLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKHosIGMpe1xuICAgIGlmKGMpIGNbMF09dGhpcy5jaGVjaztcbiAgICBpZih0aGlzLm1vZGU9PUlCX0NPREVTKXtcbiAgICAgIHRoaXMuY29kZXMuZnJlZSh6KTtcbiAgICB9XG4gICAgdGhpcy5tb2RlPUlCX1RZUEU7XG4gICAgdGhpcy5iaXRrPTA7XG4gICAgdGhpcy5iaXRiPTA7XG4gICAgdGhpcy5yZWFkPXRoaXMud3JpdGU9MDtcblxuICAgIGlmKHRoaXMuY2hlY2tmbilcbiAgICAgIHouYWRsZXI9dGhpcy5jaGVjaz16Ll9hZGxlci5hZGxlcjMyKDAsIG51bGwsIDAsIDApO1xuICB9XG5cbiBJbmZCbG9ja3MucHJvdG90eXBlLnByb2MgPSBmdW5jdGlvbih6LCByKXtcbiAgICB2YXIgdDsgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgdmFyIGI7ICAgICAgICAgICAgICAvLyBiaXQgYnVmZmVyXG4gICAgdmFyIGs7ICAgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXJcbiAgICB2YXIgcDsgICAgICAgICAgICAgIC8vIGlucHV0IGRhdGEgcG9pbnRlclxuICAgIHZhciBuOyAgICAgICAgICAgICAgLy8gYnl0ZXMgYXZhaWxhYmxlIHRoZXJlXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcbiAgICB2YXIgbTsgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGVuZCBvZiB3aW5kb3cgb3IgcmVhZCBwb2ludGVyXG5cbiAgICAvLyBjb3B5IGlucHV0L291dHB1dCBpbmZvcm1hdGlvbiB0byBsb2NhbHMgKFVQREFURSBtYWNybyByZXN0b3JlcylcbiAgICB7cD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9dGhpcy5iaXRiO2s9dGhpcy5iaXRrO31cbiAgICB7cT10aGlzLndyaXRlO209KHE8dGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO31cblxuICAgIC8vIHByb2Nlc3MgaW5wdXQgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxuICAgIHdoaWxlKHRydWUpe1xuICAgICAgc3dpdGNoICh0aGlzLm1vZGUpe1xuICAgICAgY2FzZSBJQl9UWVBFOlxuXG5cdHdoaWxlKGs8KDMpKXtcblx0ICBpZihuIT0wKXtcblx0ICAgIHI9Wl9PSztcblx0ICB9XG5cdCAgZWxzZXtcblx0ICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICB6LmF2YWlsX2luPW47XG5cdCAgICB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9O1xuXHQgIG4tLTtcblx0ICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXHR0ID0gKGIgJiA3KTtcblx0dGhpcy5sYXN0ID0gdCAmIDE7XG5cblx0c3dpdGNoICh0ID4+PiAxKXtcbiAgICAgICAgY2FzZSAwOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZWQgXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG4gICAgICAgICAgdCA9IGsgJiA3OyAgICAgICAgICAgICAgICAgICAgLy8gZ28gdG8gYnl0ZSBib3VuZGFyeVxuXG4gICAgICAgICAge2I+Pj49KHQpO2stPSh0KTt9XG4gICAgICAgICAgdGhpcy5tb2RlID0gSUJfTEVOUzsgICAgICAgICAgICAgICAgICAvLyBnZXQgbGVuZ3RoIG9mIHN0b3JlZCBibG9ja1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpeGVkXG4gICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgYmw9bmV3IEludDMyQXJyYXkoMSk7XG5cdCAgICAgIHZhciBiZD1uZXcgSW50MzJBcnJheSgxKTtcbiAgICAgICAgICAgICAgdmFyIHRsPVtdO1xuXHQgICAgICB2YXIgdGQ9W107XG5cblx0ICAgICAgaW5mbGF0ZV90cmVlc19maXhlZChibCwgYmQsIHRsLCB0ZCwgeik7XG4gICAgICAgICAgICAgIHRoaXMuY29kZXMuaW5pdChibFswXSwgYmRbMF0sIHRsWzBdLCAwLCB0ZFswXSwgMCwgeik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge2I+Pj49KDMpO2stPSgzKTt9XG5cbiAgICAgICAgICB0aGlzLm1vZGUgPSBJQl9DT0RFUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkeW5hbWljXG5cbiAgICAgICAgICB7Yj4+Pj0oMyk7ay09KDMpO31cblxuICAgICAgICAgIHRoaXMubW9kZSA9IElCX1RBQkxFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6ICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlsbGVnYWxcblxuICAgICAgICAgIHtiPj4+PSgzKTtrLT0oMyk7fVxuICAgICAgICAgIHRoaXMubW9kZSA9IEJBRDtcbiAgICAgICAgICB6Lm1zZyA9IFwiaW52YWxpZCBibG9jayB0eXBlXCI7XG4gICAgICAgICAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHRoaXMud3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblx0YnJlYWs7XG4gICAgICBjYXNlIElCX0xFTlM6XG5cdHdoaWxlKGs8KDMyKSl7XG5cdCAgaWYobiE9MCl7XG5cdCAgICByPVpfT0s7XG5cdCAgfVxuXHQgIGVsc2V7XG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfTtcblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHRpZiAoKCgofmIpID4+PiAxNikgJiAweGZmZmYpICE9IChiICYgMHhmZmZmKSl7XG5cdCAgdGhpcy5tb2RlID0gQkFEO1xuXHQgIHoubXNnID0gXCJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzXCI7XG5cdCAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHRoaXMud3JpdGU9cTtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdH1cblx0dGhpcy5sZWZ0ID0gKGIgJiAweGZmZmYpO1xuXHRiID0gayA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAvLyBkdW1wIGJpdHNcblx0dGhpcy5tb2RlID0gdGhpcy5sZWZ0IT0wID8gSUJfU1RPUkVEIDogKHRoaXMubGFzdCE9MCA/IElCX0RSWSA6IElCX1RZUEUpO1xuXHRicmVhaztcbiAgICAgIGNhc2UgSUJfU1RPUkVEOlxuXHRpZiAobiA9PSAwKXtcblx0ICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICB3cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0fVxuXG5cdGlmKG09PTApe1xuXHQgIGlmKHE9PWVuZCYmcmVhZCE9MCl7XG5cdCAgICBxPTA7IG09KHE8dGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXHQgIH1cblx0ICBpZihtPT0wKXtcblx0ICAgIHRoaXMud3JpdGU9cTsgXG5cdCAgICByPXRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgcT10aGlzLndyaXRlOyBtID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdCAgICBpZihxPT10aGlzLmVuZCAmJiB0aGlzLnJlYWQgIT0gMCl7XG5cdCAgICAgIHE9MDsgbSA9IChxIDwgdGhpcy5yZWFkID8gdGhpcy5yZWFkLXEtMSA6IHRoaXMuZW5kLXEpO1xuXHQgICAgfVxuXHQgICAgaWYobT09MCl7XG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgdGhpcy53cml0ZT1xO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICB9XG5cdCAgfVxuXHR9XG5cdHI9Wl9PSztcblxuXHR0ID0gdGhpcy5sZWZ0O1xuXHRpZih0Pm4pIHQgPSBuO1xuXHRpZih0Pm0pIHQgPSBtO1xuXHRhcnJheUNvcHkoei5uZXh0X2luLCBwLCB0aGlzLndpbmRvdywgcSwgdCk7XG5cdHAgKz0gdDsgIG4gLT0gdDtcblx0cSArPSB0OyAgbSAtPSB0O1xuXHRpZiAoKHRoaXMubGVmdCAtPSB0KSAhPSAwKVxuXHQgIGJyZWFrO1xuXHR0aGlzLm1vZGUgPSAodGhpcy5sYXN0ICE9IDAgPyBJQl9EUlkgOiBJQl9UWVBFKTtcblx0YnJlYWs7XG4gICAgICBjYXNlIElCX1RBQkxFOlxuXG5cdHdoaWxlKGs8KDE0KSl7XG5cdCAgaWYobiE9MCl7XG5cdCAgICByPVpfT0s7XG5cdCAgfVxuXHQgIGVsc2V7XG5cdCAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgei5hdmFpbF9pbj1uO1xuXHQgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICB0aGlzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfTtcblx0ICBuLS07XG5cdCAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aGlzLnRhYmxlID0gdCA9IChiICYgMHgzZmZmKTtcblx0aWYgKCh0ICYgMHgxZikgPiAyOSB8fCAoKHQgPj4gNSkgJiAweDFmKSA+IDI5KVxuXHQgIHtcblx0ICAgIHRoaXMubW9kZSA9IElCX0JBRDtcblx0ICAgIHoubXNnID0gXCJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9sc1wiO1xuXHQgICAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgICAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHRoaXMud3JpdGU9cTtcblx0ICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdHQgPSAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZik7XG5cdGlmKHRoaXMuYmxlbnM9PW51bGwgfHwgdGhpcy5ibGVucy5sZW5ndGg8dCl7XG5cdCAgICB0aGlzLmJsZW5zPW5ldyBJbnQzMkFycmF5KHQpO1xuXHR9XG5cdGVsc2V7XG5cdCAgZm9yKHZhciBpPTA7IGk8dDsgaSsrKXtcbiAgICAgICAgICAgICAgdGhpcy5ibGVuc1tpXT0wO1xuICAgICAgICAgIH1cblx0fVxuXG5cdHtiPj4+PSgxNCk7ay09KDE0KTt9XG5cblx0dGhpcy5pbmRleCA9IDA7XG5cdG1vZGUgPSBJQl9CVFJFRTtcbiAgICAgIGNhc2UgSUJfQlRSRUU6XG5cdHdoaWxlICh0aGlzLmluZGV4IDwgNCArICh0aGlzLnRhYmxlID4+PiAxMCkpe1xuXHQgIHdoaWxlKGs8KDMpKXtcblx0ICAgIGlmKG4hPTApe1xuXHQgICAgICByPVpfT0s7XG5cdCAgICB9XG5cdCAgICBlbHNle1xuXHQgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICB6LmF2YWlsX2luPW47XG5cdCAgICAgIHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH07XG5cdCAgICBuLS07XG5cdCAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgICBrKz04O1xuXHQgIH1cblxuXHQgIHRoaXMuYmxlbnNbSU5GQkxPQ0tTX0JPUkRFUlt0aGlzLmluZGV4KytdXSA9IGImNztcblxuXHQgIHtiPj4+PSgzKTtrLT0oMyk7fVxuXHR9XG5cblx0d2hpbGUodGhpcy5pbmRleCA8IDE5KXtcblx0ICB0aGlzLmJsZW5zW0lORkJMT0NLU19CT1JERVJbdGhpcy5pbmRleCsrXV0gPSAwO1xuXHR9XG5cblx0dGhpcy5iYlswXSA9IDc7XG5cdHQgPSB0aGlzLmluZnRyZWUuaW5mbGF0ZV90cmVlc19iaXRzKHRoaXMuYmxlbnMsIHRoaXMuYmIsIHRoaXMudGIsIHRoaXMuaHVmdHMsIHopO1xuXHRpZiAodCAhPSBaX09LKXtcblx0ICByID0gdDtcblx0ICBpZiAociA9PSBaX0RBVEFfRVJST1Ipe1xuXHQgICAgdGhpcy5ibGVucz1udWxsO1xuXHQgICAgdGhpcy5tb2RlID0gSUJfQkFEO1xuXHQgIH1cblxuXHQgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHdyaXRlPXE7XG5cdCAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cblx0dGhpcy5pbmRleCA9IDA7XG5cdHRoaXMubW9kZSA9IElCX0RUUkVFO1xuICAgICAgY2FzZSBJQl9EVFJFRTpcblx0d2hpbGUgKHRydWUpe1xuXHQgIHQgPSB0aGlzLnRhYmxlO1xuXHQgIGlmKCEodGhpcy5pbmRleCA8IDI1OCArICh0ICYgMHgxZikgKyAoKHQgPj4gNSkgJiAweDFmKSkpe1xuXHQgICAgYnJlYWs7XG5cdCAgfVxuXG5cdCAgdmFyIGg7IC8vaW50W11cblx0ICB2YXIgaSwgaiwgYztcblxuXHQgIHQgPSB0aGlzLmJiWzBdO1xuXG5cdCAgd2hpbGUoazwodCkpe1xuXHQgICAgaWYobiE9MCl7XG5cdCAgICAgIHI9Wl9PSztcblx0ICAgIH1cblx0ICAgIGVsc2V7XG5cdCAgICAgIHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdCAgICAgIHouYXZhaWxfaW49bjtcblx0ICAgICAgei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfTtcblx0ICAgIG4tLTtcblx0ICAgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICAgIGsrPTg7XG5cdCAgfVxuXG4vL1x0ICBpZiAodGhpcy50YlswXT09LTEpe1xuLy8gICAgICAgICAgICBkbG9nKFwibnVsbC4uLlwiKTtcbi8vXHQgIH1cblxuXHQgIHQ9dGhpcy5odWZ0c1sodGhpcy50YlswXSsoYiAmIGluZmxhdGVfbWFza1t0XSkpKjMrMV07XG5cdCAgYz10aGlzLmh1ZnRzWyh0aGlzLnRiWzBdKyhiICYgaW5mbGF0ZV9tYXNrW3RdKSkqMysyXTtcblxuXHQgIGlmIChjIDwgMTYpe1xuXHQgICAgYj4+Pj0odCk7ay09KHQpO1xuXHQgICAgdGhpcy5ibGVuc1t0aGlzLmluZGV4KytdID0gYztcblx0ICB9XG5cdCAgZWxzZSB7IC8vIGMgPT0gMTYuLjE4XG5cdCAgICBpID0gYyA9PSAxOCA/IDcgOiBjIC0gMTQ7XG5cdCAgICBqID0gYyA9PSAxOCA/IDExIDogMztcblxuXHQgICAgd2hpbGUoazwodCtpKSl7XG5cdCAgICAgIGlmKG4hPTApe1xuXHRcdHI9Wl9PSztcblx0ICAgICAgfVxuXHQgICAgICBlbHNle1xuXHRcdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdFx0ei5hdmFpbF9pbj1uO1xuXHRcdHoudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRcdHRoaXMud3JpdGU9cTtcblx0XHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICAgIH07XG5cdCAgICAgIG4tLTtcblx0ICAgICAgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgICAgICBrKz04O1xuXHQgICAgfVxuXG5cdCAgICBiPj4+PSh0KTtrLT0odCk7XG5cblx0ICAgIGogKz0gKGIgJiBpbmZsYXRlX21hc2tbaV0pO1xuXG5cdCAgICBiPj4+PShpKTtrLT0oaSk7XG5cblx0ICAgIGkgPSB0aGlzLmluZGV4O1xuXHQgICAgdCA9IHRoaXMudGFibGU7XG5cdCAgICBpZiAoaSArIGogPiAyNTggKyAodCAmIDB4MWYpICsgKCh0ID4+IDUpICYgMHgxZikgfHxcblx0XHQoYyA9PSAxNiAmJiBpIDwgMSkpe1xuXHQgICAgICB0aGlzLmJsZW5zPW51bGw7XG5cdCAgICAgIHRoaXMubW9kZSA9IElCX0JBRDtcblx0ICAgICAgei5tc2cgPSBcImludmFsaWQgYml0IGxlbmd0aCByZXBlYXRcIjtcblx0ICAgICAgciA9IFpfREFUQV9FUlJPUjtcblxuXHQgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHRoaXMud3JpdGU9cTtcblx0ICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfVxuXG5cdCAgICBjID0gYyA9PSAxNiA/IHRoaXMuYmxlbnNbaS0xXSA6IDA7XG5cdCAgICBkb3tcblx0ICAgICAgdGhpcy5ibGVuc1tpKytdID0gYztcblx0ICAgIH1cblx0ICAgIHdoaWxlICgtLWohPTApO1xuXHQgICAgdGhpcy5pbmRleCA9IGk7XG5cdCAgfVxuXHR9XG5cblx0dGhpcy50YlswXT0tMTtcblx0e1xuXHQgICAgdmFyIGJsPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgdmFyIGJkPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgdmFyIHRsPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgdmFyIHRkPW5ldyBJbnQzMkFycmF5KDEpO1xuXHQgICAgYmxbMF0gPSA5OyAgICAgICAgIC8vIG11c3QgYmUgPD0gOSBmb3IgbG9va2FoZWFkIGFzc3VtcHRpb25zXG5cdCAgICBiZFswXSA9IDY7ICAgICAgICAgLy8gbXVzdCBiZSA8PSA5IGZvciBsb29rYWhlYWQgYXNzdW1wdGlvbnNcblxuXHQgICAgdCA9IHRoaXMudGFibGU7XG5cdCAgICB0ID0gdGhpcy5pbmZ0cmVlLmluZmxhdGVfdHJlZXNfZHluYW1pYygyNTcgKyAodCAmIDB4MWYpLCBcblx0XHRcdFx0XHQgICAgICAxICsgKCh0ID4+IDUpICYgMHgxZiksXG5cdFx0XHRcdFx0ICAgICAgdGhpcy5ibGVucywgYmwsIGJkLCB0bCwgdGQsIHRoaXMuaHVmdHMsIHopO1xuXG5cdCAgICBpZiAodCAhPSBaX09LKXtcblx0ICAgICAgICBpZiAodCA9PSBaX0RBVEFfRVJST1Ipe1xuXHQgICAgICAgICAgICB0aGlzLmJsZW5zPW51bGw7XG5cdCAgICAgICAgICAgIHRoaXMubW9kZSA9IEJBRDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgciA9IHQ7XG5cblx0ICAgICAgICB0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHQgICAgICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgICAgICB0aGlzLndyaXRlPXE7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgfVxuXHQgICAgdGhpcy5jb2Rlcy5pbml0KGJsWzBdLCBiZFswXSwgdGhpcy5odWZ0cywgdGxbMF0sIHRoaXMuaHVmdHMsIHRkWzBdLCB6KTtcblx0fVxuXHR0aGlzLm1vZGUgPSBJQl9DT0RFUztcbiAgICAgIGNhc2UgSUJfQ09ERVM6XG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uOyB6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXG5cdGlmICgociA9IHRoaXMuY29kZXMucHJvYyh0aGlzLCB6LCByKSkgIT0gWl9TVFJFQU1fRU5EKXtcblx0ICByZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuXHR9XG5cdHIgPSBaX09LO1xuXHR0aGlzLmNvZGVzLmZyZWUoeik7XG5cblx0cD16Lm5leHRfaW5faW5kZXg7IG49ei5hdmFpbF9pbjtiPXRoaXMuYml0YjtrPXRoaXMuYml0aztcblx0cT10aGlzLndyaXRlO20gPSAocSA8IHRoaXMucmVhZCA/IHRoaXMucmVhZC1xLTEgOiB0aGlzLmVuZC1xKTtcblxuXHRpZiAodGhpcy5sYXN0PT0wKXtcblx0ICB0aGlzLm1vZGUgPSBJQl9UWVBFO1xuXHQgIGJyZWFrO1xuXHR9XG5cdHRoaXMubW9kZSA9IElCX0RSWTtcbiAgICAgIGNhc2UgSUJfRFJZOlxuXHR0aGlzLndyaXRlPXE7IFxuXHRyID0gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpOyBcblx0cT10aGlzLndyaXRlOyBtID0gKHEgPCB0aGlzLnJlYWQgPyB0aGlzLnJlYWQtcS0xIDogdGhpcy5lbmQtcSk7XG5cdGlmICh0aGlzLnJlYWQgIT0gdGhpcy53cml0ZSl7XG5cdCAgdGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgdGhpcy53cml0ZT1xO1xuXHQgIHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG5cdH1cblx0bW9kZSA9IERPTkU7XG4gICAgICBjYXNlIElCX0RPTkU6XG5cdHIgPSBaX1NUUkVBTV9FTkQ7XG5cblx0dGhpcy5iaXRiPWI7IHRoaXMuYml0az1rOyBcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHR0aGlzLndyaXRlPXE7XG5cdHJldHVybiB0aGlzLmluZmxhdGVfZmx1c2goeiwgcik7XG4gICAgICBjYXNlIElCX0JBRDpcblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHR0aGlzLmJpdGI9YjsgdGhpcy5iaXRrPWs7IFxuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHRoaXMud3JpdGU9cTtcblx0cmV0dXJuIHRoaXMuaW5mbGF0ZV9mbHVzaCh6LCByKTtcblxuICAgICAgZGVmYXVsdDpcblx0ciA9IFpfU1RSRUFNX0VSUk9SO1xuXG5cdHRoaXMuYml0Yj1iOyB0aGlzLmJpdGs9azsgXG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0dGhpcy53cml0ZT1xO1xuXHRyZXR1cm4gdGhpcy5pbmZsYXRlX2ZsdXNoKHosIHIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5JbmZCbG9ja3MucHJvdG90eXBlLmZyZWUgPSBmdW5jdGlvbih6KXtcbiAgICB0aGlzLnJlc2V0KHosIG51bGwpO1xuICAgIHRoaXMud2luZG93PW51bGw7XG4gICAgdGhpcy5odWZ0cz1udWxsO1xufVxuXG5JbmZCbG9ja3MucHJvdG90eXBlLnNldF9kaWN0aW9uYXJ5ID0gZnVuY3Rpb24oZCwgc3RhcnQsIG4pe1xuICAgIGFycmF5Q29weShkLCBzdGFydCwgd2luZG93LCAwLCBuKTtcbiAgICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gbjtcbn1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgaW5mbGF0ZSBpcyBjdXJyZW50bHkgYXQgdGhlIGVuZCBvZiBhIGJsb2NrIGdlbmVyYXRlZFxuICAvLyBieSBaX1NZTkNfRkxVU0ggb3IgWl9GVUxMX0ZMVVNILiBcbkluZkJsb2Nrcy5wcm90b3R5cGUuc3luY19wb2ludCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PSBJQl9MRU5TO1xufVxuXG4gIC8vIGNvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBzbGlkaW5nIHdpbmRvdyB0byB0aGUgb3V0cHV0IGFyZWFcbkluZkJsb2Nrcy5wcm90b3R5cGUuaW5mbGF0ZV9mbHVzaCA9IGZ1bmN0aW9uKHosIHIpe1xuICAgIHZhciBuO1xuICAgIHZhciBwO1xuICAgIHZhciBxO1xuXG4gICAgLy8gbG9jYWwgY29waWVzIG9mIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gcG9pbnRlcnNcbiAgICBwID0gei5uZXh0X291dF9pbmRleDtcbiAgICBxID0gdGhpcy5yZWFkO1xuXG4gICAgLy8gY29tcHV0ZSBudW1iZXIgb2YgYnl0ZXMgdG8gY29weSBhcyBmYXIgYXMgZW5kIG9mIHdpbmRvd1xuICAgIG4gPSAoKHEgPD0gdGhpcy53cml0ZSA/IHRoaXMud3JpdGUgOiB0aGlzLmVuZCkgLSBxKTtcbiAgICBpZiAobiA+IHouYXZhaWxfb3V0KSBuID0gei5hdmFpbF9vdXQ7XG4gICAgaWYgKG4hPTAgJiYgciA9PSBaX0JVRl9FUlJPUikgciA9IFpfT0s7XG5cbiAgICAvLyB1cGRhdGUgY291bnRlcnNcbiAgICB6LmF2YWlsX291dCAtPSBuO1xuICAgIHoudG90YWxfb3V0ICs9IG47XG5cbiAgICAvLyB1cGRhdGUgY2hlY2sgaW5mb3JtYXRpb25cbiAgICBpZih0aGlzLmNoZWNrZm4gIT0gbnVsbClcbiAgICAgIHouYWRsZXI9dGhpcy5jaGVjaz16Ll9hZGxlci5hZGxlcjMyKHRoaXMuY2hlY2ssIHRoaXMud2luZG93LCBxLCBuKTtcblxuICAgIC8vIGNvcHkgYXMgZmFyIGFzIGVuZCBvZiB3aW5kb3dcbiAgICBhcnJheUNvcHkodGhpcy53aW5kb3csIHEsIHoubmV4dF9vdXQsIHAsIG4pO1xuICAgIHAgKz0gbjtcbiAgICBxICs9IG47XG5cbiAgICAvLyBzZWUgaWYgbW9yZSB0byBjb3B5IGF0IGJlZ2lubmluZyBvZiB3aW5kb3dcbiAgICBpZiAocSA9PSB0aGlzLmVuZCl7XG4gICAgICAvLyB3cmFwIHBvaW50ZXJzXG4gICAgICBxID0gMDtcbiAgICAgIGlmICh0aGlzLndyaXRlID09IHRoaXMuZW5kKVxuICAgICAgICB0aGlzLndyaXRlID0gMDtcblxuICAgICAgLy8gY29tcHV0ZSBieXRlcyB0byBjb3B5XG4gICAgICBuID0gdGhpcy53cml0ZSAtIHE7XG4gICAgICBpZiAobiA+IHouYXZhaWxfb3V0KSBuID0gei5hdmFpbF9vdXQ7XG4gICAgICBpZiAobiE9MCAmJiByID09IFpfQlVGX0VSUk9SKSByID0gWl9PSztcblxuICAgICAgLy8gdXBkYXRlIGNvdW50ZXJzXG4gICAgICB6LmF2YWlsX291dCAtPSBuO1xuICAgICAgei50b3RhbF9vdXQgKz0gbjtcblxuICAgICAgLy8gdXBkYXRlIGNoZWNrIGluZm9ybWF0aW9uXG4gICAgICBpZih0aGlzLmNoZWNrZm4gIT0gbnVsbClcblx0ei5hZGxlcj10aGlzLmNoZWNrPXouX2FkbGVyLmFkbGVyMzIodGhpcy5jaGVjaywgdGhpcy53aW5kb3csIHEsIG4pO1xuXG4gICAgICAvLyBjb3B5XG4gICAgICBhcnJheUNvcHkodGhpcy53aW5kb3csIHEsIHoubmV4dF9vdXQsIHAsIG4pO1xuICAgICAgcCArPSBuO1xuICAgICAgcSArPSBuO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBwb2ludGVyc1xuICAgIHoubmV4dF9vdXRfaW5kZXggPSBwO1xuICAgIHRoaXMucmVhZCA9IHE7XG5cbiAgICAvLyBkb25lXG4gICAgcmV0dXJuIHI7XG4gIH1cblxuLy9cbi8vIEluZkNvZGVzLmphdmFcbi8vXG5cbnZhciBJQ19TVEFSVD0wOyAgLy8geDogc2V0IHVwIGZvciBMRU5cbnZhciBJQ19MRU49MTsgICAgLy8gaTogZ2V0IGxlbmd0aC9saXRlcmFsL2VvYiBuZXh0XG52YXIgSUNfTEVORVhUPTI7IC8vIGk6IGdldHRpbmcgbGVuZ3RoIGV4dHJhIChoYXZlIGJhc2UpXG52YXIgSUNfRElTVD0zOyAgIC8vIGk6IGdldCBkaXN0YW5jZSBuZXh0XG52YXIgSUNfRElTVEVYVD00Oy8vIGk6IGdldHRpbmcgZGlzdGFuY2UgZXh0cmFcbnZhciBJQ19DT1BZPTU7ICAgLy8gbzogY29weWluZyBieXRlcyBpbiB3aW5kb3csIHdhaXRpbmcgZm9yIHNwYWNlXG52YXIgSUNfTElUPTY7ICAgIC8vIG86IGdvdCBsaXRlcmFsLCB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2VcbnZhciBJQ19XQVNIPTc7ICAgLy8gbzogZ290IGVvYiwgcG9zc2libHkgc3RpbGwgb3V0cHV0IHdhaXRpbmdcbnZhciBJQ19FTkQ9ODsgICAgLy8geDogZ290IGVvYiBhbmQgYWxsIGRhdGEgZmx1c2hlZFxudmFyIElDX0JBRENPREU9OTsvLyB4OiBnb3QgZXJyb3JcblxuZnVuY3Rpb24gSW5mQ29kZXMoKSB7XG59XG5cbkluZkNvZGVzLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oYmwsIGJkLCB0bCwgdGxfaW5kZXgsIHRkLCB0ZF9pbmRleCwgeikge1xuICAgIHRoaXMubW9kZT1JQ19TVEFSVDtcbiAgICB0aGlzLmxiaXRzPWJsO1xuICAgIHRoaXMuZGJpdHM9YmQ7XG4gICAgdGhpcy5sdHJlZT10bDtcbiAgICB0aGlzLmx0cmVlX2luZGV4PXRsX2luZGV4O1xuICAgIHRoaXMuZHRyZWUgPSB0ZDtcbiAgICB0aGlzLmR0cmVlX2luZGV4PXRkX2luZGV4O1xuICAgIHRoaXMudHJlZT1udWxsO1xufVxuXG5JbmZDb2Rlcy5wcm90b3R5cGUucHJvYyA9IGZ1bmN0aW9uKHMsIHosIHIpeyBcbiAgICB2YXIgajsgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBzdG9yYWdlXG4gICAgdmFyIHQ7ICAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlciAoaW50W10pXG4gICAgdmFyIHRpbmRleDsgICAgICAgICAvLyB0ZW1wb3JhcnkgcG9pbnRlclxuICAgIHZhciBlOyAgICAgICAgICAgICAgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cbiAgICB2YXIgYj0wOyAgICAgICAgICAgIC8vIGJpdCBidWZmZXJcbiAgICB2YXIgaz0wOyAgICAgICAgICAgIC8vIGJpdHMgaW4gYml0IGJ1ZmZlclxuICAgIHZhciBwPTA7ICAgICAgICAgICAgLy8gaW5wdXQgZGF0YSBwb2ludGVyXG4gICAgdmFyIG47ICAgICAgICAgICAgICAvLyBieXRlcyBhdmFpbGFibGUgdGhlcmVcbiAgICB2YXIgcTsgICAgICAgICAgICAgIC8vIG91dHB1dCB3aW5kb3cgd3JpdGUgcG9pbnRlclxuICAgIHZhciBtOyAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcbiAgICB2YXIgZjsgICAgICAgICAgICAgIC8vIHBvaW50ZXIgdG8gY29weSBzdHJpbmdzIGZyb21cblxuICAgIC8vIGNvcHkgaW5wdXQvb3V0cHV0IGluZm9ybWF0aW9uIHRvIGxvY2FscyAoVVBEQVRFIG1hY3JvIHJlc3RvcmVzKVxuICAgIHA9ei5uZXh0X2luX2luZGV4O249ei5hdmFpbF9pbjtiPXMuYml0YjtrPXMuYml0aztcbiAgICBxPXMud3JpdGU7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7XG5cbiAgICAvLyBwcm9jZXNzIGlucHV0IGFuZCBvdXRwdXQgYmFzZWQgb24gY3VycmVudCBzdGF0ZVxuICAgIHdoaWxlICh0cnVlKXtcbiAgICAgIHN3aXRjaCAodGhpcy5tb2RlKXtcblx0Ly8gd2FpdGluZyBmb3IgXCJpOlwiPWlucHV0LCBcIm86XCI9b3V0cHV0LCBcIng6XCI9bm90aGluZ1xuICAgICAgY2FzZSBJQ19TVEFSVDogICAgICAgICAvLyB4OiBzZXQgdXAgZm9yIExFTlxuXHRpZiAobSA+PSAyNTggJiYgbiA+PSAxMCl7XG5cblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXHQgIHIgPSB0aGlzLmluZmxhdGVfZmFzdCh0aGlzLmxiaXRzLCB0aGlzLmRiaXRzLCBcblx0XHRcdCAgIHRoaXMubHRyZWUsIHRoaXMubHRyZWVfaW5kZXgsIFxuXHRcdFx0ICAgdGhpcy5kdHJlZSwgdGhpcy5kdHJlZV9pbmRleCxcblx0XHRcdCAgIHMsIHopO1xuXG5cdCAgcD16Lm5leHRfaW5faW5kZXg7bj16LmF2YWlsX2luO2I9cy5iaXRiO2s9cy5iaXRrO1xuXHQgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgIGlmIChyICE9IFpfT0spe1xuXHQgICAgdGhpcy5tb2RlID0gciA9PSBaX1NUUkVBTV9FTkQgPyBJQ19XQVNIIDogSUNfQkFEQ09ERTtcblx0ICAgIGJyZWFrO1xuXHQgIH1cblx0fVxuXHR0aGlzLm5lZWQgPSB0aGlzLmxiaXRzO1xuXHR0aGlzLnRyZWUgPSB0aGlzLmx0cmVlO1xuXHR0aGlzLnRyZWVfaW5kZXg9dGhpcy5sdHJlZV9pbmRleDtcblxuXHR0aGlzLm1vZGUgPSBJQ19MRU47XG4gICAgICBjYXNlIElDX0xFTjogICAgICAgICAgIC8vIGk6IGdldCBsZW5ndGgvbGl0ZXJhbC9lb2IgbmV4dFxuXHRqID0gdGhpcy5uZWVkO1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tO1xuXHQgIGJ8PSh6Lm5leHRfaW5bcCsrXSYweGZmKTw8aztcblx0ICBrKz04O1xuXHR9XG5cblx0dGluZGV4PSh0aGlzLnRyZWVfaW5kZXgrKGImaW5mbGF0ZV9tYXNrW2pdKSkqMztcblxuXHRiPj4+PSh0aGlzLnRyZWVbdGluZGV4KzFdKTtcblx0ay09KHRoaXMudHJlZVt0aW5kZXgrMV0pO1xuXG5cdGU9dGhpcy50cmVlW3RpbmRleF07XG5cblx0aWYoZSA9PSAwKXsgICAgICAgICAgICAgICAvLyBsaXRlcmFsXG5cdCAgdGhpcy5saXQgPSB0aGlzLnRyZWVbdGluZGV4KzJdO1xuXHQgIHRoaXMubW9kZSA9IElDX0xJVDtcblx0ICBicmVhaztcblx0fVxuXHRpZigoZSAmIDE2KSE9MCApeyAgICAgICAgICAvLyBsZW5ndGhcblx0ICB0aGlzLmdldCA9IGUgJiAxNTtcblx0ICB0aGlzLmxlbiA9IHRoaXMudHJlZVt0aW5kZXgrMl07XG5cdCAgdGhpcy5tb2RlID0gSUNfTEVORVhUO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmICgoZSAmIDY0KSA9PSAwKXsgICAgICAgIC8vIG5leHQgdGFibGVcblx0ICB0aGlzLm5lZWQgPSBlO1xuXHQgIHRoaXMudHJlZV9pbmRleCA9IHRpbmRleC8zICsgdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICBicmVhaztcblx0fVxuXHRpZiAoKGUgJiAzMikhPTApeyAgICAgICAgICAgICAgIC8vIGVuZCBvZiBibG9ja1xuXHQgIHRoaXMubW9kZSA9IElDX1dBU0g7XG5cdCAgYnJlYWs7XG5cdH1cblx0dGhpcy5tb2RlID0gSUNfQkFEQ09ERTsgICAgICAgIC8vIGludmFsaWQgY29kZVxuXHR6Lm1zZyA9IFwiaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlXCI7XG5cdHIgPSBaX0RBVEFfRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cbiAgICAgIGNhc2UgSUNfTEVORVhUOiAgICAgICAgLy8gaTogZ2V0dGluZyBsZW5ndGggZXh0cmEgKGhhdmUgYmFzZSlcblx0aiA9IHRoaXMuZ2V0O1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tOyBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRoaXMubGVuICs9IChiICYgaW5mbGF0ZV9tYXNrW2pdKTtcblxuXHRiPj49ajtcblx0ay09ajtcblxuXHR0aGlzLm5lZWQgPSB0aGlzLmRiaXRzO1xuXHR0aGlzLnRyZWUgPSB0aGlzLmR0cmVlO1xuXHR0aGlzLnRyZWVfaW5kZXggPSB0aGlzLmR0cmVlX2luZGV4O1xuXHR0aGlzLm1vZGUgPSBJQ19ESVNUO1xuICAgICAgY2FzZSBJQ19ESVNUOiAgICAgICAgICAvLyBpOiBnZXQgZGlzdGFuY2UgbmV4dFxuXHRqID0gdGhpcy5uZWVkO1xuXG5cdHdoaWxlKGs8KGopKXtcblx0ICBpZihuIT0wKXI9Wl9PSztcblx0ICBlbHNle1xuXG5cdCAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICAgIHMud3JpdGU9cTtcblx0ICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICB9XG5cdCAgbi0tOyBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7XG5cdCAgays9ODtcblx0fVxuXG5cdHRpbmRleD0odGhpcy50cmVlX2luZGV4KyhiICYgaW5mbGF0ZV9tYXNrW2pdKSkqMztcblxuXHRiPj49dGhpcy50cmVlW3RpbmRleCsxXTtcblx0ay09dGhpcy50cmVlW3RpbmRleCsxXTtcblxuXHRlID0gKHRoaXMudHJlZVt0aW5kZXhdKTtcblx0aWYoKGUgJiAxNikhPTApeyAgICAgICAgICAgICAgIC8vIGRpc3RhbmNlXG5cdCAgdGhpcy5nZXQgPSBlICYgMTU7XG5cdCAgdGhpcy5kaXN0ID0gdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICB0aGlzLm1vZGUgPSBJQ19ESVNURVhUO1xuXHQgIGJyZWFrO1xuXHR9XG5cdGlmICgoZSAmIDY0KSA9PSAwKXsgICAgICAgIC8vIG5leHQgdGFibGVcblx0ICB0aGlzLm5lZWQgPSBlO1xuXHQgIHRoaXMudHJlZV9pbmRleCA9IHRpbmRleC8zICsgdGhpcy50cmVlW3RpbmRleCsyXTtcblx0ICBicmVhaztcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19CQURDT0RFOyAgICAgICAgLy8gaW52YWxpZCBjb2RlXG5cdHoubXNnID0gXCJpbnZhbGlkIGRpc3RhbmNlIGNvZGVcIjtcblx0ciA9IFpfREFUQV9FUlJPUjtcblxuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgY2FzZSBJQ19ESVNURVhUOiAgICAgICAvLyBpOiBnZXR0aW5nIGRpc3RhbmNlIGV4dHJhXG5cdGogPSB0aGlzLmdldDtcblxuXHR3aGlsZShrPChqKSl7XG5cdCAgaWYobiE9MClyPVpfT0s7XG5cdCAgZWxzZXtcblxuXHQgICAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICBzLndyaXRlPXE7XG5cdCAgICByZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgfVxuXHQgIG4tLTsgYnw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO1xuXHQgIGsrPTg7XG5cdH1cblxuXHR0aGlzLmRpc3QgKz0gKGIgJiBpbmZsYXRlX21hc2tbal0pO1xuXG5cdGI+Pj1qO1xuXHRrLT1qO1xuXG5cdHRoaXMubW9kZSA9IElDX0NPUFk7XG4gICAgICBjYXNlIElDX0NPUFk6ICAgICAgICAgIC8vIG86IGNvcHlpbmcgYnl0ZXMgaW4gd2luZG93LCB3YWl0aW5nIGZvciBzcGFjZVxuICAgICAgICBmID0gcSAtIHRoaXMuZGlzdDtcbiAgICAgICAgd2hpbGUoZiA8IDApeyAgICAgLy8gbW9kdWxvIHdpbmRvdyBzaXplLVwid2hpbGVcIiBpbnN0ZWFkXG4gICAgICAgICAgZiArPSBzLmVuZDsgICAgIC8vIG9mIFwiaWZcIiBoYW5kbGVzIGludmFsaWQgZGlzdGFuY2VzXG5cdH1cblx0d2hpbGUgKHRoaXMubGVuIT0wKXtcblxuXHQgIGlmKG09PTApe1xuXHQgICAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICAgIGlmKG09PTApe1xuXHQgICAgICBzLndyaXRlPXE7IHI9cy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdCAgICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgICAgICBpZihxPT1zLmVuZCYmcy5yZWFkIT0wKXtxPTA7bT1xPHMucmVhZD9zLnJlYWQtcS0xOnMuZW5kLXE7fVxuXG5cdCAgICAgIGlmKG09PTApe1xuXHRcdHMuYml0Yj1iO3MuYml0az1rO1xuXHRcdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0XHRzLndyaXRlPXE7XG5cdFx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHQgICAgICB9ICBcblx0ICAgIH1cblx0ICB9XG5cblx0ICBzLndpbmRvd1txKytdPXMud2luZG93W2YrK107IG0tLTtcblxuXHQgIGlmIChmID09IHMuZW5kKVxuICAgICAgICAgICAgZiA9IDA7XG5cdCAgdGhpcy5sZW4tLTtcblx0fVxuXHR0aGlzLm1vZGUgPSBJQ19TVEFSVDtcblx0YnJlYWs7XG4gICAgICBjYXNlIElDX0xJVDogICAgICAgICAgIC8vIG86IGdvdCBsaXRlcmFsLCB3YWl0aW5nIGZvciBvdXRwdXQgc3BhY2Vcblx0aWYobT09MCl7XG5cdCAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICBpZihtPT0wKXtcblx0ICAgIHMud3JpdGU9cTsgcj1zLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHQgICAgaWYocT09cy5lbmQmJnMucmVhZCE9MCl7cT0wO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO31cblx0ICAgIGlmKG09PTApe1xuXHQgICAgICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICAgICAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgICAgICBzLndyaXRlPXE7XG5cdCAgICAgIHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblx0cj1aX09LO1xuXG5cdHMud2luZG93W3ErK109dGhpcy5saXQ7IG0tLTtcblxuXHR0aGlzLm1vZGUgPSBJQ19TVEFSVDtcblx0YnJlYWs7XG4gICAgICBjYXNlIElDX1dBU0g6ICAgICAgICAgICAvLyBvOiBnb3QgZW9iLCBwb3NzaWJseSBtb3JlIG91dHB1dFxuXHRpZiAoayA+IDcpeyAgICAgICAgLy8gcmV0dXJuIHVudXNlZCBieXRlLCBpZiBhbnlcblx0ICBrIC09IDg7XG5cdCAgbisrO1xuXHQgIHAtLTsgICAgICAgICAgICAgLy8gY2FuIGFsd2F5cyByZXR1cm4gb25lXG5cdH1cblxuXHRzLndyaXRlPXE7IHI9cy5pbmZsYXRlX2ZsdXNoKHoscik7XG5cdHE9cy53cml0ZTttPXE8cy5yZWFkP3MucmVhZC1xLTE6cy5lbmQtcTtcblxuXHRpZiAocy5yZWFkICE9IHMud3JpdGUpe1xuXHQgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgIHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0ICBzLndyaXRlPXE7XG5cdCAgcmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXHR9XG5cdHRoaXMubW9kZSA9IElDX0VORDtcbiAgICAgIGNhc2UgSUNfRU5EOlxuXHRyID0gWl9TVFJFQU1fRU5EO1xuXHRzLmJpdGI9YjtzLmJpdGs9aztcblx0ei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHRzLndyaXRlPXE7XG5cdHJldHVybiBzLmluZmxhdGVfZmx1c2goeixyKTtcblxuICAgICAgY2FzZSBJQ19CQURDT0RFOiAgICAgICAvLyB4OiBnb3QgZXJyb3JcblxuXHRyID0gWl9EQVRBX0VSUk9SO1xuXG5cdHMuYml0Yj1iO3MuYml0az1rO1xuXHR6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdHMud3JpdGU9cTtcblx0cmV0dXJuIHMuaW5mbGF0ZV9mbHVzaCh6LHIpO1xuXG4gICAgICBkZWZhdWx0OlxuXHRyID0gWl9TVFJFQU1fRVJST1I7XG5cblx0cy5iaXRiPWI7cy5iaXRrPWs7XG5cdHouYXZhaWxfaW49bjt6LnRvdGFsX2luKz1wLXoubmV4dF9pbl9pbmRleDt6Lm5leHRfaW5faW5kZXg9cDtcblx0cy53cml0ZT1xO1xuXHRyZXR1cm4gcy5pbmZsYXRlX2ZsdXNoKHoscik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbkluZkNvZGVzLnByb3RvdHlwZS5mcmVlID0gZnVuY3Rpb24oeil7XG4gICAgLy8gIFpGUkVFKHosIGMpO1xufVxuXG4gIC8vIENhbGxlZCB3aXRoIG51bWJlciBvZiBieXRlcyBsZWZ0IHRvIHdyaXRlIGluIHdpbmRvdyBhdCBsZWFzdCAyNThcbiAgLy8gKHRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGgpIGFuZCBudW1iZXIgb2YgaW5wdXQgYnl0ZXMgYXZhaWxhYmxlXG4gIC8vIGF0IGxlYXN0IHRlbi4gIFRoZSB0ZW4gYnl0ZXMgYXJlIHNpeCBieXRlcyBmb3IgdGhlIGxvbmdlc3QgbGVuZ3RoL1xuICAvLyBkaXN0YW5jZSBwYWlyIHBsdXMgZm91ciBieXRlcyBmb3Igb3ZlcmxvYWRpbmcgdGhlIGJpdCBidWZmZXIuXG5cbkluZkNvZGVzLnByb3RvdHlwZS5pbmZsYXRlX2Zhc3QgPSBmdW5jdGlvbihibCwgYmQsIHRsLCB0bF9pbmRleCwgdGQsIHRkX2luZGV4LCBzLCB6KSB7XG4gICAgdmFyIHQ7ICAgICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyXG4gICAgdmFyICAgdHA7ICAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBwb2ludGVyIChpbnRbXSlcbiAgICB2YXIgdHBfaW5kZXg7ICAgICAgICAgLy8gdGVtcG9yYXJ5IHBvaW50ZXJcbiAgICB2YXIgZTsgICAgICAgICAgICAgICAgLy8gZXh0cmEgYml0cyBvciBvcGVyYXRpb25cbiAgICB2YXIgYjsgICAgICAgICAgICAgICAgLy8gYml0IGJ1ZmZlclxuICAgIHZhciBrOyAgICAgICAgICAgICAgICAvLyBiaXRzIGluIGJpdCBidWZmZXJcbiAgICB2YXIgcDsgICAgICAgICAgICAgICAgLy8gaW5wdXQgZGF0YSBwb2ludGVyXG4gICAgdmFyIG47ICAgICAgICAgICAgICAgIC8vIGJ5dGVzIGF2YWlsYWJsZSB0aGVyZVxuICAgIHZhciBxOyAgICAgICAgICAgICAgICAvLyBvdXRwdXQgd2luZG93IHdyaXRlIHBvaW50ZXJcbiAgICB2YXIgbTsgICAgICAgICAgICAgICAgLy8gYnl0ZXMgdG8gZW5kIG9mIHdpbmRvdyBvciByZWFkIHBvaW50ZXJcbiAgICB2YXIgbWw7ICAgICAgICAgICAgICAgLy8gbWFzayBmb3IgbGl0ZXJhbC9sZW5ndGggdHJlZVxuICAgIHZhciBtZDsgICAgICAgICAgICAgICAvLyBtYXNrIGZvciBkaXN0YW5jZSB0cmVlXG4gICAgdmFyIGM7ICAgICAgICAgICAgICAgIC8vIGJ5dGVzIHRvIGNvcHlcbiAgICB2YXIgZDsgICAgICAgICAgICAgICAgLy8gZGlzdGFuY2UgYmFjayB0byBjb3B5IGZyb21cbiAgICB2YXIgcjsgICAgICAgICAgICAgICAgLy8gY29weSBzb3VyY2UgcG9pbnRlclxuXG4gICAgdmFyIHRwX2luZGV4X3RfMzsgICAgIC8vICh0cF9pbmRleCt0KSozXG5cbiAgICAvLyBsb2FkIGlucHV0LCBvdXRwdXQsIGJpdCB2YWx1ZXNcbiAgICBwPXoubmV4dF9pbl9pbmRleDtuPXouYXZhaWxfaW47Yj1zLmJpdGI7az1zLmJpdGs7XG4gICAgcT1zLndyaXRlO209cTxzLnJlYWQ/cy5yZWFkLXEtMTpzLmVuZC1xO1xuXG4gICAgLy8gaW5pdGlhbGl6ZSBtYXNrc1xuICAgIG1sID0gaW5mbGF0ZV9tYXNrW2JsXTtcbiAgICBtZCA9IGluZmxhdGVfbWFza1tiZF07XG5cbiAgICAvLyBkbyB1bnRpbCBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBzcGFjZSBmb3IgZmFzdCBsb29wXG4gICAgZG8geyAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXNzdW1lIGNhbGxlZCB3aXRoIG0gPj0gMjU4ICYmIG4gPj0gMTBcbiAgICAgIC8vIGdldCBsaXRlcmFsL2xlbmd0aCBjb2RlXG4gICAgICB3aGlsZShrPCgyMCkpeyAgICAgICAgICAgICAgLy8gbWF4IGJpdHMgZm9yIGxpdGVyYWwvbGVuZ3RoIGNvZGVcblx0bi0tO1xuXHRifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7ays9ODtcbiAgICAgIH1cblxuICAgICAgdD0gYiZtbDtcbiAgICAgIHRwPXRsOyBcbiAgICAgIHRwX2luZGV4PXRsX2luZGV4O1xuICAgICAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuICAgICAgaWYgKChlID0gdHBbdHBfaW5kZXhfdF8zXSkgPT0gMCl7XG5cdGI+Pj0odHBbdHBfaW5kZXhfdF8zKzFdKTsgay09KHRwW3RwX2luZGV4X3RfMysxXSk7XG5cblx0cy53aW5kb3dbcSsrXSA9IHRwW3RwX2luZGV4X3RfMysyXTtcblx0bS0tO1xuXHRjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGRvIHtcblxuXHRiPj49KHRwW3RwX2luZGV4X3RfMysxXSk7IGstPSh0cFt0cF9pbmRleF90XzMrMV0pO1xuXG5cdGlmKChlJjE2KSE9MCl7XG5cdCAgZSAmPSAxNTtcblx0ICBjID0gdHBbdHBfaW5kZXhfdF8zKzJdICsgKGIgJiBpbmZsYXRlX21hc2tbZV0pO1xuXG5cdCAgYj4+PWU7IGstPWU7XG5cblx0ICAvLyBkZWNvZGUgZGlzdGFuY2UgYmFzZSBvZiBibG9jayB0byBjb3B5XG5cdCAgd2hpbGUoazwoMTUpKXsgICAgICAgICAgIC8vIG1heCBiaXRzIGZvciBkaXN0YW5jZSBjb2RlXG5cdCAgICBuLS07XG5cdCAgICBifD0oei5uZXh0X2luW3ArK10mMHhmZik8PGs7ays9ODtcblx0ICB9XG5cblx0ICB0PSBiJm1kO1xuXHQgIHRwPXRkO1xuXHQgIHRwX2luZGV4PXRkX2luZGV4O1xuICAgICAgICAgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcblx0ICBlID0gdHBbdHBfaW5kZXhfdF8zXTtcblxuXHQgIGRvIHtcblxuXHQgICAgYj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHQgICAgaWYoKGUmMTYpIT0wKXtcblx0ICAgICAgLy8gZ2V0IGV4dHJhIGJpdHMgdG8gYWRkIHRvIGRpc3RhbmNlIGJhc2Vcblx0ICAgICAgZSAmPSAxNTtcblx0ICAgICAgd2hpbGUoazwoZSkpeyAgICAgICAgIC8vIGdldCBleHRyYSBiaXRzICh1cCB0byAxMylcblx0XHRuLS07XG5cdFx0Ynw9KHoubmV4dF9pbltwKytdJjB4ZmYpPDxrO2srPTg7XG5cdCAgICAgIH1cblxuXHQgICAgICBkID0gdHBbdHBfaW5kZXhfdF8zKzJdICsgKGImaW5mbGF0ZV9tYXNrW2VdKTtcblxuXHQgICAgICBiPj49KGUpOyBrLT0oZSk7XG5cblx0ICAgICAgLy8gZG8gdGhlIGNvcHlcblx0ICAgICAgbSAtPSBjO1xuXHQgICAgICBpZiAocSA+PSBkKXsgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IGJlZm9yZSBkZXN0XG5cdFx0Ly8gIGp1c3QgY29weVxuXHRcdHI9cS1kO1xuXHRcdGlmKHEtcj4wICYmIDI+KHEtcikpeyAgICAgICAgICAgXG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIG1pbmltdW0gY291bnQgaXMgdGhyZWUsXG5cdFx0ICBzLndpbmRvd1txKytdPXMud2luZG93W3IrK107IC8vIHNvIHVucm9sbCBsb29wIGEgbGl0dGxlXG5cdFx0ICBjLT0yO1xuXHRcdH1cblx0XHRlbHNle1xuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBtaW5pbXVtIGNvdW50IGlzIHRocmVlLFxuXHRcdCAgcy53aW5kb3dbcSsrXT1zLndpbmRvd1tyKytdOyAvLyBzbyB1bnJvbGwgbG9vcCBhIGxpdHRsZVxuXHRcdCAgYy09Mjtcblx0XHR9XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZXsgICAgICAgICAgICAgICAgICAvLyBlbHNlIG9mZnNldCBhZnRlciBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICAgIHI9cS1kO1xuICAgICAgICAgICAgICAgIGRve1xuICAgICAgICAgICAgICAgICAgcis9cy5lbmQ7ICAgICAgICAgIC8vIGZvcmNlIHBvaW50ZXIgaW4gd2luZG93XG4gICAgICAgICAgICAgICAgfXdoaWxlKHI8MCk7ICAgICAgICAgLy8gY292ZXJzIGludmFsaWQgZGlzdGFuY2VzXG5cdFx0ZT1zLmVuZC1yO1xuXHRcdGlmKGM+ZSl7ICAgICAgICAgICAgIC8vIGlmIHNvdXJjZSBjcm9zc2VzLFxuXHRcdCAgYy09ZTsgICAgICAgICAgICAgIC8vIHdyYXBwZWQgY29weVxuXHRcdCAgaWYocS1yPjAgJiYgZT4ocS1yKSl7ICAgICAgICAgICBcblx0XHQgICAgZG97cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107fVxuXHRcdCAgICB3aGlsZSgtLWUhPTApO1xuXHRcdCAgfVxuXHRcdCAgZWxzZXtcblx0XHQgICAgYXJyYXlDb3B5KHMud2luZG93LCByLCBzLndpbmRvdywgcSwgZSk7XG5cdFx0ICAgIHErPWU7IHIrPWU7IGU9MDtcblx0XHQgIH1cblx0XHQgIHIgPSAwOyAgICAgICAgICAgICAgICAgIC8vIGNvcHkgcmVzdCBmcm9tIHN0YXJ0IG9mIHdpbmRvd1xuXHRcdH1cblxuXHQgICAgICB9XG5cblx0ICAgICAgLy8gY29weSBhbGwgb3Igd2hhdCdzIGxlZnRcbiAgICAgICAgICAgICAgZG97cy53aW5kb3dbcSsrXSA9IHMud2luZG93W3IrK107fVxuXHRcdHdoaWxlKC0tYyE9MCk7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZigoZSY2NCk9PTApe1xuXHQgICAgICB0Kz10cFt0cF9pbmRleF90XzMrMl07XG5cdCAgICAgIHQrPShiJmluZmxhdGVfbWFza1tlXSk7XG5cdCAgICAgIHRwX2luZGV4X3RfMz0odHBfaW5kZXgrdCkqMztcblx0ICAgICAgZT10cFt0cF9pbmRleF90XzNdO1xuXHQgICAgfVxuXHQgICAgZWxzZXtcblx0ICAgICAgei5tc2cgPSBcImludmFsaWQgZGlzdGFuY2UgY29kZVwiO1xuXG5cdCAgICAgIGM9ei5hdmFpbF9pbi1uO2M9KGs+PjMpPGM/az4+MzpjO24rPWM7cC09YztrLT1jPDwzO1xuXG5cdCAgICAgIHMuYml0Yj1iO3MuYml0az1rO1xuXHQgICAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgICAgIHMud3JpdGU9cTtcblxuXHQgICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuXHQgICAgfVxuXHQgIH1cblx0ICB3aGlsZSh0cnVlKTtcblx0ICBicmVhaztcblx0fVxuXG5cdGlmKChlJjY0KT09MCl7XG5cdCAgdCs9dHBbdHBfaW5kZXhfdF8zKzJdO1xuXHQgIHQrPShiJmluZmxhdGVfbWFza1tlXSk7XG5cdCAgdHBfaW5kZXhfdF8zPSh0cF9pbmRleCt0KSozO1xuXHQgIGlmKChlPXRwW3RwX2luZGV4X3RfM10pPT0wKXtcblxuXHQgICAgYj4+PSh0cFt0cF9pbmRleF90XzMrMV0pOyBrLT0odHBbdHBfaW5kZXhfdF8zKzFdKTtcblxuXHQgICAgcy53aW5kb3dbcSsrXT10cFt0cF9pbmRleF90XzMrMl07XG5cdCAgICBtLS07XG5cdCAgICBicmVhaztcblx0ICB9XG5cdH1cblx0ZWxzZSBpZigoZSYzMikhPTApe1xuXG5cdCAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG4gXG5cdCAgcy5iaXRiPWI7cy5iaXRrPWs7XG5cdCAgei5hdmFpbF9pbj1uO3oudG90YWxfaW4rPXAtei5uZXh0X2luX2luZGV4O3oubmV4dF9pbl9pbmRleD1wO1xuXHQgIHMud3JpdGU9cTtcblxuXHQgIHJldHVybiBaX1NUUkVBTV9FTkQ7XG5cdH1cblx0ZWxzZXtcblx0ICB6Lm1zZz1cImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZVwiO1xuXG5cdCAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG5cblx0ICBzLmJpdGI9YjtzLmJpdGs9aztcblx0ICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG5cdCAgcy53cml0ZT1xO1xuXG5cdCAgcmV0dXJuIFpfREFUQV9FUlJPUjtcblx0fVxuICAgICAgfSBcbiAgICAgIHdoaWxlKHRydWUpO1xuICAgIH0gXG4gICAgd2hpbGUobT49MjU4ICYmIG4+PSAxMCk7XG5cbiAgICAvLyBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dC0tcmVzdG9yZSBwb2ludGVycyBhbmQgcmV0dXJuXG4gICAgYz16LmF2YWlsX2luLW47Yz0oaz4+Myk8Yz9rPj4zOmM7bis9YztwLT1jO2stPWM8PDM7XG5cbiAgICBzLmJpdGI9YjtzLmJpdGs9aztcbiAgICB6LmF2YWlsX2luPW47ei50b3RhbF9pbis9cC16Lm5leHRfaW5faW5kZXg7ei5uZXh0X2luX2luZGV4PXA7XG4gICAgcy53cml0ZT1xO1xuXG4gICAgcmV0dXJuIFpfT0s7XG59XG5cbi8vXG4vLyBJbmZUcmVlLmphdmFcbi8vXG5cbmZ1bmN0aW9uIEluZlRyZWUoKSB7XG59XG5cbkluZlRyZWUucHJvdG90eXBlLmh1ZnRfYnVpbGQgPSBmdW5jdGlvbihiLCBiaW5kZXgsIG4sIHMsIGQsIGUsIHQsIG0sIGhwLCBobiwgdikge1xuXG4gICAgLy8gR2l2ZW4gYSBsaXN0IG9mIGNvZGUgbGVuZ3RocyBhbmQgYSBtYXhpbXVtIHRhYmxlIHNpemUsIG1ha2UgYSBzZXQgb2ZcbiAgICAvLyB0YWJsZXMgdG8gZGVjb2RlIHRoYXQgc2V0IG9mIGNvZGVzLiAgUmV0dXJuIFpfT0sgb24gc3VjY2VzcywgWl9CVUZfRVJST1JcbiAgICAvLyBpZiB0aGUgZ2l2ZW4gY29kZSBzZXQgaXMgaW5jb21wbGV0ZSAodGhlIHRhYmxlcyBhcmUgc3RpbGwgYnVpbHQgaW4gdGhpc1xuICAgIC8vIGNhc2UpLCBaX0RBVEFfRVJST1IgaWYgdGhlIGlucHV0IGlzIGludmFsaWQgKGFuIG92ZXItc3Vic2NyaWJlZCBzZXQgb2ZcbiAgICAvLyBsZW5ndGhzKSwgb3IgWl9NRU1fRVJST1IgaWYgbm90IGVub3VnaCBtZW1vcnkuXG5cbiAgICB2YXIgYTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvdW50ZXIgZm9yIGNvZGVzIG9mIGxlbmd0aCBrXG4gICAgdmFyIGY7ICAgICAgICAgICAgICAgICAgICAgICAvLyBpIHJlcGVhdHMgaW4gdGFibGUgZXZlcnkgZiBlbnRyaWVzXG4gICAgdmFyIGc7ICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXG4gICAgdmFyIGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyB0YWJsZSBsZXZlbFxuICAgIHZhciBpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bnRlciwgY3VycmVudCBjb2RlXG4gICAgdmFyIGo7ICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VudGVyXG4gICAgdmFyIGs7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgYml0cyBpbiBjdXJyZW50IGNvZGVcbiAgICB2YXIgbDsgICAgICAgICAgICAgICAgICAgICAgIC8vIGJpdHMgcGVyIHRhYmxlIChyZXR1cm5lZCBpbiBtKVxuICAgIHZhciBtYXNrOyAgICAgICAgICAgICAgICAgICAgLy8gKDEgPDwgdykgLSAxLCB0byBhdm9pZCBjYyAtTyBidWcgb24gSFBcbiAgICB2YXIgcDsgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50ZXIgaW50byBjW10sIGJbXSwgb3IgdltdXG4gICAgdmFyIHE7ICAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMgdG8gY3VycmVudCB0YWJsZVxuICAgIHZhciB3OyAgICAgICAgICAgICAgICAgICAgICAgLy8gYml0cyBiZWZvcmUgdGhpcyB0YWJsZSA9PSAobCAqIGgpXG4gICAgdmFyIHhwOyAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludGVyIGludG8geFxuICAgIHZhciB5OyAgICAgICAgICAgICAgICAgICAgICAgLy8gbnVtYmVyIG9mIGR1bW15IGNvZGVzIGFkZGVkXG4gICAgdmFyIHo7ICAgICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgb2YgZW50cmllcyBpbiBjdXJyZW50IHRhYmxlXG5cbiAgICAvLyBHZW5lcmF0ZSBjb3VudHMgZm9yIGVhY2ggYml0IGxlbmd0aFxuXG4gICAgcCA9IDA7IGkgPSBuO1xuICAgIGRvIHtcbiAgICAgIHRoaXMuY1tiW2JpbmRleCtwXV0rKzsgcCsrOyBpLS07ICAgLy8gYXNzdW1lIGFsbCBlbnRyaWVzIDw9IEJNQVhcbiAgICB9d2hpbGUoaSE9MCk7XG5cbiAgICBpZih0aGlzLmNbMF0gPT0gbil7ICAgICAgICAgICAgICAgIC8vIG51bGwgaW5wdXQtLWFsbCB6ZXJvIGxlbmd0aCBjb2Rlc1xuICAgICAgdFswXSA9IC0xO1xuICAgICAgbVswXSA9IDA7XG4gICAgICByZXR1cm4gWl9PSztcbiAgICB9XG5cbiAgICAvLyBGaW5kIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoLCBib3VuZCAqbSBieSB0aG9zZVxuICAgIGwgPSBtWzBdO1xuICAgIGZvciAoaiA9IDE7IGogPD0gQk1BWDsgaisrKVxuICAgICAgaWYodGhpcy5jW2pdIT0wKSBicmVhaztcbiAgICBrID0gajsgICAgICAgICAgICAgICAgICAgICAgICAvLyBtaW5pbXVtIGNvZGUgbGVuZ3RoXG4gICAgaWYobCA8IGope1xuICAgICAgbCA9IGo7XG4gICAgfVxuICAgIGZvciAoaSA9IEJNQVg7IGkhPTA7IGktLSl7XG4gICAgICBpZih0aGlzLmNbaV0hPTApIGJyZWFrO1xuICAgIH1cbiAgICBnID0gaTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXhpbXVtIGNvZGUgbGVuZ3RoXG4gICAgaWYobCA+IGkpe1xuICAgICAgbCA9IGk7XG4gICAgfVxuICAgIG1bMF0gPSBsO1xuXG4gICAgLy8gQWRqdXN0IGxhc3QgbGVuZ3RoIGNvdW50IHRvIGZpbGwgb3V0IGNvZGVzLCBpZiBuZWVkZWRcbiAgICBmb3IgKHkgPSAxIDw8IGo7IGogPCBpOyBqKyssIHkgPDw9IDEpe1xuICAgICAgaWYgKCh5IC09IHRoaXMuY1tqXSkgPCAwKXtcbiAgICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh5IC09IHRoaXMuY1tpXSkgPCAwKXtcbiAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7XG4gICAgfVxuICAgIHRoaXMuY1tpXSArPSB5O1xuXG4gICAgLy8gR2VuZXJhdGUgc3RhcnRpbmcgb2Zmc2V0cyBpbnRvIHRoZSB2YWx1ZSB0YWJsZSBmb3IgZWFjaCBsZW5ndGhcbiAgICB0aGlzLnhbMV0gPSBqID0gMDtcbiAgICBwID0gMTsgIHhwID0gMjtcbiAgICB3aGlsZSAoLS1pIT0wKSB7ICAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgaSA9PSBnIGZyb20gYWJvdmVcbiAgICAgIHRoaXMueFt4cF0gPSAoaiArPSB0aGlzLmNbcF0pO1xuICAgICAgeHArKztcbiAgICAgIHArKztcbiAgICB9XG5cbiAgICAvLyBNYWtlIGEgdGFibGUgb2YgdmFsdWVzIGluIG9yZGVyIG9mIGJpdCBsZW5ndGhzXG4gICAgaSA9IDA7IHAgPSAwO1xuICAgIGRvIHtcbiAgICAgIGlmICgoaiA9IGJbYmluZGV4K3BdKSAhPSAwKXtcbiAgICAgICAgdGhpcy52W3RoaXMueFtqXSsrXSA9IGk7XG4gICAgICB9XG4gICAgICBwKys7XG4gICAgfVxuICAgIHdoaWxlICgrK2kgPCBuKTtcbiAgICBuID0gdGhpcy54W2ddOyAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBuIHRvIGxlbmd0aCBvZiB2XG5cbiAgICAvLyBHZW5lcmF0ZSB0aGUgSHVmZm1hbiBjb2RlcyBhbmQgZm9yIGVhY2gsIG1ha2UgdGhlIHRhYmxlIGVudHJpZXNcbiAgICB0aGlzLnhbMF0gPSBpID0gMDsgICAgICAgICAgICAgICAgIC8vIGZpcnN0IEh1ZmZtYW4gY29kZSBpcyB6ZXJvXG4gICAgcCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ3JhYiB2YWx1ZXMgaW4gYml0IG9yZGVyXG4gICAgaCA9IC0xOyAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gdGFibGVzIHlldC0tbGV2ZWwgLTFcbiAgICB3ID0gLWw7ICAgICAgICAgICAgICAgICAgICAgICAvLyBiaXRzIGRlY29kZWQgPT0gKGwgKiBoKVxuICAgIHRoaXMudVswXSA9IDA7ICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCB0byBrZWVwIGNvbXBpbGVycyBoYXBweVxuICAgIHEgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpdHRvXG4gICAgeiA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGl0dG9cblxuICAgIC8vIGdvIHRocm91Z2ggdGhlIGJpdCBsZW5ndGhzIChrIGFscmVhZHkgaXMgYml0cyBpbiBzaG9ydGVzdCBjb2RlKVxuICAgIGZvciAoOyBrIDw9IGc7IGsrKyl7XG4gICAgICBhID0gdGhpcy5jW2tdO1xuICAgICAgd2hpbGUgKGEtLSE9MCl7XG5cdC8vIGhlcmUgaSBpcyB0aGUgSHVmZm1hbiBjb2RlIG9mIGxlbmd0aCBrIGJpdHMgZm9yIHZhbHVlICpwXG5cdC8vIG1ha2UgdGFibGVzIHVwIHRvIHJlcXVpcmVkIGxldmVsXG4gICAgICAgIHdoaWxlIChrID4gdyArIGwpe1xuICAgICAgICAgIGgrKztcbiAgICAgICAgICB3ICs9IGw7ICAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyB0YWJsZSBhbHdheXMgbCBiaXRzXG5cdCAgLy8gY29tcHV0ZSBtaW5pbXVtIHNpemUgdGFibGUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGwgYml0c1xuICAgICAgICAgIHogPSBnIC0gdztcbiAgICAgICAgICB6ID0gKHogPiBsKSA/IGwgOiB6OyAgICAgICAgLy8gdGFibGUgc2l6ZSB1cHBlciBsaW1pdFxuICAgICAgICAgIGlmKChmPTE8PChqPWstdykpPmErMSl7ICAgICAvLyB0cnkgYSBrLXcgYml0IHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvbyBmZXcgY29kZXMgZm9yIGstdyBiaXQgdGFibGVcbiAgICAgICAgICAgIGYgLT0gYSArIDE7ICAgICAgICAgICAgICAgLy8gZGVkdWN0IGNvZGVzIGZyb20gcGF0dGVybnMgbGVmdFxuICAgICAgICAgICAgeHAgPSBrO1xuICAgICAgICAgICAgaWYoaiA8IHope1xuICAgICAgICAgICAgICB3aGlsZSAoKytqIDwgeil7ICAgICAgICAvLyB0cnkgc21hbGxlciB0YWJsZXMgdXAgdG8geiBiaXRzXG4gICAgICAgICAgICAgICAgaWYoKGYgPDw9IDEpIDw9IHRoaXMuY1srK3hwXSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgICAgICAgICAgLy8gZW5vdWdoIGNvZGVzIHRvIHVzZSB1cCBqIGJpdHNcbiAgICAgICAgICAgICAgICBmIC09IHRoaXMuY1t4cF07ICAgICAgICAgICAvLyBlbHNlIGRlZHVjdCBjb2RlcyBmcm9tIHBhdHRlcm5zXG4gICAgICAgICAgICAgIH1cblx0ICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgeiA9IDEgPDwgajsgICAgICAgICAgICAgICAgIC8vIHRhYmxlIGVudHJpZXMgZm9yIGotYml0IHRhYmxlXG5cblx0ICAvLyBhbGxvY2F0ZSBuZXcgdGFibGVcbiAgICAgICAgICBpZiAodGhpcy5oblswXSArIHogPiBNQU5ZKXsgICAgICAgLy8gKG5vdGU6IGRvZXNuJ3QgbWF0dGVyIGZvciBmaXhlZClcbiAgICAgICAgICAgIHJldHVybiBaX0RBVEFfRVJST1I7ICAgICAgIC8vIG92ZXJmbG93IG9mIE1BTllcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy51W2hdID0gcSA9IC8qaHArKi8gdGhpcy5oblswXTsgICAvLyBERUJVR1xuICAgICAgICAgIHRoaXMuaG5bMF0gKz0gejtcbiBcblx0ICAvLyBjb25uZWN0IHRvIGxhc3QgdGFibGUsIGlmIHRoZXJlIGlzIG9uZVxuXHQgIGlmKGghPTApe1xuICAgICAgICAgICAgdGhpcy54W2hdPWk7ICAgICAgICAgICAvLyBzYXZlIHBhdHRlcm4gZm9yIGJhY2tpbmcgdXBcbiAgICAgICAgICAgIHRoaXMuclswXT1qOyAgICAgLy8gYml0cyBpbiB0aGlzIHRhYmxlXG4gICAgICAgICAgICB0aGlzLnJbMV09bDsgICAgIC8vIGJpdHMgdG8gZHVtcCBiZWZvcmUgdGhpcyB0YWJsZVxuICAgICAgICAgICAgaj1pPj4+KHcgLSBsKTtcbiAgICAgICAgICAgIHRoaXMuclsyXSA9IChxIC0gdGhpcy51W2gtMV0gLSBqKTsgICAgICAgICAgICAgICAvLyBvZmZzZXQgdG8gdGhpcyB0YWJsZVxuICAgICAgICAgICAgYXJyYXlDb3B5KHRoaXMuciwgMCwgaHAsICh0aGlzLnVbaC0xXStqKSozLCAzKTsgLy8gY29ubmVjdCB0byBsYXN0IHRhYmxlXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0WzBdID0gcTsgICAgICAgICAgICAgICAvLyBmaXJzdCB0YWJsZSBpcyByZXR1cm5lZCByZXN1bHRcblx0ICB9XG4gICAgICAgIH1cblxuXHQvLyBzZXQgdXAgdGFibGUgZW50cnkgaW4gclxuICAgICAgICB0aGlzLnJbMV0gPSAoayAtIHcpO1xuICAgICAgICBpZiAocCA+PSBuKXtcbiAgICAgICAgICB0aGlzLnJbMF0gPSAxMjggKyA2NDsgICAgICAvLyBvdXQgb2YgdmFsdWVzLS1pbnZhbGlkIGNvZGVcblx0fVxuICAgICAgICBlbHNlIGlmICh2W3BdIDwgcyl7XG4gICAgICAgICAgdGhpcy5yWzBdID0gKHRoaXMudltwXSA8IDI1NiA/IDAgOiAzMiArIDY0KTsgIC8vIDI1NiBpcyBlbmQtb2YtYmxvY2tcbiAgICAgICAgICB0aGlzLnJbMl0gPSB0aGlzLnZbcCsrXTsgICAgICAgICAgLy8gc2ltcGxlIGNvZGUgaXMganVzdCB0aGUgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgIHRoaXMuclswXT0oZVt0aGlzLnZbcF0tc10rMTYrNjQpOyAvLyBub24tc2ltcGxlLS1sb29rIHVwIGluIGxpc3RzXG4gICAgICAgICAgdGhpcy5yWzJdPWRbdGhpcy52W3ArK10gLSBzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbGwgY29kZS1saWtlIGVudHJpZXMgd2l0aCByXG4gICAgICAgIGY9MTw8KGstdyk7XG4gICAgICAgIGZvciAoaj1pPj4+dztqPHo7ais9Zil7XG4gICAgICAgICAgYXJyYXlDb3B5KHRoaXMuciwgMCwgaHAsIChxK2opKjMsIDMpO1xuXHR9XG5cblx0Ly8gYmFja3dhcmRzIGluY3JlbWVudCB0aGUgay1iaXQgY29kZSBpXG4gICAgICAgIGZvciAoaiA9IDEgPDwgKGsgLSAxKTsgKGkgJiBqKSE9MDsgaiA+Pj49IDEpe1xuICAgICAgICAgIGkgXj0gajtcblx0fVxuICAgICAgICBpIF49IGo7XG5cblx0Ly8gYmFja3VwIG92ZXIgZmluaXNoZWQgdGFibGVzXG4gICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7ICAgICAgLy8gbmVlZGVkIG9uIEhQLCBjYyAtTyBidWdcbiAgICAgICAgd2hpbGUgKChpICYgbWFzaykgIT0gdGhpcy54W2hdKXtcbiAgICAgICAgICBoLS07ICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSBxXG4gICAgICAgICAgdyAtPSBsO1xuICAgICAgICAgIG1hc2sgPSAoMSA8PCB3KSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIFpfQlVGX0VSUk9SIGlmIHdlIHdlcmUgZ2l2ZW4gYW4gaW5jb21wbGV0ZSB0YWJsZVxuICAgIHJldHVybiB5ICE9IDAgJiYgZyAhPSAxID8gWl9CVUZfRVJST1IgOiBaX09LO1xufVxuXG5JbmZUcmVlLnByb3RvdHlwZS5pbmZsYXRlX3RyZWVzX2JpdHMgPSBmdW5jdGlvbihjLCBiYiwgdGIsIGhwLCB6KSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICB0aGlzLmluaXRXb3JrQXJlYSgxOSk7XG4gICAgdGhpcy5oblswXT0wO1xuICAgIHJlc3VsdCA9IHRoaXMuaHVmdF9idWlsZChjLCAwLCAxOSwgMTksIG51bGwsIG51bGwsIHRiLCBiYiwgaHAsIHRoaXMuaG4sIHRoaXMudik7XG5cbiAgICBpZihyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgIHoubXNnID0gXCJvdmVyc3Vic2NyaWJlZCBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcIjtcbiAgICB9XG4gICAgZWxzZSBpZihyZXN1bHQgPT0gWl9CVUZfRVJST1IgfHwgYmJbMF0gPT0gMCl7XG4gICAgICB6Lm1zZyA9IFwiaW5jb21wbGV0ZSBkeW5hbWljIGJpdCBsZW5ndGhzIHRyZWVcIjtcbiAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaW5mbGF0ZV90cmVlc19keW5hbWljID0gZnVuY3Rpb24obmwsIG5kLCBjLCBibCwgYmQsIHRsLCB0ZCwgaHAsIHopIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgLy8gYnVpbGQgbGl0ZXJhbC9sZW5ndGggdHJlZVxuICAgIHRoaXMuaW5pdFdvcmtBcmVhKDI4OCk7XG4gICAgdGhpcy5oblswXT0wO1xuICAgIHJlc3VsdCA9IHRoaXMuaHVmdF9idWlsZChjLCAwLCBubCwgMjU3LCBjcGxlbnMsIGNwbGV4dCwgdGwsIGJsLCBocCwgdGhpcy5obiwgdGhpcy52KTtcbiAgICBpZiAocmVzdWx0ICE9IFpfT0sgfHwgYmxbMF0gPT0gMCl7XG4gICAgICBpZihyZXN1bHQgPT0gWl9EQVRBX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcIm92ZXJzdWJzY3JpYmVkIGxpdGVyYWwvbGVuZ3RoIHRyZWVcIjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlc3VsdCAhPSBaX01FTV9FUlJPUil7XG4gICAgICAgIHoubXNnID0gXCJpbmNvbXBsZXRlIGxpdGVyYWwvbGVuZ3RoIHRyZWVcIjtcbiAgICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBidWlsZCBkaXN0YW5jZSB0cmVlXG4gICAgdGhpcy5pbml0V29ya0FyZWEoMjg4KTtcbiAgICByZXN1bHQgPSB0aGlzLmh1ZnRfYnVpbGQoYywgbmwsIG5kLCAwLCBjcGRpc3QsIGNwZGV4dCwgdGQsIGJkLCBocCwgdGhpcy5obiwgdGhpcy52KTtcblxuICAgIGlmIChyZXN1bHQgIT0gWl9PSyB8fCAoYmRbMF0gPT0gMCAmJiBubCA+IDI1Nykpe1xuICAgICAgaWYgKHJlc3VsdCA9PSBaX0RBVEFfRVJST1Ipe1xuICAgICAgICB6Lm1zZyA9IFwib3ZlcnN1YnNjcmliZWQgZGlzdGFuY2UgdHJlZVwiO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzdWx0ID09IFpfQlVGX0VSUk9SKSB7XG4gICAgICAgIHoubXNnID0gXCJpbmNvbXBsZXRlIGRpc3RhbmNlIHRyZWVcIjtcbiAgICAgICAgcmVzdWx0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAocmVzdWx0ICE9IFpfTUVNX0VSUk9SKXtcbiAgICAgICAgei5tc2cgPSBcImVtcHR5IGRpc3RhbmNlIHRyZWUgd2l0aCBsZW5ndGhzXCI7XG4gICAgICAgIHJlc3VsdCA9IFpfREFUQV9FUlJPUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFpfT0s7XG59XG4vKlxuICBzdGF0aWMgaW50IGluZmxhdGVfdHJlZXNfZml4ZWQoaW50W10gYmwsICAvL2xpdGVyYWwgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXSBiZCwgIC8vZGlzdGFuY2UgZGVzaXJlZC9hY3R1YWwgYml0IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRbXVtdIHRsLC8vbGl0ZXJhbC9sZW5ndGggdHJlZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludFtdW10gdGQsLy9kaXN0YW5jZSB0cmVlIHJlc3VsdCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFpTdHJlYW0geiAgLy9mb3IgbWVtb3J5IGFsbG9jYXRpb25cblx0XHRcdFx0ICl7XG5cbiovXG5cbmZ1bmN0aW9uIGluZmxhdGVfdHJlZXNfZml4ZWQoYmwsIGJkLCB0bCwgdGQsIHopIHtcbiAgICBibFswXT1maXhlZF9ibDtcbiAgICBiZFswXT1maXhlZF9iZDtcbiAgICB0bFswXT1maXhlZF90bDtcbiAgICB0ZFswXT1maXhlZF90ZDtcbiAgICByZXR1cm4gWl9PSztcbn1cblxuSW5mVHJlZS5wcm90b3R5cGUuaW5pdFdvcmtBcmVhID0gZnVuY3Rpb24odnNpemUpe1xuICAgIGlmKHRoaXMuaG49PW51bGwpe1xuICAgICAgICB0aGlzLmhuPW5ldyBJbnQzMkFycmF5KDEpO1xuICAgICAgICB0aGlzLnY9bmV3IEludDMyQXJyYXkodnNpemUpO1xuICAgICAgICB0aGlzLmM9bmV3IEludDMyQXJyYXkoQk1BWCsxKTtcbiAgICAgICAgdGhpcy5yPW5ldyBJbnQzMkFycmF5KDMpO1xuICAgICAgICB0aGlzLnU9bmV3IEludDMyQXJyYXkoQk1BWCk7XG4gICAgICAgIHRoaXMueD1uZXcgSW50MzJBcnJheShCTUFYKzEpO1xuICAgIH1cbiAgICBpZih0aGlzLnYubGVuZ3RoPHZzaXplKXsgXG4gICAgICAgIHRoaXMudj1uZXcgSW50MzJBcnJheSh2c2l6ZSk7IFxuICAgIH1cbiAgICBmb3IodmFyIGk9MDsgaTx2c2l6ZTsgaSsrKXt0aGlzLnZbaV09MDt9XG4gICAgZm9yKHZhciBpPTA7IGk8Qk1BWCsxOyBpKyspe3RoaXMuY1tpXT0wO31cbiAgICBmb3IodmFyIGk9MDsgaTwzOyBpKyspe3RoaXMucltpXT0wO31cbi8vICBmb3IoaW50IGk9MDsgaTxCTUFYOyBpKyspe3VbaV09MDt9XG4gICAgYXJyYXlDb3B5KHRoaXMuYywgMCwgdGhpcy51LCAwLCBCTUFYKTtcbi8vICBmb3IoaW50IGk9MDsgaTxCTUFYKzE7IGkrKyl7eFtpXT0wO31cbiAgICBhcnJheUNvcHkodGhpcy5jLCAwLCB0aGlzLngsIDAsIEJNQVgrMSk7XG59XG5cbnZhciB0ZXN0QXJyYXkgPSBuZXcgVWludDhBcnJheSgxKTtcbnZhciBoYXNTdWJhcnJheSA9ICh0eXBlb2YgdGVzdEFycmF5LnN1YmFycmF5ID09PSAnZnVuY3Rpb24nKTtcbnZhciBoYXNTbGljZSA9IGZhbHNlOyAvKiAodHlwZW9mIHRlc3RBcnJheS5zbGljZSA9PT0gJ2Z1bmN0aW9uJyk7ICovIC8vIENocm9tZSBzbGljZSBwZXJmb3JtYW5jZSBpcyBzbyBkaXJlIHRoYXQgd2UncmUgY3VycmVudGx5IG5vdCB1c2luZyBpdC4uLlxuXG5mdW5jdGlvbiBhcnJheUNvcHkoc3JjLCBzcmNPZmZzZXQsIGRlc3QsIGRlc3RPZmZzZXQsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gXG4gICAgaWYgKCFzcmMpIHtcbiAgICAgICAgdGhyb3cgXCJVbmRlZiBzcmNcIjtcbiAgICB9IGVsc2UgaWYgKCFkZXN0KSB7XG4gICAgICAgIHRocm93IFwiVW5kZWYgZGVzdFwiO1xuICAgIH1cblxuICAgIGlmIChzcmNPZmZzZXQgPT0gMCAmJiBjb3VudCA9PSBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGFycmF5Q29weV9mYXN0KHNyYywgZGVzdCwgZGVzdE9mZnNldCk7XG4gICAgfSBlbHNlIGlmIChoYXNTdWJhcnJheSkge1xuICAgICAgICBhcnJheUNvcHlfZmFzdChzcmMuc3ViYXJyYXkoc3JjT2Zmc2V0LCBzcmNPZmZzZXQgKyBjb3VudCksIGRlc3QsIGRlc3RPZmZzZXQpOyBcbiAgICB9IGVsc2UgaWYgKHNyYy5CWVRFU19QRVJfRUxFTUVOVCA9PSAxICYmIGNvdW50ID4gMTAwKSB7XG4gICAgICAgIGFycmF5Q29weV9mYXN0KG5ldyBVaW50OEFycmF5KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0ICsgc3JjT2Zmc2V0LCBjb3VudCksIGRlc3QsIGRlc3RPZmZzZXQpO1xuICAgIH0gZWxzZSB7IFxuICAgICAgICBhcnJheUNvcHlfc2xvdyhzcmMsIHNyY09mZnNldCwgZGVzdCwgZGVzdE9mZnNldCwgY291bnQpO1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBhcnJheUNvcHlfc2xvdyhzcmMsIHNyY09mZnNldCwgZGVzdCwgZGVzdE9mZnNldCwgY291bnQpIHtcblxuICAgIC8vIGRsb2coJ19zbG93IGNhbGw6IHNyY09mZnNldD0nICsgc3JjT2Zmc2V0ICsgJzsgZGVzdE9mZnNldD0nICsgZGVzdE9mZnNldCArICc7IGNvdW50PScgKyBjb3VudCk7XG5cbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIGldID0gc3JjW3NyY09mZnNldCArIGldO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXJyYXlDb3B5X2Zhc3Qoc3JjLCBkZXN0LCBkZXN0T2Zmc2V0KSB7XG4gICAgZGVzdC5zZXQoc3JjLCBkZXN0T2Zmc2V0KTtcbn1cblxuXG4gIC8vIGxhcmdlc3QgcHJpbWUgc21hbGxlciB0aGFuIDY1NTM2XG52YXIgQURMRVJfQkFTRT02NTUyMTsgXG4gIC8vIE5NQVggaXMgdGhlIGxhcmdlc3QgbiBzdWNoIHRoYXQgMjU1bihuKzEpLzIgKyAobisxKShCQVNFLTEpIDw9IDJeMzItMVxudmFyIEFETEVSX05NQVg9NTU1MjtcblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgLyogYnl0ZVtdICovIGJ1ZiwgIGluZGV4LCBsZW4pe1xuICAgIGlmKGJ1ZiA9PSBudWxsKXsgcmV0dXJuIDE7IH1cblxuICAgIHZhciBzMT1hZGxlciYweGZmZmY7XG4gICAgdmFyIHMyPShhZGxlcj4+MTYpJjB4ZmZmZjtcbiAgICB2YXIgaztcblxuICAgIHdoaWxlKGxlbiA+IDApIHtcbiAgICAgIGs9bGVuPEFETEVSX05NQVg/bGVuOkFETEVSX05NQVg7XG4gICAgICBsZW4tPWs7XG4gICAgICB3aGlsZShrPj0xNil7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgczErPWJ1ZltpbmRleCsrXSYweGZmOyBzMis9czE7XG4gICAgICAgIHMxKz1idWZbaW5kZXgrK10mMHhmZjsgczIrPXMxO1xuICAgICAgICBrLT0xNjtcbiAgICAgIH1cbiAgICAgIGlmKGshPTApe1xuICAgICAgICBkb3tcbiAgICAgICAgICBzMSs9YnVmW2luZGV4KytdJjB4ZmY7IHMyKz1zMTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSgtLWshPTApO1xuICAgICAgfVxuICAgICAgczElPUFETEVSX0JBU0U7XG4gICAgICBzMiU9QURMRVJfQkFTRTtcbiAgICB9XG4gICAgcmV0dXJuIChzMjw8MTYpfHMxO1xufVxuXG5cblxuZnVuY3Rpb24ganN6bGliX2luZmxhdGVfYnVmZmVyKGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCwgYWZ0ZXJVbmNPZmZzZXQpIHtcbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgfSBlbHNlIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgc3RhcnQsIGJ1ZmZlci5ieXRlTGVuZ3RoIC0gc3RhcnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlciwgc3RhcnQsIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHogPSBuZXcgWlN0cmVhbSgpO1xuICAgIHouaW5mbGF0ZUluaXQoREVGX1dCSVRTLCB0cnVlKTtcbiAgICB6Lm5leHRfaW4gPSBidWZmZXI7XG4gICAgei5uZXh0X2luX2luZGV4ID0gMDtcbiAgICB6LmF2YWlsX2luID0gYnVmZmVyLmxlbmd0aDtcblxuICAgIHZhciBvQmxvY2tMaXN0ID0gW107XG4gICAgdmFyIHRvdGFsU2l6ZSA9IDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIG9idWYgPSBuZXcgVWludDhBcnJheSgzMjAwMCk7XG4gICAgICAgIHoubmV4dF9vdXQgPSBvYnVmO1xuICAgICAgICB6Lm5leHRfb3V0X2luZGV4ID0gMDtcbiAgICAgICAgei5hdmFpbF9vdXQgPSBvYnVmLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0YXR1cyA9IHouaW5mbGF0ZShaX05PX0ZMVVNIKTtcbiAgICAgICAgaWYgKHN0YXR1cyAhPSBaX09LICYmIHN0YXR1cyAhPSBaX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9IFpfQlVGX0VSUk9SKSB7XG4gICAgICAgICAgICB0aHJvdyB6Lm1zZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoei5hdmFpbF9vdXQgIT0gMCkge1xuICAgICAgICAgICAgdmFyIG5ld29iID0gbmV3IFVpbnQ4QXJyYXkob2J1Zi5sZW5ndGggLSB6LmF2YWlsX291dCk7XG4gICAgICAgICAgICBhcnJheUNvcHkob2J1ZiwgMCwgbmV3b2IsIDAsIChvYnVmLmxlbmd0aCAtIHouYXZhaWxfb3V0KSk7XG4gICAgICAgICAgICBvYnVmID0gbmV3b2I7XG4gICAgICAgIH1cbiAgICAgICAgb0Jsb2NrTGlzdC5wdXNoKG9idWYpO1xuICAgICAgICB0b3RhbFNpemUgKz0gb2J1Zi5sZW5ndGg7XG4gICAgICAgIGlmIChzdGF0dXMgPT0gWl9TVFJFQU1fRU5EIHx8IHN0YXR1cyA9PSBaX0JVRl9FUlJPUikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWZ0ZXJVbmNPZmZzZXQpIHtcbiAgICAgICAgYWZ0ZXJVbmNPZmZzZXRbMF0gPSAoc3RhcnQgfHwgMCkgKyB6Lm5leHRfaW5faW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKG9CbG9ja0xpc3QubGVuZ3RoID09IDEpIHtcbiAgICAgICAgcmV0dXJuIG9CbG9ja0xpc3RbMF0uYnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh0b3RhbFNpemUpO1xuICAgICAgICB2YXIgY3Vyc29yID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvQmxvY2tMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG9CbG9ja0xpc3RbaV07XG4gICAgICAgICAgICBhcnJheUNvcHkoYiwgMCwgb3V0LCBjdXJzb3IsIGIubGVuZ3RoKTtcbiAgICAgICAgICAgIGN1cnNvciArPSBiLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0LmJ1ZmZlcjtcbiAgICB9XG59XG5cbmlmICh0eXBlb2YobW9kdWxlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaW5mbGF0ZUJ1ZmZlcjoganN6bGliX2luZmxhdGVfYnVmZmVyLFxuICAgIGFycmF5Q29weTogYXJyYXlDb3B5XG4gIH07XG59XG4iXX0=
